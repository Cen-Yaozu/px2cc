// src/index.ts
import pino from "pino";
import path from "path";
import os from "os";
import fs from "fs";
var defaultConfig = {
  level: process.env.LOG_LEVEL || "info",
  console: true,
  file: {
    dirname: path.join(os.homedir(), ".promptx", "logs")
  },
  colors: true
};
function getCallerInfo() {
  const stack = new Error().stack || "";
  const stackLines = stack.split("\n");
  for (let i = 2; i < stackLines.length; i++) {
    const line = stackLines[i];
    if (line && !line.includes("node_modules/pino") && !line.includes("packages/logger") && !line.includes("@promptx/logger")) {
      const match = line.match(/at\s+(?:.*?\s+)?\(?(.*?):(\d+):(\d+)\)?/);
      if (match && match[1] && match[2]) {
        const fullPath = match[1];
        const lineNum = parseInt(match[2], 10);
        let packageName = "app";
        const packageMatch = fullPath.match(/packages\/([^\/]+)/) || fullPath.match(/@promptx\/([^\/]+)/);
        if (packageMatch) {
          packageName = `@promptx/${packageMatch[1]}`;
        }
        const filename = path.basename(fullPath);
        return {
          package: packageName,
          file: filename,
          line: lineNum
        };
      }
    }
  }
  return { package: "app", file: "unknown", line: 0 };
}
function createLogger(config = {}) {
  const finalConfig = { ...defaultConfig, ...config };
  if (finalConfig.file) {
    const fileConfig = typeof finalConfig.file === "object" ? finalConfig.file : {};
    const logDir = fileConfig.dirname || path.join(os.homedir(), ".promptx", "logs");
    if (!fs.existsSync(logDir)) {
      fs.mkdirSync(logDir, { recursive: true });
    }
  }
  const isElectron = process.versions && process.versions.electron;
  if (isElectron || process.env.PROMPTX_NO_WORKERS === "true") {
    if (finalConfig.file) {
      const fileConfig = typeof finalConfig.file === "object" ? finalConfig.file : {};
      const logDir = fileConfig.dirname || path.join(os.homedir(), ".promptx", "logs");
      const today = (/* @__PURE__ */ new Date()).toISOString().split("T")[0];
      const logPath = path.join(logDir, `promptx-${today}.log`);
      const dest = pino.destination({
        dest: logPath,
        sync: true
        // Use sync to avoid worker thread issues in Electron
      });
      return pino({
        level: finalConfig.level || "info",
        base: { pid: process.pid },
        mixin: () => getCallerInfo(),
        // Simple formatting without pino-pretty to avoid worker threads
        formatters: {
          level: (label) => {
            return { level: label };
          },
          log: (obj) => {
            const { package: pkg, file, line, ...rest } = obj;
            return {
              ...rest,
              location: pkg && file ? `${pkg} [${file}:${line}]` : void 0
            };
          }
        }
      }, dest);
    } else {
      return pino({
        level: finalConfig.level || "info",
        base: { pid: process.pid },
        mixin: () => getCallerInfo(),
        formatters: {
          level: (label) => {
            return { level: label };
          },
          log: (obj) => {
            const { package: pkg, file, line, ...rest } = obj;
            return {
              ...rest,
              location: pkg && file ? `${pkg} [${file}:${line}]` : void 0
            };
          }
        }
      });
    }
  } else {
    const targets = [];
    if (finalConfig.console) {
      targets.push({
        target: "pino-pretty",
        level: finalConfig.level,
        options: {
          colorize: finalConfig.colors,
          translateTime: "SYS:yyyy-mm-dd HH:MM:ss.l",
          ignore: "hostname,pid,package,file,line",
          messageFormat: "{package} [{file}:{line}] {msg}"
        }
      });
    }
    if (finalConfig.file) {
      const fileConfig = typeof finalConfig.file === "object" ? finalConfig.file : {};
      const logDir = fileConfig.dirname || path.join(os.homedir(), ".promptx", "logs");
      const today = (/* @__PURE__ */ new Date()).toISOString().split("T")[0];
      targets.push({
        target: "pino/file",
        level: finalConfig.level,
        options: {
          destination: path.join(logDir, `promptx-${today}.log`)
        }
      });
      targets.push({
        target: "pino/file",
        level: "error",
        options: {
          destination: path.join(logDir, `promptx-error-${today}.log`)
        }
      });
    }
    if (targets.length > 0) {
      return pino({
        level: finalConfig.level || "info",
        base: { pid: process.pid },
        mixin: () => getCallerInfo(),
        transport: {
          targets
        }
      });
    }
  }
  return pino({
    level: finalConfig.level || "info",
    base: { pid: process.pid },
    mixin: () => getCallerInfo()
  });
}
var logger = createLogger();
var error = (msg, ...args) => {
  if (typeof msg === "string") {
    logger.error(msg);
  } else {
    logger.error(msg, args[0] || "");
  }
};
var warn = (msg, ...args) => {
  if (typeof msg === "string") {
    logger.warn(msg);
  } else {
    logger.warn(msg, args[0] || "");
  }
};
var info = (msg, ...args) => {
  if (typeof msg === "string") {
    logger.info(msg);
  } else {
    logger.info(msg, args[0] || "");
  }
};
var debug = (msg, ...args) => {
  if (typeof msg === "string") {
    logger.debug(msg);
  } else {
    logger.debug(msg, args[0] || "");
  }
};
var verbose = (msg, ...args) => {
  if (typeof msg === "string") {
    logger.trace(msg);
  } else {
    logger.trace(msg, args[0] || "");
  }
};
var log = (level, msg, ...args) => {
  const method = logger[level];
  if (typeof method === "function") {
    method(msg, ...args);
  } else {
    logger.info(msg, ...args);
  }
};
var index_default = logger;
export {
  createLogger,
  debug,
  index_default as default,
  error,
  info,
  log,
  verbose,
  warn
};
//# sourceMappingURL=index.js.map