"use strict";
var __getOwnPropNames = Object.getOwnPropertyNames;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};

// ../../node_modules/.pnpm/tsup@8.5.0_jiti@2.5.1_postcss@8.5.6_tsx@4.20.5_typescript@5.9.2_yaml@2.8.1/node_modules/tsup/assets/cjs_shims.js
var init_cjs_shims = __esm({
  "../../node_modules/.pnpm/tsup@8.5.0_jiti@2.5.1_postcss@8.5.6_tsx@4.20.5_typescript@5.9.2_yaml@2.8.1/node_modules/tsup/assets/cjs_shims.js"() {
    "use strict";
  }
});

// src/cognition/Cue.js
var require_Cue = __commonJS({
  "src/cognition/Cue.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var Cue2 = class _Cue {
      /**
       * 创建一个新的Cue节点
       * 
       * @param {string} word - 概念词，作为节点的唯一标识
       * 
       * @example
       * const cue = new Cue("认知");
       * cue.connections.set("模型", 1234567890);
       */
      constructor(word) {
        this.word = word;
        this.connections = /* @__PURE__ */ new Map();
      }
      /**
       * 获取节点的出度（连接到多少个其他节点）
       * 
       * 出度的意义：
       * - 高出度 = 枢纽节点（hub），概念发散性强
       * - 低出度 = 专门节点，概念专一性强
       * 
       * @returns {number} 出边数量
       */
      getOutDegree() {
        return this.connections.size;
      }
      /**
       * 获取最强连接（权重最高的出边）
       * 
       * 用途：
       * - Prime时选择默认激活路径
       * - Recall时决定主要扩散方向
       * 
       * @returns {{word: string, weight: number}|null} 最强连接信息
       */
      getStrongestConnection() {
        if (this.connections.size === 0) return null;
        let maxWeight = -Infinity;
        let strongestWord = null;
        for (const [word, weight] of this.connections) {
          if (weight > maxWeight) {
            maxWeight = weight;
            strongestWord = word;
          }
        }
        return { word: strongestWord, weight: maxWeight };
      }
      /**
       * 获取按权重排序的连接列表
       * 
       * @param {number} limit - 返回前N个连接
       * @returns {Array<{word: string, weight: number}>} 排序后的连接列表
       */
      getSortedConnections(limit = Infinity) {
        return Array.from(this.connections.entries()).map(([word, weight]) => ({ word, weight })).sort((a, b) => b.weight - a.weight).slice(0, limit);
      }
      /**
       * 序列化为JSON对象（用于持久化）
       * 
       * @returns {Object} 可序列化的对象
       */
      toJSON() {
        return {
          word: this.word,
          connections: Array.from(this.connections.entries()).map(([target, weight]) => ({
            target,
            weight
          }))
        };
      }
      /**
       * 从JSON对象恢复（用于加载）
       * 
       * @param {Object} json - 序列化的对象
       * @returns {Cue} 恢复的Cue实例
       */
      static fromJSON(json) {
        const cue = new _Cue(json.word);
        if (json.connections) {
          for (const conn of json.connections) {
            cue.connections.set(conn.target, conn.weight);
          }
        }
        return cue;
      }
    };
    module2.exports = Cue2;
  }
});

// src/cognition/FrequencyCue.js
var require_FrequencyCue = __commonJS({
  "src/cognition/FrequencyCue.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var Cue2 = require_Cue();
    var logger = require("@promptx/logger");
    var FrequencyCue = class _FrequencyCue extends Cue2 {
      /**
       * 创建一个带频率统计的Cue
       * 
       * @param {string} word - 概念词
       */
      constructor(word) {
        super(word);
        this.recallFrequency = 0;
      }
      /**
       * 增加recall频率
       * 
       * 设计：
       * - 简单递增，不设上限
       * - 未来可以考虑添加衰减机制
       * - 可以扩展为更复杂的统计（如时间窗口内的频率）
       */
      incrementFrequency() {
        this.recallFrequency++;
        logger.debug("[FrequencyCue] Frequency incremented", {
          word: this.word,
          newFrequency: this.recallFrequency
        });
      }
      /**
       * 获取频率值
       * 
       * @returns {number} 当前频率
       */
      getFrequency() {
        return this.recallFrequency;
      }
      /**
       * 重置频率（用于测试或清理）
       */
      resetFrequency() {
        this.recallFrequency = 0;
        logger.debug("[FrequencyCue] Frequency reset", { word: this.word });
      }
      /**
       * 序列化为JSON（包含频率信息）
       * 
       * @returns {Object} 包含频率的序列化对象
       */
      toJSON() {
        return {
          ...super.toJSON(),
          recallFrequency: this.recallFrequency
        };
      }
      /**
       * 从JSON恢复（包含频率信息）
       * 
       * @param {Object} json - 序列化的对象
       * @returns {FrequencyCue} 恢复的FrequencyCue实例
       */
      static fromJSON(json) {
        const freqCue = new _FrequencyCue(json.word);
        if (json.connections) {
          for (const conn of json.connections) {
            freqCue.connections.set(conn.target, conn.weight);
          }
        }
        freqCue.recallFrequency = json.recallFrequency || 0;
        return freqCue;
      }
      /**
       * 获取调试信息
       * 
       * @returns {Object} 调试信息
       */
      getDebugInfo() {
        return {
          word: this.word,
          outDegree: this.getOutDegree(),
          recallFrequency: this.recallFrequency,
          strongestConnection: this.getStrongestConnection()
        };
      }
    };
    module2.exports = FrequencyCue;
  }
});

// src/cognition/Network.js
var require_Network = __commonJS({
  "src/cognition/Network.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var logger = require("@promptx/logger");
    var fs = require("fs");
    var path = require("path");
    var Network2 = class {
      constructor() {
        this.cues = /* @__PURE__ */ new Map();
        logger.debug("[Network] Initialized empty network");
      }
      /**
       * 添加或获取Cue
       * 
       * 如果Cue不存在则创建，存在则返回现有的。
       * 这是一个幂等操作，多次调用结果相同。
       * 
       * @param {string} word - 概念词
       * @returns {FrequencyCue} FrequencyCue实例
       */
      getOrCreateCue(word) {
        if (!this.cues.has(word)) {
          const FrequencyCue = require_FrequencyCue();
          const cue = new FrequencyCue(word);
          this.cues.set(word, cue);
          logger.debug("[Network] Created new FrequencyCue", { word });
        }
        return this.cues.get(word);
      }
      /**
       * 获取Cue（不创建）
       * 
       * @param {string} word - 概念词
       * @returns {Cue|undefined} Cue实例或undefined
       */
      getCue(word) {
        return this.cues.get(word);
      }
      /**
       * 检查Cue是否存在
       * 
       * @param {string} word - 概念词
       * @returns {boolean} 是否存在
       */
      hasCue(word) {
        return this.cues.has(word);
      }
      /**
       * 获取网络规模
       * 
       * @returns {number} Cue总数
       */
      size() {
        return this.cues.size;
      }
      /**
       * 计算网络的入度信息
       * 
       * 入度 = 有多少其他Cue指向这个Cue
       * 这需要遍历整个网络，因为我们只存储出边。
       * 
       * @returns {Map<string, number>} word => 入度
       */
      calculateInDegrees() {
        const inDegrees = /* @__PURE__ */ new Map();
        for (const word of this.cues.keys()) {
          inDegrees.set(word, 0);
        }
        for (const [sourceWord, sourceCue] of this.cues) {
          for (const targetWord of sourceCue.connections.keys()) {
            const currentDegree = inDegrees.get(targetWord) || 0;
            inDegrees.set(targetWord, currentDegree + 1);
          }
        }
        return inDegrees;
      }
      /**
       * 计算网络的入度权重（每个节点被指向的总权重）
       * 
       * 用于Prime选择最重要的节点。
       * 
       * @returns {Map<string, number>} word => 总入度权重
       */
      calculateInWeights() {
        const inWeights = /* @__PURE__ */ new Map();
        for (const [sourceWord, sourceCue] of this.cues) {
          for (const [targetWord, weight] of sourceCue.connections) {
            const currentWeight = inWeights.get(targetWord) || 0;
            inWeights.set(targetWord, currentWeight + weight);
          }
        }
        return inWeights;
      }
      /**
       * 获取网络统计信息
       * 
       * @returns {Object} 统计信息
       */
      getStatistics() {
        let totalConnections = 0;
        let maxOutDegree = 0;
        let hubNode = null;
        let isolatedNodes = 0;
        for (const [word, cue] of this.cues) {
          const outDegree = cue.connections.size;
          totalConnections += outDegree;
          if (outDegree === 0) {
            isolatedNodes++;
          }
          if (outDegree > maxOutDegree) {
            maxOutDegree = outDegree;
            hubNode = word;
          }
        }
        const inDegrees = this.calculateInDegrees();
        let maxInDegree = 0;
        let sinkNode = null;
        for (const [word, inDegree] of inDegrees) {
          if (inDegree > maxInDegree) {
            maxInDegree = inDegree;
            sinkNode = word;
          }
        }
        return {
          totalCues: this.cues.size,
          totalConnections,
          averageOutDegree: this.cues.size > 0 ? totalConnections / this.cues.size : 0,
          maxOutDegree,
          hubNode,
          // 出度最高的节点（发散中心）
          maxInDegree,
          sinkNode,
          // 入度最高的节点（汇聚中心）
          isolatedNodes
          // 孤立节点数量
        };
      }
      /**
       * 序列化Network到JSON文件
       * 
       * 设计考虑：
       * - 使用同步版本避免异步复杂性
       * - 包含版本号便于未来升级
       * - 包含时间戳便于调试
       * 
       * @param {string} filePath - 保存路径
       * @returns {Promise<void>}
       */
      async persist(filePath) {
        try {
          const fs2 = require("fs").promises;
          const path2 = require("path");
          const data = {
            version: "1.0",
            timestamp: Date.now(),
            cues: {}
          };
          for (const [word, cue] of this.cues) {
            data.cues[word] = cue.toJSON();
          }
          const dir = path2.dirname(filePath);
          await fs2.mkdir(dir, { recursive: true });
          await fs2.writeFile(filePath, JSON.stringify(data, null, 2), "utf8");
          logger.info("[Network] Persisted to file", {
            path: filePath,
            cues: this.cues.size,
            size: JSON.stringify(data).length
          });
        } catch (error) {
          logger.error("[Network] Failed to persist", {
            path: filePath,
            error: error.message
          });
          throw error;
        }
      }
      /**
       * 从JSON文件加载Network
       * 
       * @param {string} filePath - 文件路径
       * @returns {Promise<void>}
       */
      async load(filePath) {
        try {
          const fs2 = require("fs").promises;
          const FrequencyCue = require_FrequencyCue();
          const content = await fs2.readFile(filePath, "utf8");
          const data = JSON.parse(content);
          if (data.version !== "1.0") {
            logger.warn("[Network] Version mismatch", {
              expected: "1.0",
              actual: data.version
            });
          }
          this.cues.clear();
          for (const [word, cueData] of Object.entries(data.cues)) {
            const cue = FrequencyCue.fromJSON(cueData);
            this.cues.set(word, cue);
          }
          logger.info("[Network] Loaded from file", {
            path: filePath,
            cues: this.cues.size,
            timestamp: new Date(data.timestamp).toISOString()
          });
        } catch (error) {
          logger.error("[Network] Failed to load", {
            path: filePath,
            error: error.message
          });
          throw error;
        }
      }
      /**
       * 同步版本的persist
       * 
       * Remember需要同步保存，避免异步复杂性。
       * 
       * @param {string} filePath - 保存路径
       */
      persistSync(filePath) {
        try {
          const data = {
            version: "1.0",
            timestamp: Date.now(),
            cues: {}
          };
          for (const [word, cue] of this.cues) {
            data.cues[word] = cue.toJSON();
          }
          const dir = path.dirname(filePath);
          fs.mkdirSync(dir, { recursive: true });
          fs.writeFileSync(filePath, JSON.stringify(data, null, 2), "utf8");
          logger.debug("[Network] Persisted (sync) to file", {
            path: filePath,
            cues: this.cues.size
          });
        } catch (error) {
          logger.error("[Network] Failed to persist (sync)", {
            path: filePath,
            error: error.message
          });
          throw error;
        }
      }
      /**
       * 同步版本的load
       * 
       * Prime需要同步加载，避免异步复杂性。
       * 
       * @param {string} filePath - 文件路径
       */
      loadSync(filePath) {
        try {
          const FrequencyCue = require_FrequencyCue();
          const content = fs.readFileSync(filePath, "utf8");
          const data = JSON.parse(content);
          if (data.version !== "1.0") {
            logger.warn("[Network] Version mismatch", {
              expected: "1.0",
              actual: data.version
            });
          }
          this.cues.clear();
          for (const [word, cueData] of Object.entries(data.cues)) {
            const cue = FrequencyCue.fromJSON(cueData);
            this.cues.set(word, cue);
          }
          logger.debug("[Network] Loaded (sync) from file", {
            path: filePath,
            cues: this.cues.size
          });
        } catch (error) {
          logger.error("[Network] Failed to load (sync)", {
            path: filePath,
            error: error.message
          });
          throw error;
        }
      }
      /**
       * 更新Recall频率
       * 
       * 当Recall操作完成后，更新所有被激活节点的频率。
       * 这是Network作为容器管理统计信息的体现。
       * 
       * @param {Set<string>} activatedCues - 被激活的节点集合
       */
      updateRecallFrequency(activatedCues) {
        if (!activatedCues || activatedCues.size === 0) {
          return;
        }
        let updatedCount = 0;
        for (const word of activatedCues) {
          const cue = this.cues.get(word);
          if (cue && typeof cue.incrementFrequency === "function") {
            cue.incrementFrequency();
            updatedCount++;
          }
        }
        logger.debug("[Network] Updated recall frequencies", {
          requested: activatedCues.size,
          updated: updatedCount
        });
      }
      /**
       * 获取频率统计信息
       * 
       * @returns {Object} 频率统计
       */
      getFrequencyStatistics() {
        let totalFrequency = 0;
        let maxFrequency = 0;
        let mostFrequentNode = null;
        const frequencyDistribution = /* @__PURE__ */ new Map();
        for (const [word, cue] of this.cues) {
          const frequency = cue.recallFrequency || 0;
          totalFrequency += frequency;
          if (frequency > maxFrequency) {
            maxFrequency = frequency;
            mostFrequentNode = word;
          }
          const bucket = Math.floor(frequency / 10) * 10;
          frequencyDistribution.set(bucket, (frequencyDistribution.get(bucket) || 0) + 1);
        }
        return {
          totalRecalls: totalFrequency,
          averageFrequency: this.cues.size > 0 ? totalFrequency / this.cues.size : 0,
          maxFrequency,
          mostFrequentNode,
          distribution: Array.from(frequencyDistribution.entries()).sort((a, b) => a[0] - b[0]).map(([bucket, count]) => ({ range: `${bucket}-${bucket + 9}`, count }))
        };
      }
      /**
       * 清空网络
       * 
       * 用于测试或重置。
       */
      clear() {
        const previousSize = this.cues.size;
        this.cues.clear();
        logger.info("[Network] Cleared", { previousSize });
      }
    };
    module2.exports = Network2;
  }
});

// src/cognition/Mind.js
var require_Mind = __commonJS({
  "src/cognition/Mind.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var Mind2 = class {
      /**
       * 创建一个新的Mind
       * 
       * @param {Cue} center - 中心Cue（激活的起点）
       */
      constructor(center) {
        this.center = center;
        this.activatedCues = /* @__PURE__ */ new Set();
        this.connections = [];
        this.centers = [];
        this.depths = /* @__PURE__ */ new Map();
        if (center) {
          this.activatedCues.add(center.word);
          this.depths.set(center.word, 0);
        }
      }
      /**
       * 添加一个激活的Cue
       * 
       * @param {string} word - 概念词
       * @param {number} depth - 距离中心的深度
       */
      addActivatedCue(word, depth = 0) {
        this.activatedCues.add(word);
        if (!this.depths.has(word) || this.depths.get(word) > depth) {
          this.depths.set(word, depth);
        }
      }
      /**
       * 添加一个连接
       * 
       * @param {string} from - 源节点
       * @param {string} to - 目标节点
       * @param {number} weight - 连接权重
       */
      addConnection(from, to, weight) {
        this.connections.push({ from, to, weight });
        this.activatedCues.add(from);
        this.activatedCues.add(to);
      }
      /**
       * 获取激活的节点数量
       * 
       * @returns {number} 节点数
       */
      size() {
        return this.activatedCues.size;
      }
      /**
       * 获取连接数量
       * 
       * @returns {number} 边数
       */
      connectionCount() {
        return this.connections.length;
      }
      /**
       * 检查是否为空Mind
       * 
       * @returns {boolean} 是否为空
       */
      isEmpty() {
        return this.activatedCues.size === 0;
      }
      /**
       * 获取按权重排序的连接
       * 
       * @returns {Array} 排序后的连接
       */
      getSortedConnections() {
        return [...this.connections].sort((a, b) => b.weight - a.weight);
      }
      /**
       * 获取特定节点的所有出边
       * 
       * @param {string} word - 节点词
       * @returns {Array} 出边列表
       */
      getOutgoingConnections(word) {
        return this.connections.filter((conn) => conn.from === word);
      }
      /**
       * 获取特定节点的所有入边
       * 
       * @param {string} word - 节点词
       * @returns {Array} 入边列表
       */
      getIncomingConnections(word) {
        return this.connections.filter((conn) => conn.to === word);
      }
      /**
       * 转换为可序列化的JSON对象
       * 
       * 用于：
       * - 发送给大模型
       * - 保存思维快照
       * - 可视化展示
       * 
       * @returns {Object} JSON对象
       */
      toJSON() {
        return {
          center: this.center ? this.center.word : null,
          centers: this.centers.map((c) => c.word),
          activatedCues: Array.from(this.activatedCues),
          connections: this.connections,
          depths: Array.from(this.depths.entries()).map(([word, depth]) => ({ word, depth })),
          statistics: {
            nodeCount: this.activatedCues.size,
            edgeCount: this.connections.length,
            maxDepth: Math.max(...this.depths.values(), 0)
          }
        };
      }
      /**
       * 生成Mermaid mindmap代码
       * 
       * 可以直接用于可视化展示
       * 
       * @returns {string} Mermaid mindmap代码
       */
      toMermaid() {
        if (!this.center || this.activatedCues.size === 0) {
          return "mindmap\n  root((\u7A7A))";
        }
        const tree = this.buildTree();
        let mermaid = "mindmap\n";
        mermaid += `  root((${this.center.word}))
`;
        const addChildren = (parent, indent) => {
          const children = tree.get(parent) || [];
          for (const child of children) {
            mermaid += " ".repeat(indent) + child + "\n";
            addChildren(child, indent + 2);
          }
        };
        addChildren(this.center.word, 4);
        return mermaid;
      }
      /**
       * 构建树形结构
       * 用于生成mindmap
       * 
       * @returns {Map<string, Array<string>>} 父节点 -> 子节点列表
       */
      buildTree() {
        const tree = /* @__PURE__ */ new Map();
        const visited = /* @__PURE__ */ new Set();
        for (const conn of this.connections) {
          if (!tree.has(conn.from)) {
            tree.set(conn.from, []);
          }
          if (!visited.has(`${conn.from}->${conn.to}`)) {
            tree.get(conn.from).push(conn.to);
            visited.add(`${conn.from}->${conn.to}`);
          }
        }
        for (const [parent, children] of tree) {
          const childrenWithWeight = children.map((child) => {
            const conn = this.connections.find((c) => c.from === parent && c.to === child);
            return { child, weight: conn ? conn.weight : 0 };
          });
          childrenWithWeight.sort((a, b) => b.weight - a.weight);
          tree.set(parent, childrenWithWeight.map((item) => item.child));
        }
        return tree;
      }
      /**
       * 合并另一个Mind
       * 
       * 用于多线索思考的场景
       * 
       * @param {Mind} otherMind - 要合并的Mind
       */
      merge(otherMind) {
        for (const cue of otherMind.activatedCues) {
          this.activatedCues.add(cue);
        }
        const existingConns = new Set(
          this.connections.map((c) => `${c.from}->${c.to}`)
        );
        for (const conn of otherMind.connections) {
          const key = `${conn.from}->${conn.to}`;
          if (!existingConns.has(key)) {
            this.connections.push(conn);
          }
        }
        for (const [word, depth] of otherMind.depths) {
          if (!this.depths.has(word) || this.depths.get(word) > depth) {
            this.depths.set(word, depth);
          }
        }
        if (otherMind.center) {
          this.centers.push(otherMind.center);
        }
      }
    };
    module2.exports = Mind2;
  }
});

// src/cognition/Engram.js
var require_Engram = __commonJS({
  "src/cognition/Engram.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var logger = require("@promptx/logger");
    var Engram = class _Engram {
      /**
       * 创建记忆痕迹
       * 
       * @param {Object} params - 参数对象
       * @param {string} params.content - 原始经验内容
       * @param {string|Array} params.schema - 概念序列（字符串或数组）
       * @param {number} params.strength - 记忆强度 (0-1)，表示角色的主观重要性评分
       * @param {number} [params.timestamp] - 时间戳（可选，默认为当前时间）
       */
      constructor({ content, schema, strength, timestamp }) {
        if (!content) {
          throw new Error("Engram requires content");
        }
        if (!schema) {
          throw new Error("Engram requires schema");
        }
        if (strength === void 0 || strength === null) {
          throw new Error("Engram requires strength");
        }
        this.content = content;
        this.schema = this._normalizeSchema(schema);
        this.strength = this._validateStrength(strength);
        this.timestamp = timestamp || Date.now();
        this.id = `${this.timestamp}_${Math.random().toString(36).substr(2, 9)}`;
        logger.debug("[Engram] Created new engram", {
          schemaLength: this.schema.length,
          strength: this.strength,
          timestamp: new Date(this.timestamp).toISOString()
        });
      }
      /**
       * 标准化schema格式
       * 支持字符串（换行分隔）或数组格式
       * 
       * @private
       * @param {string|Array} schema - 原始schema
       * @returns {Array<string>} 标准化的概念数组
       */
      _normalizeSchema(schema) {
        if (Array.isArray(schema)) {
          return schema.filter((item) => item && typeof item === "string");
        }
        if (typeof schema === "string") {
          return schema.split("\n").map((s) => s.trim()).filter(Boolean);
        }
        throw new Error("Schema must be a string or array");
      }
      /**
       * 验证strength值的有效性
       * 
       * @private
       * @param {number} strength - 强度值
       * @returns {number} 验证后的强度值
       */
      _validateStrength(strength) {
        const num = Number(strength);
        if (isNaN(num)) {
          throw new Error("Strength must be a number");
        }
        if (num < 0 || num > 1) {
          throw new Error("Strength must be between 0 and 1");
        }
        return num;
      }
      /**
       * 获取schema长度
       * 用于快速判断是否可以创建连接
       * 
       * @returns {number} schema数组的长度
       */
      get length() {
        return this.schema.length;
      }
      /**
       * 判断是否有效
       * schema至少需要2个元素才能创建连接
       * 
       * @returns {boolean} 是否为有效的engram
       */
      isValid() {
        return this.schema.length >= 2;
      }
      /**
       * 获取预览字符串
       * 用于日志和调试
       * 
       * @param {number} [maxLength=5] - 最大显示元素数
       * @returns {string} 预览字符串
       */
      getPreview(maxLength = 5) {
        const preview = this.schema.slice(0, maxLength).join(" -> ");
        return this.schema.length > maxLength ? `${preview}...` : preview;
      }
      /**
       * 转换为JSON对象
       * 用于序列化和传输
       * 
       * @returns {Object} JSON对象
       */
      toJSON() {
        return {
          id: this.id,
          content: this.content,
          schema: this.schema,
          strength: this.strength,
          timestamp: this.timestamp
        };
      }
      /**
       * 从JSON对象创建Engram
       * 用于反序列化
       * 
       * @static
       * @param {Object} json - JSON对象
       * @returns {Engram} 新的Engram实例
       */
      static fromJSON(json) {
        return new _Engram(json);
      }
    };
    module2.exports = Engram;
  }
});

// src/cognition/WeightContext.js
var require_WeightContext = __commonJS({
  "src/cognition/WeightContext.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var WeightContext2 = class {
      /**
       * 创建权重计算上下文
       * 
       * @param {Object} data - 上下文数据
       * @param {Cue} data.sourceCue - 源节点
       * @param {string} data.targetWord - 目标词
       * @param {number} data.position - 在Schema中的位置
       * @param {number} [data.timestamp] - 时间戳（可选，默认当前时间）
       * @param {Engram} [data.engram] - 完整的记忆痕迹对象（可选）
       */
      constructor(data) {
        this.sourceCue = data.sourceCue;
        this.targetWord = data.targetWord;
        this.position = data.position;
        this.timestamp = data.timestamp || Date.now();
        this.sourceOutDegree = this.sourceCue ? this.sourceCue.connections.size : 0;
        this.engram = data.engram || null;
        this.strength = this.engram ? this.engram.strength : 0.8;
      }
      /**
       * 获取源词
       * 
       * 便捷方法，避免总是写this.sourceCue.word
       * 
       * @returns {string|null} 源词
       */
      getSourceWord() {
        return this.sourceCue ? this.sourceCue.word : null;
      }
      /**
       * 转换为调试字符串
       * 
       * 用于日志输出，包含关键信息。
       * 
       * @returns {string} 调试信息
       */
      toString() {
        const sourceWord = this.getSourceWord();
        return `WeightContext{${sourceWord}->${this.targetWord}, pos:${this.position}, degree:${this.sourceOutDegree}}`;
      }
      /**
       * 转换为JSON对象
       * 
       * 用于序列化和日志记录。
       * 
       * @returns {Object} JSON对象
       */
      toJSON() {
        return {
          sourceWord: this.getSourceWord(),
          targetWord: this.targetWord,
          position: this.position,
          timestamp: this.timestamp,
          sourceOutDegree: this.sourceOutDegree,
          strength: this.strength
        };
      }
    };
    module2.exports = WeightContext2;
  }
});

// src/cognition/Remember.js
var require_Remember = __commonJS({
  "src/cognition/Remember.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var logger = require("@promptx/logger");
    var Remember2 = class {
      /**
       * 创建Remember实例
       * 
       * @param {Network} network - 全局认知网络
       * @param {WeightStrategy} strategy - 权重计算策略
       */
      constructor(network, options = {}) {
        this.network = network;
        this.strategy = options.strategy || null;
        if (this.strategy) {
          logger.debug("[Remember] Initialized with strategy", {
            strategy: this.strategy.constructor.name
          });
        } else {
          logger.warn("[Remember] No strategy provided");
        }
      }
      /**
       * 执行记忆写入
       * 
       * 将Engram中的Schema序列写入Network，建立Cue之间的连接，
       * 同时建立Cue到Engram.id的反向索引。
       * 
       * @param {Engram} engram - 记忆痕迹对象
       * @param {string} [engramId] - 可选的Engram ID，默认使用engram.id
       * @returns {Object} 执行结果
       * @returns {number} returns.processed - 处理的节点数
       * @returns {Array} returns.connections - 创建的连接列表
       * @returns {string} returns.engramId - 使用的Engram ID
       */
      execute(engram, engramId = null) {
        const Engram = require_Engram();
        if (!engram || !(engram instanceof Engram)) {
          logger.warn("[Remember] Invalid engram provided", { engram });
          return {
            processed: 0,
            connections: []
          };
        }
        if (!engram.isValid()) {
          logger.debug("[Remember] Engram schema too short, no connections to create", {
            length: engram.length
          });
          return {
            processed: engram.length,
            connections: []
          };
        }
        const { schema, strength, timestamp } = engram;
        logger.debug("[Remember] Processing engram", {
          length: schema.length,
          strength,
          preview: engram.getPreview()
        });
        logger.debug("[Remember] Phase 1: Ensuring all Cues exist");
        const createdCues = [];
        for (const word of schema) {
          if (!this.network.cues.has(word)) {
            createdCues.push(word);
          }
          this.network.getOrCreateCue(word);
        }
        if (createdCues.length > 0) {
          logger.debug("[Remember] Created new Cues", {
            count: createdCues.length,
            cues: createdCues.slice(0, 10)
            // 只显示前10个
          });
        }
        logger.debug("[Remember] Phase 2: Building connection structure");
        const WeightContext2 = require_WeightContext();
        const connections = [];
        for (let i = 0; i < schema.length - 1; i++) {
          const sourceWord = schema[i];
          const targetWord = schema[i + 1];
          const sourceCue = this.network.cues.get(sourceWord);
          const existingWeight = sourceCue.connections.get(targetWord);
          if (!existingWeight) {
            sourceCue.connections.set(targetWord, 0);
          }
        }
        logger.debug("[Remember] Phase 2.2: Calculating and updating weights");
        for (let i = 0; i < schema.length - 1; i++) {
          const sourceWord = schema[i];
          const targetWord = schema[i + 1];
          const sourceCue = this.network.cues.get(sourceWord);
          const context = new WeightContext2({
            sourceCue,
            targetWord,
            position: i,
            timestamp,
            engram
            // 传递完整的engram对象
          });
          const weight = this.strategy.calculate(context);
          logger.debug("[Remember] Weight calculation", {
            from: sourceWord,
            to: targetWord,
            position: i,
            outDegree: context.sourceOutDegree,
            weight
          });
          sourceCue.connections.set(targetWord, weight);
          connections.push({
            source: sourceWord,
            target: targetWord,
            weight,
            position: i
          });
        }
        logger.info("[Remember] Schema processed successfully", {
          nodes: schema.length,
          connections: connections.length,
          timestamp: new Date(timestamp).toISOString()
        });
        const actualEngramId = engramId || engram.id;
        if (actualEngramId) {
          for (const word of schema) {
            const cue = this.network.cues.get(word);
            if (cue) {
              if (!cue.memories) {
                cue.memories = /* @__PURE__ */ new Set();
              }
              cue.memories.add(actualEngramId);
              logger.debug("[Remember] Added engram reference", {
                cue: word,
                engramId: actualEngramId,
                totalReferences: cue.memories.size
              });
            }
          }
        }
        return {
          processed: schema.length,
          connections,
          timestamp,
          engramId: actualEngramId
        };
      }
    };
    module2.exports = Remember2;
  }
});

// src/cognition/ActivationStrategy.js
var require_ActivationStrategy = __commonJS({
  "src/cognition/ActivationStrategy.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var logger = require("@promptx/logger");
    var ActivationStrategy2 = class {
      constructor(options = {}) {
        this.name = "base";
        this.options = options;
      }
      /**
       * 决定如何激活节点
       * 
       * 子类必须实现此方法
       * 
       * @param {ActivationContext} context - 激活上下文
       * @returns {Object} 激活决策
       * @returns {boolean} returns.shouldActivate - 是否应该激活
       * @returns {Array} returns.edges - 要激活的边列表
       */
      activate(context) {
        throw new Error("ActivationStrategy.activate() must be implemented");
      }
      /**
       * 判断是否继续激活
       * 
       * @param {ActivationContext} context - 激活上下文
       * @returns {boolean} true继续，false停止
       */
      shouldContinue(context) {
        return true;
      }
      /**
       * 应用衰减或其他周期性操作
       * 
       * @param {ActivationContext} context - 激活上下文
       */
      applyDecay(context) {
      }
    };
    var HippocampalActivationStrategy2 = class extends ActivationStrategy2 {
      constructor(options = {}) {
        super(options);
        this.name = "hippocampal";
        this.firingThreshold = options.firingThreshold || 0.1;
        this.synapticDecay = options.synapticDecay || 0.9;
        this.inhibitionFactor = options.inhibitionFactor || 0.1;
        this.maxCycles = options.maxCycles || 10;
        this.cycleDecay = options.cycleDecay || 0.9;
        this.frequencyBoost = options.frequencyBoost || 0.1;
        this.weightStrategy = options.weightStrategy || null;
        logger.debug("[HippocampalActivationStrategy] Initialized", {
          firingThreshold: this.firingThreshold,
          synapticDecay: this.synapticDecay,
          maxCycles: this.maxCycles
        });
      }
      /**
       * 决定如何激活节点
       * 
       * @param {ActivationContext} context - 激活上下文
       * @returns {Object} 激活决策
       */
      activate(context) {
        var _a;
        if (context.currentEnergy < this.firingThreshold) {
          logger.debug("[HippocampalActivationStrategy] Energy below threshold", {
            word: (_a = context.sourceCue) == null ? void 0 : _a.word,
            energy: context.currentEnergy,
            threshold: this.firingThreshold
          });
          return { shouldActivate: false, edges: [] };
        }
        if (!context.sourceCue || !context.sourceCue.connections) {
          return { shouldActivate: false, edges: [] };
        }
        let edges = Array.from(context.sourceCue.connections.entries()).map(([targetWord, weight]) => ({
          targetWord,
          weight,
          frequency: context.getTargetFrequency(targetWord)
        }));
        if (this.weightStrategy && typeof this.weightStrategy.normalizeForActivation === "function") {
          edges = this.weightStrategy.normalizeForActivation(edges);
          logger.debug("[HippocampalActivationStrategy] Applied weight strategy normalization", {
            strategy: this.weightStrategy.constructor.name,
            edgeCount: edges.length
          });
        }
        const processedEdges = edges.map((edge) => {
          const activationProbability = edge.probability || edge.weight / edges.reduce((sum, e) => sum + e.weight, 0);
          const freqBonus = 1 + Math.log(1 + edge.frequency) * this.frequencyBoost;
          const transmittedEnergy = context.currentEnergy * activationProbability * this.synapticDecay * freqBonus;
          const inhibition = 1 - this.inhibitionFactor * context.activatedNodes.size / 100;
          const finalEnergy = transmittedEnergy * inhibition;
          return {
            targetWord: edge.targetWord,
            weight: edge.weight,
            energy: finalEnergy,
            frequency: edge.frequency,
            probability: activationProbability,
            batchMultiplier: edge.batchMultiplier || 1,
            shouldFire: finalEnergy >= this.firingThreshold
          };
        });
        const activeEdges = processedEdges.filter(
          (e) => e.shouldFire && !context.isActivated(e.targetWord)
        );
        logger.debug("[HippocampalActivationStrategy] Activation decision", {
          source: context.sourceCue.word,
          sourceEnergy: context.currentEnergy,
          totalEdges: edges.length,
          activeEdges: activeEdges.length,
          cycle: context.cycle,
          hasWeightStrategy: !!this.weightStrategy
        });
        return { shouldActivate: true, edges: activeEdges };
      }
      /**
       * 判断是否继续激活
       * 
       * @param {ActivationContext} context - 激活上下文
       * @returns {boolean} true继续，false停止
       */
      shouldContinue(context) {
        if (context.cycle >= this.maxCycles) {
          logger.debug("[HippocampalActivationStrategy] Max cycles reached", {
            cycle: context.cycle,
            maxCycles: this.maxCycles
          });
          return false;
        }
        let hasHighEnergyNode = false;
        for (const [word, energy] of context.energyPool) {
          if (energy >= this.firingThreshold) {
            hasHighEnergyNode = true;
            break;
          }
        }
        if (!hasHighEnergyNode) {
          logger.debug("[HippocampalActivationStrategy] No high energy nodes", {
            cycle: context.cycle,
            poolSize: context.energyPool.size
          });
        }
        return hasHighEnergyNode;
      }
      /**
       * 应用能量衰减
       * 
       * @param {ActivationContext} context - 激活上下文
       */
      applyDecay(context) {
        for (const [word, energy] of context.energyPool) {
          const decayedEnergy = energy * this.cycleDecay;
          if (decayedEnergy < 0.01) {
            context.energyPool.delete(word);
          } else {
            context.energyPool.set(word, decayedEnergy);
          }
        }
        logger.debug("[HippocampalActivationStrategy] Applied decay", {
          cycle: context.cycle,
          remainingNodes: context.energyPool.size,
          totalEnergy: Array.from(context.energyPool.values()).reduce((sum, e) => sum + e, 0).toFixed(2)
        });
      }
    };
    module2.exports = {
      ActivationStrategy: ActivationStrategy2,
      HippocampalActivationStrategy: HippocampalActivationStrategy2
    };
  }
});

// src/cognition/ActivationContext.js
var require_ActivationContext = __commonJS({
  "src/cognition/ActivationContext.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var ActivationContext2 = class {
      /**
       * 创建激活上下文
       * 
       * @param {Object} params - 初始参数
       * @param {Network} params.network - 认知网络
       * @param {Cue} params.sourceCue - 当前源节点
       * @param {number} params.depth - 当前深度（兼容旧代码）
       * @param {number} params.currentEnergy - 当前节点能量
       * @param {Set} params.activatedNodes - 已激活节点集
       * @param {Map} params.energyPool - 节点能量池
       * @param {number} params.cycle - 循环次数
       * @param {Array} params.connections - 连接记录
       */
      constructor(params = {}) {
        this.network = params.network;
        this.sourceCue = params.sourceCue || null;
        this.depth = params.depth || 0;
        this.currentEnergy = params.currentEnergy || 1;
        this.activatedNodes = params.activatedNodes || /* @__PURE__ */ new Set();
        this.energyPool = params.energyPool || /* @__PURE__ */ new Map();
        this.cycle = params.cycle || 0;
        this.connections = params.connections || [];
        this.timestamp = params.timestamp || Date.now();
      }
      /**
       * 获取目标节点的频率
       * 
       * @param {string} targetWord - 目标词
       * @returns {number} 频率值
       */
      getTargetFrequency(targetWord) {
        const targetCue = this.network.getCue(targetWord);
        return (targetCue == null ? void 0 : targetCue.recallFrequency) || 0;
      }
      /**
       * 检查节点是否已激活
       * 
       * @param {string} word - 节点词
       * @returns {boolean} 是否已激活
       */
      isActivated(word) {
        return this.activatedNodes.has(word);
      }
      /**
       * 获取节点的当前能量
       * 
       * @param {string} word - 节点词
       * @returns {number} 能量值
       */
      getNodeEnergy(word) {
        return this.energyPool.get(word) || 0;
      }
      /**
       * 设置节点能量
       * 
       * @param {string} word - 节点词
       * @param {number} energy - 能量值
       */
      setNodeEnergy(word, energy) {
        if (energy > 0) {
          this.energyPool.set(word, energy);
        } else {
          this.energyPool.delete(word);
        }
      }
      /**
       * 累加节点能量
       * 
       * @param {string} word - 节点词
       * @param {number} energyToAdd - 要添加的能量
       * @returns {number} 新的能量值
       */
      addNodeEnergy(word, energyToAdd) {
        const current = this.getNodeEnergy(word);
        const newEnergy = current + energyToAdd;
        this.setNodeEnergy(word, newEnergy);
        return newEnergy;
      }
      /**
       * 标记节点为已激活
       * 
       * @param {string} word - 节点词
       */
      markActivated(word) {
        this.activatedNodes.add(word);
      }
      /**
       * 记录连接
       * 
       * @param {string} from - 源节点
       * @param {string} to - 目标节点
       * @param {number} weight - 连接权重
       */
      recordConnection(from, to, weight) {
        this.connections.push({ from, to, weight });
      }
      /**
       * 增加循环计数
       */
      incrementCycle() {
        this.cycle++;
      }
      /**
       * 获取统计信息
       * 
       * @returns {Object} 统计信息
       */
      getStatistics() {
        return {
          activatedNodes: this.activatedNodes.size,
          totalEnergy: Array.from(this.energyPool.values()).reduce((sum, e) => sum + e, 0),
          highEnergyNodes: Array.from(this.energyPool.entries()).filter(([_, energy]) => energy > 0.5).length,
          connections: this.connections.length,
          cycle: this.cycle
        };
      }
      /**
       * 转换为调试字符串
       * 
       * @returns {string} 调试信息
       */
      toString() {
        const stats = this.getStatistics();
        return `ActivationContext{cycle:${this.cycle}, activated:${stats.activatedNodes}, energy:${stats.totalEnergy.toFixed(2)}}`;
      }
    };
    module2.exports = ActivationContext2;
  }
});

// src/cognition/Recall.js
var require_Recall = __commonJS({
  "src/cognition/Recall.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var logger = require("@promptx/logger");
    var Recall2 = class {
      /**
       * @param {Network} network - 全局认知网络
       * @param {Object} options - 可选配置
       * @param {ActivationStrategy} options.activationStrategy - 激活策略
       * @param {WeightStrategy} options.weightStrategy - 权重策略（用于归一化）
       */
      constructor(network, options = {}) {
        this.network = network;
        this.weightStrategy = options.weightStrategy || null;
        if (options.activationStrategy) {
          this.activationStrategy = options.activationStrategy;
          if (this.weightStrategy && typeof this.activationStrategy.setWeightStrategy === "function") {
            this.activationStrategy.setWeightStrategy(this.weightStrategy);
          }
        } else {
          const { HippocampalActivationStrategy: HippocampalActivationStrategy2 } = require_ActivationStrategy();
          this.activationStrategy = new HippocampalActivationStrategy2({
            weightStrategy: this.weightStrategy
          });
        }
        logger.debug("[Recall] Initialized", {
          strategy: this.activationStrategy.name,
          hasWeightStrategy: !!this.weightStrategy
        });
      }
      /**
       * 执行记忆检索
       * 
       * @param {string} word - 起始词
       * @returns {Mind|null} 激活的认知网络
       */
      execute(word) {
        logger.debug("[Recall] Starting recall", { word });
        const centerCue = this.network.cues.get(word);
        if (!centerCue) {
          logger.warn("[Recall] Cue not found", { word });
          return null;
        }
        logger.debug("[Recall] Found center Cue", {
          word: centerCue.word,
          outDegree: centerCue.connections.size,
          frequency: centerCue.recallFrequency || 0
        });
        const Mind2 = require_Mind();
        const mind = new Mind2(centerCue);
        const ActivationContext2 = require_ActivationContext();
        const context = new ActivationContext2({
          network: this.network,
          sourceCue: centerCue,
          energyPool: /* @__PURE__ */ new Map([[centerCue.word, 1]]),
          // 初始能量
          activatedNodes: /* @__PURE__ */ new Set([centerCue.word]),
          connections: []
        });
        const startTime = Date.now();
        while (this.activationStrategy.shouldContinue(context)) {
          const newActivations = /* @__PURE__ */ new Map();
          for (const [word2, energy] of context.energyPool) {
            const sourceCue = this.network.getCue(word2);
            if (!sourceCue) continue;
            context.sourceCue = sourceCue;
            context.currentEnergy = energy;
            const { shouldActivate, edges } = this.activationStrategy.activate(context);
            if (shouldActivate && edges.length > 0) {
              logger.debug("[Recall] Activating from node", {
                source: word2,
                energy: energy.toFixed(3),
                edgeCount: edges.length,
                cycle: context.cycle
              });
              for (const edge of edges) {
                const currentEnergy = newActivations.get(edge.targetWord) || 0;
                const totalEnergy = currentEnergy + edge.energy;
                newActivations.set(edge.targetWord, totalEnergy);
                mind.addConnection(word2, edge.targetWord, edge.weight);
                context.recordConnection(word2, edge.targetWord, edge.weight);
                logger.debug("[Recall] Edge activated", {
                  from: word2,
                  to: edge.targetWord,
                  transmittedEnergy: edge.energy.toFixed(3),
                  totalEnergy: totalEnergy.toFixed(3)
                });
              }
            }
          }
          context.energyPool.clear();
          for (const [word2, energy] of newActivations) {
            context.setNodeEnergy(word2, energy);
            if (energy >= (this.activationStrategy.firingThreshold || 0.01)) {
              if (!context.isActivated(word2)) {
                context.markActivated(word2);
                mind.addActivatedCue(word2, context.cycle + 1);
              }
            }
          }
          this.activationStrategy.applyDecay(context);
          context.incrementCycle();
          if (newActivations.size === 0) {
            logger.debug("[Recall] No new activations, stopping", {
              cycle: context.cycle
            });
            break;
          }
        }
        const duration = Date.now() - startTime;
        this.network.updateRecallFrequency(context.activatedNodes);
        logger.info("[Recall] Recall completed", {
          center: word,
          strategy: this.activationStrategy.name,
          cycles: context.cycle,
          activatedNodes: context.activatedNodes.size,
          connections: context.connections.length,
          duration: `${duration}ms`
        });
        return mind;
      }
    };
    module2.exports = Recall2;
  }
});

// src/cognition/Prime.js
var require_Prime = __commonJS({
  "src/cognition/Prime.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var logger = require("@promptx/logger");
    var Recall2 = require_Recall();
    var Prime2 = class extends Recall2 {
      /**
       * 获取默认的启动词
       * 
       * 策略优先级：
       * 1. 选择根节点（入度为0的节点）- 认知网络的起点
       * 2. 选择被指向最多的节点 - 重要概念
       * 3. 返回第一个节点 - 兜底策略
       * 
       * @returns {string|null} 启动词
       */
      getPrimeWord() {
        var _a, _b;
        if (this.network.cues.size === 0) {
          logger.warn("[Prime] Network is empty, no word to prime");
          return null;
        }
        logger.debug("[Prime] Calculating prime word from network", {
          totalCues: this.network.cues.size
        });
        const rootNodes = this.findRootNodes();
        if (rootNodes.length > 0) {
          const selectedRoot = rootNodes.reduce((best, current) => {
            var _a2, _b2, _c, _d;
            const currentOutDegree = ((_b2 = (_a2 = this.network.cues.get(current)) == null ? void 0 : _a2.connections) == null ? void 0 : _b2.size) || 0;
            const bestOutDegree = ((_d = (_c = this.network.cues.get(best)) == null ? void 0 : _c.connections) == null ? void 0 : _d.size) || 0;
            return currentOutDegree > bestOutDegree ? current : best;
          });
          logger.info("[Prime] Selected root node as prime word", {
            word: selectedRoot,
            allRoots: rootNodes,
            outDegree: ((_b = (_a = this.network.cues.get(selectedRoot)) == null ? void 0 : _a.connections) == null ? void 0 : _b.size) || 0
          });
          return selectedRoot;
        }
        const inWeights = this.network.calculateInWeights();
        if (inWeights.size > 0) {
          let maxWeight = 0;
          let primeWord = null;
          for (const [word, weight] of inWeights) {
            if (weight > maxWeight) {
              maxWeight = weight;
              primeWord = word;
            }
          }
          if (primeWord) {
            logger.info("[Prime] Selected high in-degree node as prime word", {
              word: primeWord,
              inWeight: maxWeight
            });
            return primeWord;
          }
        }
        const firstWord = this.network.cues.keys().next().value;
        logger.debug("[Prime] Using first cue as fallback", {
          word: firstWord
        });
        return firstWord;
      }
      /**
       * 寻找根节点（入度为0的节点）
       * @returns {Array<string>} 根节点列表
       */
      findRootNodes() {
        const hasIncomingEdge = /* @__PURE__ */ new Set();
        for (const [sourceWord, sourceCue] of this.network.cues) {
          for (const [targetWord] of sourceCue.connections) {
            hasIncomingEdge.add(targetWord);
          }
        }
        const rootNodes = [];
        for (const word of this.network.cues.keys()) {
          if (!hasIncomingEdge.has(word)) {
            rootNodes.push(word);
          }
        }
        logger.debug("[Prime] Found root nodes", {
          count: rootNodes.length,
          nodes: rootNodes
        });
        return rootNodes;
      }
      /**
       * 执行启动
       * 
       * @param {string} word - 可选的启动词，如果不提供则自动选择
       * @returns {Mind|null} 基础认知状态
       */
      execute(word = null) {
        var _a, _b;
        logger.info("[Prime] Starting prime operation", {
          providedWord: word,
          autoSelect: !word,
          networkSize: this.network.cues.size
        });
        if (!word) {
          word = this.getPrimeWord();
          if (!word) {
            logger.error("[Prime] Failed to find prime word, network empty or no suitable node");
            return null;
          }
          logger.info("[Prime] Auto-selected prime word", { word });
        } else {
          if (!this.network.hasCue(word)) {
            logger.warn("[Prime] Provided word not found in network", { word });
            return null;
          }
        }
        logger.info("[Prime] Executing recall with prime word", {
          word,
          cueExists: this.network.hasCue(word),
          cueConnections: ((_b = (_a = this.network.cues.get(word)) == null ? void 0 : _a.connections) == null ? void 0 : _b.size) || 0
        });
        const mind = super.execute(word);
        if (mind) {
          logger.info("[Prime] Prime completed successfully", {
            primeWord: word,
            activatedNodes: mind.activatedCues.size,
            connections: mind.connections.length
          });
        } else {
          logger.error("[Prime] Prime failed", { word });
        }
        return mind;
      }
      /**
       * 多词启动（实验性功能）
       * 
       * 同时从多个词开始激活，模拟并行思考。
       * 生成的Mind包含多个激活中心。
       * 
       * @param {Array<string>} words - 启动词数组
       * @returns {Mind} 合并的认知状态
       */
      executeMultiple(words) {
        logger.info("[Prime] Starting multi-center prime", {
          words,
          count: words.length
        });
        const Mind2 = require_Mind();
        const mergedMind = new Mind2(null);
        mergedMind.centers = [];
        const validCenters = [];
        const missingWords = [];
        for (const word of words) {
          const cue = this.network.cues.get(word);
          if (!cue) {
            missingWords.push(word);
            logger.warn("[Prime] Word not found in network", { word });
            continue;
          }
          validCenters.push(word);
          mergedMind.centers.push(cue);
          logger.debug("[Prime] Spreading from center", {
            word,
            outDegree: cue.connections.size
          });
          this.spread(cue, mergedMind, [], 0);
        }
        logger.info("[Prime] Multi-center prime completed", {
          requestedWords: words.length,
          validCenters: validCenters.length,
          missingWords,
          activatedNodes: mergedMind.activatedCues.size,
          connections: mergedMind.connections.length
        });
        return mergedMind;
      }
    };
    module2.exports = Prime2;
  }
});

// src/cognition/Memory.js
var require_Memory = __commonJS({
  "src/cognition/Memory.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var { Level } = require("level");
    var logger = require("@promptx/logger");
    var Memory = class {
      /**
       * 创建Memory实例
       * 
       * @param {string} dbPath - LevelDB数据库路径
       */
      constructor(dbPath) {
        this.db = new Level(dbPath, {
          valueEncoding: "json"
          // 自动JSON序列化/反序列化
        });
        logger.debug("[Memory] Initialized", { dbPath });
      }
      /**
       * 存储Engram对象
       * 
       * @param {Engram} engram - 要存储的Engram对象
       * @returns {Promise<string>} Engram的id（作为存储key）
       */
      async store(engram) {
        const key = engram.id;
        try {
          await this.db.put(key, engram.toJSON());
          logger.debug("[Memory] Stored engram", {
            key,
            preview: engram.getPreview(),
            strength: engram.strength
          });
          return key;
        } catch (error) {
          logger.error("[Memory] Failed to store engram", {
            key,
            error: error.message
          });
          throw error;
        }
      }
      /**
       * 获取Engram对象
       * 
       * @param {string} key - 存储key
       * @returns {Promise<Object|null>} Engram数据对象，不存在时返回null
       */
      async get(key) {
        try {
          const data = await this.db.get(key);
          logger.debug("[Memory] Retrieved engram", {
            key,
            hasContent: !!data.content
          });
          return data;
        } catch (error) {
          if (error.notFound) {
            logger.debug("[Memory] Engram not found", { key });
            return null;
          }
          logger.error("[Memory] Failed to retrieve engram", {
            key,
            error: error.message
          });
          throw error;
        }
      }
      /**
       * 关闭数据库连接
       * 
       * @returns {Promise<void>}
       */
      async close() {
        try {
          await this.db.close();
          logger.debug("[Memory] Database closed");
        } catch (error) {
          logger.error("[Memory] Failed to close database", {
            error: error.message
          });
          throw error;
        }
      }
      /**
       * 获取存储统计信息
       * 
       * @returns {Promise<Object>} 统计信息
       */
      async getStatistics() {
        try {
          let count = 0;
          for await (const [key] of this.db.iterator()) {
            count++;
          }
          return {
            totalEngrams: count,
            dbPath: this.db.location
          };
        } catch (error) {
          logger.error("[Memory] Failed to get statistics", {
            error: error.message
          });
          return {
            totalEngrams: 0,
            dbPath: this.db.location,
            error: error.message
          };
        }
      }
    };
    module2.exports = Memory;
  }
});

// src/cognition/WeightStrategy.js
var require_WeightStrategy = __commonJS({
  "src/cognition/WeightStrategy.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var WeightStrategy2 = class {
      /**
       * 计算权重
       * 
       * 子类必须实现此方法。
       * 
       * @param {WeightContext} context - 计算上下文
       * @param {Cue} context.sourceCue - 源节点
       * @param {string} context.targetWord - 目标词
       * @param {number} context.position - 在Schema中的位置
       * @param {number} context.timestamp - 时间戳
       * @param {number} context.sourceOutDegree - 源节点出度
       * @returns {number} 计算得出的权重（应为正数）
       */
      calculate(context) {
        throw new Error("WeightStrategy.calculate() must be implemented");
      }
      /**
       * 激活时归一化（用于Recall）
       * 
       * 将一组边的权重转换为激活概率
       * 默认实现：简单归一化
       * 
       * @param {Array} edges - 边数组 [{targetWord, weight}, ...]
       * @returns {Array} 归一化后的边数组，添加了probability字段
       */
      normalizeForActivation(edges) {
        if (edges.length === 0) return edges;
        const totalWeight = edges.reduce((sum, e) => sum + e.weight, 0);
        return edges.map((edge) => ({
          ...edge,
          probability: edge.weight / totalWeight
        }));
      }
    };
    var SimpleWeightStrategy2 = class extends WeightStrategy2 {
      constructor(options = {}) {
        super();
        this.baseWeight = options.baseWeight || 1;
        this.decay = options.decay || 0.9;
      }
      /**
       * 计算权重
       * 
       * @param {WeightContext} context - 计算上下文
       * @returns {number} 权重值
       */
      calculate(context) {
        const weight = this.baseWeight * Math.pow(this.decay, context.position);
        return weight;
      }
    };
    var TimeBasedWeightStrategy2 = class extends WeightStrategy2 {
      constructor(options = {}) {
        super();
        this.decay = options.decay || 0.9;
        this.activationThreshold = options.activationThreshold || 0.05;
        this.frequencyFactor = options.frequencyFactor || 0.1;
        this.network = null;
      }
      /**
       * 计算存储权重
       * 
       * @param {WeightContext} context - 计算上下文
       * @returns {number} 权重值
       */
      calculate(context) {
        const timestamp = context.timestamp;
        const positionFactor = Math.pow(this.decay, context.position);
        const strengthFactor = context.strength || 0.8;
        const weight = timestamp * positionFactor * strengthFactor;
        return weight;
      }
      /**
       * Softmax归一化（用于激活）
       * 
       * 加入频率偏置，实现"越用越强"的效果
       * 
       * @param {Array} edges - 边数组
       * @returns {Array} 归一化后的边数组
       */
      normalizeForActivation(edges) {
        if (edges.length === 0) return edges;
        const enhancedEdges = edges.map((edge) => {
          let frequency = 0;
          if (this.network) {
            const targetCue = this.network.cues.get(edge.targetWord);
            frequency = targetCue ? targetCue.recallFrequency || 0 : 0;
          }
          const logWeight = Math.log(edge.weight);
          const frequencyBias = Math.log(1 + frequency * this.frequencyFactor);
          return {
            ...edge,
            adjustedLogWeight: logWeight + frequencyBias,
            frequency
          };
        });
        const maxLogWeight = Math.max(...enhancedEdges.map((e) => e.adjustedLogWeight));
        const expWeights = enhancedEdges.map(
          (e) => Math.exp(e.adjustedLogWeight - maxLogWeight)
        );
        const sumExp = expWeights.reduce((a, b) => a + b, 0);
        const normalizedEdges = edges.map((edge, i) => ({
          ...edge,
          probability: expWeights[i] / sumExp,
          frequency: enhancedEdges[i].frequency
        })).sort((a, b) => b.probability - a.probability);
        return normalizedEdges.filter((edge) => edge.probability >= this.activationThreshold);
      }
    };
    var TemperatureWeightStrategy = class extends TimeBasedWeightStrategy2 {
      constructor(options = {}) {
        super(options);
        this.temperature = options.temperature || 0.5;
        this.contrastMode = options.contrastMode || "auto";
      }
      /**
       * 设置对比度级别
       * 
       * @param {'low'|'medium'|'high'} level - 对比度级别
       */
      setContrastLevel(level) {
        const contrastMap = {
          "low": 2,
          // 高温，低对比度（~20%差异）
          "medium": 1,
          // 常温，中等对比度（~50%差异）
          "high": 0.3
          // 低温，高对比度（~80%差异）
        };
        this.temperature = contrastMap[level] || 1;
        this.contrastMode = level;
      }
      /**
       * 设置对比度百分比
       * 
       * @param {number} percentage - 对比度百分比（0-100）
       */
      setContrastPercentage(percentage) {
        const clampedPercentage = Math.max(0, Math.min(100, percentage));
        this.temperature = 2 - clampedPercentage / 100 * 1.8;
        this.contrastMode = "custom";
      }
      /**
       * 自动调节温度（基于网络状态）
       * 
       * @param {Array} edges - 边数组
       * @returns {number} 调节后的温度
       */
      autoAdjustTemperature(edges) {
        if (this.contrastMode !== "auto") {
          return this.temperature;
        }
        const avgConnections = edges.length;
        const hubThreshold = 5;
        if (avgConnections > hubThreshold * 2) {
          return 0.3;
        } else if (avgConnections > hubThreshold) {
          return 0.5;
        } else {
          return 1;
        }
      }
      /**
       * 带温度控制的Softmax归一化
       * 
       * 核心思想：
       * - 权重本身已包含timestamp信息（weight = timestamp * decay^position）
       * - 同批次的权重数量级相近，不同批次差异巨大
       * - 温度控制这种差异的影响程度
       * 
       * @param {Array} edges - 边数组
       * @returns {Array} 归一化后的边数组
       */
      normalizeForActivation(edges) {
        if (edges.length === 0) return edges;
        const effectiveTemperature = this.autoAdjustTemperature(edges);
        const enhancedEdges = edges.map((edge) => {
          let frequency = 0;
          if (this.network) {
            const targetCue = this.network.cues.get(edge.targetWord);
            frequency = targetCue ? targetCue.recallFrequency || 0 : 0;
          }
          const logWeight = Math.log(edge.weight);
          const frequencyBias = Math.log(1 + frequency * this.frequencyFactor);
          return {
            ...edge,
            adjustedLogWeight: logWeight + frequencyBias,
            frequency
          };
        });
        const maxLogWeight = Math.max(...enhancedEdges.map((e) => e.adjustedLogWeight));
        const expWeights = enhancedEdges.map(
          (e) => Math.exp((e.adjustedLogWeight - maxLogWeight) / effectiveTemperature)
        );
        const sumExp = expWeights.reduce((a, b) => a + b, 0);
        const normalizedEdges = enhancedEdges.map((edge, i) => ({
          ...edges[i],
          probability: expWeights[i] / sumExp,
          frequency: edge.frequency,
          temperature: effectiveTemperature
        })).sort((a, b) => b.probability - a.probability);
        return normalizedEdges.filter((edge) => edge.probability >= this.activationThreshold);
      }
    };
    module2.exports = {
      WeightStrategy: WeightStrategy2,
      SimpleWeightStrategy: SimpleWeightStrategy2,
      TimeBasedWeightStrategy: TimeBasedWeightStrategy2,
      TemperatureWeightStrategy
    };
  }
});

// src/cognition/CognitionSystem.js
var require_CognitionSystem = __commonJS({
  "src/cognition/CognitionSystem.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var logger = require("@promptx/logger");
    var Network2 = require_Network();
    var Remember2 = require_Remember();
    var Recall2 = require_Recall();
    var Prime2 = require_Prime();
    var Memory = require_Memory();
    var { TemperatureWeightStrategy } = require_WeightStrategy();
    var CognitionSystem2 = class {
      /**
       * 创建认知系统
       * 
       * @param {Object} options - 配置选项
       * @param {string} options.dataPath - 数据文件路径
       * @param {Object} options.strategyOptions - 策略配置
       * @param {Object} options.rememberOptions - Remember配置
       * @param {Object} options.recallOptions - Recall配置
       */
      constructor(options = {}) {
        this.dataPath = options.dataPath || "./cognition.json";
        this.network = new Network2();
        this.strategy = new TemperatureWeightStrategy({
          decay: 0.9,
          activationThreshold: 0.01,
          // 降低过滤阈值
          frequencyFactor: 0.1,
          // 频率因子
          temperature: 0.8,
          // 提高温度，允许适度扩散
          contrastMode: "auto",
          // 自动调节对比度
          ...options.strategyOptions
        });
        this.strategy.network = this.network;
        this.rememberOptions = {
          ...options.rememberOptions,
          strategy: this.strategy
        };
        this.recallOptions = {
          ...options.recallOptions,
          weightStrategy: this.strategy
          // 传递权重策略
        };
        this.rememberEngine = null;
        this.recallEngine = null;
        this.memory = null;
        logger.info("[CognitionSystem] Initialized", {
          dataPath: this.dataPath,
          strategyType: this.strategy.constructor.name
        });
      }
      /**
       * 获取Remember引擎（懒加载）
       * 
       * @returns {Remember}
       */
      getRememberEngine() {
        if (!this.rememberEngine) {
          this.rememberEngine = new Remember2(this.network, this.rememberOptions);
        }
        return this.rememberEngine;
      }
      /**
       * 获取Recall引擎（懒加载）
       * 
       * @returns {Recall}
       */
      getRecallEngine() {
        if (!this.recallEngine) {
          this.recallEngine = new Recall2(this.network, this.recallOptions);
        }
        return this.recallEngine;
      }
      /**
       * 获取Memory存储（懒加载）
       * 
       * @returns {Memory|null} Memory实例，如果没有directory则返回null
       */
      getMemory() {
        if (!this.memory && this.network.directory) {
          const path = require("path");
          const memoryPath = path.join(this.network.directory, "engrams.db");
          this.memory = new Memory(memoryPath);
        }
        return this.memory;
      }
      /**
       * 记忆操作
       * 
       * 执行流程：
       * 1. 存储Engram到Memory（使用engram.id）
       * 2. 调用Remember引擎处理Schema连接
       * 3. 建立Cue到Engram.id的反向索引
       * 
       * @param {Engram} engram - 记忆痕迹对象
       * @returns {Promise<Object>} 记忆结果
       */
      async remember(engram) {
        logger.debug("[CognitionSystem] Remember operation", {
          id: engram.id,
          schemaLength: engram.length,
          strength: engram.strength,
          preview: engram.getPreview()
        });
        if (this.getMemory()) {
          try {
            await this.getMemory().store(engram);
            logger.debug("[CognitionSystem] Stored engram to memory", { id: engram.id });
          } catch (error) {
            logger.error("[CognitionSystem] Failed to store engram to memory", {
              id: engram.id,
              error: error.message
            });
            throw error;
          }
        }
        const remember = this.getRememberEngine();
        const result = remember.execute(engram, engram.id);
        return result;
      }
      /**
       * 回忆操作
       * 
       * 执行流程：
       * 1. 调用Recall引擎激活网络
       * 2. 加载与原始查询相关的Engrams
       * 3. 更新被激活节点的频率
       * 4. 返回激活的Mind（包含engrams）
       * 
       * @param {string} word - 起始概念
       * @returns {Promise<Mind|null>} 激活的认知网络
       */
      async recall(word) {
        logger.debug("[CognitionSystem] Recall operation", { word });
        const recall = this.getRecallEngine();
        const mind = recall.execute(word);
        if (!mind) {
          return null;
        }
        if (this.getMemory()) {
          try {
            await this.loadEngrams(mind, word);
          } catch (error) {
            logger.error("[CognitionSystem] Failed to load engrams", { error: error.message });
          }
        }
        if (mind.activatedCues.size > 0) {
          this.network.updateRecallFrequency(mind.activatedCues);
          logger.debug("[CognitionSystem] Updated frequencies after recall", {
            activatedCount: mind.activatedCues.size
          });
        }
        return mind;
      }
      /**
       * 加载与查询词直接相关的Engrams
       * 
       * @param {Mind} mind - Mind对象
       * @param {string} originalQuery - 原始查询词
       * @returns {Promise<void>}
       */
      async loadEngrams(mind, originalQuery) {
        var _a, _b;
        mind.engrams = [];
        logger.info("[CognitionSystem] DEBUG - loadEngrams process:", {
          originalQuery,
          networkCuesSize: this.network.cues.size,
          hasMemorySystem: !!this.getMemory(),
          networkCuesKeys: Array.from(this.network.cues.keys())
        });
        const queryCue = this.network.cues.get(originalQuery);
        logger.info("[CognitionSystem] DEBUG - queryCue lookup:", {
          originalQuery,
          hasQueryCue: !!queryCue,
          queryCueMemories: queryCue == null ? void 0 : queryCue.memories,
          memoriesLength: (_a = queryCue == null ? void 0 : queryCue.memories) == null ? void 0 : _a.length
        });
        if (queryCue && queryCue.memories) {
          for (const engramId of queryCue.memories) {
            const engramData = await this.getMemory().get(engramId);
            logger.debug("[CognitionSystem] DEBUG - loading engram:", {
              engramId,
              hasEngramData: !!engramData,
              engramContent: (_b = engramData == null ? void 0 : engramData.content) == null ? void 0 : _b.substring(0, 50)
            });
            if (engramData) {
              mind.engrams.push({
                id: engramData.id,
                content: engramData.content,
                schema: engramData.schema,
                strength: engramData.strength,
                timestamp: engramData.timestamp,
                activatedBy: originalQuery
              });
            }
          }
        } else {
          logger.info("[CognitionSystem] DEBUG - No engrams loaded - reason:", {
            hasQueryCue: !!queryCue,
            hasMemories: !!(queryCue == null ? void 0 : queryCue.memories),
            query: originalQuery
          });
        }
        logger.debug("[CognitionSystem] Loaded engrams", {
          query: originalQuery,
          engramCount: mind.engrams.length
        });
      }
      /**
       * 启动操作
       * 
       * 执行流程：
       * 1. 从磁盘加载Network
       * 2. 使用Prime选择起始点
       * 3. 执行预热Recall
       * 
       * @returns {Mind|null} 预热的认知网络
       */
      async prime() {
        var _a, _b, _c;
        logger.debug("[CognitionSystem] Prime operation");
        logger.info("[CognitionSystem] Using existing network", {
          cues: this.network.size()
        });
        const prime = new Prime2(this.network);
        const mind = prime.execute();
        if (!mind) {
          logger.warn("[CognitionSystem] Prime found no suitable starting point or recall failed");
          return null;
        }
        logger.info("[CognitionSystem] Prime completed", {
          activatedNodes: ((_a = mind.activatedCues) == null ? void 0 : _a.size) || 0,
          connections: ((_b = mind.connections) == null ? void 0 : _b.length) || 0,
          centerWord: mind.centerWord
        });
        if (this.getMemory() && mind.centerWord) {
          try {
            await this.loadEngrams(mind, mind.centerWord);
            logger.info("[CognitionSystem] Loaded engrams for prime center word", {
              centerWord: mind.centerWord,
              engramCount: ((_c = mind.engrams) == null ? void 0 : _c.length) || 0
            });
          } catch (error) {
            logger.error("[CognitionSystem] Failed to load engrams for prime", {
              centerWord: mind.centerWord,
              error: error.message
            });
          }
        }
        return mind;
      }
      /**
       * 获取系统统计信息
       * 
       * @returns {Object} 统计信息
       */
      getStatistics() {
        const networkStats = this.network.getStatistics();
        const frequencyStats = this.network.getFrequencyStatistics();
        return {
          network: networkStats,
          frequency: frequencyStats,
          dataPath: this.dataPath,
          strategy: {
            type: this.strategy.constructor.name,
            decay: this.strategy.decay,
            frequencyFactor: this.strategy.frequencyFactor || 0
          }
        };
      }
      /**
       * 清空系统
       * 
       * 用于测试或重置。
       */
      clear() {
        this.network.clear();
        this.rememberEngine = null;
        this.recallEngine = null;
        logger.info("[CognitionSystem] System cleared");
      }
      /**
       * 手动保存
       * 
       * 虽然remember会自动保存，但提供手动保存接口。
       */
      save() {
        this.network.persistSync(this.dataPath);
        logger.info("[CognitionSystem] Manual save completed");
      }
      /**
       * 手动加载
       * 
       * 虽然prime会自动加载，但提供手动加载接口。
       */
      load() {
        this.network.loadSync(this.dataPath);
        this.rememberEngine = null;
        this.recallEngine = null;
        logger.info("[CognitionSystem] Manual load completed");
      }
    };
    module2.exports = CognitionSystem2;
  }
});

// src/cognition/index.js
init_cjs_shims();
var Cue = require_Cue();
var Network = require_Network();
var Mind = require_Mind();
var Remember = require_Remember();
var Recall = require_Recall();
var Prime = require_Prime();
var WeightContext = require_WeightContext();
var ActivationContext = require_ActivationContext();
var CognitionSystem = require_CognitionSystem();
var { WeightStrategy, SimpleWeightStrategy, TimeBasedWeightStrategy } = require_WeightStrategy();
var { ActivationStrategy, HippocampalActivationStrategy } = require_ActivationStrategy();
module.exports = {
  // 核心数据结构
  Cue,
  Network,
  Mind,
  WeightContext,
  ActivationContext,
  // 操作类
  Remember,
  Recall,
  Prime,
  // 权重策略
  WeightStrategy,
  SimpleWeightStrategy,
  TimeBasedWeightStrategy,
  // 激活策略
  ActivationStrategy,
  HippocampalActivationStrategy,
  // 系统
  CognitionSystem
};
//# sourceMappingURL=cognition.js.map