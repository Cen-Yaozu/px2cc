"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));

// ../../node_modules/.pnpm/tsup@8.5.0_jiti@2.5.1_postcss@8.5.6_tsx@4.20.5_typescript@5.9.2_yaml@2.8.1/node_modules/tsup/assets/cjs_shims.js
var init_cjs_shims = __esm({
  "../../node_modules/.pnpm/tsup@8.5.0_jiti@2.5.1_postcss@8.5.6_tsx@4.20.5_typescript@5.9.2_yaml@2.8.1/node_modules/tsup/assets/cjs_shims.js"() {
    "use strict";
  }
});

// src/cognition/Cue.js
var require_Cue = __commonJS({
  "src/cognition/Cue.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var Cue = class _Cue {
      /**
       * 创建一个新的Cue节点
       * 
       * @param {string} word - 概念词，作为节点的唯一标识
       * 
       * @example
       * const cue = new Cue("认知");
       * cue.connections.set("模型", 1234567890);
       */
      constructor(word) {
        this.word = word;
        this.connections = /* @__PURE__ */ new Map();
      }
      /**
       * 获取节点的出度（连接到多少个其他节点）
       * 
       * 出度的意义：
       * - 高出度 = 枢纽节点（hub），概念发散性强
       * - 低出度 = 专门节点，概念专一性强
       * 
       * @returns {number} 出边数量
       */
      getOutDegree() {
        return this.connections.size;
      }
      /**
       * 获取最强连接（权重最高的出边）
       * 
       * 用途：
       * - Prime时选择默认激活路径
       * - Recall时决定主要扩散方向
       * 
       * @returns {{word: string, weight: number}|null} 最强连接信息
       */
      getStrongestConnection() {
        if (this.connections.size === 0) return null;
        let maxWeight = -Infinity;
        let strongestWord = null;
        for (const [word, weight] of this.connections) {
          if (weight > maxWeight) {
            maxWeight = weight;
            strongestWord = word;
          }
        }
        return { word: strongestWord, weight: maxWeight };
      }
      /**
       * 获取按权重排序的连接列表
       * 
       * @param {number} limit - 返回前N个连接
       * @returns {Array<{word: string, weight: number}>} 排序后的连接列表
       */
      getSortedConnections(limit = Infinity) {
        return Array.from(this.connections.entries()).map(([word, weight]) => ({ word, weight })).sort((a, b) => b.weight - a.weight).slice(0, limit);
      }
      /**
       * 序列化为JSON对象（用于持久化）
       * 
       * @returns {Object} 可序列化的对象
       */
      toJSON() {
        return {
          word: this.word,
          connections: Array.from(this.connections.entries()).map(([target, weight]) => ({
            target,
            weight
          }))
        };
      }
      /**
       * 从JSON对象恢复（用于加载）
       * 
       * @param {Object} json - 序列化的对象
       * @returns {Cue} 恢复的Cue实例
       */
      static fromJSON(json) {
        const cue = new _Cue(json.word);
        if (json.connections) {
          for (const conn of json.connections) {
            cue.connections.set(conn.target, conn.weight);
          }
        }
        return cue;
      }
    };
    module2.exports = Cue;
  }
});

// src/cognition/FrequencyCue.js
var require_FrequencyCue = __commonJS({
  "src/cognition/FrequencyCue.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var Cue = require_Cue();
    var logger = require("@promptx/logger");
    var FrequencyCue = class _FrequencyCue extends Cue {
      /**
       * 创建一个带频率统计的Cue
       * 
       * @param {string} word - 概念词
       */
      constructor(word) {
        super(word);
        this.recallFrequency = 0;
      }
      /**
       * 增加recall频率
       * 
       * 设计：
       * - 简单递增，不设上限
       * - 未来可以考虑添加衰减机制
       * - 可以扩展为更复杂的统计（如时间窗口内的频率）
       */
      incrementFrequency() {
        this.recallFrequency++;
        logger.debug("[FrequencyCue] Frequency incremented", {
          word: this.word,
          newFrequency: this.recallFrequency
        });
      }
      /**
       * 获取频率值
       * 
       * @returns {number} 当前频率
       */
      getFrequency() {
        return this.recallFrequency;
      }
      /**
       * 重置频率（用于测试或清理）
       */
      resetFrequency() {
        this.recallFrequency = 0;
        logger.debug("[FrequencyCue] Frequency reset", { word: this.word });
      }
      /**
       * 序列化为JSON（包含频率信息）
       * 
       * @returns {Object} 包含频率的序列化对象
       */
      toJSON() {
        return {
          ...super.toJSON(),
          recallFrequency: this.recallFrequency
        };
      }
      /**
       * 从JSON恢复（包含频率信息）
       * 
       * @param {Object} json - 序列化的对象
       * @returns {FrequencyCue} 恢复的FrequencyCue实例
       */
      static fromJSON(json) {
        const freqCue = new _FrequencyCue(json.word);
        if (json.connections) {
          for (const conn of json.connections) {
            freqCue.connections.set(conn.target, conn.weight);
          }
        }
        freqCue.recallFrequency = json.recallFrequency || 0;
        return freqCue;
      }
      /**
       * 获取调试信息
       * 
       * @returns {Object} 调试信息
       */
      getDebugInfo() {
        return {
          word: this.word,
          outDegree: this.getOutDegree(),
          recallFrequency: this.recallFrequency,
          strongestConnection: this.getStrongestConnection()
        };
      }
    };
    module2.exports = FrequencyCue;
  }
});

// src/cognition/Network.js
var require_Network = __commonJS({
  "src/cognition/Network.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var logger = require("@promptx/logger");
    var fs = require("fs");
    var path = require("path");
    var Network = class {
      constructor() {
        this.cues = /* @__PURE__ */ new Map();
        logger.debug("[Network] Initialized empty network");
      }
      /**
       * 添加或获取Cue
       * 
       * 如果Cue不存在则创建，存在则返回现有的。
       * 这是一个幂等操作，多次调用结果相同。
       * 
       * @param {string} word - 概念词
       * @returns {FrequencyCue} FrequencyCue实例
       */
      getOrCreateCue(word) {
        if (!this.cues.has(word)) {
          const FrequencyCue = require_FrequencyCue();
          const cue = new FrequencyCue(word);
          this.cues.set(word, cue);
          logger.debug("[Network] Created new FrequencyCue", { word });
        }
        return this.cues.get(word);
      }
      /**
       * 获取Cue（不创建）
       * 
       * @param {string} word - 概念词
       * @returns {Cue|undefined} Cue实例或undefined
       */
      getCue(word) {
        return this.cues.get(word);
      }
      /**
       * 检查Cue是否存在
       * 
       * @param {string} word - 概念词
       * @returns {boolean} 是否存在
       */
      hasCue(word) {
        return this.cues.has(word);
      }
      /**
       * 获取网络规模
       * 
       * @returns {number} Cue总数
       */
      size() {
        return this.cues.size;
      }
      /**
       * 计算网络的入度信息
       * 
       * 入度 = 有多少其他Cue指向这个Cue
       * 这需要遍历整个网络，因为我们只存储出边。
       * 
       * @returns {Map<string, number>} word => 入度
       */
      calculateInDegrees() {
        const inDegrees = /* @__PURE__ */ new Map();
        for (const word of this.cues.keys()) {
          inDegrees.set(word, 0);
        }
        for (const [sourceWord, sourceCue] of this.cues) {
          for (const targetWord of sourceCue.connections.keys()) {
            const currentDegree = inDegrees.get(targetWord) || 0;
            inDegrees.set(targetWord, currentDegree + 1);
          }
        }
        return inDegrees;
      }
      /**
       * 计算网络的入度权重（每个节点被指向的总权重）
       * 
       * 用于Prime选择最重要的节点。
       * 
       * @returns {Map<string, number>} word => 总入度权重
       */
      calculateInWeights() {
        const inWeights = /* @__PURE__ */ new Map();
        for (const [sourceWord, sourceCue] of this.cues) {
          for (const [targetWord, weight] of sourceCue.connections) {
            const currentWeight = inWeights.get(targetWord) || 0;
            inWeights.set(targetWord, currentWeight + weight);
          }
        }
        return inWeights;
      }
      /**
       * 获取网络统计信息
       * 
       * @returns {Object} 统计信息
       */
      getStatistics() {
        let totalConnections = 0;
        let maxOutDegree = 0;
        let hubNode = null;
        let isolatedNodes = 0;
        for (const [word, cue] of this.cues) {
          const outDegree = cue.connections.size;
          totalConnections += outDegree;
          if (outDegree === 0) {
            isolatedNodes++;
          }
          if (outDegree > maxOutDegree) {
            maxOutDegree = outDegree;
            hubNode = word;
          }
        }
        const inDegrees = this.calculateInDegrees();
        let maxInDegree = 0;
        let sinkNode = null;
        for (const [word, inDegree] of inDegrees) {
          if (inDegree > maxInDegree) {
            maxInDegree = inDegree;
            sinkNode = word;
          }
        }
        return {
          totalCues: this.cues.size,
          totalConnections,
          averageOutDegree: this.cues.size > 0 ? totalConnections / this.cues.size : 0,
          maxOutDegree,
          hubNode,
          // 出度最高的节点（发散中心）
          maxInDegree,
          sinkNode,
          // 入度最高的节点（汇聚中心）
          isolatedNodes
          // 孤立节点数量
        };
      }
      /**
       * 序列化Network到JSON文件
       * 
       * 设计考虑：
       * - 使用同步版本避免异步复杂性
       * - 包含版本号便于未来升级
       * - 包含时间戳便于调试
       * 
       * @param {string} filePath - 保存路径
       * @returns {Promise<void>}
       */
      async persist(filePath) {
        try {
          const fs2 = require("fs").promises;
          const path2 = require("path");
          const data = {
            version: "1.0",
            timestamp: Date.now(),
            cues: {}
          };
          for (const [word, cue] of this.cues) {
            data.cues[word] = cue.toJSON();
          }
          const dir = path2.dirname(filePath);
          await fs2.mkdir(dir, { recursive: true });
          await fs2.writeFile(filePath, JSON.stringify(data, null, 2), "utf8");
          logger.info("[Network] Persisted to file", {
            path: filePath,
            cues: this.cues.size,
            size: JSON.stringify(data).length
          });
        } catch (error) {
          logger.error("[Network] Failed to persist", {
            path: filePath,
            error: error.message
          });
          throw error;
        }
      }
      /**
       * 从JSON文件加载Network
       * 
       * @param {string} filePath - 文件路径
       * @returns {Promise<void>}
       */
      async load(filePath) {
        try {
          const fs2 = require("fs").promises;
          const FrequencyCue = require_FrequencyCue();
          const content = await fs2.readFile(filePath, "utf8");
          const data = JSON.parse(content);
          if (data.version !== "1.0") {
            logger.warn("[Network] Version mismatch", {
              expected: "1.0",
              actual: data.version
            });
          }
          this.cues.clear();
          for (const [word, cueData] of Object.entries(data.cues)) {
            const cue = FrequencyCue.fromJSON(cueData);
            this.cues.set(word, cue);
          }
          logger.info("[Network] Loaded from file", {
            path: filePath,
            cues: this.cues.size,
            timestamp: new Date(data.timestamp).toISOString()
          });
        } catch (error) {
          logger.error("[Network] Failed to load", {
            path: filePath,
            error: error.message
          });
          throw error;
        }
      }
      /**
       * 同步版本的persist
       * 
       * Remember需要同步保存，避免异步复杂性。
       * 
       * @param {string} filePath - 保存路径
       */
      persistSync(filePath) {
        try {
          const data = {
            version: "1.0",
            timestamp: Date.now(),
            cues: {}
          };
          for (const [word, cue] of this.cues) {
            data.cues[word] = cue.toJSON();
          }
          const dir = path.dirname(filePath);
          fs.mkdirSync(dir, { recursive: true });
          fs.writeFileSync(filePath, JSON.stringify(data, null, 2), "utf8");
          logger.debug("[Network] Persisted (sync) to file", {
            path: filePath,
            cues: this.cues.size
          });
        } catch (error) {
          logger.error("[Network] Failed to persist (sync)", {
            path: filePath,
            error: error.message
          });
          throw error;
        }
      }
      /**
       * 同步版本的load
       * 
       * Prime需要同步加载，避免异步复杂性。
       * 
       * @param {string} filePath - 文件路径
       */
      loadSync(filePath) {
        try {
          const FrequencyCue = require_FrequencyCue();
          const content = fs.readFileSync(filePath, "utf8");
          const data = JSON.parse(content);
          if (data.version !== "1.0") {
            logger.warn("[Network] Version mismatch", {
              expected: "1.0",
              actual: data.version
            });
          }
          this.cues.clear();
          for (const [word, cueData] of Object.entries(data.cues)) {
            const cue = FrequencyCue.fromJSON(cueData);
            this.cues.set(word, cue);
          }
          logger.debug("[Network] Loaded (sync) from file", {
            path: filePath,
            cues: this.cues.size
          });
        } catch (error) {
          logger.error("[Network] Failed to load (sync)", {
            path: filePath,
            error: error.message
          });
          throw error;
        }
      }
      /**
       * 更新Recall频率
       * 
       * 当Recall操作完成后，更新所有被激活节点的频率。
       * 这是Network作为容器管理统计信息的体现。
       * 
       * @param {Set<string>} activatedCues - 被激活的节点集合
       */
      updateRecallFrequency(activatedCues) {
        if (!activatedCues || activatedCues.size === 0) {
          return;
        }
        let updatedCount = 0;
        for (const word of activatedCues) {
          const cue = this.cues.get(word);
          if (cue && typeof cue.incrementFrequency === "function") {
            cue.incrementFrequency();
            updatedCount++;
          }
        }
        logger.debug("[Network] Updated recall frequencies", {
          requested: activatedCues.size,
          updated: updatedCount
        });
      }
      /**
       * 获取频率统计信息
       * 
       * @returns {Object} 频率统计
       */
      getFrequencyStatistics() {
        let totalFrequency = 0;
        let maxFrequency = 0;
        let mostFrequentNode = null;
        const frequencyDistribution = /* @__PURE__ */ new Map();
        for (const [word, cue] of this.cues) {
          const frequency = cue.recallFrequency || 0;
          totalFrequency += frequency;
          if (frequency > maxFrequency) {
            maxFrequency = frequency;
            mostFrequentNode = word;
          }
          const bucket = Math.floor(frequency / 10) * 10;
          frequencyDistribution.set(bucket, (frequencyDistribution.get(bucket) || 0) + 1);
        }
        return {
          totalRecalls: totalFrequency,
          averageFrequency: this.cues.size > 0 ? totalFrequency / this.cues.size : 0,
          maxFrequency,
          mostFrequentNode,
          distribution: Array.from(frequencyDistribution.entries()).sort((a, b) => a[0] - b[0]).map(([bucket, count]) => ({ range: `${bucket}-${bucket + 9}`, count }))
        };
      }
      /**
       * 清空网络
       * 
       * 用于测试或重置。
       */
      clear() {
        const previousSize = this.cues.size;
        this.cues.clear();
        logger.info("[Network] Cleared", { previousSize });
      }
    };
    module2.exports = Network;
  }
});

// src/cognition/Mind.js
var require_Mind = __commonJS({
  "src/cognition/Mind.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var Mind = class {
      /**
       * 创建一个新的Mind
       * 
       * @param {Cue} center - 中心Cue（激活的起点）
       */
      constructor(center) {
        this.center = center;
        this.activatedCues = /* @__PURE__ */ new Set();
        this.connections = [];
        this.centers = [];
        this.depths = /* @__PURE__ */ new Map();
        if (center) {
          this.activatedCues.add(center.word);
          this.depths.set(center.word, 0);
        }
      }
      /**
       * 添加一个激活的Cue
       * 
       * @param {string} word - 概念词
       * @param {number} depth - 距离中心的深度
       */
      addActivatedCue(word, depth = 0) {
        this.activatedCues.add(word);
        if (!this.depths.has(word) || this.depths.get(word) > depth) {
          this.depths.set(word, depth);
        }
      }
      /**
       * 添加一个连接
       * 
       * @param {string} from - 源节点
       * @param {string} to - 目标节点
       * @param {number} weight - 连接权重
       */
      addConnection(from, to, weight) {
        this.connections.push({ from, to, weight });
        this.activatedCues.add(from);
        this.activatedCues.add(to);
      }
      /**
       * 获取激活的节点数量
       * 
       * @returns {number} 节点数
       */
      size() {
        return this.activatedCues.size;
      }
      /**
       * 获取连接数量
       * 
       * @returns {number} 边数
       */
      connectionCount() {
        return this.connections.length;
      }
      /**
       * 检查是否为空Mind
       * 
       * @returns {boolean} 是否为空
       */
      isEmpty() {
        return this.activatedCues.size === 0;
      }
      /**
       * 获取按权重排序的连接
       * 
       * @returns {Array} 排序后的连接
       */
      getSortedConnections() {
        return [...this.connections].sort((a, b) => b.weight - a.weight);
      }
      /**
       * 获取特定节点的所有出边
       * 
       * @param {string} word - 节点词
       * @returns {Array} 出边列表
       */
      getOutgoingConnections(word) {
        return this.connections.filter((conn) => conn.from === word);
      }
      /**
       * 获取特定节点的所有入边
       * 
       * @param {string} word - 节点词
       * @returns {Array} 入边列表
       */
      getIncomingConnections(word) {
        return this.connections.filter((conn) => conn.to === word);
      }
      /**
       * 转换为可序列化的JSON对象
       * 
       * 用于：
       * - 发送给大模型
       * - 保存思维快照
       * - 可视化展示
       * 
       * @returns {Object} JSON对象
       */
      toJSON() {
        return {
          center: this.center ? this.center.word : null,
          centers: this.centers.map((c) => c.word),
          activatedCues: Array.from(this.activatedCues),
          connections: this.connections,
          depths: Array.from(this.depths.entries()).map(([word, depth]) => ({ word, depth })),
          statistics: {
            nodeCount: this.activatedCues.size,
            edgeCount: this.connections.length,
            maxDepth: Math.max(...this.depths.values(), 0)
          }
        };
      }
      /**
       * 生成Mermaid mindmap代码
       * 
       * 可以直接用于可视化展示
       * 
       * @returns {string} Mermaid mindmap代码
       */
      toMermaid() {
        if (!this.center || this.activatedCues.size === 0) {
          return "mindmap\n  root((\u7A7A))";
        }
        const tree = this.buildTree();
        let mermaid = "mindmap\n";
        mermaid += `  root((${this.center.word}))
`;
        const addChildren = (parent, indent) => {
          const children = tree.get(parent) || [];
          for (const child of children) {
            mermaid += " ".repeat(indent) + child + "\n";
            addChildren(child, indent + 2);
          }
        };
        addChildren(this.center.word, 4);
        return mermaid;
      }
      /**
       * 构建树形结构
       * 用于生成mindmap
       * 
       * @returns {Map<string, Array<string>>} 父节点 -> 子节点列表
       */
      buildTree() {
        const tree = /* @__PURE__ */ new Map();
        const visited = /* @__PURE__ */ new Set();
        for (const conn of this.connections) {
          if (!tree.has(conn.from)) {
            tree.set(conn.from, []);
          }
          if (!visited.has(`${conn.from}->${conn.to}`)) {
            tree.get(conn.from).push(conn.to);
            visited.add(`${conn.from}->${conn.to}`);
          }
        }
        for (const [parent, children] of tree) {
          const childrenWithWeight = children.map((child) => {
            const conn = this.connections.find((c) => c.from === parent && c.to === child);
            return { child, weight: conn ? conn.weight : 0 };
          });
          childrenWithWeight.sort((a, b) => b.weight - a.weight);
          tree.set(parent, childrenWithWeight.map((item) => item.child));
        }
        return tree;
      }
      /**
       * 合并另一个Mind
       * 
       * 用于多线索思考的场景
       * 
       * @param {Mind} otherMind - 要合并的Mind
       */
      merge(otherMind) {
        for (const cue of otherMind.activatedCues) {
          this.activatedCues.add(cue);
        }
        const existingConns = new Set(
          this.connections.map((c) => `${c.from}->${c.to}`)
        );
        for (const conn of otherMind.connections) {
          const key = `${conn.from}->${conn.to}`;
          if (!existingConns.has(key)) {
            this.connections.push(conn);
          }
        }
        for (const [word, depth] of otherMind.depths) {
          if (!this.depths.has(word) || this.depths.get(word) > depth) {
            this.depths.set(word, depth);
          }
        }
        if (otherMind.center) {
          this.centers.push(otherMind.center);
        }
      }
    };
    module2.exports = Mind;
  }
});

// src/cognition/Engram.js
var require_Engram = __commonJS({
  "src/cognition/Engram.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var logger = require("@promptx/logger");
    var Engram = class _Engram {
      /**
       * 创建记忆痕迹
       * 
       * @param {Object} params - 参数对象
       * @param {string} params.content - 原始经验内容
       * @param {string|Array} params.schema - 概念序列（字符串或数组）
       * @param {number} params.strength - 记忆强度 (0-1)，表示角色的主观重要性评分
       * @param {number} [params.timestamp] - 时间戳（可选，默认为当前时间）
       */
      constructor({ content, schema, strength, timestamp }) {
        if (!content) {
          throw new Error("Engram requires content");
        }
        if (!schema) {
          throw new Error("Engram requires schema");
        }
        if (strength === void 0 || strength === null) {
          throw new Error("Engram requires strength");
        }
        this.content = content;
        this.schema = this._normalizeSchema(schema);
        this.strength = this._validateStrength(strength);
        this.timestamp = timestamp || Date.now();
        this.id = `${this.timestamp}_${Math.random().toString(36).substr(2, 9)}`;
        logger.debug("[Engram] Created new engram", {
          schemaLength: this.schema.length,
          strength: this.strength,
          timestamp: new Date(this.timestamp).toISOString()
        });
      }
      /**
       * 标准化schema格式
       * 支持字符串（换行分隔）或数组格式
       * 
       * @private
       * @param {string|Array} schema - 原始schema
       * @returns {Array<string>} 标准化的概念数组
       */
      _normalizeSchema(schema) {
        if (Array.isArray(schema)) {
          return schema.filter((item) => item && typeof item === "string");
        }
        if (typeof schema === "string") {
          return schema.split("\n").map((s) => s.trim()).filter(Boolean);
        }
        throw new Error("Schema must be a string or array");
      }
      /**
       * 验证strength值的有效性
       * 
       * @private
       * @param {number} strength - 强度值
       * @returns {number} 验证后的强度值
       */
      _validateStrength(strength) {
        const num = Number(strength);
        if (isNaN(num)) {
          throw new Error("Strength must be a number");
        }
        if (num < 0 || num > 1) {
          throw new Error("Strength must be between 0 and 1");
        }
        return num;
      }
      /**
       * 获取schema长度
       * 用于快速判断是否可以创建连接
       * 
       * @returns {number} schema数组的长度
       */
      get length() {
        return this.schema.length;
      }
      /**
       * 判断是否有效
       * schema至少需要2个元素才能创建连接
       * 
       * @returns {boolean} 是否为有效的engram
       */
      isValid() {
        return this.schema.length >= 2;
      }
      /**
       * 获取预览字符串
       * 用于日志和调试
       * 
       * @param {number} [maxLength=5] - 最大显示元素数
       * @returns {string} 预览字符串
       */
      getPreview(maxLength = 5) {
        const preview = this.schema.slice(0, maxLength).join(" -> ");
        return this.schema.length > maxLength ? `${preview}...` : preview;
      }
      /**
       * 转换为JSON对象
       * 用于序列化和传输
       * 
       * @returns {Object} JSON对象
       */
      toJSON() {
        return {
          id: this.id,
          content: this.content,
          schema: this.schema,
          strength: this.strength,
          timestamp: this.timestamp
        };
      }
      /**
       * 从JSON对象创建Engram
       * 用于反序列化
       * 
       * @static
       * @param {Object} json - JSON对象
       * @returns {Engram} 新的Engram实例
       */
      static fromJSON(json) {
        return new _Engram(json);
      }
    };
    module2.exports = Engram;
  }
});

// src/cognition/WeightContext.js
var require_WeightContext = __commonJS({
  "src/cognition/WeightContext.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var WeightContext = class {
      /**
       * 创建权重计算上下文
       * 
       * @param {Object} data - 上下文数据
       * @param {Cue} data.sourceCue - 源节点
       * @param {string} data.targetWord - 目标词
       * @param {number} data.position - 在Schema中的位置
       * @param {number} [data.timestamp] - 时间戳（可选，默认当前时间）
       * @param {Engram} [data.engram] - 完整的记忆痕迹对象（可选）
       */
      constructor(data) {
        this.sourceCue = data.sourceCue;
        this.targetWord = data.targetWord;
        this.position = data.position;
        this.timestamp = data.timestamp || Date.now();
        this.sourceOutDegree = this.sourceCue ? this.sourceCue.connections.size : 0;
        this.engram = data.engram || null;
        this.strength = this.engram ? this.engram.strength : 0.8;
      }
      /**
       * 获取源词
       * 
       * 便捷方法，避免总是写this.sourceCue.word
       * 
       * @returns {string|null} 源词
       */
      getSourceWord() {
        return this.sourceCue ? this.sourceCue.word : null;
      }
      /**
       * 转换为调试字符串
       * 
       * 用于日志输出，包含关键信息。
       * 
       * @returns {string} 调试信息
       */
      toString() {
        const sourceWord = this.getSourceWord();
        return `WeightContext{${sourceWord}->${this.targetWord}, pos:${this.position}, degree:${this.sourceOutDegree}}`;
      }
      /**
       * 转换为JSON对象
       * 
       * 用于序列化和日志记录。
       * 
       * @returns {Object} JSON对象
       */
      toJSON() {
        return {
          sourceWord: this.getSourceWord(),
          targetWord: this.targetWord,
          position: this.position,
          timestamp: this.timestamp,
          sourceOutDegree: this.sourceOutDegree,
          strength: this.strength
        };
      }
    };
    module2.exports = WeightContext;
  }
});

// src/cognition/Remember.js
var require_Remember = __commonJS({
  "src/cognition/Remember.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var logger = require("@promptx/logger");
    var Remember = class {
      /**
       * 创建Remember实例
       * 
       * @param {Network} network - 全局认知网络
       * @param {WeightStrategy} strategy - 权重计算策略
       */
      constructor(network, options = {}) {
        this.network = network;
        this.strategy = options.strategy || null;
        if (this.strategy) {
          logger.debug("[Remember] Initialized with strategy", {
            strategy: this.strategy.constructor.name
          });
        } else {
          logger.warn("[Remember] No strategy provided");
        }
      }
      /**
       * 执行记忆写入
       * 
       * 将Engram中的Schema序列写入Network，建立Cue之间的连接，
       * 同时建立Cue到Engram.id的反向索引。
       * 
       * @param {Engram} engram - 记忆痕迹对象
       * @param {string} [engramId] - 可选的Engram ID，默认使用engram.id
       * @returns {Object} 执行结果
       * @returns {number} returns.processed - 处理的节点数
       * @returns {Array} returns.connections - 创建的连接列表
       * @returns {string} returns.engramId - 使用的Engram ID
       */
      execute(engram, engramId = null) {
        const Engram = require_Engram();
        if (!engram || !(engram instanceof Engram)) {
          logger.warn("[Remember] Invalid engram provided", { engram });
          return {
            processed: 0,
            connections: []
          };
        }
        if (!engram.isValid()) {
          logger.debug("[Remember] Engram schema too short, no connections to create", {
            length: engram.length
          });
          return {
            processed: engram.length,
            connections: []
          };
        }
        const { schema, strength, timestamp } = engram;
        logger.debug("[Remember] Processing engram", {
          length: schema.length,
          strength,
          preview: engram.getPreview()
        });
        logger.debug("[Remember] Phase 1: Ensuring all Cues exist");
        const createdCues = [];
        for (const word of schema) {
          if (!this.network.cues.has(word)) {
            createdCues.push(word);
          }
          this.network.getOrCreateCue(word);
        }
        if (createdCues.length > 0) {
          logger.debug("[Remember] Created new Cues", {
            count: createdCues.length,
            cues: createdCues.slice(0, 10)
            // 只显示前10个
          });
        }
        logger.debug("[Remember] Phase 2: Building connection structure");
        const WeightContext = require_WeightContext();
        const connections = [];
        for (let i = 0; i < schema.length - 1; i++) {
          const sourceWord = schema[i];
          const targetWord = schema[i + 1];
          const sourceCue = this.network.cues.get(sourceWord);
          const existingWeight = sourceCue.connections.get(targetWord);
          if (!existingWeight) {
            sourceCue.connections.set(targetWord, 0);
          }
        }
        logger.debug("[Remember] Phase 2.2: Calculating and updating weights");
        for (let i = 0; i < schema.length - 1; i++) {
          const sourceWord = schema[i];
          const targetWord = schema[i + 1];
          const sourceCue = this.network.cues.get(sourceWord);
          const context = new WeightContext({
            sourceCue,
            targetWord,
            position: i,
            timestamp,
            engram
            // 传递完整的engram对象
          });
          const weight = this.strategy.calculate(context);
          logger.debug("[Remember] Weight calculation", {
            from: sourceWord,
            to: targetWord,
            position: i,
            outDegree: context.sourceOutDegree,
            weight
          });
          sourceCue.connections.set(targetWord, weight);
          connections.push({
            source: sourceWord,
            target: targetWord,
            weight,
            position: i
          });
        }
        logger.info("[Remember] Schema processed successfully", {
          nodes: schema.length,
          connections: connections.length,
          timestamp: new Date(timestamp).toISOString()
        });
        const actualEngramId = engramId || engram.id;
        if (actualEngramId) {
          for (const word of schema) {
            const cue = this.network.cues.get(word);
            if (cue) {
              if (!cue.memories) {
                cue.memories = /* @__PURE__ */ new Set();
              }
              cue.memories.add(actualEngramId);
              logger.debug("[Remember] Added engram reference", {
                cue: word,
                engramId: actualEngramId,
                totalReferences: cue.memories.size
              });
            }
          }
        }
        return {
          processed: schema.length,
          connections,
          timestamp,
          engramId: actualEngramId
        };
      }
    };
    module2.exports = Remember;
  }
});

// src/cognition/ActivationStrategy.js
var require_ActivationStrategy = __commonJS({
  "src/cognition/ActivationStrategy.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var logger = require("@promptx/logger");
    var ActivationStrategy = class {
      constructor(options = {}) {
        this.name = "base";
        this.options = options;
      }
      /**
       * 决定如何激活节点
       * 
       * 子类必须实现此方法
       * 
       * @param {ActivationContext} context - 激活上下文
       * @returns {Object} 激活决策
       * @returns {boolean} returns.shouldActivate - 是否应该激活
       * @returns {Array} returns.edges - 要激活的边列表
       */
      activate(context) {
        throw new Error("ActivationStrategy.activate() must be implemented");
      }
      /**
       * 判断是否继续激活
       * 
       * @param {ActivationContext} context - 激活上下文
       * @returns {boolean} true继续，false停止
       */
      shouldContinue(context) {
        return true;
      }
      /**
       * 应用衰减或其他周期性操作
       * 
       * @param {ActivationContext} context - 激活上下文
       */
      applyDecay(context) {
      }
    };
    var HippocampalActivationStrategy = class extends ActivationStrategy {
      constructor(options = {}) {
        super(options);
        this.name = "hippocampal";
        this.firingThreshold = options.firingThreshold || 0.1;
        this.synapticDecay = options.synapticDecay || 0.9;
        this.inhibitionFactor = options.inhibitionFactor || 0.1;
        this.maxCycles = options.maxCycles || 10;
        this.cycleDecay = options.cycleDecay || 0.9;
        this.frequencyBoost = options.frequencyBoost || 0.1;
        this.weightStrategy = options.weightStrategy || null;
        logger.debug("[HippocampalActivationStrategy] Initialized", {
          firingThreshold: this.firingThreshold,
          synapticDecay: this.synapticDecay,
          maxCycles: this.maxCycles
        });
      }
      /**
       * 决定如何激活节点
       * 
       * @param {ActivationContext} context - 激活上下文
       * @returns {Object} 激活决策
       */
      activate(context) {
        var _a;
        if (context.currentEnergy < this.firingThreshold) {
          logger.debug("[HippocampalActivationStrategy] Energy below threshold", {
            word: (_a = context.sourceCue) == null ? void 0 : _a.word,
            energy: context.currentEnergy,
            threshold: this.firingThreshold
          });
          return { shouldActivate: false, edges: [] };
        }
        if (!context.sourceCue || !context.sourceCue.connections) {
          return { shouldActivate: false, edges: [] };
        }
        let edges = Array.from(context.sourceCue.connections.entries()).map(([targetWord, weight]) => ({
          targetWord,
          weight,
          frequency: context.getTargetFrequency(targetWord)
        }));
        if (this.weightStrategy && typeof this.weightStrategy.normalizeForActivation === "function") {
          edges = this.weightStrategy.normalizeForActivation(edges);
          logger.debug("[HippocampalActivationStrategy] Applied weight strategy normalization", {
            strategy: this.weightStrategy.constructor.name,
            edgeCount: edges.length
          });
        }
        const processedEdges = edges.map((edge) => {
          const activationProbability = edge.probability || edge.weight / edges.reduce((sum, e) => sum + e.weight, 0);
          const freqBonus = 1 + Math.log(1 + edge.frequency) * this.frequencyBoost;
          const transmittedEnergy = context.currentEnergy * activationProbability * this.synapticDecay * freqBonus;
          const inhibition = 1 - this.inhibitionFactor * context.activatedNodes.size / 100;
          const finalEnergy = transmittedEnergy * inhibition;
          return {
            targetWord: edge.targetWord,
            weight: edge.weight,
            energy: finalEnergy,
            frequency: edge.frequency,
            probability: activationProbability,
            batchMultiplier: edge.batchMultiplier || 1,
            shouldFire: finalEnergy >= this.firingThreshold
          };
        });
        const activeEdges = processedEdges.filter(
          (e) => e.shouldFire && !context.isActivated(e.targetWord)
        );
        logger.debug("[HippocampalActivationStrategy] Activation decision", {
          source: context.sourceCue.word,
          sourceEnergy: context.currentEnergy,
          totalEdges: edges.length,
          activeEdges: activeEdges.length,
          cycle: context.cycle,
          hasWeightStrategy: !!this.weightStrategy
        });
        return { shouldActivate: true, edges: activeEdges };
      }
      /**
       * 判断是否继续激活
       * 
       * @param {ActivationContext} context - 激活上下文
       * @returns {boolean} true继续，false停止
       */
      shouldContinue(context) {
        if (context.cycle >= this.maxCycles) {
          logger.debug("[HippocampalActivationStrategy] Max cycles reached", {
            cycle: context.cycle,
            maxCycles: this.maxCycles
          });
          return false;
        }
        let hasHighEnergyNode = false;
        for (const [word, energy] of context.energyPool) {
          if (energy >= this.firingThreshold) {
            hasHighEnergyNode = true;
            break;
          }
        }
        if (!hasHighEnergyNode) {
          logger.debug("[HippocampalActivationStrategy] No high energy nodes", {
            cycle: context.cycle,
            poolSize: context.energyPool.size
          });
        }
        return hasHighEnergyNode;
      }
      /**
       * 应用能量衰减
       * 
       * @param {ActivationContext} context - 激活上下文
       */
      applyDecay(context) {
        for (const [word, energy] of context.energyPool) {
          const decayedEnergy = energy * this.cycleDecay;
          if (decayedEnergy < 0.01) {
            context.energyPool.delete(word);
          } else {
            context.energyPool.set(word, decayedEnergy);
          }
        }
        logger.debug("[HippocampalActivationStrategy] Applied decay", {
          cycle: context.cycle,
          remainingNodes: context.energyPool.size,
          totalEnergy: Array.from(context.energyPool.values()).reduce((sum, e) => sum + e, 0).toFixed(2)
        });
      }
    };
    module2.exports = {
      ActivationStrategy,
      HippocampalActivationStrategy
    };
  }
});

// src/cognition/ActivationContext.js
var require_ActivationContext = __commonJS({
  "src/cognition/ActivationContext.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var ActivationContext = class {
      /**
       * 创建激活上下文
       * 
       * @param {Object} params - 初始参数
       * @param {Network} params.network - 认知网络
       * @param {Cue} params.sourceCue - 当前源节点
       * @param {number} params.depth - 当前深度（兼容旧代码）
       * @param {number} params.currentEnergy - 当前节点能量
       * @param {Set} params.activatedNodes - 已激活节点集
       * @param {Map} params.energyPool - 节点能量池
       * @param {number} params.cycle - 循环次数
       * @param {Array} params.connections - 连接记录
       */
      constructor(params = {}) {
        this.network = params.network;
        this.sourceCue = params.sourceCue || null;
        this.depth = params.depth || 0;
        this.currentEnergy = params.currentEnergy || 1;
        this.activatedNodes = params.activatedNodes || /* @__PURE__ */ new Set();
        this.energyPool = params.energyPool || /* @__PURE__ */ new Map();
        this.cycle = params.cycle || 0;
        this.connections = params.connections || [];
        this.timestamp = params.timestamp || Date.now();
      }
      /**
       * 获取目标节点的频率
       * 
       * @param {string} targetWord - 目标词
       * @returns {number} 频率值
       */
      getTargetFrequency(targetWord) {
        const targetCue = this.network.getCue(targetWord);
        return (targetCue == null ? void 0 : targetCue.recallFrequency) || 0;
      }
      /**
       * 检查节点是否已激活
       * 
       * @param {string} word - 节点词
       * @returns {boolean} 是否已激活
       */
      isActivated(word) {
        return this.activatedNodes.has(word);
      }
      /**
       * 获取节点的当前能量
       * 
       * @param {string} word - 节点词
       * @returns {number} 能量值
       */
      getNodeEnergy(word) {
        return this.energyPool.get(word) || 0;
      }
      /**
       * 设置节点能量
       * 
       * @param {string} word - 节点词
       * @param {number} energy - 能量值
       */
      setNodeEnergy(word, energy) {
        if (energy > 0) {
          this.energyPool.set(word, energy);
        } else {
          this.energyPool.delete(word);
        }
      }
      /**
       * 累加节点能量
       * 
       * @param {string} word - 节点词
       * @param {number} energyToAdd - 要添加的能量
       * @returns {number} 新的能量值
       */
      addNodeEnergy(word, energyToAdd) {
        const current = this.getNodeEnergy(word);
        const newEnergy = current + energyToAdd;
        this.setNodeEnergy(word, newEnergy);
        return newEnergy;
      }
      /**
       * 标记节点为已激活
       * 
       * @param {string} word - 节点词
       */
      markActivated(word) {
        this.activatedNodes.add(word);
      }
      /**
       * 记录连接
       * 
       * @param {string} from - 源节点
       * @param {string} to - 目标节点
       * @param {number} weight - 连接权重
       */
      recordConnection(from, to, weight) {
        this.connections.push({ from, to, weight });
      }
      /**
       * 增加循环计数
       */
      incrementCycle() {
        this.cycle++;
      }
      /**
       * 获取统计信息
       * 
       * @returns {Object} 统计信息
       */
      getStatistics() {
        return {
          activatedNodes: this.activatedNodes.size,
          totalEnergy: Array.from(this.energyPool.values()).reduce((sum, e) => sum + e, 0),
          highEnergyNodes: Array.from(this.energyPool.entries()).filter(([_, energy]) => energy > 0.5).length,
          connections: this.connections.length,
          cycle: this.cycle
        };
      }
      /**
       * 转换为调试字符串
       * 
       * @returns {string} 调试信息
       */
      toString() {
        const stats = this.getStatistics();
        return `ActivationContext{cycle:${this.cycle}, activated:${stats.activatedNodes}, energy:${stats.totalEnergy.toFixed(2)}}`;
      }
    };
    module2.exports = ActivationContext;
  }
});

// src/cognition/Recall.js
var require_Recall = __commonJS({
  "src/cognition/Recall.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var logger = require("@promptx/logger");
    var Recall = class {
      /**
       * @param {Network} network - 全局认知网络
       * @param {Object} options - 可选配置
       * @param {ActivationStrategy} options.activationStrategy - 激活策略
       * @param {WeightStrategy} options.weightStrategy - 权重策略（用于归一化）
       */
      constructor(network, options = {}) {
        this.network = network;
        this.weightStrategy = options.weightStrategy || null;
        if (options.activationStrategy) {
          this.activationStrategy = options.activationStrategy;
          if (this.weightStrategy && typeof this.activationStrategy.setWeightStrategy === "function") {
            this.activationStrategy.setWeightStrategy(this.weightStrategy);
          }
        } else {
          const { HippocampalActivationStrategy } = require_ActivationStrategy();
          this.activationStrategy = new HippocampalActivationStrategy({
            weightStrategy: this.weightStrategy
          });
        }
        logger.debug("[Recall] Initialized", {
          strategy: this.activationStrategy.name,
          hasWeightStrategy: !!this.weightStrategy
        });
      }
      /**
       * 执行记忆检索
       * 
       * @param {string} word - 起始词
       * @returns {Mind|null} 激活的认知网络
       */
      execute(word) {
        logger.debug("[Recall] Starting recall", { word });
        const centerCue = this.network.cues.get(word);
        if (!centerCue) {
          logger.warn("[Recall] Cue not found", { word });
          return null;
        }
        logger.debug("[Recall] Found center Cue", {
          word: centerCue.word,
          outDegree: centerCue.connections.size,
          frequency: centerCue.recallFrequency || 0
        });
        const Mind = require_Mind();
        const mind = new Mind(centerCue);
        const ActivationContext = require_ActivationContext();
        const context = new ActivationContext({
          network: this.network,
          sourceCue: centerCue,
          energyPool: /* @__PURE__ */ new Map([[centerCue.word, 1]]),
          // 初始能量
          activatedNodes: /* @__PURE__ */ new Set([centerCue.word]),
          connections: []
        });
        const startTime = Date.now();
        while (this.activationStrategy.shouldContinue(context)) {
          const newActivations = /* @__PURE__ */ new Map();
          for (const [word2, energy] of context.energyPool) {
            const sourceCue = this.network.getCue(word2);
            if (!sourceCue) continue;
            context.sourceCue = sourceCue;
            context.currentEnergy = energy;
            const { shouldActivate, edges } = this.activationStrategy.activate(context);
            if (shouldActivate && edges.length > 0) {
              logger.debug("[Recall] Activating from node", {
                source: word2,
                energy: energy.toFixed(3),
                edgeCount: edges.length,
                cycle: context.cycle
              });
              for (const edge of edges) {
                const currentEnergy = newActivations.get(edge.targetWord) || 0;
                const totalEnergy = currentEnergy + edge.energy;
                newActivations.set(edge.targetWord, totalEnergy);
                mind.addConnection(word2, edge.targetWord, edge.weight);
                context.recordConnection(word2, edge.targetWord, edge.weight);
                logger.debug("[Recall] Edge activated", {
                  from: word2,
                  to: edge.targetWord,
                  transmittedEnergy: edge.energy.toFixed(3),
                  totalEnergy: totalEnergy.toFixed(3)
                });
              }
            }
          }
          context.energyPool.clear();
          for (const [word2, energy] of newActivations) {
            context.setNodeEnergy(word2, energy);
            if (energy >= (this.activationStrategy.firingThreshold || 0.01)) {
              if (!context.isActivated(word2)) {
                context.markActivated(word2);
                mind.addActivatedCue(word2, context.cycle + 1);
              }
            }
          }
          this.activationStrategy.applyDecay(context);
          context.incrementCycle();
          if (newActivations.size === 0) {
            logger.debug("[Recall] No new activations, stopping", {
              cycle: context.cycle
            });
            break;
          }
        }
        const duration = Date.now() - startTime;
        this.network.updateRecallFrequency(context.activatedNodes);
        logger.info("[Recall] Recall completed", {
          center: word,
          strategy: this.activationStrategy.name,
          cycles: context.cycle,
          activatedNodes: context.activatedNodes.size,
          connections: context.connections.length,
          duration: `${duration}ms`
        });
        return mind;
      }
    };
    module2.exports = Recall;
  }
});

// src/cognition/Prime.js
var require_Prime = __commonJS({
  "src/cognition/Prime.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var logger = require("@promptx/logger");
    var Recall = require_Recall();
    var Prime = class extends Recall {
      /**
       * 获取默认的启动词
       * 
       * 策略优先级：
       * 1. 选择根节点（入度为0的节点）- 认知网络的起点
       * 2. 选择被指向最多的节点 - 重要概念
       * 3. 返回第一个节点 - 兜底策略
       * 
       * @returns {string|null} 启动词
       */
      getPrimeWord() {
        var _a, _b;
        if (this.network.cues.size === 0) {
          logger.warn("[Prime] Network is empty, no word to prime");
          return null;
        }
        logger.debug("[Prime] Calculating prime word from network", {
          totalCues: this.network.cues.size
        });
        const rootNodes = this.findRootNodes();
        if (rootNodes.length > 0) {
          const selectedRoot = rootNodes.reduce((best, current) => {
            var _a2, _b2, _c, _d;
            const currentOutDegree = ((_b2 = (_a2 = this.network.cues.get(current)) == null ? void 0 : _a2.connections) == null ? void 0 : _b2.size) || 0;
            const bestOutDegree = ((_d = (_c = this.network.cues.get(best)) == null ? void 0 : _c.connections) == null ? void 0 : _d.size) || 0;
            return currentOutDegree > bestOutDegree ? current : best;
          });
          logger.info("[Prime] Selected root node as prime word", {
            word: selectedRoot,
            allRoots: rootNodes,
            outDegree: ((_b = (_a = this.network.cues.get(selectedRoot)) == null ? void 0 : _a.connections) == null ? void 0 : _b.size) || 0
          });
          return selectedRoot;
        }
        const inWeights = this.network.calculateInWeights();
        if (inWeights.size > 0) {
          let maxWeight = 0;
          let primeWord = null;
          for (const [word, weight] of inWeights) {
            if (weight > maxWeight) {
              maxWeight = weight;
              primeWord = word;
            }
          }
          if (primeWord) {
            logger.info("[Prime] Selected high in-degree node as prime word", {
              word: primeWord,
              inWeight: maxWeight
            });
            return primeWord;
          }
        }
        const firstWord = this.network.cues.keys().next().value;
        logger.debug("[Prime] Using first cue as fallback", {
          word: firstWord
        });
        return firstWord;
      }
      /**
       * 寻找根节点（入度为0的节点）
       * @returns {Array<string>} 根节点列表
       */
      findRootNodes() {
        const hasIncomingEdge = /* @__PURE__ */ new Set();
        for (const [sourceWord, sourceCue] of this.network.cues) {
          for (const [targetWord] of sourceCue.connections) {
            hasIncomingEdge.add(targetWord);
          }
        }
        const rootNodes = [];
        for (const word of this.network.cues.keys()) {
          if (!hasIncomingEdge.has(word)) {
            rootNodes.push(word);
          }
        }
        logger.debug("[Prime] Found root nodes", {
          count: rootNodes.length,
          nodes: rootNodes
        });
        return rootNodes;
      }
      /**
       * 执行启动
       * 
       * @param {string} word - 可选的启动词，如果不提供则自动选择
       * @returns {Mind|null} 基础认知状态
       */
      execute(word = null) {
        var _a, _b;
        logger.info("[Prime] Starting prime operation", {
          providedWord: word,
          autoSelect: !word,
          networkSize: this.network.cues.size
        });
        if (!word) {
          word = this.getPrimeWord();
          if (!word) {
            logger.error("[Prime] Failed to find prime word, network empty or no suitable node");
            return null;
          }
          logger.info("[Prime] Auto-selected prime word", { word });
        } else {
          if (!this.network.hasCue(word)) {
            logger.warn("[Prime] Provided word not found in network", { word });
            return null;
          }
        }
        logger.info("[Prime] Executing recall with prime word", {
          word,
          cueExists: this.network.hasCue(word),
          cueConnections: ((_b = (_a = this.network.cues.get(word)) == null ? void 0 : _a.connections) == null ? void 0 : _b.size) || 0
        });
        const mind = super.execute(word);
        if (mind) {
          logger.info("[Prime] Prime completed successfully", {
            primeWord: word,
            activatedNodes: mind.activatedCues.size,
            connections: mind.connections.length
          });
        } else {
          logger.error("[Prime] Prime failed", { word });
        }
        return mind;
      }
      /**
       * 多词启动（实验性功能）
       * 
       * 同时从多个词开始激活，模拟并行思考。
       * 生成的Mind包含多个激活中心。
       * 
       * @param {Array<string>} words - 启动词数组
       * @returns {Mind} 合并的认知状态
       */
      executeMultiple(words) {
        logger.info("[Prime] Starting multi-center prime", {
          words,
          count: words.length
        });
        const Mind = require_Mind();
        const mergedMind = new Mind(null);
        mergedMind.centers = [];
        const validCenters = [];
        const missingWords = [];
        for (const word of words) {
          const cue = this.network.cues.get(word);
          if (!cue) {
            missingWords.push(word);
            logger.warn("[Prime] Word not found in network", { word });
            continue;
          }
          validCenters.push(word);
          mergedMind.centers.push(cue);
          logger.debug("[Prime] Spreading from center", {
            word,
            outDegree: cue.connections.size
          });
          this.spread(cue, mergedMind, [], 0);
        }
        logger.info("[Prime] Multi-center prime completed", {
          requestedWords: words.length,
          validCenters: validCenters.length,
          missingWords,
          activatedNodes: mergedMind.activatedCues.size,
          connections: mergedMind.connections.length
        });
        return mergedMind;
      }
    };
    module2.exports = Prime;
  }
});

// src/cognition/Memory.js
var require_Memory = __commonJS({
  "src/cognition/Memory.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var { Level } = require("level");
    var logger = require("@promptx/logger");
    var Memory = class {
      /**
       * 创建Memory实例
       * 
       * @param {string} dbPath - LevelDB数据库路径
       */
      constructor(dbPath) {
        this.db = new Level(dbPath, {
          valueEncoding: "json"
          // 自动JSON序列化/反序列化
        });
        logger.debug("[Memory] Initialized", { dbPath });
      }
      /**
       * 存储Engram对象
       * 
       * @param {Engram} engram - 要存储的Engram对象
       * @returns {Promise<string>} Engram的id（作为存储key）
       */
      async store(engram) {
        const key = engram.id;
        try {
          await this.db.put(key, engram.toJSON());
          logger.debug("[Memory] Stored engram", {
            key,
            preview: engram.getPreview(),
            strength: engram.strength
          });
          return key;
        } catch (error) {
          logger.error("[Memory] Failed to store engram", {
            key,
            error: error.message
          });
          throw error;
        }
      }
      /**
       * 获取Engram对象
       * 
       * @param {string} key - 存储key
       * @returns {Promise<Object|null>} Engram数据对象，不存在时返回null
       */
      async get(key) {
        try {
          const data = await this.db.get(key);
          logger.debug("[Memory] Retrieved engram", {
            key,
            hasContent: !!data.content
          });
          return data;
        } catch (error) {
          if (error.notFound) {
            logger.debug("[Memory] Engram not found", { key });
            return null;
          }
          logger.error("[Memory] Failed to retrieve engram", {
            key,
            error: error.message
          });
          throw error;
        }
      }
      /**
       * 关闭数据库连接
       * 
       * @returns {Promise<void>}
       */
      async close() {
        try {
          await this.db.close();
          logger.debug("[Memory] Database closed");
        } catch (error) {
          logger.error("[Memory] Failed to close database", {
            error: error.message
          });
          throw error;
        }
      }
      /**
       * 获取存储统计信息
       * 
       * @returns {Promise<Object>} 统计信息
       */
      async getStatistics() {
        try {
          let count = 0;
          for await (const [key] of this.db.iterator()) {
            count++;
          }
          return {
            totalEngrams: count,
            dbPath: this.db.location
          };
        } catch (error) {
          logger.error("[Memory] Failed to get statistics", {
            error: error.message
          });
          return {
            totalEngrams: 0,
            dbPath: this.db.location,
            error: error.message
          };
        }
      }
    };
    module2.exports = Memory;
  }
});

// src/cognition/WeightStrategy.js
var require_WeightStrategy = __commonJS({
  "src/cognition/WeightStrategy.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var WeightStrategy = class {
      /**
       * 计算权重
       * 
       * 子类必须实现此方法。
       * 
       * @param {WeightContext} context - 计算上下文
       * @param {Cue} context.sourceCue - 源节点
       * @param {string} context.targetWord - 目标词
       * @param {number} context.position - 在Schema中的位置
       * @param {number} context.timestamp - 时间戳
       * @param {number} context.sourceOutDegree - 源节点出度
       * @returns {number} 计算得出的权重（应为正数）
       */
      calculate(context) {
        throw new Error("WeightStrategy.calculate() must be implemented");
      }
      /**
       * 激活时归一化（用于Recall）
       * 
       * 将一组边的权重转换为激活概率
       * 默认实现：简单归一化
       * 
       * @param {Array} edges - 边数组 [{targetWord, weight}, ...]
       * @returns {Array} 归一化后的边数组，添加了probability字段
       */
      normalizeForActivation(edges) {
        if (edges.length === 0) return edges;
        const totalWeight = edges.reduce((sum, e) => sum + e.weight, 0);
        return edges.map((edge) => ({
          ...edge,
          probability: edge.weight / totalWeight
        }));
      }
    };
    var SimpleWeightStrategy = class extends WeightStrategy {
      constructor(options = {}) {
        super();
        this.baseWeight = options.baseWeight || 1;
        this.decay = options.decay || 0.9;
      }
      /**
       * 计算权重
       * 
       * @param {WeightContext} context - 计算上下文
       * @returns {number} 权重值
       */
      calculate(context) {
        const weight = this.baseWeight * Math.pow(this.decay, context.position);
        return weight;
      }
    };
    var TimeBasedWeightStrategy = class extends WeightStrategy {
      constructor(options = {}) {
        super();
        this.decay = options.decay || 0.9;
        this.activationThreshold = options.activationThreshold || 0.05;
        this.frequencyFactor = options.frequencyFactor || 0.1;
        this.network = null;
      }
      /**
       * 计算存储权重
       * 
       * @param {WeightContext} context - 计算上下文
       * @returns {number} 权重值
       */
      calculate(context) {
        const timestamp = context.timestamp;
        const positionFactor = Math.pow(this.decay, context.position);
        const strengthFactor = context.strength || 0.8;
        const weight = timestamp * positionFactor * strengthFactor;
        return weight;
      }
      /**
       * Softmax归一化（用于激活）
       * 
       * 加入频率偏置，实现"越用越强"的效果
       * 
       * @param {Array} edges - 边数组
       * @returns {Array} 归一化后的边数组
       */
      normalizeForActivation(edges) {
        if (edges.length === 0) return edges;
        const enhancedEdges = edges.map((edge) => {
          let frequency = 0;
          if (this.network) {
            const targetCue = this.network.cues.get(edge.targetWord);
            frequency = targetCue ? targetCue.recallFrequency || 0 : 0;
          }
          const logWeight = Math.log(edge.weight);
          const frequencyBias = Math.log(1 + frequency * this.frequencyFactor);
          return {
            ...edge,
            adjustedLogWeight: logWeight + frequencyBias,
            frequency
          };
        });
        const maxLogWeight = Math.max(...enhancedEdges.map((e) => e.adjustedLogWeight));
        const expWeights = enhancedEdges.map(
          (e) => Math.exp(e.adjustedLogWeight - maxLogWeight)
        );
        const sumExp = expWeights.reduce((a, b) => a + b, 0);
        const normalizedEdges = edges.map((edge, i) => ({
          ...edge,
          probability: expWeights[i] / sumExp,
          frequency: enhancedEdges[i].frequency
        })).sort((a, b) => b.probability - a.probability);
        return normalizedEdges.filter((edge) => edge.probability >= this.activationThreshold);
      }
    };
    var TemperatureWeightStrategy = class extends TimeBasedWeightStrategy {
      constructor(options = {}) {
        super(options);
        this.temperature = options.temperature || 0.5;
        this.contrastMode = options.contrastMode || "auto";
      }
      /**
       * 设置对比度级别
       * 
       * @param {'low'|'medium'|'high'} level - 对比度级别
       */
      setContrastLevel(level) {
        const contrastMap = {
          "low": 2,
          // 高温，低对比度（~20%差异）
          "medium": 1,
          // 常温，中等对比度（~50%差异）
          "high": 0.3
          // 低温，高对比度（~80%差异）
        };
        this.temperature = contrastMap[level] || 1;
        this.contrastMode = level;
      }
      /**
       * 设置对比度百分比
       * 
       * @param {number} percentage - 对比度百分比（0-100）
       */
      setContrastPercentage(percentage) {
        const clampedPercentage = Math.max(0, Math.min(100, percentage));
        this.temperature = 2 - clampedPercentage / 100 * 1.8;
        this.contrastMode = "custom";
      }
      /**
       * 自动调节温度（基于网络状态）
       * 
       * @param {Array} edges - 边数组
       * @returns {number} 调节后的温度
       */
      autoAdjustTemperature(edges) {
        if (this.contrastMode !== "auto") {
          return this.temperature;
        }
        const avgConnections = edges.length;
        const hubThreshold = 5;
        if (avgConnections > hubThreshold * 2) {
          return 0.3;
        } else if (avgConnections > hubThreshold) {
          return 0.5;
        } else {
          return 1;
        }
      }
      /**
       * 带温度控制的Softmax归一化
       * 
       * 核心思想：
       * - 权重本身已包含timestamp信息（weight = timestamp * decay^position）
       * - 同批次的权重数量级相近，不同批次差异巨大
       * - 温度控制这种差异的影响程度
       * 
       * @param {Array} edges - 边数组
       * @returns {Array} 归一化后的边数组
       */
      normalizeForActivation(edges) {
        if (edges.length === 0) return edges;
        const effectiveTemperature = this.autoAdjustTemperature(edges);
        const enhancedEdges = edges.map((edge) => {
          let frequency = 0;
          if (this.network) {
            const targetCue = this.network.cues.get(edge.targetWord);
            frequency = targetCue ? targetCue.recallFrequency || 0 : 0;
          }
          const logWeight = Math.log(edge.weight);
          const frequencyBias = Math.log(1 + frequency * this.frequencyFactor);
          return {
            ...edge,
            adjustedLogWeight: logWeight + frequencyBias,
            frequency
          };
        });
        const maxLogWeight = Math.max(...enhancedEdges.map((e) => e.adjustedLogWeight));
        const expWeights = enhancedEdges.map(
          (e) => Math.exp((e.adjustedLogWeight - maxLogWeight) / effectiveTemperature)
        );
        const sumExp = expWeights.reduce((a, b) => a + b, 0);
        const normalizedEdges = enhancedEdges.map((edge, i) => ({
          ...edges[i],
          probability: expWeights[i] / sumExp,
          frequency: edge.frequency,
          temperature: effectiveTemperature
        })).sort((a, b) => b.probability - a.probability);
        return normalizedEdges.filter((edge) => edge.probability >= this.activationThreshold);
      }
    };
    module2.exports = {
      WeightStrategy,
      SimpleWeightStrategy,
      TimeBasedWeightStrategy,
      TemperatureWeightStrategy
    };
  }
});

// src/cognition/CognitionSystem.js
var require_CognitionSystem = __commonJS({
  "src/cognition/CognitionSystem.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var logger = require("@promptx/logger");
    var Network = require_Network();
    var Remember = require_Remember();
    var Recall = require_Recall();
    var Prime = require_Prime();
    var Memory = require_Memory();
    var { TemperatureWeightStrategy } = require_WeightStrategy();
    var CognitionSystem = class {
      /**
       * 创建认知系统
       * 
       * @param {Object} options - 配置选项
       * @param {string} options.dataPath - 数据文件路径
       * @param {Object} options.strategyOptions - 策略配置
       * @param {Object} options.rememberOptions - Remember配置
       * @param {Object} options.recallOptions - Recall配置
       */
      constructor(options = {}) {
        this.dataPath = options.dataPath || "./cognition.json";
        this.network = new Network();
        this.strategy = new TemperatureWeightStrategy({
          decay: 0.9,
          activationThreshold: 0.01,
          // 降低过滤阈值
          frequencyFactor: 0.1,
          // 频率因子
          temperature: 0.8,
          // 提高温度，允许适度扩散
          contrastMode: "auto",
          // 自动调节对比度
          ...options.strategyOptions
        });
        this.strategy.network = this.network;
        this.rememberOptions = {
          ...options.rememberOptions,
          strategy: this.strategy
        };
        this.recallOptions = {
          ...options.recallOptions,
          weightStrategy: this.strategy
          // 传递权重策略
        };
        this.rememberEngine = null;
        this.recallEngine = null;
        this.memory = null;
        logger.info("[CognitionSystem] Initialized", {
          dataPath: this.dataPath,
          strategyType: this.strategy.constructor.name
        });
      }
      /**
       * 获取Remember引擎（懒加载）
       * 
       * @returns {Remember}
       */
      getRememberEngine() {
        if (!this.rememberEngine) {
          this.rememberEngine = new Remember(this.network, this.rememberOptions);
        }
        return this.rememberEngine;
      }
      /**
       * 获取Recall引擎（懒加载）
       * 
       * @returns {Recall}
       */
      getRecallEngine() {
        if (!this.recallEngine) {
          this.recallEngine = new Recall(this.network, this.recallOptions);
        }
        return this.recallEngine;
      }
      /**
       * 获取Memory存储（懒加载）
       * 
       * @returns {Memory|null} Memory实例，如果没有directory则返回null
       */
      getMemory() {
        if (!this.memory && this.network.directory) {
          const path = require("path");
          const memoryPath = path.join(this.network.directory, "engrams.db");
          this.memory = new Memory(memoryPath);
        }
        return this.memory;
      }
      /**
       * 记忆操作
       * 
       * 执行流程：
       * 1. 存储Engram到Memory（使用engram.id）
       * 2. 调用Remember引擎处理Schema连接
       * 3. 建立Cue到Engram.id的反向索引
       * 
       * @param {Engram} engram - 记忆痕迹对象
       * @returns {Promise<Object>} 记忆结果
       */
      async remember(engram) {
        logger.debug("[CognitionSystem] Remember operation", {
          id: engram.id,
          schemaLength: engram.length,
          strength: engram.strength,
          preview: engram.getPreview()
        });
        if (this.getMemory()) {
          try {
            await this.getMemory().store(engram);
            logger.debug("[CognitionSystem] Stored engram to memory", { id: engram.id });
          } catch (error) {
            logger.error("[CognitionSystem] Failed to store engram to memory", {
              id: engram.id,
              error: error.message
            });
            throw error;
          }
        }
        const remember = this.getRememberEngine();
        const result = remember.execute(engram, engram.id);
        return result;
      }
      /**
       * 回忆操作
       * 
       * 执行流程：
       * 1. 调用Recall引擎激活网络
       * 2. 加载与原始查询相关的Engrams
       * 3. 更新被激活节点的频率
       * 4. 返回激活的Mind（包含engrams）
       * 
       * @param {string} word - 起始概念
       * @returns {Promise<Mind|null>} 激活的认知网络
       */
      async recall(word) {
        logger.debug("[CognitionSystem] Recall operation", { word });
        const recall = this.getRecallEngine();
        const mind = recall.execute(word);
        if (!mind) {
          return null;
        }
        if (this.getMemory()) {
          try {
            await this.loadEngrams(mind, word);
          } catch (error) {
            logger.error("[CognitionSystem] Failed to load engrams", { error: error.message });
          }
        }
        if (mind.activatedCues.size > 0) {
          this.network.updateRecallFrequency(mind.activatedCues);
          logger.debug("[CognitionSystem] Updated frequencies after recall", {
            activatedCount: mind.activatedCues.size
          });
        }
        return mind;
      }
      /**
       * 加载与查询词直接相关的Engrams
       * 
       * @param {Mind} mind - Mind对象
       * @param {string} originalQuery - 原始查询词
       * @returns {Promise<void>}
       */
      async loadEngrams(mind, originalQuery) {
        var _a, _b;
        mind.engrams = [];
        logger.info("[CognitionSystem] DEBUG - loadEngrams process:", {
          originalQuery,
          networkCuesSize: this.network.cues.size,
          hasMemorySystem: !!this.getMemory(),
          networkCuesKeys: Array.from(this.network.cues.keys())
        });
        const queryCue = this.network.cues.get(originalQuery);
        logger.info("[CognitionSystem] DEBUG - queryCue lookup:", {
          originalQuery,
          hasQueryCue: !!queryCue,
          queryCueMemories: queryCue == null ? void 0 : queryCue.memories,
          memoriesLength: (_a = queryCue == null ? void 0 : queryCue.memories) == null ? void 0 : _a.length
        });
        if (queryCue && queryCue.memories) {
          for (const engramId of queryCue.memories) {
            const engramData = await this.getMemory().get(engramId);
            logger.debug("[CognitionSystem] DEBUG - loading engram:", {
              engramId,
              hasEngramData: !!engramData,
              engramContent: (_b = engramData == null ? void 0 : engramData.content) == null ? void 0 : _b.substring(0, 50)
            });
            if (engramData) {
              mind.engrams.push({
                id: engramData.id,
                content: engramData.content,
                schema: engramData.schema,
                strength: engramData.strength,
                timestamp: engramData.timestamp,
                activatedBy: originalQuery
              });
            }
          }
        } else {
          logger.info("[CognitionSystem] DEBUG - No engrams loaded - reason:", {
            hasQueryCue: !!queryCue,
            hasMemories: !!(queryCue == null ? void 0 : queryCue.memories),
            query: originalQuery
          });
        }
        logger.debug("[CognitionSystem] Loaded engrams", {
          query: originalQuery,
          engramCount: mind.engrams.length
        });
      }
      /**
       * 启动操作
       * 
       * 执行流程：
       * 1. 从磁盘加载Network
       * 2. 使用Prime选择起始点
       * 3. 执行预热Recall
       * 
       * @returns {Mind|null} 预热的认知网络
       */
      async prime() {
        var _a, _b, _c;
        logger.debug("[CognitionSystem] Prime operation");
        logger.info("[CognitionSystem] Using existing network", {
          cues: this.network.size()
        });
        const prime = new Prime(this.network);
        const mind = prime.execute();
        if (!mind) {
          logger.warn("[CognitionSystem] Prime found no suitable starting point or recall failed");
          return null;
        }
        logger.info("[CognitionSystem] Prime completed", {
          activatedNodes: ((_a = mind.activatedCues) == null ? void 0 : _a.size) || 0,
          connections: ((_b = mind.connections) == null ? void 0 : _b.length) || 0,
          centerWord: mind.centerWord
        });
        if (this.getMemory() && mind.centerWord) {
          try {
            await this.loadEngrams(mind, mind.centerWord);
            logger.info("[CognitionSystem] Loaded engrams for prime center word", {
              centerWord: mind.centerWord,
              engramCount: ((_c = mind.engrams) == null ? void 0 : _c.length) || 0
            });
          } catch (error) {
            logger.error("[CognitionSystem] Failed to load engrams for prime", {
              centerWord: mind.centerWord,
              error: error.message
            });
          }
        }
        return mind;
      }
      /**
       * 获取系统统计信息
       * 
       * @returns {Object} 统计信息
       */
      getStatistics() {
        const networkStats = this.network.getStatistics();
        const frequencyStats = this.network.getFrequencyStatistics();
        return {
          network: networkStats,
          frequency: frequencyStats,
          dataPath: this.dataPath,
          strategy: {
            type: this.strategy.constructor.name,
            decay: this.strategy.decay,
            frequencyFactor: this.strategy.frequencyFactor || 0
          }
        };
      }
      /**
       * 清空系统
       * 
       * 用于测试或重置。
       */
      clear() {
        this.network.clear();
        this.rememberEngine = null;
        this.recallEngine = null;
        logger.info("[CognitionSystem] System cleared");
      }
      /**
       * 手动保存
       * 
       * 虽然remember会自动保存，但提供手动保存接口。
       */
      save() {
        this.network.persistSync(this.dataPath);
        logger.info("[CognitionSystem] Manual save completed");
      }
      /**
       * 手动加载
       * 
       * 虽然prime会自动加载，但提供手动加载接口。
       */
      load() {
        this.network.loadSync(this.dataPath);
        this.rememberEngine = null;
        this.recallEngine = null;
        logger.info("[CognitionSystem] Manual load completed");
      }
    };
    module2.exports = CognitionSystem;
  }
});

// src/cognition/index.js
var require_cognition = __commonJS({
  "src/cognition/index.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var Cue = require_Cue();
    var Network = require_Network();
    var Mind = require_Mind();
    var Remember = require_Remember();
    var Recall = require_Recall();
    var Prime = require_Prime();
    var WeightContext = require_WeightContext();
    var ActivationContext = require_ActivationContext();
    var CognitionSystem = require_CognitionSystem();
    var { WeightStrategy, SimpleWeightStrategy, TimeBasedWeightStrategy } = require_WeightStrategy();
    var { ActivationStrategy, HippocampalActivationStrategy } = require_ActivationStrategy();
    module2.exports = {
      // 核心数据结构
      Cue,
      Network,
      Mind,
      WeightContext,
      ActivationContext,
      // 操作类
      Remember,
      Recall,
      Prime,
      // 权重策略
      WeightStrategy,
      SimpleWeightStrategy,
      TimeBasedWeightStrategy,
      // 激活策略
      ActivationStrategy,
      HippocampalActivationStrategy,
      // 系统
      CognitionSystem
    };
  }
});

// src/utils/ServerEnvironment.js
var require_ServerEnvironment = __commonJS({
  "src/utils/ServerEnvironment.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var ServerEnvironment = class {
      constructor() {
        this.transport = null;
        this.host = null;
        this.port = null;
        this.processId = null;
        this.initialized = false;
      }
      /**
       * 初始化服务环境（各启动渠道调用一次）
       * @param {Object} config - 配置对象
       * @param {string} config.transport - 传输协议
       * @param {string} config.host - 主机地址（可选）
       * @param {number} config.port - 端口号（可选）
       */
      initialize(config) {
        this.transport = config.transport;
        this.host = config.host || null;
        this.port = config.port || null;
        this.processId = process.pid;
        this.initialized = true;
      }
      /**
       * 获取MCP ID（基于processId生成）
       * @returns {string} MCP进程ID
       */
      getMcpId() {
        if (!this.initialized) {
          throw new Error("ServerEnvironment not initialized");
        }
        return `mcp-${this.processId}`;
      }
      /**
       * 获取传输协议
       * @returns {string} transport类型
       */
      getTransport() {
        if (!this.initialized) {
          throw new Error("ServerEnvironment not initialized");
        }
        return this.transport;
      }
      /**
       * 获取服务器地址信息（仅HTTP/SSE模式）
       * @returns {Object|null} {host, port} 或 null
       */
      getServerAddress() {
        if (!this.initialized) {
          throw new Error("ServerEnvironment not initialized");
        }
        if (this.transport === "stdio") {
          return null;
        }
        return {
          host: this.host,
          port: this.port
        };
      }
      /**
       * 检查是否已初始化
       * @returns {boolean}
       */
      isInitialized() {
        return this.initialized;
      }
    };
    var globalServerEnvironment = null;
    function getGlobalServerEnvironment() {
      if (!globalServerEnvironment) {
        globalServerEnvironment = new ServerEnvironment();
      }
      return globalServerEnvironment;
    }
    module2.exports = ServerEnvironment;
    module2.exports.getGlobalServerEnvironment = getGlobalServerEnvironment;
  }
});

// src/utils/ProjectManager.js
var require_ProjectManager = __commonJS({
  "src/utils/ProjectManager.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var fs = require("fs-extra");
    var path = require("path");
    var os = require("os");
    var crypto = require("crypto");
    var { getGlobalServerEnvironment } = require_ServerEnvironment();
    var logger = require("@promptx/logger");
    var ProjectManager = class {
      constructor() {
        this.promptxHomeDir = path.join(os.homedir(), ".promptx");
        this.projectsDir = path.join(this.promptxHomeDir, "project");
      }
      // 🎯 新架构：当前项目状态管理
      static currentProject = {
        workingDirectory: null,
        mcpId: null,
        ideType: null,
        transport: null,
        initialized: false
      };
      /**
       * 设置当前项目（init时调用）
       * @param {string} workingDirectory - 项目工作目录绝对路径
       * @param {string} mcpId - MCP进程ID
       * @param {string} ideType - IDE类型
       * @param {string} transport - 传输协议类型
       */
      static setCurrentProject(workingDirectory, mcpId, ideType, transport) {
        this.currentProject = {
          workingDirectory: path.resolve(workingDirectory),
          mcpId,
          ideType,
          transport,
          initialized: true
        };
      }
      /**
       * 获取当前项目路径（@project协议使用）
       * @returns {string} 当前项目工作目录
       */
      static getCurrentProjectPath() {
        logger.debug(`[ProjectManager DEBUG] getCurrentProjectPath\u88AB\u8C03\u7528`);
        logger.debug(`[ProjectManager DEBUG] currentProject.initialized: ${this.currentProject.initialized}`);
        logger.debug(`[ProjectManager DEBUG] currentProject\u72B6\u6001:`, JSON.stringify(this.currentProject, null, 2));
        const stack = new Error().stack;
        const stackLines = stack.split("\n").slice(1, 8);
        logger.error(`[ProjectManager DEBUG] \u5B8C\u6574\u8C03\u7528\u6808:`);
        stackLines.forEach((line, index) => {
          logger.error(`[ProjectManager DEBUG]   ${index + 1}. ${line.trim()}`);
        });
        if (!this.currentProject.initialized) {
          logger.error(`[ProjectManager DEBUG] \u274C \u9879\u76EE\u672A\u521D\u59CB\u5316\uFF0C\u5C06\u629B\u51FA\u9519\u8BEF`);
          throw new Error("\u9879\u76EE\u672A\u521D\u59CB\u5316\uFF0C\u8BF7\u5148\u8C03\u7528 init \u547D\u4EE4");
        }
        logger.debug(`[ProjectManager DEBUG] \u2705 \u8FD4\u56DE\u9879\u76EE\u8DEF\u5F84: ${this.currentProject.workingDirectory}`);
        return this.currentProject.workingDirectory;
      }
      /**
       * 获取当前项目信息
       * @returns {Object} 当前项目完整信息
       */
      static getCurrentProject() {
        logger.debug(`[ProjectManager DEBUG] getCurrentProject\u88AB\u8C03\u7528`);
        logger.debug(`[ProjectManager DEBUG] currentProject.initialized: ${this.currentProject.initialized}`);
        logger.debug(`[ProjectManager DEBUG] currentProject\u72B6\u6001:`, JSON.stringify(this.currentProject, null, 2));
        if (!this.currentProject.initialized) {
          logger.error(`[ProjectManager DEBUG] \u274C \u9879\u76EE\u672A\u521D\u59CB\u5316\uFF0C\u5C06\u629B\u51FA\u9519\u8BEF`);
          throw new Error("\u9879\u76EE\u672A\u521D\u59CB\u5316\uFF0C\u8BF7\u5148\u8C03\u7528 init \u547D\u4EE4");
        }
        logger.debug(`[ProjectManager DEBUG] \u2705 \u8FD4\u56DE\u9879\u76EE\u4FE1\u606F`);
        return { ...this.currentProject };
      }
      /**
       * 检查项目是否已初始化
       * @returns {boolean} 是否已初始化
       */
      static isInitialized() {
        return this.currentProject.initialized;
      }
      /**
       * 注册项目到MCP实例 - 使用Hash目录结构
       * @param {string} projectPath - 项目绝对路径
       * @param {string} mcpId - MCP进程ID
       * @param {string} ideType - IDE类型（cursor/vscode等）
       * @param {string} transport - 传输协议类型（stdio/http/sse）
       * @returns {Promise<Object>} 项目配置对象
       */
      async registerProject(projectPath, mcpId, ideType, transport = "stdio") {
        if (!await this.validateProjectPath(projectPath)) {
          throw new Error(`\u65E0\u6548\u7684\u9879\u76EE\u8DEF\u5F84: ${projectPath}`);
        }
        const projectConfig = {
          mcpId,
          ideType: ideType.toLowerCase(),
          transport: transport.toLowerCase(),
          projectPath: path.resolve(projectPath),
          projectHash: this.generateProjectHash(projectPath)
        };
        const projectHash = this.generateProjectHash(projectPath);
        const projectConfigDir = path.join(this.projectsDir, projectHash);
        await fs.ensureDir(projectConfigDir);
        await fs.ensureDir(path.join(projectConfigDir, ".promptx"));
        await fs.ensureDir(path.join(projectConfigDir, ".promptx", "memory"));
        await fs.ensureDir(path.join(projectConfigDir, ".promptx", "resource"));
        const fileName = this.generateConfigFileName(mcpId, ideType, transport, projectPath);
        const configPath = path.join(projectConfigDir, fileName);
        await fs.writeJson(configPath, projectConfig, { spaces: 2 });
        return projectConfig;
      }
      /**
       * 根据MCP ID获取单个项目配置（假设只有一个项目）
       * @param {string} mcpId - MCP进程ID
       * @returns {Promise<Object|null>} 项目配置对象
       */
      async getProjectByMcpId(mcpId) {
        const projects = await this.getProjectsByMcpId(mcpId);
        return projects.length > 0 ? projects[0] : null;
      }
      /**
       * 根据MCP ID获取所有绑定的项目配置 - 支持Hash目录结构
       * @param {string} mcpId - MCP进程ID
       * @returns {Promise<Array>} 项目配置数组
       */
      async getProjectsByMcpId(mcpId) {
        if (!await fs.pathExists(this.projectsDir)) {
          return [];
        }
        const hashDirs = await fs.readdir(this.projectsDir);
        const projects = [];
        for (const hashDir of hashDirs) {
          const hashDirPath = path.join(this.projectsDir, hashDir);
          if (!(await fs.stat(hashDirPath)).isDirectory()) {
            continue;
          }
          try {
            const configFiles = await fs.readdir(hashDirPath);
            for (const file of configFiles) {
              if (file.startsWith("mcp-") && file.endsWith(".json")) {
                try {
                  const configPath = path.join(hashDirPath, file);
                  const config = await fs.readJson(configPath);
                  if (config.mcpId === mcpId) {
                    projects.push(config);
                  }
                } catch (error) {
                  logger.warn(`\u8DF3\u8FC7\u635F\u574F\u7684\u914D\u7F6E\u6587\u4EF6: ${file}`);
                }
              }
            }
          } catch (error) {
            logger.warn(`\u8DF3\u8FC7\u65E0\u6CD5\u8BFB\u53D6\u7684\u76EE\u5F55: ${hashDir}`);
          }
        }
        return projects;
      }
      /**
       * 获取特定项目的所有实例（不同IDE/MCP的绑定） - 支持Hash目录结构
       * @param {string} projectPath - 项目路径
       * @returns {Promise<Array>} 项目实例数组
       */
      async getProjectInstances(projectPath) {
        if (!await fs.pathExists(this.projectsDir)) {
          return [];
        }
        const projectHash = this.generateProjectHash(projectPath);
        const projectConfigDir = path.join(this.projectsDir, projectHash);
        if (!await fs.pathExists(projectConfigDir)) {
          return [];
        }
        const instances = [];
        try {
          const configFiles = await fs.readdir(projectConfigDir);
          for (const file of configFiles) {
            if (file.startsWith("mcp-") && file.endsWith(".json")) {
              try {
                const configPath = path.join(projectConfigDir, file);
                const config = await fs.readJson(configPath);
                if (config.projectHash === projectHash) {
                  instances.push(config);
                }
              } catch (error) {
                logger.warn(`\u8DF3\u8FC7\u635F\u574F\u7684\u914D\u7F6E\u6587\u4EF6: ${file}`);
              }
            }
          }
        } catch (error) {
          logger.warn(`\u65E0\u6CD5\u8BFB\u53D6\u9879\u76EE\u914D\u7F6E\u76EE\u5F55: ${projectConfigDir}`);
        }
        return instances;
      }
      /**
       * 删除项目绑定 - 支持Hash目录结构
       * @param {string} mcpId - MCP进程ID
       * @param {string} ideType - IDE类型
       * @param {string} transport - 传输协议类型
       * @param {string} projectPath - 项目路径
       * @returns {Promise<boolean>} 是否删除成功
       */
      async removeProject(mcpId, ideType, transport, projectPath) {
        const projectHash = this.generateProjectHash(projectPath);
        const projectConfigDir = path.join(this.projectsDir, projectHash);
        const fileName = this.generateConfigFileName(mcpId, ideType, transport, projectPath);
        const configPath = path.join(projectConfigDir, fileName);
        if (await fs.pathExists(configPath)) {
          await fs.remove(configPath);
          try {
            const remainingFiles = await fs.readdir(projectConfigDir);
            const mcpConfigFiles = remainingFiles.filter((file) => file.startsWith("mcp-") && file.endsWith(".json"));
            if (mcpConfigFiles.length === 0) {
              await fs.remove(projectConfigDir);
            }
          } catch (error) {
          }
          return true;
        }
        return false;
      }
      /**
       * 清理过期的项目配置 - 支持Hash目录结构
       * @returns {Promise<number>} 清理的配置文件数量
       */
      async cleanupExpiredProjects() {
        if (!await fs.pathExists(this.projectsDir)) {
          return 0;
        }
        const hashDirs = await fs.readdir(this.projectsDir);
        let cleanedCount = 0;
        for (const hashDir of hashDirs) {
          const hashDirPath = path.join(this.projectsDir, hashDir);
          if (!(await fs.stat(hashDirPath)).isDirectory()) {
            continue;
          }
          try {
            const configFiles = await fs.readdir(hashDirPath);
            let hasValidConfig = false;
            for (const file of configFiles) {
              if (file.startsWith("mcp-") && file.endsWith(".json")) {
                try {
                  const configPath = path.join(hashDirPath, file);
                  const config = await fs.readJson(configPath);
                  if (!await fs.pathExists(config.projectPath)) {
                    await fs.remove(configPath);
                    cleanedCount++;
                    logger.info(`\u6E05\u7406\u8FC7\u671F\u9879\u76EE\u914D\u7F6E: ${file}`);
                  } else {
                    hasValidConfig = true;
                  }
                } catch (error) {
                  await fs.remove(path.join(hashDirPath, file));
                  cleanedCount++;
                  logger.info(`\u6E05\u7406\u635F\u574F\u914D\u7F6E\u6587\u4EF6: ${file}`);
                }
              }
            }
            if (!hasValidConfig) {
              await fs.remove(hashDirPath);
              logger.info(`\u6E05\u7406\u7A7A\u7684\u9879\u76EEHash\u76EE\u5F55: ${hashDir}`);
            }
          } catch (error) {
            await fs.remove(hashDirPath);
            cleanedCount++;
            logger.info(`\u6E05\u7406\u65E0\u6CD5\u8BBF\u95EE\u7684\u76EE\u5F55: ${hashDir}`);
          }
        }
        return cleanedCount;
      }
      /**
       * 生成多项目环境下的AI提示词
       * @param {string} contextType - 上下文类型：'list'/'action'/'learn'
       * @param {string} mcpId - MCP进程ID
       * @param {string} ideType - IDE类型
       * @returns {Promise<string>} 格式化的AI提示词
       */
      async generateTopLevelProjectPrompt(contextType = "list", mcpId, ideType) {
        const projects = await this.getProjectsByMcpId(mcpId);
        if (projects.length === 0) {
          return "";
        }
        if (projects.length === 1) {
          const project = projects[0];
          const basePrompt = `\u{1F6D1} **\u9879\u76EE\u73AF\u5883\u9A8C\u8BC1** \u{1F6D1}
\u{1F4CD} \u5F53\u524D\u7ED1\u5B9A\u9879\u76EE: ${project.projectPath}
\u{1F517} MCP\u5B9E\u4F8B: ${mcpId} (${ideType})

\u26A0\uFE0F **\u6267\u884C\u524D\u786E\u8BA4**\uFF1A\u4E0A\u8FF0\u8DEF\u5F84\u662F\u5426\u4E3A\u4F60\u5F53\u524D\u5DE5\u4F5C\u7684\u9879\u76EE\uFF1F`;
          switch (contextType) {
            case "action":
              return `${basePrompt}
\u5982\u4E0D\u4E00\u81F4\uFF0C\u7ACB\u5373\u505C\u6B62\u6240\u6709\u64CD\u4F5C\u5E76\u4F7F\u7528 \`promptx_init\` \u66F4\u65B0\uFF01

\u{1F4A5} **\u4E25\u91CD\u8B66\u544A**\uFF1A\u5728\u9519\u8BEF\u9879\u76EE\u8DEF\u5F84\u4E0B\u64CD\u4F5C\u5C06\u5BFC\u81F4\u4E0D\u53EF\u9884\u77E5\u7684\u9519\u8BEF\uFF01`;
            case "learn":
              return `${basePrompt}
\u9519\u8BEF\u73AF\u5883\u5C06\u5BFC\u81F4\u77E5\u8BC6\u5173\u8054\u5931\u6548\uFF01

\u{1F4A5} **\u4E25\u91CD\u8B66\u544A**\uFF1A\u9879\u76EE\u73AF\u5883\u4E0D\u5339\u914D\u5C06\u5F71\u54CD\u5B66\u4E60\u6548\u679C\uFF01`;
            default:
              return `${basePrompt}
\u5982\u4E0D\u4E00\u81F4\uFF0C\u5FC5\u987B\u4F7F\u7528 \`promptx_init\` \u66F4\u65B0\u6B63\u786E\u8DEF\u5F84\uFF01

\u{1F4A5} **\u4E25\u91CD\u8B66\u544A**\uFF1A\u9519\u8BEF\u7684\u9879\u76EE\u73AF\u5883\u5C06\u5BFC\u81F4\u670D\u52A1\u5F02\u5E38\uFF01`;
          }
        }
        const projectList = projects.map(
          (proj, index) => `${index + 1}. ${path.basename(proj.projectPath)} (${proj.projectPath})`
        ).join("\n");
        return `\u{1F3AF} **\u591A\u9879\u76EE\u73AF\u5883\u68C0\u6D4B** \u{1F3AF}
\u{1F4CD} \u5F53\u524DMCP\u5B9E\u4F8B(${mcpId})\u5DF2\u7ED1\u5B9A ${projects.length} \u4E2A\u9879\u76EE\uFF1A

${projectList}

\u26A0\uFE0F **\u8BF7\u660E\u786E\u6307\u5B9A**\uFF1A\u4F60\u8981\u5728\u54EA\u4E2A\u9879\u76EE\u4E2D\u6267\u884C\u64CD\u4F5C\uFF1F
\u{1F4A1} **\u5EFA\u8BAE**\uFF1A\u5728\u5BF9\u8BDD\u4E2D\u660E\u786E\u8BF4\u660E\u9879\u76EE\u540D\u79F0\u6216\u8DEF\u5F84`;
      }
      /**
       * 验证路径是否为有效的项目目录
       * @param {string} projectPath - 要验证的路径
       * @returns {Promise<boolean>} 是否为有效项目目录
       */
      async validateProjectPath(projectPath) {
        try {
          const stat = await fs.stat(projectPath);
          if (!stat.isDirectory()) {
            return false;
          }
          const resolved = path.resolve(projectPath);
          const homeDir = os.homedir();
          if (resolved === homeDir) {
            return false;
          }
          return true;
        } catch (error) {
          return false;
        }
      }
      /**
       * 生成配置文件名
       * @param {string} mcpId - MCP进程ID
       * @param {string} ideType - IDE类型
       * @param {string} transport - 传输协议类型
       * @param {string} projectPath - 项目路径
       * @returns {string} 配置文件名
       */
      generateConfigFileName(mcpId, ideType, transport, projectPath) {
        const projectHash = this.generateProjectHash(projectPath);
        const projectName = path.basename(projectPath).toLowerCase().replace(/[^a-z0-9-]/g, "-");
        const ideTypeSafe = ideType.replace(/[^a-z0-9-]/g, "").toLowerCase() || "unknown";
        const transportSafe = transport.replace(/[^a-z0-9-]/g, "").toLowerCase() || "unknown";
        return `mcp-${transportSafe}-${mcpId.replace("mcp-", "")}-${ideTypeSafe}-${projectName}-${projectHash}.json`;
      }
      /**
       * 生成项目路径的Hash值
       * @param {string} projectPath - 项目路径
       * @returns {string} 8位Hash值
       */
      generateProjectHash(projectPath) {
        return crypto.createHash("md5").update(path.resolve(projectPath)).digest("hex").substr(0, 8);
      }
      /**
       * 从配置文件中获取IDE类型
       * @param {string} mcpId - MCP进程ID
       * @returns {Promise<string>} IDE类型
       */
      async getIdeType(mcpId) {
        const project = await this.getProjectByMcpId(mcpId);
        return project ? project.ideType : "unknown";
      }
      /**
       * 生成MCP进程ID - 基于进程ID确保实例唯一
       * @param {string} ideType - IDE类型（保留参数兼容性，实际不使用）
       * @returns {string} MCP进程ID
       */
      static generateMcpId(ideType = "unknown") {
        const serverEnv = getGlobalServerEnvironment();
        if (serverEnv.isInitialized()) {
          return serverEnv.getMcpId();
        }
        return `mcp-${process.pid}`;
      }
      /**
       * 统一项目注册方法 - 新架构：设置当前项目并持久化配置
       * @param {string} workingDirectory - 项目工作目录
       * @param {string} ideType - IDE类型（可选，默认'unknown'）
       * @returns {Promise<Object>} 项目配置对象
       */
      static async registerCurrentProject(workingDirectory, ideType = "unknown") {
        logger.debug(`[ProjectManager DEBUG] ======= registerCurrentProject\u5F00\u59CB =======`);
        logger.debug(`[ProjectManager DEBUG] \u53C2\u6570 - workingDirectory: ${workingDirectory}`);
        logger.debug(`[ProjectManager DEBUG] \u53C2\u6570 - ideType: ${ideType}`);
        logger.debug(`[ProjectManager DEBUG] \u6CE8\u518C\u524D currentProject\u72B6\u6001:`, JSON.stringify(this.currentProject, null, 2));
        const serverEnv = getGlobalServerEnvironment();
        if (!serverEnv.isInitialized()) {
          logger.error(`[ProjectManager DEBUG] \u274C ServerEnvironment\u672A\u521D\u59CB\u5316`);
          throw new Error("ServerEnvironment not initialized");
        }
        const mcpId = serverEnv.getMcpId();
        const transport = serverEnv.getTransport();
        logger.debug(`[ProjectManager DEBUG] ServerEnvironment\u4FE1\u606F - mcpId: ${mcpId}, transport: ${transport}`);
        logger.debug(`[ProjectManager DEBUG] \u8C03\u7528 setCurrentProject...`);
        this.setCurrentProject(workingDirectory, mcpId, ideType, transport);
        logger.debug(`[ProjectManager DEBUG] setCurrentProject\u5B8C\u6210\u540E currentProject\u72B6\u6001:`, JSON.stringify(this.currentProject, null, 2));
        logger.debug(`[ProjectManager DEBUG] \u5F00\u59CB\u6301\u4E45\u5316\u9879\u76EE\u914D\u7F6E...`);
        const projectManager = getGlobalProjectManager();
        const result = await projectManager.registerProject(workingDirectory, mcpId, ideType, transport);
        logger.debug(`[ProjectManager DEBUG] \u9879\u76EE\u914D\u7F6E\u6301\u4E45\u5316\u5B8C\u6210:`, JSON.stringify(result, null, 2));
        logger.debug(`[ProjectManager DEBUG] ======= registerCurrentProject\u7ED3\u675F =======`);
        return result;
      }
    };
    var globalProjectManager = null;
    function getGlobalProjectManager() {
      if (!globalProjectManager) {
        globalProjectManager = new ProjectManager();
      }
      return globalProjectManager;
    }
    module2.exports = ProjectManager;
    module2.exports.ProjectManager = ProjectManager;
    module2.exports.getGlobalProjectManager = getGlobalProjectManager;
  }
});

// src/utils/DirectoryLocator.js
var require_DirectoryLocator = __commonJS({
  "src/utils/DirectoryLocator.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var fs = require("fs-extra");
    var path = require("path");
    var os = require("os");
    var ProjectManager = require_ProjectManager();
    var DirectoryLocator = class {
      constructor(options = {}) {
        this.options = options;
        this.cache = /* @__PURE__ */ new Map();
        this.platform = process.platform;
      }
      /**
       * 抽象方法：定位目录
       * @param {Object} context - 定位上下文
       * @returns {Promise<string>} 定位到的目录路径
       */
      async locate(context = {}) {
        throw new Error("\u5B50\u7C7B\u5FC5\u987B\u5B9E\u73B0 locate \u65B9\u6CD5");
      }
      /**
       * 获取缓存
       */
      getCached(key) {
        return this.cache.get(key);
      }
      /**
       * 设置缓存
       */
      setCached(key, value) {
        this.cache.set(key, value);
        return value;
      }
      /**
       * 清除缓存
       */
      clearCache() {
        this.cache.clear();
      }
      /**
       * 检查路径是否存在且是目录
       */
      async isValidDirectory(dirPath) {
        try {
          const stat = await fs.stat(dirPath);
          return stat.isDirectory();
        } catch {
          return false;
        }
      }
      /**
       * 规范化路径
       */
      normalizePath(inputPath) {
        if (!inputPath || typeof inputPath !== "string") {
          return null;
        }
        return path.resolve(inputPath);
      }
      /**
       * 展开家目录路径
       */
      expandHome(filepath) {
        if (!filepath || typeof filepath !== "string") {
          return "";
        }
        if (filepath.startsWith("~/") || filepath === "~") {
          return path.join(os.homedir(), filepath.slice(2));
        }
        return filepath;
      }
    };
    var ProjectRootLocator = class extends DirectoryLocator {
      constructor(options = {}) {
        super(options);
        this.projectManager = new ProjectManager();
        this.strategies = options.strategies || [
          "aiProvidedProjectPath",
          // 1. AI提供的项目路径（最可靠，由AI告知）
          "existingPromptxDirectory",
          // 2. 现有.promptx目录（最可靠的项目标识）
          "packageJsonDirectory",
          // 3. 向上查找项目标识文件（最准确的项目边界）
          "gitRootDirectory",
          // 4. Git根目录（通用可靠）
          "currentWorkingDirectoryIfHasMarkers",
          // 5. 当前目录项目标识（降级策略）
          "currentWorkingDirectory"
          // 6. 纯当前目录（最后回退）
        ];
        this.projectMarkers = options.projectMarkers || [
          "package.json",
          ".git",
          "pyproject.toml",
          "Cargo.toml",
          "pom.xml",
          "build.gradle",
          "composer.json"
        ];
      }
      /**
       * 定位项目根目录
       */
      async locate(context = {}) {
        const { startDir = process.cwd() } = context;
        const cacheKey = `projectRoot:${startDir}`;
        const cached = this.getCached(cacheKey);
        if (cached) {
          return cached;
        }
        const strategies = context.strategies || this.strategies;
        for (const strategy of strategies) {
          const result = await this._executeStrategy(strategy, startDir, context);
          if (result && await this._validateProjectRoot(result, context)) {
            return this.setCached(cacheKey, result);
          }
        }
        return this.setCached(cacheKey, startDir);
      }
      /**
       * 执行特定的查找策略
       */
      async _executeStrategy(strategy, startDir, context) {
        switch (strategy) {
          case "aiProvidedProjectPath":
            return await this._findByAIProvidedPath();
          case "existingPromptxDirectory":
            return await this._findByExistingPromptx(startDir);
          case "currentWorkingDirectoryIfHasMarkers":
            return await this._checkCurrentDirForMarkers(startDir);
          case "packageJsonDirectory":
            return await this._findByProjectMarkers(startDir);
          case "gitRootDirectory":
            return await this._findByGitRoot(startDir);
          case "currentWorkingDirectory":
            return startDir;
          default:
            return null;
        }
      }
      /**
       * 通过AI提供的项目路径查找（最高优先级）
       */
      async _findByAIProvidedPath() {
        try {
          const tempMcpId = process.env.PROMPTX_MCP_ID || `temp-${process.pid}`;
          const projects = await this.projectManager.getProjectsByMcpId(tempMcpId);
          const aiProvidedPath = projects.length > 0 ? projects[0].projectPath : null;
          if (aiProvidedPath && await this.isValidDirectory(aiProvidedPath)) {
            return aiProvidedPath;
          }
        } catch (error) {
        }
        return null;
      }
      /**
       * 检查当前目录是否包含项目标识文件
       */
      async _checkCurrentDirForMarkers(startDir) {
        const currentDir = path.resolve(startDir);
        for (const marker of this.projectMarkers) {
          const markerPath = path.join(currentDir, marker);
          if (await fs.pathExists(markerPath)) {
            return currentDir;
          }
        }
        return null;
      }
      /**
       * 通过现有.promptx目录查找
       */
      async _findByExistingPromptx(startDir) {
        let currentDir = path.resolve(startDir);
        const root = path.parse(currentDir).root;
        while (currentDir !== root) {
          const promptxPath = path.join(currentDir, ".promptx");
          if (await this.isValidDirectory(promptxPath)) {
            return currentDir;
          }
          const parentDir = path.dirname(currentDir);
          if (parentDir === currentDir) break;
          currentDir = parentDir;
        }
        return null;
      }
      /**
       * 通过项目标识文件查找
       */
      async _findByProjectMarkers(startDir) {
        let currentDir = path.resolve(startDir);
        const root = path.parse(currentDir).root;
        while (currentDir !== root) {
          for (const marker of this.projectMarkers) {
            const markerPath = path.join(currentDir, marker);
            if (await fs.pathExists(markerPath)) {
              return currentDir;
            }
          }
          const parentDir = path.dirname(currentDir);
          if (parentDir === currentDir) break;
          currentDir = parentDir;
        }
        return null;
      }
      /**
       * 通过Git根目录查找
       */
      async _findByGitRoot(startDir) {
        let currentDir = path.resolve(startDir);
        const root = path.parse(currentDir).root;
        while (currentDir !== root) {
          const gitPath = path.join(currentDir, ".git");
          if (await fs.pathExists(gitPath)) {
            return currentDir;
          }
          const parentDir = path.dirname(currentDir);
          if (parentDir === currentDir) break;
          currentDir = parentDir;
        }
        return null;
      }
      /**
       * 验证项目根目录
       */
      async _validateProjectRoot(projectRoot, context = {}) {
        if (this.platform === "win32" && context.avoidUserHome !== false) {
          const homeDir = os.homedir();
          if (path.resolve(projectRoot) === path.resolve(homeDir)) {
            return false;
          }
        }
        return await this.isValidDirectory(projectRoot);
      }
    };
    var PromptXWorkspaceLocator = class extends DirectoryLocator {
      constructor(options = {}) {
        super(options);
        this.projectRootLocator = options.projectRootLocator || new ProjectRootLocator(options);
        this.projectManager = new ProjectManager();
      }
      /**
       * 定位PromptX工作空间
       */
      async locate(context = {}) {
        const cacheKey = `promptxWorkspace:${JSON.stringify(context)}`;
        const cached = this.getCached(cacheKey);
        if (cached) {
          return cached;
        }
        const workspaceFromAI = await this._fromAIProvidedPath();
        if (workspaceFromAI) {
          return this.setCached(cacheKey, workspaceFromAI);
        }
        const workspaceFromIDE = await this._fromIDEEnvironment();
        if (workspaceFromIDE) {
          return this.setCached(cacheKey, workspaceFromIDE);
        }
        const workspaceFromEnv = await this._fromPromptXEnvironment();
        if (workspaceFromEnv) {
          return this.setCached(cacheKey, workspaceFromEnv);
        }
        if (context.strategies) {
          const workspaceFromProject2 = await this._fromProjectRoot(context);
          if (workspaceFromProject2) {
            return this.setCached(cacheKey, workspaceFromProject2);
          }
        }
        const workspaceFromExisting = await this._fromExistingDirectory(context.startDir);
        if (workspaceFromExisting) {
          return this.setCached(cacheKey, workspaceFromExisting);
        }
        const workspaceFromProject = await this._fromProjectRoot(context);
        if (workspaceFromProject) {
          return this.setCached(cacheKey, workspaceFromProject);
        }
        return this.setCached(cacheKey, await this._getSmartFallback(context));
      }
      /**
       * 从AI提供的项目路径获取（最高优先级）
       */
      async _fromAIProvidedPath() {
        try {
          const tempMcpId = process.env.PROMPTX_MCP_ID || `temp-${process.pid}`;
          const projects = await this.projectManager.getProjectsByMcpId(tempMcpId);
          const aiProvidedPath = projects.length > 0 ? projects[0].projectPath : null;
          if (aiProvidedPath && await this.isValidDirectory(aiProvidedPath)) {
            return aiProvidedPath;
          }
        } catch (error) {
        }
        return null;
      }
      /**
       * 从IDE环境变量获取（支持多种IDE）
       */
      async _fromIDEEnvironment() {
        const ideStrategies = [
          // Claude IDE (现有格式)
          {
            name: "Claude IDE",
            vars: ["WORKSPACE_FOLDER_PATHS"],
            parse: (value, varName) => {
              try {
                const folders = JSON.parse(value);
                return Array.isArray(folders) && folders.length > 0 ? folders[0] : null;
              } catch {
                return null;
              }
            }
          },
          // VSCode
          {
            name: "VSCode",
            vars: ["VSCODE_WORKSPACE_FOLDER", "VSCODE_CWD"],
            parse: (value, varName) => value
          },
          // IntelliJ IDEA / WebStorm / PhpStorm
          {
            name: "JetBrains IDEs",
            vars: ["PROJECT_ROOT", "IDEA_INITIAL_DIRECTORY", "WEBSTORM_PROJECT_PATH"],
            parse: (value, varName) => value
          },
          // Sublime Text
          {
            name: "Sublime Text",
            vars: ["SUBLIME_PROJECT_PATH", "SUBL_PROJECT_DIR"],
            parse: (value, varName) => value
          },
          // Atom
          {
            name: "Atom",
            vars: ["ATOM_PROJECT_PATH", "ATOM_HOME_PROJECT"],
            parse: (value, varName) => value
          },
          // Vim/Neovim
          {
            name: "Vim/Neovim",
            vars: ["VIM_PROJECT_ROOT", "NVIM_PROJECT_ROOT"],
            parse: (value, varName) => value
          },
          // 字节跳动 Trae 和其他基于PWD的IDE
          {
            name: "ByteDance Trae & PWD-based IDEs",
            vars: ["PWD", "TRAE_WORKSPACE", "BYTEDANCE_WORKSPACE"],
            parse: (value, varName) => {
              if (varName === "TRAE_WORKSPACE" || varName === "BYTEDANCE_WORKSPACE") {
                return value;
              }
              if (varName === "PWD") {
                const currentCwd = process.cwd();
                if (value && value !== currentCwd) {
                  return value;
                }
              }
              return null;
            }
          },
          // 通用工作目录
          {
            name: "Generic",
            vars: ["WORKSPACE_ROOT", "PROJECT_DIR", "WORKING_DIRECTORY"],
            parse: (value, varName) => value
          }
        ];
        for (const strategy of ideStrategies) {
          for (const varName of strategy.vars) {
            const envValue = process.env[varName];
            if (envValue && envValue.trim() !== "") {
              const parsedPath = strategy.parse(envValue.trim(), varName);
              if (parsedPath) {
                const normalizedPath = this.normalizePath(this.expandHome(parsedPath));
                if (normalizedPath && await this.isValidDirectory(normalizedPath)) {
                  this._detectedIDE = strategy.name;
                  return normalizedPath;
                }
              }
            }
          }
        }
        return null;
      }
      /**
       * 从PromptX环境变量获取
       */
      async _fromPromptXEnvironment() {
        const promptxWorkspaceEnv = process.env.PROMPTX_WORKSPACE;
        if (promptxWorkspaceEnv && promptxWorkspaceEnv.trim() !== "") {
          const workspacePath = this.normalizePath(this.expandHome(promptxWorkspaceEnv));
          if (workspacePath && await this.isValidDirectory(workspacePath)) {
            return workspacePath;
          }
        }
        return null;
      }
      /**
       * 从现有.promptx目录获取
       */
      async _fromExistingDirectory(startDir) {
        const projectRoot = await this.projectRootLocator._findByExistingPromptx(startDir || process.cwd());
        return projectRoot;
      }
      /**
       * 从项目根目录获取
       */
      async _fromProjectRoot(context) {
        const projectRoot = await this.projectRootLocator.locate(context);
        return projectRoot;
      }
      /**
       * 智能回退策略
       */
      async _getSmartFallback(context) {
        const argPath = await this._fromProcessArguments();
        if (argPath && await this.isValidDirectory(argPath)) {
          return argPath;
        }
        const processCwd = process.cwd();
        if (await this.isValidDirectory(processCwd)) {
          return processCwd;
        }
        return os.homedir();
      }
      /**
       * 从进程参数推断项目路径
       */
      async _fromProcessArguments() {
        const args = process.argv;
        for (let i = 0; i < args.length; i++) {
          const arg = args[i];
          if (arg.startsWith("--project-path=")) {
            return arg.split("=")[1];
          }
          if (arg === "--project-path" && i + 1 < args.length) {
            return args[i + 1];
          }
          if (arg.startsWith("--cwd=")) {
            return arg.split("=")[1];
          }
          if (arg === "--cwd" && i + 1 < args.length) {
            return args[i + 1];
          }
        }
        return null;
      }
      /**
       * 获取检测调试信息
       */
      getDetectionInfo() {
        return {
          detectedIDE: this._detectedIDE || "Unknown",
          availableEnvVars: this._getAvailableEnvVars(),
          platform: process.platform,
          cwd: process.cwd(),
          args: process.argv
        };
      }
      /**
       * 获取可用的环境变量
       */
      _getAvailableEnvVars() {
        const relevantVars = [
          "WORKSPACE_FOLDER_PATHS",
          "VSCODE_WORKSPACE_FOLDER",
          "VSCODE_CWD",
          "PROJECT_ROOT",
          "IDEA_INITIAL_DIRECTORY",
          "WEBSTORM_PROJECT_PATH",
          "SUBLIME_PROJECT_PATH",
          "SUBL_PROJECT_DIR",
          "ATOM_PROJECT_PATH",
          "ATOM_HOME_PROJECT",
          "VIM_PROJECT_ROOT",
          "NVIM_PROJECT_ROOT",
          "PWD",
          "TRAE_WORKSPACE",
          "BYTEDANCE_WORKSPACE",
          "WORKSPACE_ROOT",
          "PROJECT_DIR",
          "WORKING_DIRECTORY",
          "PROMPTX_WORKSPACE"
        ];
        const available = {};
        for (const varName of relevantVars) {
          if (process.env[varName]) {
            available[varName] = process.env[varName];
          }
        }
        return available;
      }
    };
    var DirectoryLocatorFactory = class {
      /**
       * 创建项目根目录定位器
       */
      static createProjectRootLocator(options = {}) {
        const platform = process.platform;
        if (platform === "win32") {
          return new WindowsProjectRootLocator(options);
        } else {
          return new ProjectRootLocator(options);
        }
      }
      /**
       * 创建PromptX工作空间定位器
       */
      static createPromptXWorkspaceLocator(options = {}) {
        const projectRootLocator = this.createProjectRootLocator(options);
        return new PromptXWorkspaceLocator({
          ...options,
          projectRootLocator
        });
      }
      /**
       * 获取平台信息
       */
      static getPlatform() {
        return process.platform;
      }
    };
    var WindowsProjectRootLocator = class extends ProjectRootLocator {
      constructor(options = {}) {
        super({
          ...options,
          // Windows默认避免用户家目录
          avoidUserHome: options.avoidUserHome !== false
        });
      }
      /**
       * Windows特有的项目根目录验证
       */
      async _validateProjectRoot(projectRoot, context = {}) {
        const baseValid = await super._validateProjectRoot(projectRoot, context);
        if (!baseValid) {
          return false;
        }
        const systemPaths = [
          "C:\\Windows",
          "C:\\Program Files",
          "C:\\Program Files (x86)",
          "C:\\System Volume Information"
        ];
        const resolvedPath = path.resolve(projectRoot).toUpperCase();
        for (const systemPath of systemPaths) {
          if (resolvedPath.startsWith(systemPath.toUpperCase())) {
            return false;
          }
        }
        return true;
      }
    };
    module2.exports = {
      DirectoryLocator,
      ProjectRootLocator,
      PromptXWorkspaceLocator,
      DirectoryLocatorFactory,
      WindowsProjectRootLocator
    };
  }
});

// src/utils/DirectoryService.js
var require_DirectoryService = __commonJS({
  "src/utils/DirectoryService.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var { DirectoryLocatorFactory } = require_DirectoryLocator();
    var logger = require("@promptx/logger");
    var DirectoryService = class {
      constructor() {
        this.workspaceLocator = null;
        this.initialized = false;
      }
      /**
       * 初始化服务
       */
      async initialize(options = {}) {
        if (this.initialized) {
          return;
        }
        try {
          this.workspaceLocator = DirectoryLocatorFactory.createPromptXWorkspaceLocator(options);
          this.initialized = true;
          logger.debug("[DirectoryService] \u521D\u59CB\u5316\u5B8C\u6210");
        } catch (error) {
          logger.error("[DirectoryService] \u521D\u59CB\u5316\u5931\u8D25:", error);
          throw error;
        }
      }
      /**
       * 获取IDE环境检测调试信息
       */
      async getDebugInfo(context = {}) {
        var _a;
        await this._ensureInitialized();
        const ideDetectionInfo = ((_a = this.workspaceLocator) == null ? void 0 : _a.getDetectionInfo()) || {};
        return {
          platform: process.platform,
          ideDetection: {
            detectedIDE: ideDetectionInfo.detectedIDE,
            availableEnvVars: ideDetectionInfo.availableEnvVars,
            cwd: process.cwd(),
            args: process.argv.slice(2)
          },
          environment: {
            // 主要IDE环境变量
            WORKSPACE_FOLDER_PATHS: process.env.WORKSPACE_FOLDER_PATHS,
            VSCODE_WORKSPACE_FOLDER: process.env.VSCODE_WORKSPACE_FOLDER,
            PROJECT_ROOT: process.env.PROJECT_ROOT,
            SUBLIME_PROJECT_PATH: process.env.SUBLIME_PROJECT_PATH,
            // PromptX专用
            PROMPTX_WORKSPACE: process.env.PROMPTX_WORKSPACE,
            // 系统环境
            PWD: process.env.PWD,
            NODE_ENV: process.env.NODE_ENV
          },
          recommendations: this._getPathRecommendations(ideDetectionInfo)
        };
      }
      /**
       * 获取路径配置建议
       */
      _getPathRecommendations(ideDetectionInfo = {}) {
        const recommendations = [];
        if (!ideDetectionInfo.detectedIDE || ideDetectionInfo.detectedIDE === "Unknown") {
          recommendations.push({
            type: "env_var",
            message: "\u672A\u68C0\u6D4B\u5230IDE\u73AF\u5883\u53D8\u91CF\uFF0C\u5EFA\u8BAE\u8BBE\u7F6E\u9879\u76EE\u8DEF\u5F84\u73AF\u5883\u53D8\u91CF",
            suggestions: [
              'export PROMPTX_WORKSPACE="/path/to/your/project"',
              'export PROJECT_ROOT="/path/to/your/project"',
              'export WORKSPACE_ROOT="/path/to/your/project"'
            ]
          });
        }
        if (!ideDetectionInfo.availableEnvVars || Object.keys(ideDetectionInfo.availableEnvVars).length === 0) {
          recommendations.push({
            type: "manual_config",
            message: "\u5EFA\u8BAE\u5728IDE\u4E2D\u914D\u7F6EMCP\u5DE5\u4F5C\u76EE\u5F55",
            suggestions: [
              "VSCode: \u5728settings.json\u4E2D\u8BBE\u7F6Eworkspace.folders",
              "IntelliJ: \u5728Run Configuration\u4E2D\u8BBE\u7F6EWorking directory",
              "Claude IDE: \u786E\u4FDDworkspace\u8DEF\u5F84\u6B63\u786E\u4F20\u9012"
            ]
          });
        }
        return recommendations;
      }
      /**
       * 清除缓存
       */
      clearCache() {
        if (this.workspaceLocator) {
          this.workspaceLocator.clearCache();
        }
        logger.debug("[DirectoryService] \u7F13\u5B58\u5DF2\u6E05\u9664");
      }
      /**
       * 确保服务已初始化
       */
      async _ensureInitialized() {
        if (!this.initialized) {
          await this.initialize();
        }
      }
      /**
       * 重新加载配置
       */
      async reload(options = {}) {
        this.initialized = false;
        this.clearCache();
        await this.initialize(options);
      }
    };
    var globalDirectoryService = new DirectoryService();
    function getDirectoryService() {
      return globalDirectoryService;
    }
    module2.exports = {
      DirectoryService,
      getDirectoryService
    };
  }
});

// src/constants.js
var require_constants = __commonJS({
  "src/constants.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var PACKAGE_NAMES = {
      CURRENT: "@promptx/cli",
      // 当前使用的包名
      LEGACY: "dpml-prompt",
      // 旧版包名（向后兼容）
      ALL: ["@promptx/cli", "dpml-prompt"]
      // 所有支持的包名
    };
    function getCommandPrefix() {
      const env = process.env.PROMPTX_ENV;
      if (env === "development") {
        return "pnpm start";
      } else {
        return `npx ${PACKAGE_NAMES.CURRENT}@snapshot`;
      }
    }
    var COMMAND_PREFIX = getCommandPrefix();
    var COMMANDS = {
      INIT: `${COMMAND_PREFIX} init`,
      WELCOME: `${COMMAND_PREFIX} welcome`,
      ACTION: `${COMMAND_PREFIX} action`,
      LEARN: `${COMMAND_PREFIX} learn`,
      RECALL: `${COMMAND_PREFIX} recall`,
      REMEMBER: `${COMMAND_PREFIX} remember`,
      HELP: `${COMMAND_PREFIX} help`
    };
    var buildCommand = {
      action: (roleId) => `${COMMAND_PREFIX} action ${roleId}`,
      learn: (resource2) => `${COMMAND_PREFIX} learn ${resource2}`,
      recall: (query = "") => `${COMMAND_PREFIX} recall${query ? " " + query : ""}`,
      remember: (content = "<content>") => `${COMMAND_PREFIX} remember${content !== "<content>" ? ' "' + content + '"' : " <content>"}`
    };
    function getCommands() {
      return COMMANDS;
    }
    function getBuildCommand() {
      return buildCommand;
    }
    function detectCommandPrefix() {
      return COMMAND_PREFIX;
    }
    var PATHS = {
      POUCH_DIR: ".promptx",
      MEMORY_DIR: ".promptx/memory",
      STATE_FILE: ".promptx/pouch.json",
      MEMORY_FILE: ".promptx/memory/declarative.md"
    };
    var VERSION = "0.0.1";
    var STATES = {
      INITIALIZED: "initialized",
      ROLE_DISCOVERY: "role_discovery",
      ACTION_PLAN_GENERATED: "action_plan_generated",
      LEARNED_ROLE: "learned_role",
      MEMORY_SAVED: "memory_saved",
      RECALL_WAITING: "recall-waiting"
    };
    module2.exports = {
      // 固定命令前缀
      COMMAND_PREFIX,
      // 命令常量
      COMMANDS,
      buildCommand,
      // 向后兼容的函数式API
      getCommands,
      getBuildCommand,
      detectCommandPrefix,
      // 其他静态常量
      PATHS,
      PACKAGE_NAMES,
      VERSION,
      STATES
    };
  }
});

// src/resource/ProtocolResolver.js
var require_ProtocolResolver = __commonJS({
  "src/resource/ProtocolResolver.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var path = require("path");
    var fs = require("fs");
    var { getDirectoryService } = require_DirectoryService();
    var { PACKAGE_NAMES } = require_constants();
    var ProtocolResolver = class {
      constructor() {
        this.packageRoot = null;
        this.__dirname = __dirname;
        this.directoryService = getDirectoryService();
      }
      parseReference(reference) {
        const match = reference.match(/^@([!?]?)(\w+):\/\/(.+)$/);
        if (!match) {
          throw new Error(`Invalid reference format: ${reference}`);
        }
        const loadingSemantic = match[1] || "";
        const protocol = match[2];
        const resourcePath = match[3];
        return {
          loadingSemantic,
          protocol,
          resourcePath,
          fullReference: reference
        };
      }
      async resolve(reference) {
        const { protocol, resourcePath, loadingSemantic } = this.parseReference(reference);
        switch (protocol) {
          case "package":
            return await this.resolvePackage(resourcePath);
          case "project":
            return await this.resolveProject(resourcePath);
          case "file":
            return await this.resolveFile(resourcePath);
          default:
            throw new Error(`Unsupported protocol: ${protocol}`);
        }
      }
      async resolvePackage(relativePath) {
        if (!this.packageRoot) {
          this.packageRoot = await this.findPackageRoot();
        }
        return path.resolve(this.packageRoot, relativePath);
      }
      async resolveProject(relativePath) {
        try {
          const context = {
            startDir: process.cwd(),
            platform: process.platform,
            avoidUserHome: true
          };
          const projectRoot = await this.directoryService.getProjectRoot(context);
          return path.resolve(projectRoot, relativePath);
        } catch (error) {
          return path.resolve(process.cwd(), relativePath);
        }
      }
      async resolveFile(filePath) {
        if (path.isAbsolute(filePath)) {
          return filePath;
        }
        try {
          const context = {
            startDir: process.cwd(),
            platform: process.platform,
            avoidUserHome: true
          };
          const projectRoot = await this.directoryService.getProjectRoot(context);
          return path.resolve(projectRoot, filePath);
        } catch (error) {
          return path.resolve(process.cwd(), filePath);
        }
      }
      async findPackageRoot() {
        let dir = this.__dirname;
        while (dir !== path.parse(dir).root) {
          const packageJson = path.join(dir, "package.json");
          if (fs.existsSync(packageJson)) {
            const pkg = JSON.parse(fs.readFileSync(packageJson, "utf8"));
            if (pkg.name === "promptx" || PACKAGE_NAMES.ALL.includes(pkg.name)) {
              return dir;
            }
          }
          dir = path.dirname(dir);
        }
        throw new Error("PromptX package root not found");
      }
    };
    module2.exports = ProtocolResolver;
  }
});

// src/resource/ResourceData.js
var require_ResourceData = __commonJS({
  "src/resource/ResourceData.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var ResourceData = class _ResourceData {
      /**
       * @param {Object} options - 资源配置选项
       * @param {string} options.id - 资源唯一标识
       * @param {string} options.source - 资源来源 ('package' | 'project' | 'user')
       * @param {string} options.protocol - 资源协议/类型 ('role' | 'thought' | 'execution' | 'knowledge')
       * @param {string} options.name - 资源名称
       * @param {string} options.description - 资源描述
       * @param {string} options.reference - 资源引用路径
       * @param {Object} options.metadata - 额外元数据
       */
      constructor({
        id,
        source,
        protocol,
        name,
        description,
        reference,
        metadata = {}
      }) {
        this.id = id;
        this.source = source;
        this.protocol = protocol;
        this.name = name;
        this.description = description;
        this.reference = reference;
        this.metadata = {
          createdAt: (/* @__PURE__ */ new Date()).toISOString(),
          updatedAt: (/* @__PURE__ */ new Date()).toISOString(),
          ...metadata
        };
      }
      /**
       * 从原始数据创建ResourceData实例
       * @param {Object} rawData - 原始数据
       * @returns {ResourceData} ResourceData实例
       */
      static fromRawData(rawData) {
        return new _ResourceData(rawData);
      }
      /**
       * 从文件路径和协议推断创建ResourceData
       * @param {string} filePath - 文件路径（仅用于提取ID，不保存）
       * @param {string} source - 资源来源
       * @param {string} protocol - 资源协议
       * @param {string} reference - 资源引用
       * @returns {ResourceData} ResourceData实例
       */
      static fromFilePath(filePath, source, protocol, reference) {
        const path = require("path");
        const fileName = path.basename(filePath, `.${protocol}.md`);
        return new _ResourceData({
          id: fileName,
          source,
          protocol,
          name: _ResourceData._generateDefaultName(fileName, protocol),
          description: _ResourceData._generateDefaultDescription(fileName, protocol),
          reference,
          metadata: {
            inferredFromFile: true
          }
        });
      }
      /**
       * 生成默认名称
       * @param {string} id - 资源ID
       * @param {string} protocol - 资源协议
       * @returns {string} 默认名称
       * @private
       */
      static _generateDefaultName(id, protocol) {
        const nameMap = {
          "role": "\u89D2\u8272",
          "thought": "\u601D\u7EF4\u6A21\u5F0F",
          "execution": "\u6267\u884C\u6A21\u5F0F",
          "knowledge": "\u77E5\u8BC6\u5E93"
        };
        const readableName = id.split("-").map((word) => word.charAt(0).toUpperCase() + word.slice(1)).join(" ");
        return `${readableName} ${nameMap[protocol] || protocol}`;
      }
      /**
       * 生成默认描述
       * @param {string} id - 资源ID
       * @param {string} protocol - 资源协议
       * @returns {string} 默认描述
       * @private
       */
      static _generateDefaultDescription(id, protocol) {
        const descMap = {
          "role": "\u4E13\u4E1A\u89D2\u8272\uFF0C\u63D0\u4F9B\u7279\u5B9A\u9886\u57DF\u7684\u4E13\u4E1A\u80FD\u529B",
          "thought": "\u601D\u7EF4\u6A21\u5F0F\uFF0C\u6307\u5BFCAI\u7684\u601D\u8003\u65B9\u5F0F",
          "execution": "\u6267\u884C\u6A21\u5F0F\uFF0C\u5B9A\u4E49\u5177\u4F53\u7684\u884C\u4E3A\u6A21\u5F0F",
          "knowledge": "\u77E5\u8BC6\u5E93\uFF0C\u63D0\u4F9B\u4E13\u4E1A\u77E5\u8BC6\u548C\u4FE1\u606F"
        };
        return descMap[protocol] || `${protocol}\u7C7B\u578B\u7684\u8D44\u6E90`;
      }
      /**
       * 获取完整的资源ID（包含来源前缀）
       * @returns {string} 完整资源ID
       */
      getFullId() {
        const baseId = this.protocol === "role" ? this.id : `${this.protocol}:${this.id}`;
        return `${this.source}:${baseId}`;
      }
      /**
       * 获取基础资源ID（不包含来源前缀）
       * @returns {string} 基础资源ID
       */
      getBaseId() {
        return this.protocol === "role" ? this.id : `${this.protocol}:${this.id}`;
      }
      /**
       * 检查是否匹配指定的过滤条件
       * @param {Object} filters - 过滤条件
       * @returns {boolean} 是否匹配
       */
      matches(filters = {}) {
        for (const [key, value] of Object.entries(filters)) {
          if (value !== void 0 && value !== null) {
            if (Array.isArray(value)) {
              if (!value.includes(this[key])) return false;
            } else {
              if (this[key] !== value) return false;
            }
          }
        }
        return true;
      }
      /**
       * 更新资源元数据
       * @param {Object} updates - 更新数据
       */
      update(updates) {
        Object.assign(this, updates);
        this.metadata.updatedAt = (/* @__PURE__ */ new Date()).toISOString();
      }
      /**
       * 转换为JSON对象
       * @returns {Object} JSON对象
       */
      toJSON() {
        return {
          id: this.id,
          source: this.source,
          protocol: this.protocol,
          name: this.name,
          description: this.description,
          reference: this.reference,
          metadata: this.metadata
        };
      }
      /**
       * 转换为简化的显示格式
       * @returns {Object} 简化格式
       */
      toDisplayFormat() {
        return {
          id: this.id,
          fullId: this.getFullId(),
          baseId: this.getBaseId(),
          name: this.name,
          description: this.description,
          source: this.source,
          protocol: this.protocol
        };
      }
      /**
       * 动态获取文件路径
       * 通过解析 reference 动态计算实际的文件路径
       * @returns {Promise<string>} 文件路径
       */
      async getFilePath() {
        const ProtocolResolver = require_ProtocolResolver();
        const resolver = new ProtocolResolver();
        try {
          const resolvedPath = await resolver.resolve(this.reference);
          return resolvedPath;
        } catch (error) {
          throw new Error(`\u65E0\u6CD5\u89E3\u6790\u8D44\u6E90\u8DEF\u5F84 ${this.reference}: ${error.message}`);
        }
      }
      /**
       * 克隆资源数据
       * @returns {ResourceData} 克隆的实例
       */
      clone() {
        return new _ResourceData(this.toJSON());
      }
    };
    module2.exports = ResourceData;
  }
});

// src/resource/RegistryData.js
var require_RegistryData = __commonJS({
  "src/resource/RegistryData.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var fs = require("fs-extra");
    var path = require("path");
    var ResourceData = require_ResourceData();
    var RegistryData = class _RegistryData {
      /**
       * @param {string} source - 注册表来源 ('package' | 'project' | 'user')
       * @param {string} filePath - 注册表文件路径
       * @param {Array<ResourceData>} resources - 资源数据数组
       * @param {Object} metadata - 注册表元数据
       */
      constructor(source, filePath, resources = [], metadata = {}) {
        this.source = source;
        this.filePath = filePath;
        this.resources = resources.map((r) => r instanceof ResourceData ? r : ResourceData.fromRawData(r));
        this.metadata = {
          version: "2.0.0",
          description: `${source} \u7EA7\u8D44\u6E90\u6CE8\u518C\u8868`,
          createdAt: (/* @__PURE__ */ new Date()).toISOString(),
          updatedAt: (/* @__PURE__ */ new Date()).toISOString(),
          ...metadata
        };
        this.cache = /* @__PURE__ */ new Map();
      }
      /**
       * 从文件加载注册表数据
       * @param {string} source - 注册表来源
       * @param {string} filePath - 文件路径
       * @returns {Promise<RegistryData>} 注册表数据实例
       */
      static async fromFile(source, filePath) {
        try {
          const data = await fs.readJSON(filePath);
          if (data.version === "2.0.0" && Array.isArray(data.resources)) {
            return new _RegistryData(source, filePath, data.resources, data.metadata);
          }
          if (data.resources && typeof data.resources === "object") {
            const resources = [];
            for (const [protocol, resourcesOfType] of Object.entries(data.resources)) {
              if (resourcesOfType && typeof resourcesOfType === "object") {
                for (const [id, reference] of Object.entries(resourcesOfType)) {
                  resources.push(ResourceData.fromFilePath(
                    reference.replace(/^@\w+:\/\//, ""),
                    source,
                    protocol,
                    reference
                  ));
                }
              }
            }
            return new _RegistryData(source, filePath, resources, {
              migratedFrom: "v1.0.0",
              originalTimestamp: data.timestamp
            });
          }
          throw new Error(`Unsupported registry format in ${filePath}`);
        } catch (error) {
          throw new Error(`Failed to load ${source} registry from ${filePath}: ${error.message}`);
        }
      }
      /**
       * 创建空的注册表数据
       * @param {string} source - 注册表来源
       * @param {string} filePath - 注册表文件路径
       * @returns {RegistryData} 空注册表数据实例
       */
      static createEmpty(source, filePath) {
        return new _RegistryData(source, filePath, [], {
          description: `${source} \u7EA7\u8D44\u6E90\u6CE8\u518C\u8868`,
          createdAt: (/* @__PURE__ */ new Date()).toISOString()
        });
      }
      /**
       * 添加资源
       * @param {ResourceData|Object} resource - 资源数据
       */
      addResource(resource2) {
        const resourceData = resource2 instanceof ResourceData ? resource2 : ResourceData.fromRawData(resource2);
        if (this.source !== "merged" && resourceData.source !== this.source) {
          resourceData.source = this.source;
        }
        const existingIndex = this.resources.findIndex((r) => r.id === resourceData.id && r.protocol === resourceData.protocol);
        if (existingIndex >= 0) {
          this.resources[existingIndex] = resourceData;
        } else {
          this.resources.push(resourceData);
        }
        this._updateMetadata();
        this.cache.clear();
      }
      /**
       * 移除资源
       * @param {string} id - 资源ID
       * @param {string} protocol - 资源协议
       * @returns {boolean} 是否成功移除
       */
      removeResource(id, protocol) {
        const initialLength = this.resources.length;
        this.resources = this.resources.filter((r) => !(r.id === id && r.protocol === protocol));
        const removed = this.resources.length < initialLength;
        if (removed) {
          this._updateMetadata();
          this.cache.clear();
        }
        return removed;
      }
      /**
       * 查找资源
       * @param {Object} filters - 过滤条件
       * @returns {Array<ResourceData>} 匹配的资源数组
       */
      findResources(filters = {}) {
        return this.resources.filter((resource2) => resource2.matches(filters));
      }
      /**
       * 根据ID查找资源
       * @param {string} id - 资源ID
       * @param {string} protocol - 资源协议（可选）
       * @returns {ResourceData|null} 找到的资源
       */
      findResourceById(id, protocol = null) {
        return this.resources.find((r) => {
          if (protocol) {
            return r.id === id && r.protocol === protocol;
          }
          return r.id === id;
        }) || null;
      }
      /**
       * 获取指定协议类型的所有资源
       * @param {string} protocol - 资源协议
       * @returns {Array<ResourceData>} 资源数组
       */
      getResourcesByProtocol(protocol) {
        return this.resources.filter((r) => r.protocol === protocol);
      }
      /**
       * 获取资源Map（兼容旧接口）
       * @param {boolean} includeSourcePrefix - 是否包含源前缀
       * @returns {Map<string, string>} 资源ID到引用的映射
       */
      getResourceMap(includeSourcePrefix = true) {
        const cacheKey = `resourceMap_${includeSourcePrefix}`;
        if (this.cache.has(cacheKey)) {
          return this.cache.get(cacheKey);
        }
        const registry = /* @__PURE__ */ new Map();
        for (const resource2 of this.resources) {
          if (includeSourcePrefix) {
            registry.set(resource2.getFullId(), resource2.reference);
            registry.set(resource2.getBaseId(), resource2.reference);
          } else {
            registry.set(resource2.getBaseId(), resource2.reference);
          }
        }
        this.cache.set(cacheKey, registry);
        return registry;
      }
      /**
       * 获取所有资源数据
       * @returns {Array<ResourceData>} 所有资源数组
       */
      getAllResources() {
        return [...this.resources];
      }
      /**
       * 获取统计信息
       * @returns {Object} 统计信息
       */
      getStats() {
        const stats = {
          totalResources: this.resources.length,
          byProtocol: {},
          bySource: {}
        };
        for (const resource2 of this.resources) {
          stats.byProtocol[resource2.protocol] = (stats.byProtocol[resource2.protocol] || 0) + 1;
          stats.bySource[resource2.source] = (stats.bySource[resource2.source] || 0) + 1;
        }
        return stats;
      }
      /**
       * 合并其他注册表数据
       * @param {RegistryData} otherRegistry - 其他注册表数据
       * @param {boolean} overwrite - 是否覆盖现有资源
       */
      merge(otherRegistry, overwrite = false) {
        for (const resource2 of otherRegistry.resources) {
          const existing = this.findResourceById(resource2.id, resource2.protocol);
          if (!existing || overwrite) {
            this.addResource(resource2.clone());
          }
        }
      }
      /**
       * 保存注册表到文件
       * @returns {Promise<void>}
       */
      async save() {
        try {
          await fs.ensureDir(path.dirname(this.filePath));
          this._updateMetadata();
          const saveData = {
            version: this.metadata.version,
            source: this.source,
            metadata: this.metadata,
            resources: this.resources.map((r) => r.toJSON()),
            stats: this.getStats()
          };
          await fs.writeJSON(this.filePath, saveData, { spaces: 2 });
        } catch (error) {
          throw new Error(`Failed to save ${this.source} registry to ${this.filePath}: ${error.message}`);
        }
      }
      /**
       * 更新元数据
       * @private
       */
      _updateMetadata() {
        this.metadata.updatedAt = (/* @__PURE__ */ new Date()).toISOString();
        this.metadata.resourceCount = this.resources.length;
      }
      /**
       * 获取注册表大小
       * @returns {number} 资源数量
       */
      get size() {
        return this.resources.length;
      }
      /**
       * 检查注册表是否为空
       * @returns {boolean} 是否为空
       */
      isEmpty() {
        return this.resources.length === 0;
      }
      /**
       * 清空所有资源
       */
      clear() {
        this.resources = [];
        this._updateMetadata();
        this.cache.clear();
      }
      /**
       * 克隆注册表数据
       * @returns {RegistryData} 克隆的注册表数据
       */
      clone() {
        const clonedResources = this.resources.map((r) => r.clone());
        return new _RegistryData(this.source, this.filePath, clonedResources, { ...this.metadata });
      }
      /**
       * 转换为JSON对象
       * @returns {Object} JSON对象
       */
      toJSON() {
        return {
          version: this.metadata.version,
          source: this.source,
          metadata: this.metadata,
          resources: this.resources.map((r) => r.toJSON()),
          stats: this.getStats()
        };
      }
    };
    module2.exports = RegistryData;
  }
});

// src/resource/types.js
var require_types = __commonJS({
  "src/resource/types.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var LoadingSemantics = {
      DEFAULT: "default",
      // @ - AI自行决定加载时机
      HOT_LOAD: "hot_load",
      // @! - 立即加载
      LAZY_LOAD: "lazy_load"
      // @? - 懒加载
    };
    var ParsedReference = class {
      constructor() {
        this.loadingSemantics = LoadingSemantics.DEFAULT;
        this.protocol = "";
        this.path = "";
        this.queryParams = new QueryParams();
        this.isNested = false;
        this.nestedRef = null;
        this.originalRef = "";
      }
    };
    var QueryParams = class {
      constructor() {
        this.line = null;
        this.format = null;
        this.cache = null;
        this.params = /* @__PURE__ */ new Map();
      }
      /**
       * 设置参数
       */
      set(key, value) {
        if (["line", "format", "cache"].includes(key)) {
          this[key] = value;
        } else {
          this.params.set(key, value);
        }
      }
      /**
       * 获取参数
       */
      get(key) {
        if (["line", "format", "cache"].includes(key)) {
          return this[key];
        }
        return this.params.get(key);
      }
      /**
       * 获取所有参数
       */
      getAll() {
        const result = {};
        if (this.line !== null) {
          result.line = this.line;
        }
        if (this.format !== null) {
          result.format = this.format;
        }
        if (this.cache !== null) {
          result.cache = this.cache;
        }
        for (const [key, value] of this.params) {
          result[key] = value;
        }
        return result;
      }
      /**
       * 转换为字符串用于缓存键
       */
      toString() {
        const params = [];
        if (this.line !== null) {
          params.push(`line=${this.line}`);
        }
        if (this.format !== null) {
          params.push(`format=${this.format}`);
        }
        if (this.cache !== null) {
          params.push(`cache=${this.cache}`);
        }
        const sortedParams = Array.from(this.params.entries()).sort();
        for (const [key, value] of sortedParams) {
          params.push(`${key}=${value}`);
        }
        return params.join("&");
      }
    };
    var NestedReference = class {
      constructor() {
        this.outer = null;
        this.inner = null;
        this.depth = 0;
      }
    };
    var ResourceContent = class {
      constructor(path, content, metadata = {}) {
        this.path = path;
        this.content = content;
        this.metadata = metadata;
        this.relativePath = "";
        this.lastModified = null;
        this.size = content ? content.length : 0;
      }
    };
    var LazyResource = class {
      constructor(path, loader) {
        this.path = path;
        this.loader = loader;
        this.loaded = false;
        this._content = null;
      }
      /**
       * 加载资源
       */
      async load() {
        if (!this.loaded) {
          this._content = await this.loader(this.path);
          this.loaded = true;
        }
        return this._content;
      }
    };
    var ProcessedResult = class {
      constructor() {
        this.content = "";
        this.metadata = {};
        this.format = "text";
        this.sources = [];
        this.cached = false;
      }
    };
    var ResourceResult = class _ResourceResult {
      constructor() {
        this.content = "";
        this.metadata = {};
        this.sources = [];
        this.format = "text";
        this.cached = false;
        this.loadTime = Date.now();
        this.success = true;
        this.error = null;
      }
      /**
       * 创建成功结果
       */
      static success(content, metadata = {}) {
        const result = new _ResourceResult();
        result.content = content;
        result.metadata = metadata;
        result.success = true;
        return result;
      }
      /**
       * 创建错误结果
       */
      static error(error, metadata = {}) {
        const result = new _ResourceResult();
        result.success = false;
        result.error = error;
        result.metadata = metadata;
        return result;
      }
    };
    var ProtocolInfo = class {
      constructor() {
        this.name = "";
        this.description = "";
        this.location = "";
        this.params = {};
        this.registry = /* @__PURE__ */ new Map();
      }
    };
    module2.exports = {
      LoadingSemantics,
      ParsedReference,
      QueryParams,
      NestedReference,
      ResourceContent,
      LazyResource,
      ProcessedResult,
      ResourceResult,
      ProtocolInfo
    };
  }
});

// src/resource/resourceProtocolParser.js
var require_resourceProtocolParser = __commonJS({
  "src/resource/resourceProtocolParser.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var {
      LoadingSemantics,
      ParsedReference,
      QueryParams,
      NestedReference
    } = require_types();
    var ResourceProtocolParser = class {
      constructor() {
        this.resourceRefRegex = /^(@[!?]?|@)([a-zA-Z][a-zA-Z0-9_-]*):(.+)$/;
        this.nestedRefRegex = /^(@[!?]?|@)([a-zA-Z][a-zA-Z0-9_-]*):(@[!?]?|@)?(.+)$/;
        this.queryParamsRegex = /^([^?]+)(?:\?(.+))?$/;
      }
      /**
       * 解析资源引用
       * @param {string} resourceRef - 资源引用字符串
       * @returns {ParsedReference} 解析后的引用对象
       */
      parse(resourceRef) {
        if (!resourceRef || typeof resourceRef !== "string") {
          throw new Error("Invalid resource reference: must be a non-empty string");
        }
        const trimmedRef = resourceRef.trim();
        if (!this.validateSyntax(trimmedRef)) {
          throw new Error(`Invalid resource reference syntax: ${trimmedRef}`);
        }
        const parsed = new ParsedReference();
        parsed.originalRef = trimmedRef;
        if (this.isNestedReference(trimmedRef)) {
          return this.parseNestedReference(trimmedRef);
        }
        return this.parseBasicReference(trimmedRef);
      }
      /**
       * 解析基础资源引用
       * @param {string} ref - 基础引用
       * @returns {ParsedReference}
       */
      parseBasicReference(ref) {
        const parsed = new ParsedReference();
        parsed.originalRef = ref;
        parsed.loadingSemantics = this.parseLoadingSemantics(ref);
        const withoutSemantics = this.removeLoadingSemantics(ref);
        const match = withoutSemantics.match(/^([a-zA-Z][a-zA-Z0-9_-]*):(.+)$/);
        if (!match) {
          throw new Error(`Invalid protocol format: ${ref}`);
        }
        parsed.protocol = match[1];
        let pathAndParams = match[2];
        if (pathAndParams.startsWith("//")) {
          pathAndParams = pathAndParams.substring(2);
        }
        const pathMatch = pathAndParams.match(this.queryParamsRegex);
        if (pathMatch) {
          parsed.path = pathMatch[1];
          if (pathMatch[2]) {
            parsed.queryParams = this.parseQueryParams(pathMatch[2]);
          }
        } else {
          parsed.path = pathAndParams;
        }
        return parsed;
      }
      /**
       * 解析嵌套引用
       * @param {string} ref - 嵌套引用
       * @returns {ParsedReference}
       */
      parseNestedReference(ref) {
        const parsed = new ParsedReference();
        parsed.originalRef = ref;
        parsed.isNested = true;
        parsed.loadingSemantics = this.parseLoadingSemantics(ref);
        const withoutOuterSemantics = this.removeLoadingSemantics(ref);
        const match = withoutOuterSemantics.match(/^([a-zA-Z][a-zA-Z0-9_-]*):(.+)$/);
        if (!match) {
          throw new Error(`Invalid nested reference format: ${ref}`);
        }
        parsed.protocol = match[1];
        let innerRef = match[2];
        if (innerRef.startsWith("//")) {
          innerRef = innerRef.substring(2);
        }
        if (!innerRef.startsWith("@")) {
          innerRef = "@" + innerRef;
        }
        try {
          const innerParsed = this.parse(innerRef);
          const nested = new NestedReference();
          nested.outer = parsed;
          nested.inner = innerParsed;
          nested.depth = this.calculateNestingDepth(innerParsed);
          parsed.nestedRef = nested;
        } catch (error) {
          throw new Error(`Invalid nested inner reference: ${error.message}`);
        }
        return parsed;
      }
      /**
       * 解析加载语义
       * @param {string} ref - 资源引用
       * @returns {string} 加载语义
       */
      parseLoadingSemantics(ref) {
        if (ref.startsWith("@!")) {
          return LoadingSemantics.HOT_LOAD;
        } else if (ref.startsWith("@?")) {
          return LoadingSemantics.LAZY_LOAD;
        } else if (ref.startsWith("@")) {
          return LoadingSemantics.DEFAULT;
        }
        throw new Error(`Invalid loading semantics: ${ref}`);
      }
      /**
       * 移除加载语义前缀
       * @param {string} ref - 资源引用
       * @returns {string} 移除前缀后的引用
       */
      removeLoadingSemantics(ref) {
        if (ref.startsWith("@!") || ref.startsWith("@?")) {
          return ref.substring(2);
        } else if (ref.startsWith("@")) {
          return ref.substring(1);
        }
        return ref;
      }
      /**
       * 解析查询参数
       * @param {string} queryString - 查询字符串
       * @returns {QueryParams} 查询参数对象
       */
      parseQueryParams(queryString) {
        const params = new QueryParams();
        if (!queryString) {
          return params;
        }
        const pairs = queryString.split("&");
        for (const pair of pairs) {
          const [key, value] = pair.split("=").map(decodeURIComponent);
          if (key) {
            if (key === "cache") {
              params.set(key, value === "true" || value === "1");
            } else {
              params.set(key, value || "");
            }
          }
        }
        return params;
      }
      /**
       * 验证语法
       * @param {string} ref - 资源引用
       * @returns {boolean} 是否有效
       */
      validateSyntax(ref) {
        if (!ref) return false;
        if (!ref.startsWith("@")) return false;
        const withoutSemantics = this.removeLoadingSemantics(ref);
        return /^[a-zA-Z][a-zA-Z0-9_-]*:.+$/.test(withoutSemantics);
      }
      /**
       * 检查是否为嵌套引用
       * @param {string} ref - 资源引用
       * @returns {boolean} 是否为嵌套引用
       */
      isNestedReference(ref) {
        const withoutSemantics = this.removeLoadingSemantics(ref);
        const colonIndex = withoutSemantics.indexOf(":");
        if (colonIndex === -1) return false;
        const afterColon = withoutSemantics.substring(colonIndex + 1);
        return afterColon.includes("@") || afterColon.includes("://");
      }
      /**
       * 计算嵌套深度
       * @param {ParsedReference} ref - 解析后的引用
       * @returns {number} 嵌套深度
       */
      calculateNestingDepth(ref) {
        if (!ref.isNested) return 1;
        return 1 + this.calculateNestingDepth(ref.nestedRef.inner);
      }
      /**
       * 提取协议名
       * @param {string} ref - 资源引用
       * @returns {string} 协议名
       */
      extractProtocol(ref) {
        const withoutSemantics = this.removeLoadingSemantics(ref);
        const colonIndex = withoutSemantics.indexOf(":");
        return colonIndex > 0 ? withoutSemantics.substring(0, colonIndex) : "";
      }
      /**
       * 提取路径
       * @param {string} ref - 资源引用
       * @returns {string} 路径
       */
      extractPath(ref) {
        const withoutSemantics = this.removeLoadingSemantics(ref);
        const colonIndex = withoutSemantics.indexOf(":");
        if (colonIndex === -1) return "";
        let pathAndParams = withoutSemantics.substring(colonIndex + 1);
        if (pathAndParams.startsWith("//")) {
          pathAndParams = pathAndParams.substring(2);
        }
        const queryIndex = pathAndParams.indexOf("?");
        return queryIndex > 0 ? pathAndParams.substring(0, queryIndex) : pathAndParams;
      }
      /**
       * 提取查询参数字符串
       * @param {string} ref - 资源引用
       * @returns {string} 查询参数字符串
       */
      extractParams(ref) {
        const queryIndex = ref.indexOf("?");
        return queryIndex > 0 ? ref.substring(queryIndex + 1) : "";
      }
    };
    module2.exports = ResourceProtocolParser;
  }
});

// src/resource/discovery/BaseDiscovery.js
var require_BaseDiscovery = __commonJS({
  "src/resource/discovery/BaseDiscovery.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var BaseDiscovery = class {
      /**
       * 构造函数
       * @param {string} source - 发现源类型 (PACKAGE, PROJECT, USER, INTERNET)
       * @param {number} priority - 优先级，数字越小优先级越高
       */
      constructor(source, priority = 0) {
        if (!source) {
          throw new Error("Discovery source is required");
        }
        this.source = source;
        this.priority = priority;
        this.cache = /* @__PURE__ */ new Map();
      }
      /**
       * 抽象方法：发现资源
       * 子类必须实现此方法
       * @returns {Promise<Array>} 发现的资源列表
       */
      async discover() {
        throw new Error("discover method must be implemented by subclass");
      }
      /**
       * 获取发现器信息
       * @returns {Object} 发现器元数据
       */
      getDiscoveryInfo() {
        return {
          source: this.source,
          priority: this.priority,
          description: `${this.source} resource discovery`
        };
      }
      /**
       * 验证资源结构
       * @param {Object} resource - 待验证的资源对象
       * @throws {Error} 如果资源结构无效
       */
      validateResource(resource2) {
        if (!resource2 || typeof resource2 !== "object") {
          throw new Error("Resource must be an object");
        }
        if (!resource2.id || !resource2.reference) {
          throw new Error("Resource must have id and reference");
        }
        if (typeof resource2.id !== "string" || !resource2.id.includes(":")) {
          throw new Error('Resource id must be in format "protocol:resourcePath"');
        }
        if (typeof resource2.reference !== "string" || !resource2.reference.startsWith("@")) {
          throw new Error('Resource reference must be in DPML format "@protocol://path"');
        }
      }
      /**
       * 规范化资源对象，添加元数据
       * @param {Object} resource - 原始资源对象
       * @returns {Object} 规范化后的资源对象
       */
      normalizeResource(resource2) {
        this.validateResource(resource2);
        const normalizedResource = {
          id: resource2.id,
          reference: resource2.reference,
          metadata: {
            source: this.source,
            priority: this.priority,
            timestamp: /* @__PURE__ */ new Date(),
            ...resource2.metadata
            // 保留现有元数据
          }
        };
        return normalizedResource;
      }
      /**
       * 清理缓存
       */
      clearCache() {
        this.cache.clear();
      }
      /**
       * 获取缓存大小
       * @returns {number} 缓存条目数量
       */
      getCacheSize() {
        return this.cache.size;
      }
      /**
       * 从缓存获取资源
       * @param {string} key - 缓存键
       * @returns {*} 缓存的值或undefined
       */
      getFromCache(key) {
        return this.cache.get(key);
      }
      /**
       * 设置缓存
       * @param {string} key - 缓存键
       * @param {*} value - 缓存值
       */
      setCache(key, value) {
        this.cache.set(key, value);
      }
    };
    module2.exports = BaseDiscovery;
  }
});

// src/resource/discovery/PackageDiscovery.js
var require_PackageDiscovery = __commonJS({
  "src/resource/discovery/PackageDiscovery.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var BaseDiscovery = require_BaseDiscovery();
    var logger = require("@promptx/logger");
    var PackageDiscovery = class extends BaseDiscovery {
      constructor(resourceManager) {
        super("PACKAGE");
        this.resourceManager = resourceManager;
      }
      /**
       * 发现包级资源 - 从 @promptx/resource 包加载
       * @returns {Promise<Array>} 发现的资源列表
       */
      async discover() {
        var _a, _b, _c;
        try {
          const { registry } = require("@promptx/resource");
          if (!registry) {
            logger.warn("[PackageDiscovery] @promptx/resource \u6CE8\u518C\u8868\u672A\u6B63\u786E\u52A0\u8F7D");
            return [];
          }
          const resources = [];
          if (Array.isArray(registry.resources)) {
            for (const resource2 of registry.resources) {
              resources.push({
                id: resource2.id,
                type: resource2.protocol,
                // 使用 protocol 字段
                path: ((_a = resource2.metadata) == null ? void 0 : _a.path) || resource2.reference,
                name: resource2.name || resource2.id,
                metadata: {
                  description: resource2.description,
                  modified: (_b = resource2.metadata) == null ? void 0 : _b.modified,
                  size: (_c = resource2.metadata) == null ? void 0 : _c.size,
                  source: "package",
                  // 小写以保持一致
                  packageName: "@promptx/resource"
                }
              });
            }
          }
          logger.info(`[PackageDiscovery] \u2705 \u4ECE @promptx/resource \u52A0\u8F7D\u4E86 ${resources.length} \u4E2A\u7CFB\u7EDF\u8D44\u6E90`);
          return resources;
        } catch (error) {
          logger.warn(`[PackageDiscovery] \u26A0\uFE0F \u52A0\u8F7D @promptx/resource \u5931\u8D25: ${error.message}`);
          return [];
        }
      }
      /**
       * 发现包级资源注册表
       * @returns {Promise<Map>} 资源注册表 Map<resourceId, reference>
       */
      async discoverRegistry() {
        var _a;
        try {
          const { registry } = require("@promptx/resource");
          if (!registry) {
            logger.warn("[PackageDiscovery] @promptx/resource \u6CE8\u518C\u8868\u672A\u6B63\u786E\u52A0\u8F7D");
            return /* @__PURE__ */ new Map();
          }
          const registryMap = /* @__PURE__ */ new Map();
          if (Array.isArray(registry.resources)) {
            for (const resource2 of registry.resources) {
              const reference = resource2.reference || `@package://resources/${(_a = resource2.metadata) == null ? void 0 : _a.path}`;
              registryMap.set(resource2.id, reference);
              registryMap.set(`package:${resource2.id}`, reference);
            }
          }
          if (registryMap.size > 0) {
            logger.info(`[PackageDiscovery] \u2705 \u4ECE @promptx/resource \u52A0\u8F7D\u4E86 ${registryMap.size / 2} \u4E2A\u7CFB\u7EDF\u8D44\u6E90\u5230\u6CE8\u518C\u8868`);
          }
          return registryMap;
        } catch (error) {
          logger.warn(`[PackageDiscovery] \u26A0\uFE0F \u7CFB\u7EDF\u8D44\u6E90\u6CE8\u518C\u8868\u52A0\u8F7D\u5931\u8D25: ${error.message}`);
          return /* @__PURE__ */ new Map();
        }
      }
      /**
       * 获取包资源的基础目录（用于文件访问）
       * @returns {Promise<string>} 包资源目录路径
       */
      async getPackageRoot() {
        try {
          const resourcePackagePath = require.resolve("@promptx/resource");
          const path = require("path");
          let currentDir = path.dirname(resourcePackagePath);
          while (currentDir !== path.dirname(currentDir)) {
            const packageJsonPath = path.join(currentDir, "package.json");
            try {
              const packageJson = require(packageJsonPath);
              if (packageJson.name === "@promptx/resource") {
                return currentDir;
              }
            } catch {
            }
            currentDir = path.dirname(currentDir);
          }
          throw new Error("\u65E0\u6CD5\u627E\u5230 @promptx/resource \u5305\u7684\u6839\u76EE\u5F55");
        } catch (error) {
          logger.error(`[PackageDiscovery] \u274C \u83B7\u53D6\u5305\u6839\u76EE\u5F55\u5931\u8D25: ${error.message}`);
          throw error;
        }
      }
      /**
       * 获取注册表数据（ResourceManager 需要的方法）
       * @returns {Promise<RegistryData>} 注册表数据实例
       */
      async getRegistryData() {
        var _a;
        try {
          logger.info("[PackageDiscovery] Starting getRegistryData...");
          const { registry } = require("@promptx/resource");
          logger.info("[PackageDiscovery] @promptx/resource loaded successfully");
          const RegistryData = require_RegistryData();
          const ResourceData = require_ResourceData();
          if (!registry) {
            logger.warn("[PackageDiscovery] Registry is empty");
            return new RegistryData("package", "", []);
          }
          logger.info(`[PackageDiscovery] Registry loaded with ${((_a = registry.resources) == null ? void 0 : _a.length) || 0} resources`);
          const resources = [];
          if (Array.isArray(registry.resources)) {
            for (const resource2 of registry.resources) {
              resources.push(new ResourceData({
                id: resource2.id,
                source: "package",
                // 使用小写保持一致
                protocol: resource2.protocol,
                // 直接使用资源的 protocol 字段
                name: resource2.name || resource2.id,
                description: resource2.description || "",
                reference: resource2.reference,
                metadata: resource2.metadata || {}
              }));
            }
          }
          logger.info(`[PackageDiscovery] Successfully created ${resources.length} ResourceData objects`);
          return new RegistryData("package", "@promptx/resource", resources);
        } catch (error) {
          logger.error(`[PackageDiscovery] Error in getRegistryData: ${error.message}`);
          logger.error(`[PackageDiscovery] Stack trace: ${error.stack}`);
          logger.warn(`[PackageDiscovery] \u83B7\u53D6\u6CE8\u518C\u8868\u6570\u636E\u5931\u8D25: ${error.message}`);
          const RegistryData = require_RegistryData();
          return new RegistryData("package", "", []);
        }
      }
      /**
       * 获取环境信息（用于调试）
       */
      getEnvironmentInfo() {
        return {
          type: "PackageDiscovery",
          source: "@promptx/resource",
          loaded: this._tryRequirePackage() !== null
        };
      }
      /**
       * 尝试加载包（内部辅助方法）
       */
      _tryRequirePackage() {
        try {
          const { registry } = require("@promptx/resource");
          return registry ? { registry } : null;
        } catch {
          return null;
        }
      }
    };
    module2.exports = PackageDiscovery;
  }
});

// src/resource/discovery/ProjectDiscovery.js
var require_ProjectDiscovery = __commonJS({
  "src/resource/discovery/ProjectDiscovery.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var logger = require("@promptx/logger");
    var RegistryData = require_RegistryData();
    var ResourceData = require_ResourceData();
    var fs = require("fs-extra");
    var path = require("path");
    var ProjectDiscovery = class {
      constructor() {
        this.source = "PROJECT";
        this.priority = 2;
        this.projectProtocol = null;
      }
      /**
       * 获取ProjectProtocol实例
       */
      getProjectProtocol() {
        if (!this.projectProtocol) {
          const { getGlobalResourceManager } = require_resource();
          const resourceManager = getGlobalResourceManager();
          this.projectProtocol = resourceManager.protocols.get("project");
        }
        return this.projectProtocol;
      }
      /**
       * 发现项目级资源注册表
       * @returns {Promise<Map>} 资源注册表 Map<resourceId, reference>
       */
      async discoverRegistry() {
        try {
          const registryMap = await this.loadFromRegistry();
          if (registryMap.size > 0) {
            logger.debug(`ProjectDiscovery \u4ECE\u6CE8\u518C\u8868\u52A0\u8F7D ${registryMap.size} \u4E2A\u8D44\u6E90`);
            return registryMap;
          }
          logger.debug("ProjectDiscovery \u6CE8\u518C\u8868\u4E0D\u5B58\u5728\uFF0C\u4F7F\u7528\u52A8\u6001\u626B\u63CF");
          const resources = await this.scanProjectResources();
          return this.buildRegistryFromResources(resources);
        } catch (error) {
          logger.warn(`[ProjectDiscovery] Registry discovery failed: ${error.message}`);
          return /* @__PURE__ */ new Map();
        }
      }
      /**
       * 从注册表文件加载资源
       * @returns {Promise<Map>} 资源注册表
       */
      async loadFromRegistry() {
        try {
          const protocol = this.getProjectProtocol();
          const registryPath = await protocol.resolvePath(".promptx/resource/project.registry.json");
          if (!await fs.pathExists(registryPath)) {
            return /* @__PURE__ */ new Map();
          }
          const registryData = await RegistryData.fromFile("project", registryPath);
          return registryData.getResourceMap(true);
        } catch (error) {
          logger.warn(`[ProjectDiscovery] Failed to load registry: ${error.message}`);
          return /* @__PURE__ */ new Map();
        }
      }
      /**
       * 动态扫描项目资源 - 恢复重构前的专业扫描逻辑
       * @returns {Promise<Array>} 资源列表
       */
      async scanProjectResources() {
        try {
          const protocol = this.getProjectProtocol();
          const resourceDir = await protocol.resolvePath(".promptx/resource");
          if (!await fs.pathExists(resourceDir)) {
            logger.debug("ProjectDiscovery \u9879\u76EE\u8D44\u6E90\u76EE\u5F55\u4E0D\u5B58\u5728");
            return [];
          }
          const tempRegistry = RegistryData.createEmpty("project", null);
          await this._scanDirectory(resourceDir, tempRegistry);
          const resources = [];
          for (const resource2 of tempRegistry.resources) {
            resources.push({
              id: resource2.id,
              protocol: resource2.protocol,
              reference: resource2.reference,
              source: resource2.source
            });
          }
          logger.info(`[ProjectDiscovery] \u2705 \u9879\u76EE\u626B\u63CF\u5B8C\u6210\uFF0C\u53D1\u73B0 ${resources.length} \u4E2A\u8D44\u6E90`);
          return resources;
        } catch (error) {
          logger.warn(`[ProjectDiscovery] \u626B\u63CF\u9879\u76EE\u8D44\u6E90\u5931\u8D25: ${error.message}`);
          return [];
        }
      }
      /**
       * 扫描目录并添加资源到注册表（通用递归扫描）
       * @param {string} resourcesDir - 资源目录
       * @param {RegistryData} registryData - 注册表数据
       * @private
       */
      async _scanDirectory(resourcesDir, registryData) {
        try {
          await this._recursiveScan(resourcesDir, "", registryData);
        } catch (error) {
          logger.warn(`[ProjectDiscovery] \u626B\u63CF\u8D44\u6E90\u76EE\u5F55\u5931\u8D25: ${error.message}`);
        }
      }
      /**
       * 递归扫描目录
       * @param {string} currentPath - 当前扫描路径
       * @param {string} relativePath - 相对于resource目录的路径
       * @param {RegistryData} registryData - 注册表数据
       * @private
       */
      async _recursiveScan(currentPath, relativePath, registryData) {
        try {
          const items = await fs.readdir(currentPath);
          for (const item of items) {
            const itemPath = path.join(currentPath, item);
            const stat = await fs.stat(itemPath);
            const newRelativePath = relativePath ? `${relativePath}/${item}` : item;
            if (stat.isDirectory()) {
              await this._recursiveScan(itemPath, newRelativePath, registryData);
            } else {
              await this._processFile(itemPath, newRelativePath, registryData);
            }
          }
        } catch (error) {
          logger.warn(`[ProjectDiscovery] \u626B\u63CF${currentPath}\u5931\u8D25: ${error.message}`);
        }
      }
      /**
       * 处理单个文件
       * @param {string} filePath - 文件完整路径
       * @param {string} relativePath - 相对路径
       * @param {RegistryData} registryData - 注册表数据
       * @private
       */
      async _processFile(filePath, relativePath, registryData) {
        const fileName = path.basename(filePath);
        let protocol = null;
        let resourceId = null;
        if (fileName.endsWith(".role.md")) {
          protocol = "role";
          resourceId = path.basename(fileName, ".role.md");
        } else if (fileName.endsWith(".thought.md")) {
          protocol = "thought";
          resourceId = path.basename(fileName, ".thought.md");
        } else if (fileName.endsWith(".execution.md")) {
          protocol = "execution";
          resourceId = path.basename(fileName, ".execution.md");
        } else if (fileName.endsWith(".knowledge.md")) {
          protocol = "knowledge";
          resourceId = path.basename(fileName, ".knowledge.md");
        } else if (fileName.endsWith(".tool.js")) {
          protocol = "tool";
          resourceId = path.basename(fileName, ".tool.js");
        } else if (fileName.endsWith(".manual.md")) {
          protocol = "manual";
          resourceId = path.basename(fileName, ".manual.md");
        }
        if (protocol && resourceId) {
          if (await this._validateResourceFile(filePath, protocol)) {
            const reference = `@project://.promptx/resource/${relativePath}`;
            const resourceData = new ResourceData({
              id: resourceId,
              source: "project",
              protocol,
              name: ResourceData._generateDefaultName(resourceId, protocol),
              description: ResourceData._generateDefaultDescription(resourceId, protocol),
              reference,
              metadata: {
                scannedAt: (/* @__PURE__ */ new Date()).toISOString(),
                path: relativePath
              }
            });
            registryData.addResource(resourceData);
            logger.debug(`[ProjectDiscovery] \u53D1\u73B0${protocol}\u8D44\u6E90: ${resourceId} at ${relativePath}`);
          }
        }
      }
      /**
       * 验证资源文件格式（恢复重构前逻辑）
       * @param {string} filePath - 文件路径
       * @param {string} protocol - 协议类型
       * @returns {Promise<boolean>} 是否是有效的资源文件
       */
      async _validateResourceFile(filePath, protocol) {
        try {
          const content = await fs.readFile(filePath, "utf8");
          if (!content || typeof content !== "string") {
            return false;
          }
          const trimmedContent = content.trim();
          if (trimmedContent.length === 0) {
            return false;
          }
          switch (protocol) {
            case "role":
              return trimmedContent.includes("<role>") && trimmedContent.includes("</role>");
            case "execution":
              return trimmedContent.includes("<execution>") && trimmedContent.includes("</execution>");
            case "thought":
              return trimmedContent.includes("<thought>") && trimmedContent.includes("</thought>");
            case "knowledge":
              return true;
            case "manual":
              return trimmedContent.includes("<manual>") && trimmedContent.includes("</manual>");
            case "tool":
              try {
                new Function(trimmedContent);
                return true;
              } catch (e) {
                logger.warn(`[ProjectDiscovery] Invalid JavaScript in tool file ${filePath}: ${e.message}`);
                return false;
              }
            default:
              return false;
          }
        } catch (error) {
          logger.warn(`[ProjectDiscovery] Failed to validate ${filePath}: ${error.message}`);
          return false;
        }
      }
      /**
       * 从资源列表构建注册表Map
       * @param {Array} resources - 资源列表
       * @returns {Map} 资源注册表
       */
      buildRegistryFromResources(resources) {
        const registryMap = /* @__PURE__ */ new Map();
        resources.forEach((resource2) => {
          const key = `project:${resource2.id}`;
          registryMap.set(key, resource2.reference);
        });
        return registryMap;
      }
      /**
       * 生成并保存项目注册表文件
       * @returns {Promise<RegistryData>} 生成的注册表数据
       */
      async generateRegistry() {
        try {
          const protocol = this.getProjectProtocol();
          const registryPath = await protocol.resolvePath(".promptx/resource/project.registry.json");
          const registryData = RegistryData.createEmpty("project", registryPath);
          const resourceDir = await protocol.resolvePath(".promptx/resource");
          if (await fs.pathExists(resourceDir)) {
            await this._scanDirectory(resourceDir, registryData);
          }
          await fs.ensureDir(path.dirname(registryPath));
          await registryData.save();
          logger.info(`[ProjectDiscovery] \u2705 \u9879\u76EE\u6CE8\u518C\u8868\u751F\u6210\u5B8C\u6210\uFF0C\u53D1\u73B0 ${registryData.size} \u4E2A\u8D44\u6E90`);
          return registryData;
        } catch (error) {
          logger.error(`[ProjectDiscovery] \u751F\u6210\u6CE8\u518C\u8868\u5931\u8D25: ${error.message}`);
          return RegistryData.createEmpty("project");
        }
      }
      /**
       * 获取注册表数据（兼容旧接口）
       * @returns {Promise<RegistryData>} 注册表数据
       */
      async getRegistryData() {
        try {
          const protocol = this.getProjectProtocol();
          const registryPath = await protocol.resolvePath(".promptx/resource/project.registry.json");
          if (await fs.pathExists(registryPath)) {
            const registryData = await RegistryData.fromFile("project", registryPath);
            if (registryData.size > 0) {
              logger.info(`[ProjectDiscovery] \u{1F4CB} \u4ECE\u6CE8\u518C\u8868\u52A0\u8F7D ${registryData.size} \u4E2A\u8D44\u6E90`);
              return registryData;
            }
          }
          logger.info(`[ProjectDiscovery] \u{1F4CB} \u9879\u76EE\u6CE8\u518C\u8868\u65E0\u6548\uFF0C\u91CD\u65B0\u751F\u6210`);
          return await this.generateRegistry();
        } catch (error) {
          logger.error(`[ProjectDiscovery] \u83B7\u53D6\u6CE8\u518C\u8868\u6570\u636E\u5931\u8D25: ${error.message}`);
          return RegistryData.createEmpty("project");
        }
      }
    };
    module2.exports = ProjectDiscovery;
  }
});

// src/resource/discovery/UserDiscovery.js
var require_UserDiscovery = __commonJS({
  "src/resource/discovery/UserDiscovery.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var BaseDiscovery = require_BaseDiscovery();
    var logger = require("@promptx/logger");
    var RegistryData = require_RegistryData();
    var ResourceData = require_ResourceData();
    var fs = require("fs-extra");
    var path = require("path");
    var UserDiscovery = class extends BaseDiscovery {
      constructor() {
        super("USER", 3);
        this.userProtocol = null;
      }
      /**
       * 获取 UserProtocol 实例
       */
      getUserProtocol() {
        if (!this.userProtocol) {
          const { getGlobalResourceManager } = require_resource();
          const resourceManager = getGlobalResourceManager();
          this.userProtocol = resourceManager.protocols.get("user");
        }
        return this.userProtocol;
      }
      /**
       * 发现 User 级资源注册表
       * @returns {Promise<Map>} 资源注册表 Map<resourceId, reference>
       */
      async discoverRegistry() {
        try {
          const registryMap = await this.loadFromRegistry();
          if (registryMap.size > 0) {
            logger.debug(`UserDiscovery \u4ECE\u6CE8\u518C\u8868\u52A0\u8F7D ${registryMap.size} \u4E2A\u8D44\u6E90`);
            return registryMap;
          }
          logger.debug("UserDiscovery \u6CE8\u518C\u8868\u4E0D\u5B58\u5728\uFF0C\u4F7F\u7528\u52A8\u6001\u626B\u63CF");
          const resources = await this.scanUserResources();
          return this.buildRegistryFromResources(resources);
        } catch (error) {
          logger.warn(`[UserDiscovery] Registry discovery failed: ${error.message}`);
          return /* @__PURE__ */ new Map();
        }
      }
      /**
       * 从注册表文件加载资源
       * @returns {Promise<Map>} 资源注册表
       */
      async loadFromRegistry() {
        try {
          const protocol = this.getUserProtocol();
          const registryPath = await protocol.resolvePath(".promptx/resource/user.registry.json");
          if (!await fs.pathExists(registryPath)) {
            return /* @__PURE__ */ new Map();
          }
          const registryData = await RegistryData.fromFile("user", registryPath);
          return registryData.getResourceMap(true);
        } catch (error) {
          logger.warn(`[UserDiscovery] Failed to load registry: ${error.message}`);
          return /* @__PURE__ */ new Map();
        }
      }
      /**
       * 动态扫描 User 资源
       * @returns {Promise<Array>} 资源列表
       */
      async scanUserResources() {
        try {
          const protocol = this.getUserProtocol();
          const resourceDir = await protocol.resolvePath(".promptx/resource");
          if (!await fs.pathExists(resourceDir)) {
            logger.debug("UserDiscovery User \u8D44\u6E90\u76EE\u5F55\u4E0D\u5B58\u5728");
            return [];
          }
          const tempRegistry = RegistryData.createEmpty("user", null);
          await this._scanDirectory(resourceDir, tempRegistry);
          const resources = [];
          for (const resource2 of tempRegistry.resources) {
            resources.push({
              id: resource2.id,
              protocol: resource2.protocol,
              reference: resource2.reference,
              source: resource2.source
            });
          }
          logger.info(`[UserDiscovery] \u2705 User \u626B\u63CF\u5B8C\u6210\uFF0C\u53D1\u73B0 ${resources.length} \u4E2A\u8D44\u6E90`);
          return resources;
        } catch (error) {
          logger.warn(`[UserDiscovery] \u626B\u63CF User \u8D44\u6E90\u5931\u8D25: ${error.message}`);
          return [];
        }
      }
      /**
       * 扫描目录并添加资源到注册表
       * @param {string} resourcesDir - 资源目录
       * @param {RegistryData} registryData - 注册表数据
       * @private
       */
      async _scanDirectory(resourcesDir, registryData) {
        try {
          await this._recursiveScan(resourcesDir, "", registryData);
        } catch (error) {
          logger.warn(`[UserDiscovery] \u626B\u63CF\u8D44\u6E90\u76EE\u5F55\u5931\u8D25: ${error.message}`);
        }
      }
      /**
       * 递归扫描目录
       * @param {string} currentPath - 当前扫描路径
       * @param {string} relativePath - 相对于 resource 目录的路径
       * @param {RegistryData} registryData - 注册表数据
       * @private
       */
      async _recursiveScan(currentPath, relativePath, registryData) {
        try {
          const items = await fs.readdir(currentPath);
          for (const item of items) {
            const itemPath = path.join(currentPath, item);
            const stat = await fs.stat(itemPath);
            const newRelativePath = relativePath ? `${relativePath}/${item}` : item;
            if (stat.isDirectory()) {
              await this._recursiveScan(itemPath, newRelativePath, registryData);
            } else {
              await this._processFile(itemPath, newRelativePath, registryData);
            }
          }
        } catch (error) {
          logger.warn(`[UserDiscovery] \u626B\u63CF${currentPath}\u5931\u8D25: ${error.message}`);
        }
      }
      /**
       * 处理单个文件
       * @param {string} filePath - 文件完整路径
       * @param {string} relativePath - 相对路径
       * @param {RegistryData} registryData - 注册表数据
       * @private
       */
      async _processFile(filePath, relativePath, registryData) {
        const fileName = path.basename(filePath);
        let protocol = null;
        let resourceId = null;
        logger.debug(`[UserDiscovery._processFile] Processing: ${relativePath} (file: ${fileName})`);
        if (fileName.endsWith(".role.md")) {
          protocol = "role";
          resourceId = path.basename(fileName, ".role.md");
        } else if (fileName.endsWith(".thought.md")) {
          protocol = "thought";
          resourceId = path.basename(fileName, ".thought.md");
        } else if (fileName.endsWith(".execution.md")) {
          protocol = "execution";
          resourceId = path.basename(fileName, ".execution.md");
        } else if (fileName.endsWith(".knowledge.md")) {
          protocol = "knowledge";
          resourceId = path.basename(fileName, ".knowledge.md");
        } else if (fileName.endsWith(".tool.js")) {
          protocol = "tool";
          resourceId = path.basename(fileName, ".tool.js");
        } else if (fileName.endsWith(".manual.md")) {
          protocol = "manual";
          resourceId = path.basename(fileName, ".manual.md");
        }
        if (protocol && resourceId) {
          logger.info(`[UserDiscovery._processFile] Found ${protocol} resource: ${resourceId}`);
          if (await this._validateResourceFile(filePath, protocol)) {
            const reference = `@user://.promptx/resource/${relativePath}`;
            const resourceData = new ResourceData({
              id: resourceId,
              source: "user",
              protocol,
              name: ResourceData._generateDefaultName(resourceId, protocol),
              description: ResourceData._generateDefaultDescription(resourceId, protocol),
              reference,
              metadata: {
                scannedAt: (/* @__PURE__ */ new Date()).toISOString(),
                path: relativePath
              }
            });
            registryData.addResource(resourceData);
            logger.info(`[UserDiscovery] \u2705 \u6210\u529F\u6DFB\u52A0${protocol}\u8D44\u6E90: ${resourceId} at ${relativePath}`);
          }
        }
      }
      /**
       * 验证资源文件格式
       * @param {string} filePath - 文件路径
       * @param {string} protocol - 协议类型
       * @returns {Promise<boolean>} 是否是有效的资源文件
       */
      async _validateResourceFile(filePath, protocol) {
        try {
          const content = await fs.readFile(filePath, "utf8");
          if (!content || typeof content !== "string") {
            return false;
          }
          const trimmedContent = content.trim();
          if (trimmedContent.length === 0) {
            return false;
          }
          switch (protocol) {
            case "role":
              return trimmedContent.includes("<role>") && trimmedContent.includes("</role>");
            case "execution":
              return trimmedContent.includes("<execution>") && trimmedContent.includes("</execution>");
            case "thought":
              return trimmedContent.includes("<thought>") && trimmedContent.includes("</thought>");
            case "knowledge":
              return true;
            case "manual":
              return trimmedContent.includes("<manual>") && trimmedContent.includes("</manual>");
            case "tool":
              try {
                new Function(trimmedContent);
                return true;
              } catch (e) {
                logger.warn(`[UserDiscovery] Invalid JavaScript in tool file ${filePath}: ${e.message}`);
                return false;
              }
            default:
              return false;
          }
        } catch (error) {
          logger.warn(`[UserDiscovery] Failed to validate ${filePath}: ${error.message}`);
          return false;
        }
      }
      /**
       * 从资源列表构建注册表 Map
       * @param {Array} resources - 资源列表
       * @returns {Map} 资源注册表
       */
      buildRegistryFromResources(resources) {
        const registryMap = /* @__PURE__ */ new Map();
        resources.forEach((resource2) => {
          const key = `user:${resource2.id}`;
          registryMap.set(key, resource2.reference);
        });
        return registryMap;
      }
      /**
       * 生成并保存 User 注册表文件
       * @returns {Promise<RegistryData>} 生成的注册表数据
       */
      async generateRegistry() {
        try {
          const protocol = this.getUserProtocol();
          const registryPath = await protocol.resolvePath(".promptx/resource/user.registry.json");
          const registryData = RegistryData.createEmpty("user", registryPath);
          const resourceDir = await protocol.resolvePath(".promptx/resource");
          if (await fs.pathExists(resourceDir)) {
            await this._scanDirectory(resourceDir, registryData);
          }
          await fs.ensureDir(path.dirname(registryPath));
          await registryData.save();
          logger.info(`[UserDiscovery] \u2705 User \u6CE8\u518C\u8868\u751F\u6210\u5B8C\u6210\uFF0C\u53D1\u73B0 ${registryData.size} \u4E2A\u8D44\u6E90`);
          return registryData;
        } catch (error) {
          logger.error(`[UserDiscovery] \u751F\u6210\u6CE8\u518C\u8868\u5931\u8D25: ${error.message}`);
          return RegistryData.createEmpty("user");
        }
      }
      /**
       * 获取注册表数据（兼容接口）
       * @returns {Promise<RegistryData>} 注册表数据
       */
      async getRegistryData() {
        try {
          const protocol = this.getUserProtocol();
          const registryPath = await protocol.resolvePath(".promptx/resource/user.registry.json");
          if (await fs.pathExists(registryPath)) {
            const registryData = await RegistryData.fromFile("user", registryPath);
            if (registryData.size > 0) {
              logger.info(`[UserDiscovery] \u{1F4CB} \u4ECE\u6CE8\u518C\u8868\u52A0\u8F7D ${registryData.size} \u4E2A\u8D44\u6E90`);
              return registryData;
            }
          }
          logger.info(`[UserDiscovery] \u{1F4CB} User \u6CE8\u518C\u8868\u65E0\u6548\uFF0C\u91CD\u65B0\u751F\u6210`);
          return await this.generateRegistry();
        } catch (error) {
          logger.error(`[UserDiscovery] \u83B7\u53D6\u6CE8\u518C\u8868\u6570\u636E\u5931\u8D25: ${error.message}`);
          return RegistryData.createEmpty("user");
        }
      }
      /**
       * 发现资源（BaseDiscovery 要求的抽象方法）
       * @returns {Promise<Array>} 发现的资源列表
       */
      async discover() {
        const registryMap = await this.discoverRegistry();
        const resources = [];
        for (const [key, reference] of registryMap) {
          const [source, id] = key.split(":");
          if (source === "user" && id) {
            resources.push({
              id,
              reference,
              source: "user"
            });
          }
        }
        return resources;
      }
    };
    module2.exports = UserDiscovery;
  }
});

// src/resource/discovery/DiscoveryManager.js
var require_DiscoveryManager = __commonJS({
  "src/resource/discovery/DiscoveryManager.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var PackageDiscovery = require_PackageDiscovery();
    var ProjectDiscovery = require_ProjectDiscovery();
    var UserDiscovery = require_UserDiscovery();
    var logger = require("@promptx/logger");
    var DiscoveryManager = class {
      /**
       * 构造函数
       * @param {Array} discoveries - 自定义发现器列表，如果不提供则使用默认配置
       */
      constructor(discoveries = null) {
        if (discoveries) {
          this.discoveries = [...discoveries];
        } else {
          this.discoveries = [
            new PackageDiscovery(),
            // 优先级: 1
            new ProjectDiscovery(),
            // 优先级: 2
            new UserDiscovery()
            // 优先级: 3 (最高)
          ];
        }
        this._sortDiscoveriesByPriority();
      }
      /**
       * 添加发现器
       * @param {Object} discovery - 实现了发现器接口的对象
       */
      addDiscovery(discovery) {
        if (!discovery || typeof discovery.discover !== "function") {
          throw new Error("Discovery must implement discover method");
        }
        this.discoveries.push(discovery);
        this._sortDiscoveriesByPriority();
      }
      /**
       * 移除发现器
       * @param {string} source - 发现器源类型
       */
      removeDiscovery(source) {
        this.discoveries = this.discoveries.filter((discovery) => discovery.source !== source);
      }
      /**
       * 发现所有资源（并行模式）
       * @returns {Promise<Array>} 所有发现的资源列表
       */
      async discoverAll() {
        const discoveryPromises = this.discoveries.map(async (discovery) => {
          try {
            const resources = await discovery.discover();
            return Array.isArray(resources) ? resources : [];
          } catch (error) {
            logger.warn(`[DiscoveryManager] ${discovery.source} discovery failed: ${error.message}`);
            return [];
          }
        });
        const discoveryResults = await Promise.allSettled(discoveryPromises);
        const allResources = [];
        discoveryResults.forEach((result, index) => {
          if (result.status === "fulfilled") {
            allResources.push(...result.value);
          } else {
            logger.warn(`[DiscoveryManager] ${this.discoveries[index].source} discovery rejected: ${result.reason}`);
          }
        });
        return allResources;
      }
      /**
       * 发现并合并所有注册表（RegistryData架构）
       * @returns {Promise<Map>} 合并后的资源注册表 Map<resourceId, reference>
       */
      async discoverRegistries() {
        const registryPromises = this.discoveries.map(async (discovery) => {
          try {
            if (typeof discovery.discoverRegistry === "function") {
              const registry = await discovery.discoverRegistry();
              return registry instanceof Map ? registry : /* @__PURE__ */ new Map();
            } else {
              const resources = await discovery.discover();
              const registry = /* @__PURE__ */ new Map();
              if (Array.isArray(resources)) {
                resources.forEach((resource2) => {
                  if (resource2.id && resource2.reference) {
                    registry.set(resource2.id, resource2.reference);
                  }
                });
              }
              return registry;
            }
          } catch (error) {
            logger.warn(`[DiscoveryManager] ${discovery.source} registry discovery failed: ${error.message}`);
            return /* @__PURE__ */ new Map();
          }
        });
        const registryResults = await Promise.allSettled(registryPromises);
        const registries = [];
        registryResults.forEach((result, index) => {
          if (result.status === "fulfilled") {
            registries.push(result.value);
          } else {
            logger.warn(`[DiscoveryManager] ${this.discoveries[index].source} registry discovery rejected: ${result.reason}`);
            registries.push(/* @__PURE__ */ new Map());
          }
        });
        return this._mergeRegistries(registries);
      }
      /**
       * 按源类型发现注册表
       * @param {string} source - 发现器源类型
       * @returns {Promise<Map>} 指定源的资源注册表
       */
      async discoverRegistryBySource(source) {
        const discovery = this._findDiscoveryBySource(source);
        if (!discovery) {
          throw new Error(`Discovery source ${source} not found`);
        }
        if (typeof discovery.discoverRegistry === "function") {
          return await discovery.discoverRegistry();
        } else {
          const resources = await discovery.discover();
          const registry = /* @__PURE__ */ new Map();
          if (Array.isArray(resources)) {
            resources.forEach((resource2) => {
              if (resource2.id && resource2.reference) {
                registry.set(resource2.id, resource2.reference);
              }
            });
          }
          return registry;
        }
      }
      /**
       * 按源类型发现资源
       * @param {string} source - 发现器源类型
       * @returns {Promise<Array>} 指定源的资源列表
       */
      async discoverBySource(source) {
        const discovery = this._findDiscoveryBySource(source);
        if (!discovery) {
          throw new Error(`Discovery source ${source} not found`);
        }
        return await discovery.discover();
      }
      /**
       * 获取所有发现器信息
       * @returns {Array} 发现器信息列表
       */
      getDiscoveryInfo() {
        return this.discoveries.map((discovery) => {
          if (typeof discovery.getDiscoveryInfo === "function") {
            return discovery.getDiscoveryInfo();
          } else {
            return {
              source: discovery.source || "UNKNOWN",
              priority: discovery.priority || 0,
              description: "No description available"
            };
          }
        });
      }
      /**
       * 清理所有发现器缓存
       */
      clearCache() {
        this.discoveries.forEach((discovery) => {
          if (typeof discovery.clearCache === "function") {
            discovery.clearCache();
          }
        });
      }
      /**
       * 获取发现器数量
       * @returns {number} 注册的发现器数量
       */
      getDiscoveryCount() {
        return this.discoveries.length;
      }
      /**
       * 合并多个注册表（支持分层级资源管理）
       * @param {Array<Map>} registries - 注册表数组，按优先级排序（数字越小优先级越高）
       * @returns {Map} 合并后的注册表
       * @private
       */
      _mergeRegistries(registries) {
        const mergedRegistry = /* @__PURE__ */ new Map();
        for (let i = registries.length - 1; i >= 0; i--) {
          const registry = registries[i];
          if (registry instanceof Map) {
            for (const [key, value] of registry) {
              mergedRegistry.set(key, value);
            }
          }
        }
        const priorityLevels = ["package", "project", "user"];
        const baseResourceMap = /* @__PURE__ */ new Map();
        for (const [fullId, reference] of mergedRegistry) {
          const colonIndex = fullId.indexOf(":");
          let source = "unknown";
          let baseId = fullId;
          if (colonIndex !== -1) {
            const possibleSource = fullId.substring(0, colonIndex);
            if (priorityLevels.includes(possibleSource)) {
              source = possibleSource;
              baseId = fullId.substring(colonIndex + 1);
            }
          }
          const currentPriority = priorityLevels.indexOf(source);
          const existing = baseResourceMap.get(baseId);
          if (!existing || currentPriority > existing.priority) {
            baseResourceMap.set(baseId, {
              source,
              reference,
              priority: currentPriority,
              fullId
            });
          }
        }
        const finalRegistry = /* @__PURE__ */ new Map();
        for (const [key, value] of mergedRegistry) {
          if (key.includes(":") && priorityLevels.includes(key.split(":")[0])) {
            finalRegistry.set(key, value);
          }
        }
        for (const [baseId, info] of baseResourceMap) {
          finalRegistry.set(baseId, info.reference);
        }
        return finalRegistry;
      }
      /**
       * 按优先级排序发现器
       * @private
       */
      _sortDiscoveriesByPriority() {
        this.discoveries.sort((a, b) => {
          const priorityA = a.priority || 0;
          const priorityB = b.priority || 0;
          return priorityA - priorityB;
        });
      }
      /**
       * 根据源类型查找发现器
       * @param {string} source - 发现器源类型
       * @returns {Object|undefined} 找到的发现器或undefined
       * @private
       */
      _findDiscoveryBySource(source) {
        return this.discoveries.find((discovery) => discovery.source === source);
      }
    };
    module2.exports = DiscoveryManager;
  }
});

// src/resource/protocols/ResourceProtocol.js
var require_ResourceProtocol = __commonJS({
  "src/resource/protocols/ResourceProtocol.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var ResourceProtocol = class _ResourceProtocol {
      /**
       * 构造函数
       * @param {string} name - 协议名称
       * @param {object} options - 配置选项
       */
      constructor(name, options = {}) {
        if (new.target === _ResourceProtocol) {
          throw new Error("ResourceProtocol\u662F\u62BD\u8C61\u7C7B\uFF0C\u4E0D\u80FD\u76F4\u63A5\u5B9E\u4F8B\u5316");
        }
        this.name = name;
        this.options = options;
        this.cache = /* @__PURE__ */ new Map();
        this.enableCache = options.enableCache === true;
      }
      /**
       * 协议信息 - 需要子类实现
       * @returns {object} 协议信息
       */
      getProtocolInfo() {
        throw new Error("\u5B50\u7C7B\u5FC5\u987B\u5B9E\u73B0 getProtocolInfo() \u65B9\u6CD5");
      }
      /**
       * 解析资源路径 - 需要子类实现
       * @param {string} resourcePath - 原始资源路径
       * @param {QueryParams} queryParams - 查询参数
       * @returns {Promise<string>} 解析后的路径
       */
      async resolvePath(resourcePath, queryParams) {
        throw new Error("\u5B50\u7C7B\u5FC5\u987B\u5B9E\u73B0 resolvePath() \u65B9\u6CD5");
      }
      /**
       * 加载资源内容 - 需要子类实现
       * @param {string} resolvedPath - 解析后的路径
       * @param {QueryParams} queryParams - 查询参数
       * @returns {Promise<string>} 资源内容
       */
      async loadContent(resolvedPath, queryParams) {
        throw new Error("\u5B50\u7C7B\u5FC5\u987B\u5B9E\u73B0 loadContent() \u65B9\u6CD5");
      }
      /**
       * 验证资源路径格式 - 可选实现
       * @param {string} resourcePath - 资源路径
       * @returns {boolean} 是否有效
       */
      validatePath(resourcePath) {
        return typeof resourcePath === "string" && resourcePath.length > 0;
      }
      /**
       * 支持的查询参数列表 - 可选实现
       * @returns {object} 参数说明
       */
      getSupportedParams() {
        return {
          line: 'string - \u884C\u8303\u56F4\uFF0C\u5982 "1-10"',
          format: "string - \u8F93\u51FA\u683C\u5F0F",
          cache: "boolean - \u662F\u5426\u7F13\u5B58"
        };
      }
      /**
       * 统一的资源解析入口点
       * @param {string} resourcePath - 资源路径
       * @param {QueryParams} queryParams - 查询参数
       * @returns {Promise<string>} 资源内容
       */
      async resolve(resourcePath, queryParams) {
        if (!this.validatePath(resourcePath)) {
          const error = new Error(`\u65E0\u6548\u7684\u8D44\u6E90\u8DEF\u5F84: ${resourcePath}`);
          const logger = require("@promptx/logger");
          logger.error(`[ResourceProtocol] \u8DEF\u5F84\u9A8C\u8BC1\u5931\u8D25: ${resourcePath}`);
          logger.error(`[ResourceProtocol] \u8C03\u7528\u5806\u6808:`, error.stack);
          throw error;
        }
        const cacheKey = this.generateCacheKey(resourcePath, queryParams);
        if (this.enableCache && this.cache.has(cacheKey)) {
          return this.cache.get(cacheKey);
        }
        const resolvedPath = await this.resolvePath(resourcePath, queryParams);
        const content = await this.loadContent(resolvedPath, queryParams);
        const filteredContent = this.applyCommonParams(content, queryParams);
        if (this.enableCache) {
          this.cache.set(cacheKey, filteredContent);
        }
        return filteredContent;
      }
      /**
       * 生成缓存键
       * @param {string} resourcePath - 资源路径
       * @param {QueryParams} queryParams - 查询参数
       * @returns {string} 缓存键
       */
      generateCacheKey(resourcePath, queryParams) {
        const params = queryParams ? queryParams.getAll() : {};
        return `${this.name}:${resourcePath}:${JSON.stringify(params)}`;
      }
      /**
       * 应用通用查询参数
       * @param {string} content - 原始内容
       * @param {QueryParams} queryParams - 查询参数
       * @returns {string} 过滤后的内容
       */
      applyCommonParams(content, queryParams) {
        if (!queryParams) {
          return content;
        }
        let result = content;
        if (queryParams.line) {
          result = this.applyLineFilter(result, queryParams.line);
        }
        if (queryParams.format && queryParams.format !== "text") {
          result = this.applyFormat(result, queryParams.format);
        }
        return result;
      }
      /**
       * 应用行过滤
       * @param {string} content - 内容
       * @param {string} lineRange - 行范围，如 "5-10" 或 "5"
       * @returns {string} 过滤后的内容
       */
      applyLineFilter(content, lineRange) {
        const lines = content.split("\n");
        if (lineRange.includes("-")) {
          const [start, end] = lineRange.split("-").map((n) => parseInt(n.trim(), 10));
          const startIndex = Math.max(0, start - 1);
          const endIndex = Math.min(lines.length, end);
          return lines.slice(startIndex, endIndex).join("\n");
        } else {
          const lineNum = parseInt(lineRange, 10);
          const lineIndex = lineNum - 1;
          return lines[lineIndex] || "";
        }
      }
      /**
       * 应用格式化
       * @param {string} content - 内容
       * @param {string} format - 格式
       * @returns {string} 格式化后的内容
       */
      applyFormat(content, format) {
        switch (format) {
          case "json":
            try {
              return JSON.stringify(JSON.parse(content), null, 2);
            } catch {
              return content;
            }
          case "trim":
            return content.trim();
          default:
            return content;
        }
      }
      /**
       * 清除缓存
       */
      clearCache() {
        this.cache.clear();
      }
      /**
       * 获取缓存统计
       * @returns {object} 缓存统计信息
       */
      getCacheStats() {
        return {
          protocol: this.name,
          size: this.cache.size,
          enabled: this.enableCache
        };
      }
    };
    module2.exports = ResourceProtocol;
  }
});

// src/resource/protocols/PackageProtocol.js
var require_PackageProtocol = __commonJS({
  "src/resource/protocols/PackageProtocol.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var path = require("path");
    var fs = require("fs");
    var fsPromises = require("fs").promises;
    var ResourceProtocol = require_ResourceProtocol();
    var { QueryParams } = require_types();
    var logger = require("@promptx/logger");
    var { getDirectoryService } = require_DirectoryService();
    var PackageProtocol = class extends ResourceProtocol {
      constructor(options = {}) {
        super("package", options);
        this.directoryService = getDirectoryService();
      }
      /**
       * 设置注册表（保持与其他协议的一致性）
       */
      setRegistry(registry) {
        this.registry = registry || {};
      }
      /**
       * 获取协议信息
       */
      getProtocolInfo() {
        return {
          name: this.name,
          description: "\u5305\u534F\u8BAE - \u667A\u80FD\u8BBF\u95EENPM\u5305\u8D44\u6E90\uFF0C\u652F\u6301\u591A\u79CD\u5B89\u88C5\u6A21\u5F0F",
          examples: [
            "@package://package.json",
            "@package://src/index.js",
            "@package://docs/README.md",
            "@package://resource/core/thought.md",
            "@package://templates/basic/template.md"
          ],
          installModes: [
            "development",
            // 开发模式
            "local",
            // 本地npm install
            "global",
            // 全局npm install -g
            "npx",
            // npx执行
            "monorepo",
            // monorepo workspace
            "link"
            // npm link
          ]
        };
      }
      /**
       * 获取包根目录 - 始终使用 dist 目录
       */
      async getPackageRoot() {
        try {
          const resourcePath = require.resolve("@promptx/resource");
          logger.info(`[PackageProtocol] require.resolve('@promptx/resource') returned: ${resourcePath}`);
          const distDir = path.dirname(resourcePath);
          logger.info(`[PackageProtocol] Using dist directory as package root: ${distDir}`);
          const resourcesDir = path.join(distDir, "resources");
          logger.info(`[PackageProtocol] Resources directory path: ${resourcesDir}`);
          logger.info(`[PackageProtocol] Resources directory exists: ${fs.existsSync(resourcesDir)}`);
          return distDir;
        } catch (error) {
          logger.error(`[PackageProtocol] Cannot locate @promptx/resource package: ${error.message}`);
          logger.error(`[PackageProtocol] Error stack:`, error.stack);
          logger.error(`[PackageProtocol] This is a critical system error, @promptx/resource must exist and be accessible via require`);
          throw error;
        }
      }
      /**
       * 解析路径到具体的文件系统路径 - 使用 PackageResource
       * @param {string} relativePath - 相对于包根目录的路径
       * @param {QueryParams} params - 查询参数
       * @returns {Promise<string>} 解析后的绝对路径
       */
      async resolvePath(relativePath, params = null) {
        logger.info(`[PackageProtocol] Resolving path: ${relativePath}`);
        try {
          const resourceModule = require("@promptx/resource");
          logger.info(`[PackageProtocol] Resource module loaded:`, Object.keys(resourceModule));
          const { packageResource } = resourceModule;
          logger.info(`[PackageProtocol] PackageResource type:`, typeof packageResource);
          logger.debug(`[PackageProtocol] Successfully loaded PackageResource`);
          const cleanPath = relativePath.replace(/^\/+/, "");
          logger.debug(`[PackageProtocol] Cleaned path: ${cleanPath}`);
          const fullPath = packageResource.resolvePath(cleanPath);
          logger.info(`[PackageProtocol] PackageResource resolved path: ${fullPath}`);
          const exists = packageResource.exists(cleanPath);
          logger.info(`[PackageProtocol] File exists: ${exists} (path: ${fullPath})`);
          if (!exists) {
            logger.error(`[PackageProtocol] Resource file not found: ${fullPath}`);
            return null;
          }
          return fullPath;
        } catch (error) {
          logger.error(`[PackageProtocol] Failed to resolve resource path: ${error.message}`);
          logger.error(`[PackageProtocol] Error stack:`, error.stack);
          throw error;
        }
      }
      /**
       * 验证文件访问权限（基于package.json的files字段）
       * @param {string} packageRoot - 包根目录
       * @param {string} relativePath - 相对路径
       */
      validateFileAccess(packageRoot, relativePath) {
        logger.debug(`[PackageProtocol] Validating file access for: ${relativePath}`);
      }
      /**
       * 检查资源是否存在
       */
      async exists(resourcePath, queryParams) {
        try {
          const resolvedPath = await this.resolvePath(resourcePath, queryParams);
          await fsPromises.access(resolvedPath);
          return true;
        } catch (error) {
          return false;
        }
      }
      /**
       * 加载资源内容
       * @param {string} resolvedPath - 已解析的路径
       * @param {QueryParams} [queryParams] - 查询参数
       * @returns {Object} 包含内容和元数据的对象
       */
      async loadContent(resolvedPath, queryParams) {
        try {
          await fsPromises.access(resolvedPath);
          const content = await fsPromises.readFile(resolvedPath, "utf8");
          const stats = await fsPromises.stat(resolvedPath);
          const packageRoot = await this.getPackageRoot();
          return {
            content,
            path: resolvedPath,
            protocol: "package",
            metadata: {
              size: content.length,
              lastModified: stats.mtime,
              absolutePath: resolvedPath,
              relativePath: path.relative(packageRoot, resolvedPath)
            }
          };
        } catch (error) {
          if (error.code === "ENOENT") {
            throw new Error(`Package resource not found: ${resolvedPath}`);
          }
          throw new Error(`Failed to load package resource: ${error.message}`);
        }
      }
      /**
       * 获取调试信息
       */
      getDebugInfo() {
        return {
          protocol: this.name,
          packageRoot: this.getPackageRoot(),
          currentWorkingDirectory: process.cwd(),
          moduleDirectory: __dirname,
          cacheSize: this.cache.size
        };
      }
      /**
       * 清理缓存
       */
      clearCache() {
        super.clearCache();
      }
    };
    module2.exports = PackageProtocol;
  }
});

// src/utils/ProjectPathResolver.js
var require_ProjectPathResolver = __commonJS({
  "src/utils/ProjectPathResolver.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var path = require("path");
    var ProjectManager = require_ProjectManager();
    var ProjectPathResolver = class {
      constructor() {
        this.projectDirs = {
          root: "",
          // 项目根目录
          src: "src",
          // 源代码目录
          lib: "lib",
          // 库目录
          build: "build",
          // 构建输出目录
          dist: "dist",
          // 分发目录
          docs: "docs",
          // 文档目录
          test: "test",
          // 测试目录
          tests: "tests",
          // 测试目录（复数）
          spec: "spec",
          // 规范测试目录
          config: "config",
          // 配置目录
          scripts: "scripts",
          // 脚本目录
          assets: "assets",
          // 资源目录
          public: "public",
          // 公共资源目录
          static: "static",
          // 静态资源目录
          templates: "templates",
          // 模板目录
          examples: "examples",
          // 示例目录
          tools: "tools",
          // 工具目录
          ".promptx": ".promptx"
          // PromptX配置目录
        };
      }
      /**
       * 解析@project://协议路径
       * @param {string} resourcePath - 资源路径，如 "src/index.js" 或 ".promptx/resource/..."
       * @returns {string} 解析后的绝对路径
       */
      resolvePath(resourcePath) {
        const projectRoot = ProjectManager.getCurrentProjectPath();
        if (resourcePath.startsWith(".promptx/")) {
          const fullPath2 = path.join(projectRoot, resourcePath);
          return this._validatePath(fullPath2, projectRoot);
        }
        const parts = resourcePath.split("/");
        const dirType = parts[0];
        const relativePath = parts.slice(1).join("/");
        if (!this.projectDirs.hasOwnProperty(dirType)) {
          throw new Error(`\u4E0D\u652F\u6301\u7684\u9879\u76EE\u76EE\u5F55\u7C7B\u578B: ${dirType}\u3002\u652F\u6301\u7684\u7C7B\u578B: ${Object.keys(this.projectDirs).join(", ")}`);
        }
        const projectDirPath = this.projectDirs[dirType];
        const targetDir = projectDirPath ? path.join(projectRoot, projectDirPath) : projectRoot;
        if (!relativePath) {
          return targetDir;
        }
        const fullPath = path.join(targetDir, relativePath);
        return this._validatePath(fullPath, projectRoot);
      }
      /**
       * 获取项目根目录
       * @returns {string} 当前项目根目录
       */
      getProjectRoot() {
        return ProjectManager.getCurrentProjectPath();
      }
      /**
       * 获取PromptX配置目录路径
       * @returns {string} .promptx目录路径
       */
      getPromptXDirectory() {
        const projectRoot = ProjectManager.getCurrentProjectPath();
        return path.join(projectRoot, ".promptx");
      }
      /**
       * 获取项目资源目录路径
       * @returns {string} 项目资源目录路径
       */
      getResourceDirectory() {
        const promptxDir = this.getPromptXDirectory();
        return path.join(promptxDir, "resource");
      }
      /**
       * 获取项目注册表文件路径
       * @returns {string} 注册表文件路径
       */
      getRegistryPath() {
        const resourceDir = this.getResourceDirectory();
        return path.join(resourceDir, "project.registry.json");
      }
      /**
       * 获取记忆目录路径
       * @returns {string} 记忆目录路径
       */
      getMemoryDirectory() {
        const promptxDir = this.getPromptXDirectory();
        return path.join(promptxDir, "memory");
      }
      /**
       * 验证路径安全性
       * @param {string} fullPath - 完整路径
       * @param {string} projectRoot - 项目根目录
       * @returns {string} 验证后的路径
       * @private
       */
      _validatePath(fullPath, projectRoot) {
        const resolvedPath = path.resolve(fullPath);
        const resolvedProjectRoot = path.resolve(projectRoot);
        if (!resolvedPath.startsWith(resolvedProjectRoot)) {
          throw new Error(`\u5B89\u5168\u9519\u8BEF\uFF1A\u8DEF\u5F84\u8D85\u51FA\u9879\u76EE\u76EE\u5F55\u8303\u56F4: ${resolvedPath}`);
        }
        return resolvedPath;
      }
      /**
       * 获取支持的目录类型
       * @returns {Array<string>} 支持的目录类型列表
       */
      getSupportedDirectories() {
        return Object.keys(this.projectDirs);
      }
      /**
       * 检查目录类型是否支持
       * @param {string} dirType - 目录类型
       * @returns {boolean} 是否支持
       */
      isSupportedDirectory(dirType) {
        return this.projectDirs.hasOwnProperty(dirType);
      }
    };
    var globalProjectPathResolver = null;
    function getGlobalProjectPathResolver() {
      if (!globalProjectPathResolver) {
        globalProjectPathResolver = new ProjectPathResolver();
      }
      return globalProjectPathResolver;
    }
    module2.exports = ProjectPathResolver;
    module2.exports.getGlobalProjectPathResolver = getGlobalProjectPathResolver;
  }
});

// src/resource/protocols/UserProtocol.js
var require_UserProtocol = __commonJS({
  "src/resource/protocols/UserProtocol.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var ResourceProtocol = require_ResourceProtocol();
    var path = require("path");
    var fs = require("fs").promises;
    var envPaths = require("env-paths");
    var os = require("os");
    var getUserDirectories = () => {
      const promptxPaths = envPaths("promptx");
      return {
        getHomeFolder: () => os.homedir(),
        getDesktopFolder: () => path.join(os.homedir(), "Desktop"),
        getDocumentsFolder: () => path.join(os.homedir(), "Documents"),
        getDownloadsFolder: () => path.join(os.homedir(), "Downloads"),
        getMusicFolder: () => path.join(os.homedir(), "Music"),
        getPicturesFolder: () => path.join(os.homedir(), "Pictures"),
        getVideosFolder: () => path.join(os.homedir(), "Videos"),
        // 新增：env-paths标准目录
        getDataFolder: () => promptxPaths.data,
        getConfigFolder: () => promptxPaths.config,
        getCacheFolder: () => promptxPaths.cache,
        getLogFolder: () => promptxPaths.log,
        getTempFolder: () => promptxPaths.temp
      };
    };
    var UserProtocol = class extends ResourceProtocol {
      constructor(options = {}) {
        super("user", options);
        this.userDirs = {
          home: "getHomeFolder",
          desktop: "getDesktopFolder",
          documents: "getDocumentsFolder",
          downloads: "getDownloadsFolder",
          music: "getMusicFolder",
          pictures: "getPicturesFolder",
          videos: "getVideosFolder",
          // 新增：env-paths标准目录
          data: "getDataFolder",
          config: "getConfigFolder",
          cache: "getCacheFolder",
          log: "getLogFolder",
          temp: "getTempFolder"
        };
        this.dirCache = /* @__PURE__ */ new Map();
      }
      /**
       * 设置注册表（保持与其他协议的一致性）
       */
      setRegistry(registry) {
        this.registry = registry || {};
      }
      /**
       * 获取协议信息
       * @returns {object} 协议信息
       */
      getProtocolInfo() {
        return {
          name: "user",
          description: "\u7528\u6237\u76EE\u5F55\u534F\u8BAE\uFF0C\u76F4\u63A5\u6620\u5C04\u5230\u7528\u6237\u4E3B\u76EE\u5F55",
          location: "user://{path}",
          examples: [
            "user://.promptx/toolbox/text-analyzer",
            "user://.bashrc",
            "user://Documents/notes.txt",
            "user://Desktop/readme.md",
            "user://Downloads/file.zip",
            "user://.promptx/config.json"
          ],
          basePath: "\u7528\u6237\u4E3B\u76EE\u5F55 (~)",
          params: this.getSupportedParams()
        };
      }
      /**
       * 支持的查询参数
       * @returns {object} 参数说明
       */
      getSupportedParams() {
        return {
          ...super.getSupportedParams(),
          exists: "boolean - \u4EC5\u8FD4\u56DE\u5B58\u5728\u7684\u6587\u4EF6/\u76EE\u5F55",
          type: "string - \u8FC7\u6EE4\u7C7B\u578B (file|dir|both)"
        };
      }
      /**
       * 验证用户协议路径
       * @param {string} resourcePath - 资源路径
       * @returns {boolean} 是否有效
       */
      validatePath(resourcePath) {
        if (!resourcePath || typeof resourcePath !== "string") {
          return false;
        }
        if (resourcePath.startsWith(".promptx/")) {
          return true;
        }
        const parts = resourcePath.split("/");
        const dirType = parts[0];
        return this.userDirs.hasOwnProperty(dirType);
      }
      /**
       * 解析用户目录路径
       * @param {string} resourcePath - 原始资源路径，如 ".promptx/toolbox/test-tool"
       * @param {QueryParams} queryParams - 查询参数
       * @returns {Promise<string>} 解析后的绝对路径
       */
      async resolvePath(resourcePath, queryParams) {
        const userHomeDir = getUserDirectories().getHomeFolder();
        if (!resourcePath) {
          return userHomeDir;
        }
        const fullPath = path.join(userHomeDir, resourcePath);
        const resolvedPath = path.resolve(fullPath);
        const resolvedUserDir = path.resolve(userHomeDir);
        if (!resolvedPath.startsWith(resolvedUserDir)) {
          throw new Error(`\u5B89\u5168\u9519\u8BEF\uFF1A\u8DEF\u5F84\u8D85\u51FA\u7528\u6237\u76EE\u5F55\u8303\u56F4: ${resolvedPath}`);
        }
        return resolvedPath;
      }
      /**
       * 获取用户目录路径
       * @param {string} dirType - 目录类型
       * @returns {Promise<string>} 目录路径
       */
      async getUserDirectory(dirType) {
        if (this.dirCache.has(dirType)) {
          return this.dirCache.get(dirType);
        }
        const userDirectories = getUserDirectories();
        const methodName = this.userDirs[dirType];
        if (!userDirectories[methodName]) {
          throw new Error(`\u672A\u627E\u5230\u7528\u6237\u76EE\u5F55\u83B7\u53D6\u65B9\u6CD5: ${methodName}`);
        }
        try {
          let dirPath;
          if (typeof userDirectories[methodName] === "function") {
            dirPath = userDirectories[methodName]();
          } else {
            dirPath = userDirectories[methodName];
          }
          this.dirCache.set(dirType, dirPath);
          return dirPath;
        } catch (error) {
          throw new Error(`\u83B7\u53D6\u7528\u6237\u76EE\u5F55\u5931\u8D25 (${dirType}): ${error.message}`);
        }
      }
      /**
       * 加载资源内容
       * @param {string} resolvedPath - 解析后的路径
       * @param {QueryParams} queryParams - 查询参数
       * @returns {Promise<string>} 资源内容
       */
      async loadContent(resolvedPath, queryParams) {
        try {
          const stats = await fs.stat(resolvedPath);
          if (stats.isDirectory()) {
            return await this.loadDirectoryContent(resolvedPath, queryParams);
          } else if (stats.isFile()) {
            return await this.loadFileContent(resolvedPath, queryParams);
          } else {
            throw new Error(`\u4E0D\u652F\u6301\u7684\u6587\u4EF6\u7C7B\u578B: ${resolvedPath}`);
          }
        } catch (error) {
          if (error.code === "ENOENT") {
            if (queryParams && queryParams.get("exists") === "false") {
              return "";
            }
            throw new Error(`\u6587\u4EF6\u6216\u76EE\u5F55\u4E0D\u5B58\u5728: ${resolvedPath}`);
          }
          throw error;
        }
      }
      /**
       * 加载文件内容
       * @param {string} filePath - 文件路径
       * @param {QueryParams} queryParams - 查询参数
       * @returns {Promise<string>} 文件内容
       */
      async loadFileContent(filePath, queryParams) {
        const encoding = (queryParams == null ? void 0 : queryParams.get("encoding")) || "utf8";
        return await fs.readFile(filePath, encoding);
      }
      /**
       * 加载目录内容
       * @param {string} dirPath - 目录路径
       * @param {QueryParams} queryParams - 查询参数
       * @returns {Promise<string>} 目录内容列表
       */
      async loadDirectoryContent(dirPath, queryParams) {
        const entries = await fs.readdir(dirPath, { withFileTypes: true });
        const typeFilter = queryParams == null ? void 0 : queryParams.get("type");
        let filteredEntries = entries;
        if (typeFilter) {
          filteredEntries = entries.filter((entry) => {
            switch (typeFilter) {
              case "file":
                return entry.isFile();
              case "dir":
                return entry.isDirectory();
              case "both":
                return true;
              default:
                return true;
            }
          });
        }
        const format = (queryParams == null ? void 0 : queryParams.get("format")) || "list";
        switch (format) {
          case "json":
            return JSON.stringify(
              filteredEntries.map((entry) => ({
                name: entry.name,
                type: entry.isDirectory() ? "directory" : "file",
                path: path.join(dirPath, entry.name)
              })),
              null,
              2
            );
          case "paths":
            return filteredEntries.map((entry) => path.join(dirPath, entry.name)).join("\n");
          case "list":
          default:
            return filteredEntries.map((entry) => {
              const type = entry.isDirectory() ? "[DIR]" : "[FILE]";
              return `${type} ${entry.name}`;
            }).join("\n");
        }
      }
      /**
       * 列出所有支持的用户目录
       * @returns {Promise<object>} 目录信息
       */
      async listUserDirectories() {
        const result = {};
        for (const dirType of Object.keys(this.userDirs)) {
          try {
            result[dirType] = await this.getUserDirectory(dirType);
          } catch (error) {
            result[dirType] = { error: error.message };
          }
        }
        return result;
      }
      /**
       * 清除目录缓存
       */
      clearCache() {
        super.clearCache();
        this.dirCache.clear();
      }
    };
    module2.exports = UserProtocol;
  }
});

// src/resource/protocols/ProjectProtocol.js
var require_ProjectProtocol = __commonJS({
  "src/resource/protocols/ProjectProtocol.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var ResourceProtocol = require_ResourceProtocol();
    var path = require("path");
    var fs = require("fs").promises;
    var { getGlobalProjectPathResolver } = require_ProjectPathResolver();
    var ProjectManager = require_ProjectManager();
    var UserProtocol = require_UserProtocol();
    var ProjectProtocol = class extends ResourceProtocol {
      constructor(options = {}) {
        super("project", options);
        this.pathResolver = null;
        this.userProtocol = new UserProtocol(options);
      }
      /**
       * 获取路径解析器（延迟初始化）
       * @returns {ProjectPathResolver} 路径解析器实例
       */
      getPathResolver() {
        if (!this.pathResolver) {
          this.pathResolver = getGlobalProjectPathResolver();
        }
        return this.pathResolver;
      }
      /**
       * 设置注册表（保持与其他协议的一致性）
       */
      setRegistry(registry) {
        this.registry = registry || {};
      }
      /**
       * 获取协议信息
       * @returns {object} 协议信息
       */
      getProtocolInfo() {
        return {
          name: "project",
          description: "\u9879\u76EE\u534F\u8BAE\uFF0C\u57FA\u4E8E\u5F53\u524D\u9879\u76EE\u72B6\u6001\u7684\u9AD8\u6027\u80FD\u8DEF\u5F84\u89E3\u6790",
          location: "project://{directory}/{path}",
          examples: [
            "project://src/index.js",
            "project://lib/utils.js",
            "project://docs/README.md",
            "project://root/package.json",
            "project://test/unit/"
          ],
          supportedDirectories: this.getPathResolver().getSupportedDirectories(),
          architecture: "state-based",
          params: this.getSupportedParams()
        };
      }
      /**
       * 支持的查询参数
       * @returns {object} 参数说明
       */
      getSupportedParams() {
        return {
          ...super.getSupportedParams(),
          from: "string - \u6307\u5B9A\u641C\u7D22\u8D77\u59CB\u76EE\u5F55",
          create: "boolean - \u5982\u679C\u76EE\u5F55\u4E0D\u5B58\u5728\u662F\u5426\u521B\u5EFA",
          exists: "boolean - \u4EC5\u8FD4\u56DE\u5B58\u5728\u7684\u6587\u4EF6/\u76EE\u5F55",
          type: "string - \u8FC7\u6EE4\u7C7B\u578B (file|dir|both)"
        };
      }
      /**
       * 验证项目协议路径
       * @param {string} resourcePath - 资源路径
       * @returns {boolean} 是否有效
       */
      validatePath(resourcePath) {
        if (!super.validatePath(resourcePath)) {
          return false;
        }
        if (resourcePath.startsWith(".promptx/")) {
          return true;
        }
        const parts = resourcePath.split("/");
        const dirType = parts[0];
        return this.getPathResolver().isSupportedDirectory(dirType);
      }
      /**
       * 解析项目路径 - 新架构：高性能零查找 + HTTP模式支持
       * @param {string} resourcePath - 原始资源路径，如 "src/index.js" 或 ".promptx/resource/..."
       * @param {QueryParams} queryParams - 查询参数
       * @returns {Promise<string>} 解析后的绝对路径
       */
      async resolvePath(resourcePath, queryParams) {
        try {
          const currentProject = ProjectManager.getCurrentProject();
          const { transport } = currentProject;
          if (transport === "http") {
            return await this.resolveHttpPath(resourcePath, queryParams, currentProject);
          } else {
            return this.resolveLocalPath(resourcePath, queryParams, currentProject);
          }
        } catch (error) {
          throw new Error(`\u89E3\u6790@project://\u8DEF\u5F84\u5931\u8D25: ${error.message}`);
        }
      }
      /**
       * 本地模式路径解析（原有逻辑）
       * @param {string} resourcePath - 资源路径
       * @param {QueryParams} queryParams - 查询参数
       * @param {Object} currentProject - 当前项目信息
       * @returns {string} 解析后的绝对路径
       */
      resolveLocalPath(resourcePath, queryParams, currentProject) {
        return this.getPathResolver().resolvePath(resourcePath);
      }
      /**
       * HTTP模式路径解析（映射到用户目录的项目空间）
       * @param {string} resourcePath - 资源路径，如".promptx/resource/xxx"
       * @param {QueryParams} queryParams - 查询参数
       * @param {Object} currentProject - 当前项目信息
       * @returns {Promise<string>} 解析后的绝对路径
       */
      async resolveHttpPath(resourcePath, queryParams, currentProject) {
        const projectHash = this.generateProjectHash(currentProject.workingDirectory);
        let mappedResourcePath = resourcePath;
        if (resourcePath === ".promptx") {
          mappedResourcePath = "data";
        } else if (resourcePath.startsWith(".promptx/")) {
          mappedResourcePath = resourcePath.replace(/^\.promptx\//, "data/");
        } else {
          mappedResourcePath = `data/${resourcePath}`;
        }
        const mappedPath = `.promptx/project/${projectHash}/${mappedResourcePath}`;
        return await this.userProtocol.resolvePath(mappedPath, queryParams);
      }
      /**
       * 生成项目路径的Hash值（与ProjectManager保持一致）
       * @param {string} projectPath - 项目路径
       * @returns {string} 8位Hash值
       */
      generateProjectHash(projectPath) {
        const crypto = require("crypto");
        return crypto.createHash("md5").update(path.resolve(projectPath)).digest("hex").substr(0, 8);
      }
      /**
       * 加载资源内容
       * @param {string} resolvedPath - 解析后的路径
       * @param {QueryParams} queryParams - 查询参数
       * @returns {Promise<string>} 资源内容
       */
      async loadContent(resolvedPath, queryParams) {
        try {
          const currentProject = ProjectManager.getCurrentProject();
          const { transport } = currentProject;
          if (transport === "http") {
            return await this.userProtocol.loadContent(resolvedPath, queryParams);
          } else {
            return await this.loadLocalContent(resolvedPath, queryParams);
          }
        } catch (error) {
          throw error;
        }
      }
      /**
       * 本地模式加载资源内容（原有逻辑）
       * @param {string} resolvedPath - 解析后的路径
       * @param {QueryParams} queryParams - 查询参数
       * @returns {Promise<string>} 资源内容
       */
      async loadLocalContent(resolvedPath, queryParams) {
        try {
          const stats = await fs.stat(resolvedPath);
          if (stats.isDirectory()) {
            return await this.loadDirectoryContent(resolvedPath, queryParams);
          } else if (stats.isFile()) {
            return await this.loadFileContent(resolvedPath, queryParams);
          } else {
            throw new Error(`\u4E0D\u652F\u6301\u7684\u6587\u4EF6\u7C7B\u578B: ${resolvedPath}`);
          }
        } catch (error) {
          if (error.code === "ENOENT") {
            if ((queryParams == null ? void 0 : queryParams.get("create")) === "true") {
              await fs.mkdir(path.dirname(resolvedPath), { recursive: true });
              return "";
            }
            if ((queryParams == null ? void 0 : queryParams.get("exists")) === "false") {
              return "";
            }
            throw new Error(`\u6587\u4EF6\u6216\u76EE\u5F55\u4E0D\u5B58\u5728: ${resolvedPath}`);
          }
          throw error;
        }
      }
      /**
       * 加载文件内容
       * @param {string} filePath - 文件路径
       * @param {QueryParams} queryParams - 查询参数
       * @returns {Promise<string>} 文件内容
       */
      async loadFileContent(filePath, queryParams) {
        const encoding = (queryParams == null ? void 0 : queryParams.get("encoding")) || "utf8";
        return await fs.readFile(filePath, encoding);
      }
      /**
       * 加载目录内容
       * @param {string} dirPath - 目录路径
       * @param {QueryParams} queryParams - 查询参数
       * @returns {Promise<string>} 目录内容列表
       */
      async loadDirectoryContent(dirPath, queryParams) {
        const entries = await fs.readdir(dirPath, { withFileTypes: true });
        const typeFilter = queryParams == null ? void 0 : queryParams.get("type");
        let filteredEntries = entries;
        if (typeFilter) {
          filteredEntries = entries.filter((entry) => {
            switch (typeFilter) {
              case "file":
                return entry.isFile();
              case "dir":
                return entry.isDirectory();
              case "both":
                return true;
              default:
                return true;
            }
          });
        }
        const format = (queryParams == null ? void 0 : queryParams.get("format")) || "list";
        switch (format) {
          case "json":
            return JSON.stringify(
              filteredEntries.map((entry) => ({
                name: entry.name,
                type: entry.isDirectory() ? "directory" : "file",
                path: path.join(dirPath, entry.name)
              })),
              null,
              2
            );
          case "paths":
            return filteredEntries.map((entry) => path.join(dirPath, entry.name)).join("\n");
          case "list":
          default:
            return filteredEntries.map((entry) => {
              const type = entry.isDirectory() ? "[DIR]" : "[FILE]";
              return `${type} ${entry.name}`;
            }).join("\n");
        }
      }
      /**
       * 列出项目结构信息 - 新架构
       * @returns {Promise<object>} 项目信息
       */
      async getProjectInfo() {
        try {
          const projectRoot = this.getPathResolver().getProjectRoot();
          const promptxPath = this.getPathResolver().getPromptXDirectory();
          const result = {
            projectRoot,
            promptxPath,
            architecture: "state-based",
            supportedDirectories: this.getPathResolver().getSupportedDirectories(),
            directories: {}
          };
          for (const dirType of this.getPathResolver().getSupportedDirectories()) {
            try {
              const fullPath = this.getPathResolver().resolvePath(dirType);
              const stats = await fs.stat(fullPath);
              result.directories[dirType] = {
                path: fullPath,
                exists: true,
                type: stats.isDirectory() ? "directory" : "file"
              };
            } catch (error) {
              result.directories[dirType] = {
                path: "N/A",
                exists: false
              };
            }
          }
          return result;
        } catch (error) {
          return {
            error: `\u83B7\u53D6\u9879\u76EE\u4FE1\u606F\u5931\u8D25: ${error.message}`,
            architecture: "state-based"
          };
        }
      }
      /**
       * 清除缓存 - 新架构：无需清除路径缓存
       */
      clearCache() {
        super.clearCache();
      }
    };
    module2.exports = ProjectProtocol;
  }
});

// src/resource/protocols/RoleProtocol.js
var require_RoleProtocol = __commonJS({
  "src/resource/protocols/RoleProtocol.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var ResourceProtocol = require_ResourceProtocol();
    var fs = require("fs-extra");
    var path = require("path");
    var RoleProtocol = class extends ResourceProtocol {
      constructor() {
        super("role");
        this.registry = {};
        this.registryManager = null;
      }
      /**
       * 设置注册表管理器
       */
      setRegistryManager(manager) {
        this.registryManager = manager;
      }
      /**
       * 设置注册表
       */
      setRegistry(registry) {
        this.registry = registry || {};
      }
      /**
       * 获取协议信息
       */
      getProtocolInfo() {
        return {
          name: "role",
          description: "AI\u89D2\u8272\u8D44\u6E90\u534F\u8BAE",
          location: "role://{role_id}",
          examples: [
            "role://video-copywriter",
            "role://product-owner",
            "role://assistant",
            "role://prompt-developer"
          ]
        };
      }
      /**
       * 解析角色协议
       * @param {string} rolePath - 角色路径，如 'java-developer'
       * @param {Object} queryParams - 查询参数（暂未使用）
       * @returns {Promise<string>} 角色文件内容
       */
      async resolve(rolePath, queryParams = {}) {
        try {
          const fullResourceId = `role:${rolePath}`;
          const shortResourceId = rolePath;
          let resourceData = this.registryManager.registryData.findResourceById(rolePath, "role");
          if (!resourceData) {
            resourceData = this.registryManager.registryData.findResourceById(fullResourceId);
          }
          if (!resourceData) {
            const availableRoles = this.registryManager.registryData.getResourcesByProtocol("role").map((r) => r.id).join(", ");
            throw new Error(`\u89D2\u8272 '${rolePath}' \u672A\u627E\u5230\u3002\u53EF\u7528\u89D2\u8272: ${availableRoles}`);
          }
          const result = await this.registryManager.loadResourceByProtocol(resourceData.reference);
          return result;
        } catch (error) {
          throw new Error(`RoleProtocol.resolve failed: ${error.message}`);
        }
      }
      /**
       * 加载资源内容
       */
      async loadContent(resolvedPath, queryParams) {
        try {
          const content = await fs.readFile(resolvedPath, "utf-8");
          return content;
        } catch (error) {
          throw new Error(`\u65E0\u6CD5\u52A0\u8F7D\u89D2\u8272\u6587\u4EF6 ${resolvedPath}: ${error.message}`);
        }
      }
      /**
       * 验证资源路径
       */
      validatePath(resourcePath) {
        return /^[a-zA-Z0-9_-]+$/.test(resourcePath);
      }
    };
    module2.exports = RoleProtocol;
  }
});

// src/resource/protocols/ThoughtProtocol.js
var require_ThoughtProtocol = __commonJS({
  "src/resource/protocols/ThoughtProtocol.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var ResourceProtocol = require_ResourceProtocol();
    var fs = require("fs-extra");
    var path = require("path");
    var ThoughtProtocol = class extends ResourceProtocol {
      constructor() {
        super("thought");
        this.registry = {};
        this.registryManager = null;
      }
      /**
       * 设置注册表管理器
       */
      setRegistryManager(manager) {
        this.registryManager = manager;
      }
      /**
       * 设置注册表
       */
      setRegistry(registry) {
        this.registry = registry || {};
      }
      /**
       * 获取协议信息
       */
      getProtocolInfo() {
        return {
          name: "thought",
          description: "\u601D\u7EF4\u6A21\u5F0F\u8D44\u6E90\u534F\u8BAE",
          location: "thought://{thought_id}",
          examples: [
            "thought://prompt-developer",
            "thought://product-owner"
          ]
        };
      }
      /**
       * 解析思维协议
       * @param {string} thoughtPath - 思维路径，如 'remember'
       * @param {Object} queryParams - 查询参数（暂未使用）
       * @returns {Promise<string>} 思维文件内容
       */
      async resolve(thoughtPath, queryParams = {}) {
        try {
          const fullResourceId = `thought:${thoughtPath}`;
          let resourceData = this.registryManager.registryData.findResourceById(thoughtPath, "thought");
          if (!resourceData) {
            resourceData = this.registryManager.registryData.findResourceById(fullResourceId);
          }
          if (!resourceData) {
            const availableThoughts = this.registryManager.registryData.getResourcesByProtocol("thought").map((r) => r.id).join(", ");
            throw new Error(`\u601D\u7EF4\u6A21\u5F0F '${thoughtPath}' \u672A\u627E\u5230\u3002\u53EF\u7528\u601D\u7EF4\u6A21\u5F0F: ${availableThoughts}`);
          }
          const result = await this.registryManager.loadResourceByProtocol(resourceData.reference);
          return result;
        } catch (error) {
          throw new Error(`ThoughtProtocol.resolve failed: ${error.message}`);
        }
      }
      /**
       * 加载资源内容
       */
      async loadContent(resolvedPath, queryParams) {
        try {
          const content = await fs.readFile(resolvedPath, "utf-8");
          return content;
        } catch (error) {
          throw new Error(`\u65E0\u6CD5\u52A0\u8F7D\u601D\u7EF4\u6A21\u5F0F\u6587\u4EF6 ${resolvedPath}: ${error.message}`);
        }
      }
      /**
       * 验证资源路径
       */
      validatePath(resourcePath) {
        return /^[a-zA-Z0-9_-]+$/.test(resourcePath);
      }
    };
    module2.exports = ThoughtProtocol;
  }
});

// src/resource/protocols/ExecutionProtocol.js
var require_ExecutionProtocol = __commonJS({
  "src/resource/protocols/ExecutionProtocol.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var ResourceProtocol = require_ResourceProtocol();
    var fs = require("fs-extra");
    var path = require("path");
    var ExecutionProtocol = class extends ResourceProtocol {
      constructor() {
        super("execution");
        this.registry = {};
        this.registryManager = null;
      }
      /**
       * 设置注册表管理器
       */
      setRegistryManager(manager) {
        this.registryManager = manager;
      }
      /**
       * 设置注册表
       */
      setRegistry(registry) {
        this.registry = registry || {};
      }
      /**
       * 获取协议信息
       */
      getProtocolInfo() {
        return {
          name: "execution",
          description: "\u6267\u884C\u6A21\u5F0F\u8D44\u6E90\u534F\u8BAE",
          location: "execution://{execution_id}",
          examples: [
            "execution://deal-at-reference",
            "execution://prompt-developer",
            "execution://memory-trigger"
          ]
        };
      }
      /**
       * 解析执行协议
       * @param {string} executionPath - 执行路径，如 'best-practice'
       * @param {Object} queryParams - 查询参数（暂未使用）
       * @returns {Promise<string>} 执行文件内容
       */
      async resolve(executionPath, queryParams = {}) {
        try {
          const fullResourceId = `execution:${executionPath}`;
          let resourceData = this.registryManager.registryData.findResourceById(executionPath, "execution");
          if (!resourceData) {
            resourceData = this.registryManager.registryData.findResourceById(fullResourceId);
          }
          if (!resourceData) {
            const availableExecutions = this.registryManager.registryData.getResourcesByProtocol("execution").map((r) => r.id).join(", ");
            throw new Error(`\u6267\u884C\u6A21\u5F0F '${executionPath}' \u672A\u627E\u5230\u3002\u53EF\u7528\u6267\u884C\u6A21\u5F0F: ${availableExecutions}`);
          }
          const result = await this.registryManager.loadResourceByProtocol(resourceData.reference);
          return result;
        } catch (error) {
          throw new Error(`ExecutionProtocol.resolve failed: ${error.message}`);
        }
      }
      /**
       * 加载资源内容
       */
      async loadContent(resolvedPath, queryParams) {
        try {
          const content = await fs.readFile(resolvedPath, "utf-8");
          return content;
        } catch (error) {
          throw new Error(`\u65E0\u6CD5\u52A0\u8F7D\u6267\u884C\u6A21\u5F0F\u6587\u4EF6 ${resolvedPath}: ${error.message}`);
        }
      }
      /**
       * 验证资源路径
       */
      validatePath(resourcePath) {
        return /^[a-zA-Z0-9_-]+$/.test(resourcePath);
      }
    };
    module2.exports = ExecutionProtocol;
  }
});

// src/resource/protocols/KnowledgeProtocol.js
var require_KnowledgeProtocol = __commonJS({
  "src/resource/protocols/KnowledgeProtocol.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var ResourceProtocol = require_ResourceProtocol();
    var fs = require("fs-extra");
    var path = require("path");
    var KnowledgeProtocol = class extends ResourceProtocol {
      constructor() {
        super("knowledge");
        this.registry = {};
        this.registryManager = null;
      }
      /**
       * 设置注册表管理器
       */
      setRegistryManager(manager) {
        this.registryManager = manager;
      }
      /**
       * 设置注册表
       */
      setRegistry(registry) {
        this.registry = registry || {};
      }
      /**
       * 获取协议信息
       */
      getProtocolInfo() {
        return {
          name: "knowledge",
          description: "\u77E5\u8BC6\u8D44\u6E90\u534F\u8BAE",
          location: "knowledge://{knowledge_id}",
          examples: [
            "knowledge://xiaohongshu-marketing",
            "knowledge://ai-tools-guide"
          ]
        };
      }
      /**
       * 解析知识协议
       * @param {string} knowledgePath - 知识路径，如 'scrum'
       * @param {Object} queryParams - 查询参数（暂未使用）
       * @returns {Promise<string>} 知识文件内容
       */
      async resolve(knowledgePath, queryParams = {}) {
        try {
          const fullResourceId = `knowledge:${knowledgePath}`;
          let resourceData = this.registryManager.registryData.findResourceById(knowledgePath, "knowledge");
          if (!resourceData) {
            resourceData = this.registryManager.registryData.findResourceById(fullResourceId);
          }
          if (!resourceData) {
            const availableKnowledge = this.registryManager.registryData.getResourcesByProtocol("knowledge").map((r) => r.id).join(", ");
            throw new Error(`\u77E5\u8BC6\u6A21\u5757 '${knowledgePath}' \u672A\u627E\u5230\u3002\u53EF\u7528\u77E5\u8BC6\u6A21\u5757: ${availableKnowledge}`);
          }
          const result = await this.registryManager.loadResourceByProtocol(resourceData.reference);
          return result;
        } catch (error) {
          throw new Error(`KnowledgeProtocol.resolve failed: ${error.message}`);
        }
      }
      /**
       * 加载资源内容
       */
      async loadContent(resolvedPath, queryParams) {
        try {
          const content = await fs.readFile(resolvedPath, "utf-8");
          return content;
        } catch (error) {
          throw new Error(`\u65E0\u6CD5\u52A0\u8F7D\u77E5\u8BC6\u8D44\u6E90\u6587\u4EF6 ${resolvedPath}: ${error.message}`);
        }
      }
      /**
       * 验证资源路径
       */
      validatePath(resourcePath) {
        return /^[a-zA-Z0-9_-]+$/.test(resourcePath);
      }
    };
    module2.exports = KnowledgeProtocol;
  }
});

// src/resource/protocols/ToolProtocol.js
var require_ToolProtocol = __commonJS({
  "src/resource/protocols/ToolProtocol.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var ResourceProtocol = require_ResourceProtocol();
    var ToolProtocol = class extends ResourceProtocol {
      constructor() {
        super("tool");
        this.registryManager = null;
      }
      /**
       * 设置注册表管理器引用
       * @param {Object} manager - ResourceManager实例
       */
      setRegistryManager(manager) {
        this.registryManager = manager;
      }
      /**
       * 解析工具资源路径
       * @param {string} toolPath - 工具名称，如 "calculator"
       * @param {Object} queryParams - 查询参数（可选）
       * @returns {Promise<Object>} 工具代码和元数据
       */
      async resolve(toolPath, queryParams = {}) {
        if (!this.registryManager) {
          throw new Error("ToolProtocol: Registry manager not set");
        }
        const toolResource = this.registryManager.registryData.findResourceById(toolPath, "tool");
        if (!toolResource) {
          throw new Error(`Tool '${toolPath}' not found in registry`);
        }
        const toolContent = await this.registryManager.loadResourceByProtocol(toolResource.reference);
        this.validateToolContent(toolContent, toolPath);
        return {
          id: toolPath,
          content: toolContent,
          metadata: toolResource,
          source: toolResource.source || "unknown"
        };
      }
      /**
       * 验证工具内容格式
       * @param {string} content - 工具文件内容
       * @param {string} toolPath - 工具路径
       */
      validateToolContent(content, toolPath) {
        if (!content || typeof content !== "string") {
          throw new Error(`Tool '${toolPath}': Invalid or empty content`);
        }
        try {
          new Function(content);
        } catch (syntaxError) {
          throw new Error(`Tool '${toolPath}': JavaScript syntax error - ${syntaxError.message}`);
        }
      }
      /**
       * 获取协议信息
       * @returns {Object} 协议描述信息
       */
      getProtocolInfo() {
        return {
          name: "tool",
          description: "Tool\u8D44\u6E90\u534F\u8BAE - \u52A0\u8F7D\u53EF\u6267\u884C\u7684JavaScript\u5DE5\u5177",
          syntax: "tool://{tool_id}",
          examples: [
            "tool://calculator",
            "tool://send-email",
            "tool://data-processor",
            "tool://api-client"
          ],
          supportedFileTypes: [".tool.js"],
          usageNote: "\u5DE5\u5177\u6587\u4EF6\u5FC5\u987B\u5BFC\u51FA\u7B26\u5408PromptX Tool Interface\u7684\u5BF9\u8C61"
        };
      }
      /**
       * 检查缓存策略
       * @param {string} toolPath - 工具路径
       * @returns {boolean} 是否应该缓存
       */
      shouldCache(toolPath) {
        return true;
      }
      /**
       * 获取缓存键
       * @param {string} toolPath - 工具路径
       * @returns {string} 缓存键
       */
      getCacheKey(toolPath) {
        return `tool://${toolPath}`;
      }
    };
    module2.exports = ToolProtocol;
  }
});

// src/resource/protocols/ManualProtocol.js
var require_ManualProtocol = __commonJS({
  "src/resource/protocols/ManualProtocol.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var ResourceProtocol = require_ResourceProtocol();
    var ManualProtocol = class extends ResourceProtocol {
      constructor() {
        super("manual");
        this.registryManager = null;
      }
      /**
       * 设置注册表管理器引用
       * @param {Object} manager - ResourceManager实例
       */
      setRegistryManager(manager) {
        this.registryManager = manager;
      }
      /**
       * 解析工具手册资源路径
       * @param {string} manualPath - 手册名称，如 "calculator"
       * @param {Object} queryParams - 查询参数（可选）
       * @returns {Promise<Object>} 手册内容和元数据
       */
      async resolve(manualPath, queryParams = {}) {
        if (!this.registryManager) {
          throw new Error("ManualProtocol: Registry manager not set");
        }
        const manualResource = this.registryManager.registryData.findResourceById(manualPath, "manual");
        if (!manualResource) {
          const toolResource = this.registryManager.registryData.findResourceById(manualPath, "tool");
          if (toolResource) {
            throw new Error(`Manual '${manualPath}' not found. Found corresponding tool but no manual. Consider creating ${manualPath}.manual.md`);
          }
          throw new Error(`Manual '${manualPath}' not found in registry`);
        }
        const manualContent = await this.registryManager.loadResourceByProtocol(manualResource.reference);
        this.validateManualContent(manualContent, manualPath);
        return {
          id: manualPath,
          content: manualContent,
          metadata: manualResource,
          source: manualResource.source || "unknown"
        };
      }
      /**
       * 验证手册内容格式
       * @param {string} content - 手册文件内容
       * @param {string} manualPath - 手册路径
       */
      validateManualContent(content, manualPath) {
        if (!content || typeof content !== "string") {
          throw new Error(`Manual '${manualPath}': Invalid or empty content`);
        }
        const trimmedContent = content.trim();
        if (trimmedContent.length === 0) {
          throw new Error(`Manual '${manualPath}': Empty manual content`);
        }
        if (!trimmedContent.includes("<manual>") || !trimmedContent.includes("</manual>")) {
          throw new Error(`Manual '${manualPath}': Missing required <manual> tags`);
        }
      }
      /**
       * 获取协议信息
       * @returns {Object} 协议描述信息
       */
      getProtocolInfo() {
        return {
          name: "manual",
          description: "Manual\u8D44\u6E90\u534F\u8BAE - \u52A0\u8F7D\u5DE5\u5177\u4F7F\u7528\u624B\u518C\u548C\u8BF4\u660E\u6587\u6863",
          syntax: "manual://{manual_id}",
          examples: [
            "manual://calculator",
            "manual://send-email",
            "manual://data-processor",
            "manual://api-client"
          ],
          supportedFileTypes: [".manual.md"],
          usageNote: "\u624B\u518C\u6587\u4EF6\u5FC5\u987B\u4F7F\u7528<manual>\u6807\u7B7E\u5305\u88F9\u5185\u5BB9\uFF0C\u63D0\u4F9B\u5DE5\u5177\u7684\u8BE6\u7EC6\u4F7F\u7528\u8BF4\u660E"
        };
      }
      /**
       * 检查缓存策略
       * @param {string} manualPath - 手册路径
       * @returns {boolean} 是否应该缓存
       */
      shouldCache(manualPath) {
        return true;
      }
      /**
       * 获取缓存键
       * @param {string} manualPath - 手册路径
       * @returns {string} 缓存键
       */
      getCacheKey(manualPath) {
        return `manual://${manualPath}`;
      }
    };
    module2.exports = ManualProtocol;
  }
});

// src/resource/protocols/FileProtocol.js
var require_FileProtocol = __commonJS({
  "src/resource/protocols/FileProtocol.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var ResourceProtocol = require_ResourceProtocol();
    var path = require("path");
    var fs = require("fs").promises;
    var FileProtocol = class extends ResourceProtocol {
      constructor(options = {}) {
        super("file", options);
      }
      /**
       * 设置注册表（保持与其他协议的一致性）
       */
      setRegistry(registry) {
        this.registry = registry || {};
      }
      /**
       * 获取协议信息
       * @returns {object} 协议信息
       */
      getProtocolInfo() {
        return {
          name: "file",
          description: "\u6587\u4EF6\u7CFB\u7EDF\u534F\u8BAE\uFF0C\u63D0\u4F9B\u672C\u5730\u6587\u4EF6\u8BBF\u95EE",
          location: "file://{path}",
          examples: [
            "file://package.json",
            "file:///absolute/path/to/file.txt",
            "file://./relative/path/file.md",
            "file://../parent/file.json"
          ],
          params: this.getSupportedParams()
        };
      }
      /**
       * 支持的查询参数
       * @returns {object} 参数说明
       */
      getSupportedParams() {
        return {
          ...super.getSupportedParams(),
          encoding: "string - \u6587\u4EF6\u7F16\u7801 (utf8, ascii, binary\u7B49)",
          exists: "boolean - \u4EC5\u8FD4\u56DE\u5B58\u5728\u7684\u6587\u4EF6"
        };
      }
      /**
       * 验证文件协议路径
       * @param {string} resourcePath - 资源路径
       * @returns {boolean} 是否有效
       */
      validatePath(resourcePath) {
        if (!super.validatePath(resourcePath)) {
          return false;
        }
        return typeof resourcePath === "string" && resourcePath.length > 0;
      }
      /**
       * 解析文件路径
       * @param {string} resourcePath - 原始资源路径
       * @param {QueryParams} queryParams - 查询参数
       * @returns {Promise<string>} 解析后的绝对路径
       */
      async resolvePath(resourcePath, queryParams) {
        let resolvedPath;
        if (path.isAbsolute(resourcePath)) {
          resolvedPath = resourcePath;
        } else {
          resolvedPath = path.resolve(process.cwd(), resourcePath);
        }
        resolvedPath = path.normalize(resolvedPath);
        return resolvedPath;
      }
      /**
       * 加载资源内容
       * @param {string} resolvedPath - 解析后的路径
       * @param {QueryParams} queryParams - 查询参数
       * @returns {Promise<string>} 资源内容
       */
      async loadContent(resolvedPath, queryParams) {
        try {
          const stats = await fs.stat(resolvedPath);
          if (stats.isDirectory()) {
            return await this.loadDirectoryContent(resolvedPath, queryParams);
          } else if (stats.isFile()) {
            return await this.loadFileContent(resolvedPath, queryParams);
          } else {
            throw new Error(`\u4E0D\u652F\u6301\u7684\u6587\u4EF6\u7C7B\u578B: ${resolvedPath}`);
          }
        } catch (error) {
          if (error.code === "ENOENT") {
            if (queryParams && queryParams.get("exists") === "false") {
              return "";
            }
            throw new Error(`\u6587\u4EF6\u6216\u76EE\u5F55\u4E0D\u5B58\u5728: ${resolvedPath}`);
          }
          throw error;
        }
      }
      /**
       * 加载文件内容
       * @param {string} filePath - 文件路径
       * @param {QueryParams} queryParams - 查询参数
       * @returns {Promise<string>} 文件内容
       */
      async loadFileContent(filePath, queryParams) {
        const encoding = (queryParams == null ? void 0 : queryParams.get("encoding")) || "utf8";
        return await fs.readFile(filePath, encoding);
      }
      /**
       * 加载目录内容
       * @param {string} dirPath - 目录路径
       * @param {QueryParams} queryParams - 查询参数
       * @returns {Promise<string>} 目录内容列表
       */
      async loadDirectoryContent(dirPath, queryParams) {
        const entries = await fs.readdir(dirPath, { withFileTypes: true });
        const typeFilter = queryParams == null ? void 0 : queryParams.get("type");
        let filteredEntries = entries;
        if (typeFilter) {
          filteredEntries = entries.filter((entry) => {
            switch (typeFilter) {
              case "file":
                return entry.isFile();
              case "dir":
                return entry.isDirectory();
              case "both":
                return true;
              default:
                return true;
            }
          });
        }
        const format = (queryParams == null ? void 0 : queryParams.get("format")) || "list";
        switch (format) {
          case "json":
            return JSON.stringify(
              filteredEntries.map((entry) => ({
                name: entry.name,
                type: entry.isDirectory() ? "directory" : "file",
                path: path.join(dirPath, entry.name)
              })),
              null,
              2
            );
          case "paths":
            return filteredEntries.map((entry) => path.join(dirPath, entry.name)).join("\n");
          case "list":
          default:
            return filteredEntries.map((entry) => {
              const type = entry.isDirectory() ? "[DIR]" : "[FILE]";
              return `${type} ${entry.name}`;
            }).join("\n");
        }
      }
    };
    module2.exports = FileProtocol;
  }
});

// src/resource/resourceManager.js
var require_resourceManager = __commonJS({
  "src/resource/resourceManager.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var fs = require("fs");
    var RegistryData = require_RegistryData();
    var ResourceProtocolParser = require_resourceProtocolParser();
    var DiscoveryManager = require_DiscoveryManager();
    var logger = require("@promptx/logger");
    var PackageProtocol = require_PackageProtocol();
    var ProjectProtocol = require_ProjectProtocol();
    var RoleProtocol = require_RoleProtocol();
    var ThoughtProtocol = require_ThoughtProtocol();
    var ExecutionProtocol = require_ExecutionProtocol();
    var KnowledgeProtocol = require_KnowledgeProtocol();
    var ToolProtocol = require_ToolProtocol();
    var ManualProtocol = require_ManualProtocol();
    var UserProtocol = require_UserProtocol();
    var FileProtocol = require_FileProtocol();
    var ResourceManager = class {
      constructor() {
        this.registryData = RegistryData.createEmpty("merged", null);
        this.protocolParser = new ResourceProtocolParser();
        this.parser = new ResourceProtocolParser();
        this.discoveryManager = new DiscoveryManager();
        this.protocols = /* @__PURE__ */ new Map();
        this.initializeProtocols();
      }
      /**
       * 初始化所有协议处理器
       */
      initializeProtocols() {
        this.protocols.set("package", new PackageProtocol());
        this.protocols.set("project", new ProjectProtocol());
        this.protocols.set("file", new FileProtocol());
        this.protocols.set("user", new UserProtocol());
        this.protocols.set("role", new RoleProtocol());
        this.protocols.set("thought", new ThoughtProtocol());
        this.protocols.set("execution", new ExecutionProtocol());
        this.protocols.set("knowledge", new KnowledgeProtocol());
        this.protocols.set("tool", new ToolProtocol());
        this.protocols.set("manual", new ManualProtocol());
      }
      /**
       * 新架构初始化方法
       */
      async initializeWithNewArchitecture() {
        try {
          logger.info("[ResourceManager] Starting initialization...");
          this.registryData.clear();
          logger.info("[ResourceManager] Cleared existing registry");
          if (this.discoveryManager && typeof this.discoveryManager.clearCache === "function") {
            this.discoveryManager.clearCache();
            logger.info("[ResourceManager] Cleared discovery cache");
          }
          logger.info("[ResourceManager] Populating registry data...");
          await this.populateRegistryData();
          this.setupLogicalProtocols();
          this.initialized = true;
          const stats = this.registryData.getStats();
          logger.info("[ResourceManager] Initialization complete:", {
            totalResources: this.registryData.size,
            bySource: stats.bySource,
            byProtocol: stats.byProtocol
          });
        } catch (error) {
          logger.warn(`ResourceManager new architecture initialization failed: ${error.message}`);
          logger.warn("ResourceManager continuing with empty registry");
          this.initialized = true;
        }
      }
      /**
       * 填充新的RegistryData
       */
      async populateRegistryData() {
        this.registryData.clear();
        logger.info("[ResourceManager] Discovery managers:", {
          count: this.discoveryManager.discoveries.length,
          sources: this.discoveryManager.discoveries.map((d) => d.source)
        });
        for (const discovery of this.discoveryManager.discoveries) {
          try {
            logger.info(`[ResourceManager] Loading from ${discovery.source} discovery...`);
            if (typeof discovery.getRegistryData === "function") {
              const registryData = await discovery.getRegistryData();
              if (registryData && registryData.resources) {
                const resourceCount = registryData.size || 0;
                logger.info(`[ResourceManager] Found ${resourceCount} resources from ${discovery.source}`);
                this.registryData.merge(registryData, true);
                if (discovery.source === "USER" && registryData.resources) {
                  logger.debug(`[ResourceManager] USER resources to merge:`, registryData.resources.map((r) => `${r.protocol}://${r.id}`));
                }
                logger.info(`[ResourceManager] After merging ${discovery.source}, total: ${this.registryData.size}`);
              } else {
                logger.info(`[ResourceManager] No resources found from ${discovery.source}`);
              }
            } else {
              logger.info(`[ResourceManager] ${discovery.source} does not support getRegistryData`);
            }
          } catch (error) {
            logger.warn(`Failed to get RegistryData from ${discovery.source}: ${error.message}`);
          }
        }
        logger.info("[ResourceManager] Registry population complete, total resources:", this.registryData.size);
      }
      /**
       * 为逻辑协议设置注册表引用
       */
      setupLogicalProtocols() {
        const roleProtocol = this.protocols.get("role");
        const executionProtocol = this.protocols.get("execution");
        const thoughtProtocol = this.protocols.get("thought");
        const knowledgeProtocol = this.protocols.get("knowledge");
        const toolProtocol = this.protocols.get("tool");
        const manualProtocol = this.protocols.get("manual");
        if (roleProtocol) {
          roleProtocol.setRegistryManager(this);
        }
        if (executionProtocol) {
          executionProtocol.setRegistryManager(this);
        }
        if (thoughtProtocol) {
          thoughtProtocol.setRegistryManager(this);
        }
        if (knowledgeProtocol) {
          knowledgeProtocol.setRegistryManager(this);
        }
        if (toolProtocol) {
          toolProtocol.setRegistryManager(this);
        }
        if (manualProtocol) {
          manualProtocol.setRegistryManager(this);
        }
      }
      /**
       * 通过协议解析加载资源内容
       * @param {string} reference - 资源引用
       * @returns {Promise<string>} 资源内容
       */
      async loadResourceByProtocol(reference) {
        const parsed = this.protocolParser.parse(reference);
        const protocol = this.protocols.get(parsed.protocol);
        if (!protocol) {
          throw new Error(`\u4E0D\u652F\u6301\u7684\u534F\u8BAE: ${parsed.protocol}`);
        }
        const result = await protocol.resolve(parsed.path, parsed.queryParams);
        if (typeof result === "string") {
          return result;
        } else if (result && typeof result === "object" && result.content) {
          return result.content;
        } else {
          throw new Error(`\u534F\u8BAE${parsed.protocol}\u8FD4\u56DE\u4E86\u65E0\u6548\u7684\u5185\u5BB9\u683C\u5F0F`);
        }
      }
      async loadResource(resourceId) {
        try {
          if (!this.initialized) {
            logger.info("[ResourceManager] Initializing resource manager...");
            await this.initializeWithNewArchitecture();
          }
          if (resourceId.startsWith("@")) {
            const parsed = this.protocolParser.parse(resourceId);
            const basicProtocols = ["file", "user", "package", "project"];
            if (basicProtocols.includes(parsed.protocol)) {
              const content3 = await this.loadResourceByProtocol(resourceId);
              return {
                success: true,
                content: content3,
                resourceId,
                reference: resourceId
              };
            }
            logger.debug(`[ResourceManager] Finding resource: protocol=${parsed.protocol}, id=${parsed.path}`);
            const resourceData = this.registryData.findResourceById(parsed.path, parsed.protocol);
            if (!resourceData) {
              const availableResources = this.registryData.getResourcesByProtocol(parsed.protocol);
              logger.error(`[ResourceManager] Resource not found: ${parsed.protocol}:${parsed.path}`);
              logger.error(`[ResourceManager] Available ${parsed.protocol} resources:`, availableResources.map((r) => `${r.id} (${r.source})`));
              throw new Error(`Resource not found: ${parsed.protocol}:${parsed.path}`);
            }
            logger.debug(`[ResourceManager] Found resource: ${resourceData.id} from ${resourceData.source}`);
            const content2 = await this.loadResourceByProtocol(resourceData.reference);
            return {
              success: true,
              content: content2,
              resourceId,
              reference: resourceData.reference
            };
          }
          const urlMatch = resourceId.match(/^([a-zA-Z][a-zA-Z0-9_-]*):\/\/(.+)$/);
          if (urlMatch) {
            const [, protocol, id] = urlMatch;
            const resourceData = this.registryData.findResourceById(id, protocol);
            if (!resourceData) {
              throw new Error(`Resource not found: ${resourceId}`);
            }
            const content2 = await this.loadResourceByProtocol(resourceData.reference);
            return {
              success: true,
              content: content2,
              resourceId,
              reference: resourceData.reference
            };
          }
          let reference = null;
          if (resourceId.includes(":")) {
            const [protocol, id] = resourceId.split(":", 2);
            const resourceData = this.registryData.findResourceById(id, protocol);
            if (resourceData) {
              reference = resourceData.reference;
            }
          } else {
            const resourceData = this.registryData.findResourceById(resourceId);
            if (resourceData) {
              reference = resourceData.reference;
            }
          }
          if (!reference) {
            throw new Error(`Resource not found: ${resourceId}`);
          }
          const content = await this.loadResourceByProtocol(reference);
          return {
            success: true,
            content,
            resourceId,
            reference
          };
        } catch (error) {
          logger.debug(`ResourceManager.loadResource failed for ${resourceId}: ${error.message}`);
          return {
            success: false,
            error,
            // 返回完整的Error对象，而不是message字符串
            resourceId
          };
        }
      }
      /**
       * 解析协议引用并返回相关信息
       */
      async resolveProtocolReference(reference) {
        try {
          const parsed = this.protocolParser.parse(reference);
          return {
            success: true,
            protocol: parsed.protocol,
            path: parsed.path,
            queryParams: parsed.queryParams,
            reference
          };
        } catch (error) {
          return {
            success: false,
            error: error.message,
            reference
          };
        }
      }
      /**
       * 获取所有可用的协议列表
       */
      getAvailableProtocols() {
        return Array.from(this.protocols.keys());
      }
      /**
       * 检查是否支持指定协议
       */
      supportsProtocol(protocol) {
        return this.protocols.has(protocol);
      }
      /**
       * 设置初始化状态
       */
      set initialized(value) {
        this._initialized = value;
      }
      /**
       * 获取初始化状态
       */
      get initialized() {
        return this._initialized || false;
      }
      /**
       * 解析资源URL（向后兼容接口）
       * 返回格式：{success: boolean, content?: string, error?: Error}
       */
      async resolve(resourceUrl) {
        return await this.loadResource(resourceUrl);
      }
      /**
       * 获取注册表统计信息
       */
      getStats() {
        return {
          totalResources: this.registryData.size,
          protocols: this.getAvailableProtocols(),
          initialized: this.initialized
        };
      }
      /**
       * 刷新资源（重新发现并注册）
       */
      async refreshResources() {
        try {
          this.initialized = false;
          this.registryData.clear();
          if (this.discoveryManager && typeof this.discoveryManager.clearCache === "function") {
            this.discoveryManager.clearCache();
          }
          await this.initializeWithNewArchitecture();
        } catch (error) {
          logger.warn(`ResourceManager resource refresh failed: ${error.message}`);
        }
      }
    };
    module2.exports = ResourceManager;
  }
});

// src/resource/index.js
var require_resource = __commonJS({
  "src/resource/index.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var ResourceManager = require_resourceManager();
    var ResourceProtocolParser = require_resourceProtocolParser();
    var {
      LoadingSemantics,
      ParsedReference,
      QueryParams,
      NestedReference,
      ResourceContent,
      LazyResource,
      ProcessedResult,
      ResourceResult,
      ProtocolInfo
    } = require_types();
    var globalResourceManager = null;
    function getGlobalResourceManager() {
      if (!globalResourceManager) {
        globalResourceManager = new ResourceManager();
      }
      return globalResourceManager;
    }
    function resetGlobalResourceManager() {
      globalResourceManager = null;
    }
    module2.exports = {
      // 主管理器类
      ResourceManager,
      // 全局单例实例
      getGlobalResourceManager,
      resetGlobalResourceManager,
      // 核心组件
      ResourceProtocolParser,
      // 数据类型
      LoadingSemantics,
      ParsedReference,
      QueryParams,
      NestedReference,
      ResourceContent,
      LazyResource,
      ProcessedResult,
      ResourceResult,
      ProtocolInfo,
      // 便捷方法 - 创建默认实例（保持向后兼容）
      createManager: (options) => new ResourceManager(options),
      // 便捷方法 - 快速解析
      parse: (resourceRef) => {
        const parser = new ResourceProtocolParser();
        return parser.parse(resourceRef);
      },
      // 便捷方法 - 快速验证
      validate: (resourceRef) => {
        try {
          const parser = new ResourceProtocolParser();
          parser.parse(resourceRef);
          return true;
        } catch (error) {
          return false;
        }
      }
    };
  }
});

// src/toolx/SandboxIsolationManager.js
var require_SandboxIsolationManager = __commonJS({
  "src/toolx/SandboxIsolationManager.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var path = require("path");
    var Module = require("module");
    var logger = require("@promptx/logger");
    var SandboxIsolationManager = class {
      constructor(workingPath, options = {}) {
        this.workingPath = workingPath;
        this.toolboxPath = options.toolboxPath || workingPath;
        this.sandboxPath = workingPath;
        this.options = {
          enableDependencyLoading: true,
          enableBuiltinModules: true,
          enableFileSystemAccess: false,
          ...options
        };
        this.isolatedContext = null;
      }
      /**
       * 创建完全隔离的沙箱环境
       * @returns {Object} 隔离的沙箱上下文
       */
      createIsolatedContext() {
        if (this.isolatedContext) {
          return this.isolatedContext;
        }
        this.isolatedContext = {
          // 1. 模块系统隔离 - 核心功能
          require: this.createIsolatedRequire(),
          module: { exports: {} },
          exports: {},
          // 2. 进程环境隔离
          process: this.createIsolatedProcess(),
          // 3. 全局对象隔离
          ...this.createIsolatedGlobals(),
          // 4. 路径相关隔离
          __dirname: this.workingPath,
          __filename: path.join(this.workingPath, "sandbox.js"),
          // 5. 注入受限的 fs（直接可用）
          fs: this.createRestrictedFS(),
          // 6. 阻止动态代码执行
          eval: () => {
            throw new Error("[SandboxIsolation] eval is not allowed in sandbox");
          },
          Function: void 0
        };
        return this.isolatedContext;
      }
      /**
       * 创建隔离的require函数 - 解决核心依赖加载问题
       * @returns {Function} 隔离的require函数
       */
      createIsolatedRequire() {
        const contextFile = path.join(this.toolboxPath, "package.json");
        let sandboxRequire;
        try {
          sandboxRequire = Module.createRequire(contextFile);
        } catch (error) {
          const virtualContextFile = path.join(this.toolboxPath, "virtual-context.js");
          sandboxRequire = Module.createRequire(virtualContextFile);
        }
        return (moduleName) => {
          if (moduleName === "fs" || moduleName === "fs/promises") {
            return this.createRestrictedFS();
          }
          if (moduleName === "child_process") {
            throw new Error("[SandboxIsolation] child_process is not allowed in sandbox");
          }
          if (moduleName === "path") {
            return this.createRestrictedPath();
          }
          try {
            return sandboxRequire(moduleName);
          } catch (error) {
            return this.handleRequireFallback(moduleName, error);
          }
        };
      }
      /**
       * 处理require失败的智能fallback
       * @param {string} moduleName - 模块名
       * @param {Error} error - 原始错误
       * @returns {*} 模块对象或抛出错误
       */
      handleRequireFallback(moduleName, error) {
        if (this.options.enableBuiltinModules && this.isBuiltinModule(moduleName)) {
          try {
            return require(moduleName);
          } catch (builtinError) {
          }
        }
        if (this.options.analysisMode && error.code === "MODULE_NOT_FOUND") {
          logger.debug(`[SandboxIsolation] Analysis mode: mocking module ${moduleName}`);
          return this.createMockModule();
        }
        throw error;
      }
      /**
       * 检查是否为Node.js内置模块
       * @param {string} moduleName - 模块名
       * @returns {boolean} 是否为内置模块
       */
      isBuiltinModule(moduleName) {
        const builtinModules = [
          "path",
          "fs",
          "url",
          "crypto",
          "util",
          "os",
          "events",
          "stream",
          "http",
          "https",
          "querystring",
          "zlib",
          "buffer",
          "child_process"
        ];
        return builtinModules.includes(moduleName) || moduleName.startsWith("node:");
      }
      /**
       * 创建mock模块对象
       * @returns {Object} mock对象
       */
      createMockModule() {
        return new Proxy({}, {
          get: () => () => ({}),
          // 所有属性和方法都返回空函数/对象
          apply: () => ({}),
          // 如果被当作函数调用
          construct: () => ({})
          // 如果被当作构造函数
        });
      }
      /**
       * 创建受限的文件系统
       * 实现完全透明的拦截，在VM层面控制文件访问边界
       * @returns {Object} 受限的fs对象
       */
      createRestrictedFS() {
        const realFs = require("fs");
        const boundary = path.resolve(this.workingPath);
        logger.info(`[SandboxFS] Creating restricted FS with boundary: ${boundary}`);
        const resolveSafePath = (inputPath) => {
          if (!inputPath) {
            throw new Error("[SandboxFS] Path is required");
          }
          let resolved;
          if (path.isAbsolute(inputPath)) {
            resolved = path.resolve(inputPath);
          } else {
            resolved = path.resolve(boundary, inputPath);
          }
          resolved = path.normalize(resolved);
          if (!resolved.startsWith(boundary)) {
            logger.error(`[SandboxFS] \u6587\u4EF6\u8BBF\u95EE\u8D8A\u6743\u5C1D\u8BD5\uFF1A
          \u8F93\u5165\u8DEF\u5F84: ${inputPath}
          \u89E3\u6790\u7ED3\u679C: ${resolved}
          \u5141\u8BB8\u8FB9\u754C: ${boundary}
          \u8C03\u7528\u6808: ${new Error().stack}
        `);
            throw new Error(
              `[SandboxFS] \u6587\u4EF6\u8BBF\u95EE\u88AB\u62D2\u7EDD\uFF1A\u8DEF\u5F84 "${inputPath}" \u8D85\u51FA\u5DE5\u4F5C\u76EE\u5F55\u8FB9\u754C ${boundary}`
            );
          }
          return resolved;
        };
        const handler = {
          get(target, prop) {
            const original = target[prop];
            if (typeof original !== "function") {
              if (prop === "promises") {
                return new Proxy(realFs.promises, {
                  get(promiseTarget, promiseProp) {
                    const promiseOriginal = promiseTarget[promiseProp];
                    if (typeof promiseOriginal !== "function") {
                      return promiseOriginal;
                    }
                    return async function(...args) {
                      if (args.length > 0 && typeof args[0] === "string") {
                        args[0] = resolveSafePath(args[0]);
                      }
                      if ((promiseProp === "rename" || promiseProp === "copyFile") && args.length > 1) {
                        args[1] = resolveSafePath(args[1]);
                      }
                      return await promiseOriginal.apply(promiseTarget, args);
                    };
                  }
                });
              }
              return original;
            }
            return function(...args) {
              if (args.length > 0 && typeof args[0] === "string") {
                args[0] = resolveSafePath(args[0]);
              }
              if ((prop === "renameSync" || prop === "copyFileSync") && args.length > 1) {
                args[1] = resolveSafePath(args[1]);
              }
              return original.apply(target, args);
            };
          }
        };
        return new Proxy(realFs, handler);
      }
      /**
       * 创建受限的 path 模块
       * 防止使用 path.resolve 绕过限制
       * @returns {Object} 受限的path对象
       */
      createRestrictedPath() {
        const realPath = require("path");
        const boundary = path.resolve(this.workingPath);
        return new Proxy(realPath, {
          get(target, prop) {
            if (prop === "resolve") {
              return (...args) => {
                const resolved = target.resolve(...args);
                if (!resolved.startsWith(boundary)) {
                  logger.warn(`[SandboxPath] path.resolve \u5C1D\u8BD5\u8D8A\u6743: ${resolved}`);
                }
                return resolved;
              };
            }
            return target[prop];
          }
        });
      }
      /**
       * 创建隔离的process对象
       * @returns {Object} 隔离的process对象
       */
      createIsolatedProcess() {
        return {
          // 环境变量（浅拷贝，避免污染）
          env: { ...process.env },
          // 工作目录返回 workingPath（~/.promptx）
          cwd: () => this.workingPath,
          // 安全的只读属性
          version: process.version,
          platform: process.platform,
          arch: process.arch,
          pid: process.pid,
          // 时间相关
          hrtime: process.hrtime,
          uptime: process.uptime,
          // 禁用危险方法
          exit: () => {
            throw new Error("[SandboxIsolation] process.exit() is not allowed in sandbox");
          },
          abort: () => {
            throw new Error("[SandboxIsolation] process.abort() is not allowed in sandbox");
          },
          // 阻止底层访问
          binding: () => {
            throw new Error("[SandboxIsolation] process.binding() is not allowed in sandbox");
          },
          dlopen: () => {
            throw new Error("[SandboxIsolation] Native modules are not allowed in sandbox");
          }
        };
      }
      /**
       * 创建隔离的全局对象
       * @returns {Object} 安全的全局对象集合
       */
      createIsolatedGlobals() {
        return {
          // 基础类型
          Object,
          Array,
          String,
          Number,
          Boolean,
          Date,
          RegExp,
          Error,
          // JSON处理
          JSON,
          // 数学对象
          Math,
          // URL处理
          URL,
          URLSearchParams,
          // 缓冲区
          Buffer,
          // 定时器
          setTimeout,
          clearTimeout,
          setInterval,
          clearInterval,
          setImmediate,
          clearImmediate,
          // 输出
          console,
          // Keep console for sandboxed code
          // Promise相关
          Promise
        };
      }
      /**
       * 启用分析模式 - 用于工具分析阶段
       */
      enableAnalysisMode() {
        this.options.analysisMode = true;
        this.isolatedContext = null;
      }
      /**
       * 启用执行模式 - 用于工具执行阶段
       */
      enableExecutionMode() {
        this.options.analysisMode = false;
        this.isolatedContext = null;
      }
      /**
       * 清理隔离管理器
       */
      cleanup() {
        this.isolatedContext = null;
      }
      /**
       * 获取隔离状态信息
       * @returns {Object} 状态信息
       */
      getIsolationStatus() {
        return {
          sandboxPath: this.sandboxPath,
          options: this.options,
          contextCreated: !!this.isolatedContext,
          timestamp: (/* @__PURE__ */ new Date()).toISOString()
        };
      }
    };
    module2.exports = SandboxIsolationManager;
  }
});

// src/toolx/SandboxErrorManager.js
var require_SandboxErrorManager = __commonJS({
  "src/toolx/SandboxErrorManager.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var SandboxErrorManager = class {
      constructor() {
        this.version = "1.0.0";
      }
      /**
       * 分析原始错误并生成智能错误信息
       * @param {Error} originalError - 原始错误对象
       * @param {Object} context - 错误上下文信息
       * @param {string} context.toolId - 工具ID
       * @param {Array} context.dependencies - 声明的依赖列表
       * @param {string} context.sandboxPath - 沙箱路径
       * @param {string} context.phase - 执行阶段 (analyze|prepare|execute)
       * @returns {Object} 增强的错误信息
       */
      analyzeError(originalError, context = {}) {
        const errorType = this.classifyError(originalError, context);
        const agentInstructions = this.generateAgentInstructions(errorType, originalError, context);
        return {
          // 保持与ToolCommand兼容的原始信息
          originalError,
          message: originalError.message,
          // 增强的智能信息
          type: errorType,
          agentInstructions,
          context,
          // MCP友好的格式化消息
          formattedMessage: this.formatForMCP(errorType, originalError, agentInstructions, context)
        };
      }
      /**
       * 错误分类逻辑
       * @param {Error} error - 错误对象
       * @param {Object} context - 上下文信息
       * @returns {string} 错误类型
       */
      classifyError(error, context) {
        const message = error.message.toLowerCase();
        if (message.includes("cannot find module")) {
          const missingModule = this.extractModuleName(error.message);
          let isDeclaredDependency = false;
          if (Array.isArray(context.dependencies)) {
            isDeclaredDependency = context.dependencies.some(
              (dep) => dep.split("@")[0] === missingModule
            );
          } else if (typeof context.dependencies === "object" && context.dependencies) {
            isDeclaredDependency = Object.keys(context.dependencies).includes(missingModule);
          }
          if (isDeclaredDependency) {
            return "DEPENDENCY_MISSING";
          } else {
            return "UNDECLARED_DEPENDENCY";
          }
        }
        if (message.includes("pnpm install failed") || message.includes("dependency installation") || message.includes("npm err")) {
          return "DEPENDENCY_INSTALL_FAILED";
        }
        if (message.includes("failed to load tool") || message.includes("tool does not export") || message.includes("invalid tool export format")) {
          return "TOOL_LOADING_ERROR";
        }
        if (message.includes("parameter validation failed") || message.includes("missing required parameter")) {
          return "PARAMETER_VALIDATION_ERROR";
        }
        if (message.includes("sandbox") || message.includes("vm")) {
          return "SANDBOX_ENVIRONMENT_ERROR";
        }
        if (message.includes("timeout") || message.includes("etimedout")) {
          return "NETWORK_TIMEOUT";
        }
        return "UNKNOWN_ERROR";
      }
      /**
       * 为Agent生成智能指令
       * @param {string} errorType - 错误类型
       * @param {Error} originalError - 原始错误
       * @param {Object} context - 上下文
       * @returns {Object} Agent指令对象
       */
      generateAgentInstructions(errorType, originalError, context) {
        switch (errorType) {
          case "DEPENDENCY_MISSING":
            return {
              action: "AUTO_RETRY_WITH_FORCE_REINSTALL",
              autoRetryable: true,
              command: "\u81EA\u52A8\u91CD\u8BD5\uFF0C\u6DFB\u52A0 forceReinstall: true \u53C2\u6570",
              explanation: "\u4F9D\u8D56\u5DF2\u58F0\u660E\u4F46\u672A\u6B63\u786E\u5B89\u88C5\uFF0C\u901A\u8FC7\u5F3A\u5236\u91CD\u88C5\u53EF\u89E3\u51B3",
              userMessage: `\u68C0\u6D4B\u5230\u4F9D\u8D56 ${this.extractModuleName(originalError.message)} \u5B89\u88C5\u4E0D\u5B8C\u6574\uFF0C\u6B63\u5728\u81EA\u52A8\u91CD\u65B0\u5B89\u88C5...`,
              retryParameters: { forceReinstall: true }
            };
          case "UNDECLARED_DEPENDENCY": {
            const missingModule = this.extractModuleName(originalError.message);
            return {
              action: "REPORT_MISSING_DEPENDENCY",
              autoRetryable: false,
              command: "\u63D0\u793A\u5DE5\u5177\u5F00\u53D1\u8005\u6DFB\u52A0\u4F9D\u8D56\u58F0\u660E",
              explanation: `\u5DE5\u5177\u4EE3\u7801\u4F7F\u7528\u4E86\u672A\u58F0\u660E\u7684\u4F9D\u8D56: ${missingModule}`,
              userMessage: `\u274C \u5DE5\u5177\u7F3A\u5C11\u4F9D\u8D56\u58F0\u660E

\u{1F527} \u9700\u8981\u5728\u5DE5\u5177\u7684 getDependencies() \u65B9\u6CD5\u4E2D\u6DFB\u52A0\uFF1A
   '${missingModule}': 'latest'

\u{1F4DD} \u5B8C\u6574\u793A\u4F8B\uFF08\u65B0\u683C\u5F0F\uFF09\uFF1A
   getDependencies() {
     return {
       ${context.dependencies && typeof context.dependencies === "object" && !Array.isArray(context.dependencies) ? Object.entries(context.dependencies).map(([k, v]) => `'${k}': '${v}'`).join(",\n       ") + "," : "// \u5176\u4ED6\u4F9D\u8D56..."}
       '${missingModule}': 'latest'
     };
   }`,
              developerAction: `\u5728 ${context.toolId}.tool.js \u7684 getDependencies() \u4E2D\u6DFB\u52A0 '${missingModule}': 'latest'`
            };
          }
          case "DEPENDENCY_INSTALL_FAILED":
            return {
              action: "CHECK_NETWORK_AND_RETRY",
              autoRetryable: false,
              command: "\u68C0\u67E5\u7F51\u7EDC\u8FDE\u63A5\uFF0C\u5EFA\u8BAE\u7528\u6237\u7A0D\u540E\u91CD\u8BD5",
              explanation: "\u4F9D\u8D56\u5B89\u88C5\u8FC7\u7A0B\u5931\u8D25\uFF0C\u53EF\u80FD\u662F\u7F51\u7EDC\u95EE\u9898\u6216\u5305\u6E90\u95EE\u9898",
              userMessage: `\u274C \u4F9D\u8D56\u5B89\u88C5\u5931\u8D25

\u{1F310} \u53EF\u80FD\u539F\u56E0\uFF1A
   \u2022 \u7F51\u7EDC\u8FDE\u63A5\u4E0D\u7A33\u5B9A
   \u2022 npm/pnpm \u955C\u50CF\u6E90\u95EE\u9898
   \u2022 \u4F9D\u8D56\u5305\u7248\u672C\u4E0D\u5B58\u5728

\u{1F4A1} \u5EFA\u8BAE\u89E3\u51B3\u65B9\u6848\uFF1A
   1. \u68C0\u67E5\u7F51\u7EDC\u8FDE\u63A5
   2. \u7A0D\u540E\u91CD\u8BD5\uFF08\u4F7F\u7528 forceReinstall: true\uFF09
   3. \u5982\u679C\u6301\u7EED\u5931\u8D25\uFF0C\u8BF7\u8054\u7CFB\u5F00\u53D1\u8005`,
              retryDelay: 5e3
            };
          case "TOOL_LOADING_ERROR":
            return {
              action: "REPORT_TOOL_ERROR",
              autoRetryable: false,
              command: "\u62A5\u544A\u5DE5\u5177\u6587\u4EF6\u95EE\u9898",
              explanation: "\u5DE5\u5177\u4EE3\u7801\u672C\u8EAB\u5B58\u5728\u95EE\u9898\uFF0C\u9700\u8981\u5F00\u53D1\u8005\u4FEE\u590D",
              userMessage: `\u274C \u5DE5\u5177\u52A0\u8F7D\u5931\u8D25

\u{1F527} \u5DE5\u5177\u4EE3\u7801\u95EE\u9898\uFF1A${originalError.message}

\u{1F4A1} \u8FD9\u662F\u5DE5\u5177\u5F00\u53D1\u95EE\u9898\uFF0C\u8BF7\u8054\u7CFB\u5DE5\u5177\u4F5C\u8005\u4FEE\u590D`,
              developerAction: "\u68C0\u67E5\u5DE5\u5177\u7684 module.exports \u548C\u57FA\u672C\u8BED\u6CD5"
            };
          case "NETWORK_TIMEOUT":
            return {
              action: "RETRY_WITH_EXTENDED_TIMEOUT",
              autoRetryable: true,
              command: "\u81EA\u52A8\u91CD\u8BD5\uFF0C\u4F7F\u7528\u66F4\u957F\u7684\u8D85\u65F6\u65F6\u95F4",
              explanation: "\u7F51\u7EDC\u8D85\u65F6\uFF0C\u4F7F\u7528\u66F4\u957F\u8D85\u65F6\u65F6\u95F4\u91CD\u8BD5",
              userMessage: "\u23F0 \u7F51\u7EDC\u8D85\u65F6\uFF0C\u6B63\u5728\u4F7F\u7528\u66F4\u957F\u8D85\u65F6\u65F6\u95F4\u91CD\u8BD5...",
              retryParameters: { timeout: 6e4 }
              // 60秒
            };
          default:
            return {
              action: "REPORT_UNKNOWN_ERROR",
              autoRetryable: false,
              command: "\u62A5\u544A\u672A\u77E5\u9519\u8BEF\u7ED9\u7528\u6237",
              explanation: "\u672A\u77E5\u9519\u8BEF\u7C7B\u578B\uFF0C\u9700\u8981\u4EBA\u5DE5\u5206\u6790",
              userMessage: `\u274C \u6267\u884C\u5931\u8D25\uFF1A${originalError.message}

\u{1F916} \u8FD9\u662F\u4E00\u4E2A\u672A\u5206\u7C7B\u7684\u9519\u8BEF\uFF0C\u8BF7\u5C06\u6B64\u4FE1\u606F\u53CD\u9988\u7ED9\u5F00\u53D1\u8005\u4EE5\u6539\u8FDB\u9519\u8BEF\u5904\u7406`,
              debugInfo: {
                stack: originalError.stack,
                context
              }
            };
        }
      }
      /**
       * 为MCP协议格式化错误消息
       * @param {string} errorType - 错误类型
       * @param {Error} originalError - 原始错误
       * @param {Object} agentInstructions - Agent指令
       * @param {Object} context - 上下文
       * @returns {string} MCP友好的错误消息
       */
      formatForMCP(errorType, originalError, agentInstructions, context) {
        const emoji = this.getErrorEmoji(errorType);
        const timestamp = (/* @__PURE__ */ new Date()).toISOString();
        let message = `${emoji} ToolSandbox\u6267\u884C\u5931\u8D25

\u{1F3F7}\uFE0F \u9519\u8BEF\u7C7B\u578B: ${errorType}
\u23F0 \u65F6\u95F4: ${timestamp}
\u{1F527} \u5DE5\u5177: ${context.toolId || "unknown"}
\u{1F4C1} \u9636\u6BB5: ${context.phase || "unknown"}

\u{1F4CB} \u8BE6\u7EC6\u4FE1\u606F:
${originalError.message}

\u{1F916} AI\u5904\u7406\u5EFA\u8BAE:
${agentInstructions.userMessage || agentInstructions.explanation}`;
        if (agentInstructions.autoRetryable) {
          message += `

\u{1F504} \u81EA\u52A8\u6062\u590D: ${agentInstructions.action}
\u26A1 \u64CD\u4F5C: ${agentInstructions.command}`;
        }
        return message;
      }
      /**
       * 从错误消息中提取模块名
       * @param {string} errorMessage - 错误消息
       * @returns {string} 模块名
       */
      extractModuleName(errorMessage) {
        const match = errorMessage.match(/Cannot (?:find|resolve) module ['\"]([^'\"]+)['\"]/);
        return match ? match[1] : "unknown";
      }
      /**
       * 根据错误类型获取对应emoji
       * @param {string} errorType - 错误类型
       * @returns {string} emoji
       */
      getErrorEmoji(errorType) {
        const emojiMap = {
          "DEPENDENCY_MISSING": "\u{1F4E6}",
          "UNDECLARED_DEPENDENCY": "\u{1F50D}",
          "DEPENDENCY_INSTALL_FAILED": "\u{1F310}",
          "TOOL_LOADING_ERROR": "\u{1F527}",
          "PARAMETER_VALIDATION_ERROR": "\u{1F4DD}",
          "SANDBOX_ENVIRONMENT_ERROR": "\u{1F3D7}\uFE0F",
          "NETWORK_TIMEOUT": "\u23F0",
          "UNKNOWN_ERROR": "\u2753"
        };
        return emojiMap[errorType] || "\u274C";
      }
      /**
       * 检查错误是否可以自动恢复
       * @param {Object} intelligentError - 智能错误对象
       * @returns {boolean} 是否可自动恢复
       */
      isAutoRecoverable(intelligentError) {
        return intelligentError.agentInstructions.autoRetryable === true;
      }
      /**
       * 获取自动恢复的重试参数
       * @param {Object} intelligentError - 智能错误对象
       * @returns {Object|null} 重试参数
       */
      getRetryParameters(intelligentError) {
        return intelligentError.agentInstructions.retryParameters || null;
      }
    };
    module2.exports = SandboxErrorManager;
  }
});

// src/toolx/ToolDirectoryManager.js
var require_ToolDirectoryManager = __commonJS({
  "src/toolx/ToolDirectoryManager.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var path = require("path");
    var fs = require("fs").promises;
    var logger = require("@promptx/logger");
    var ToolDirectoryManager = class {
      constructor(toolId, resourceManager) {
        this.toolId = toolId;
        this.resourceManager = resourceManager;
        this.directories = {
          working: "@user://.promptx",
          // 工作目录
          toolbox: `@user://.promptx/toolbox/${toolId}`,
          // 工具隔离目录
          dependencies: `@user://.promptx/toolbox/${toolId}/node_modules`,
          // 依赖目录
          cache: `@user://.promptx/cache/${toolId}`,
          // 缓存目录
          temp: `@user://.promptx/temp/${toolId}`
          // 临时文件目录
        };
        this.resolvedPaths = {};
      }
      /**
       * 初始化所有路径（通过协议解析）
       */
      async initialize() {
        for (const [key, protocolPath] of Object.entries(this.directories)) {
          this.resolvedPaths[key] = await this.resolveProtocolPath(protocolPath);
        }
        logger.debug("[ToolDirectoryManager] Initialized paths:", this.resolvedPaths);
      }
      /**
       * 通过协议解析路径
       * @param {string} protocolPath - 协议路径，如 @user://.promptx
       * @returns {Promise<string>} 解析后的绝对路径
       */
      async resolveProtocolPath(protocolPath) {
        const result = await this.resourceManager.resolveProtocolReference(protocolPath);
        if (!result.success) {
          throw new Error(`Failed to resolve protocol path ${protocolPath}: ${result.error}`);
        }
        const protocol = this.resourceManager.protocols.get(result.protocol);
        if (!protocol) {
          throw new Error(`Protocol ${result.protocol} not supported`);
        }
        if (typeof protocol.resolvePath === "function") {
          return await protocol.resolvePath(result.path, result.queryParams || /* @__PURE__ */ new Map());
        } else {
          throw new Error(`Protocol ${result.protocol} does not support path resolution`);
        }
      }
      /**
       * 获取工作目录路径
       * @returns {string} 工作目录路径
       */
      getWorkingPath() {
        return this.resolvedPaths.working;
      }
      /**
       * 获取工具箱目录路径
       * @returns {string} 工具箱目录路径
       */
      getToolboxPath() {
        return this.resolvedPaths.toolbox;
      }
      /**
       * 获取依赖目录路径
       * @returns {string} node_modules 路径
       */
      getDependenciesPath() {
        return this.resolvedPaths.dependencies;
      }
      /**
       * 获取缓存目录路径
       * @returns {string} 缓存目录路径
       */
      getCachePath() {
        return this.resolvedPaths.cache;
      }
      /**
       * 获取临时目录路径
       * @returns {string} 临时目录路径
       */
      getTempPath() {
        return this.resolvedPaths.temp;
      }
      /**
       * 获取 package.json 路径
       * @returns {string} package.json 路径
       */
      getPackageJsonPath() {
        return path.join(this.resolvedPaths.toolbox, "package.json");
      }
      /**
       * 确保必要的目录存在
       */
      async ensureDirectories() {
        await this.ensureDirectory(this.resolvedPaths.working);
        await this.ensureDirectory(this.resolvedPaths.toolbox);
      }
      /**
       * 确保单个目录存在
       * @param {string} dirPath - 目录路径
       */
      async ensureDirectory(dirPath) {
        try {
          await fs.access(dirPath);
        } catch (error) {
          if (error.code === "ENOENT") {
            await fs.mkdir(dirPath, { recursive: true });
            logger.debug(`[ToolDirectoryManager] Created directory: ${dirPath}`);
          } else {
            throw error;
          }
        }
      }
      /**
       * 检查目录是否存在
       * @param {string} dirPath - 目录路径
       * @returns {Promise<boolean>} 是否存在
       */
      async directoryExists(dirPath) {
        try {
          await fs.access(dirPath);
          return true;
        } catch {
          return false;
        }
      }
      /**
       * 检查工具箱目录是否存在
       * @returns {Promise<boolean>}
       */
      async toolboxExists() {
        return await this.directoryExists(this.resolvedPaths.toolbox);
      }
      /**
       * 清理临时文件
       */
      async cleanupTemp() {
        if (this.resolvedPaths.temp && await this.directoryExists(this.resolvedPaths.temp)) {
          const { rmdir } = require("fs").promises;
          await rmdir(this.resolvedPaths.temp, { recursive: true });
          logger.debug(`[ToolDirectoryManager] Cleaned up temp directory: ${this.resolvedPaths.temp}`);
        }
      }
      /**
       * 删除工具箱目录（用于强制重建）
       */
      async deleteToolbox() {
        if (this.resolvedPaths.toolbox && await this.toolboxExists()) {
          const { rmdir } = require("fs").promises;
          await rmdir(this.resolvedPaths.toolbox, { recursive: true });
          logger.debug(`[ToolDirectoryManager] Deleted toolbox directory: ${this.resolvedPaths.toolbox}`);
        }
      }
      /**
       * 获取协议路径（用于日志或调试）
       * @param {string} key - 目录键名
       * @returns {string} 协议路径
       */
      getProtocolPath(key) {
        return this.directories[key];
      }
      /**
       * 支持自定义协议路径（未来扩展）
       * 比如支持 @project:// 或 @s3:// 等
       */
      async setCustomDirectory(key, protocolPath) {
        this.directories[key] = protocolPath;
        this.resolvedPaths[key] = await this.resolveProtocolPath(protocolPath);
      }
    };
    module2.exports = ToolDirectoryManager;
  }
});

// src/toolx/ESModuleRequireSupport.js
var require_ESModuleRequireSupport = __commonJS({
  "src/toolx/ESModuleRequireSupport.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var path = require("path");
    var fs = require("fs").promises;
    var logger = require("@promptx/logger");
    var ESModuleRequireSupport = class {
      constructor(toolboxPath) {
        this.toolboxPath = toolboxPath;
        this.moduleTypeCache = /* @__PURE__ */ new Map();
      }
      /**
       * 创建统一的 require 函数
       * 所有模块都返回 Promise，实现统一的使用体验
       * 
       * @param {Function} sandboxRequire - 沙箱环境的 require 函数
       * @returns {Function} 增强的 require 函数
       */
      createUnifiedRequire(sandboxRequire) {
        return async (moduleName) => {
          try {
            const moduleType = await this.detectModuleType(moduleName);
            logger.debug(`[ESModuleSupport] Loading ${moduleName} as ${moduleType}`);
            if (moduleType === "esm") {
              return await this.loadESModule(moduleName);
            } else {
              try {
                const module3 = sandboxRequire(moduleName);
                return Promise.resolve(module3);
              } catch (error) {
                if (error.code === "ERR_REQUIRE_ESM") {
                  logger.debug(`[ESModuleSupport] Fallback to ES Module for ${moduleName}`);
                  return await this.loadESModule(moduleName);
                }
                throw error;
              }
            }
          } catch (error) {
            logger.error(`[ESModuleSupport] Failed to load module ${moduleName}: ${error.message}`);
            throw new Error(`Cannot load module '${moduleName}': ${error.message}`);
          }
        };
      }
      /**
       * 检测模块类型
       * @param {string} moduleName - 模块名
       * @returns {Promise<string>} 'esm' | 'commonjs' | 'unknown'
       */
      async detectModuleType(moduleName) {
        if (this.moduleTypeCache.has(moduleName)) {
          return this.moduleTypeCache.get(moduleName);
        }
        try {
          const packagePath = this.resolvePackagePath(moduleName);
          const packageJsonPath = path.join(packagePath, "package.json");
          const packageJsonContent = await fs.readFile(packageJsonPath, "utf8");
          const packageJson = JSON.parse(packageJsonContent);
          let moduleType = "commonjs";
          if (packageJson.type === "module") {
            moduleType = "esm";
          } else if (packageJson.exports && typeof packageJson.exports === "object") {
            if (packageJson.exports.import || packageJson.exports["."] && packageJson.exports["."].import) {
              moduleType = "esm";
            }
          } else if (packageJson.module) {
            if (!packageJson.main) {
              moduleType = "esm";
            }
          }
          this.moduleTypeCache.set(moduleName, moduleType);
          logger.debug(`[ESModuleSupport] Module ${moduleName} detected as ${moduleType}`);
          return moduleType;
        } catch (error) {
          logger.debug(`[ESModuleSupport] Cannot detect module type for ${moduleName}: ${error.message}`);
          this.moduleTypeCache.set(moduleName, "unknown");
          return "unknown";
        }
      }
      /**
       * 解析包路径（支持 scoped 包）
       * @param {string} moduleName - 模块名
       * @returns {string} 包的实际路径
       */
      resolvePackagePath(moduleName) {
        const parts = moduleName.split("/");
        if (moduleName.startsWith("@") && parts.length >= 2) {
          const scopedPackageName = parts.slice(0, 2).join("/");
          return path.join(this.toolboxPath, "node_modules", scopedPackageName);
        } else {
          return path.join(this.toolboxPath, "node_modules", parts[0]);
        }
      }
      /**
       * 加载 ES Module
       * @param {string} moduleName - 模块名
       * @returns {Promise<Object>} 模块对象
       */
      async loadESModule(moduleName) {
        try {
          const modulePath = this.resolveModuleEntryPoint(moduleName);
          logger.debug(`[ESModuleSupport] Importing ES Module from ${modulePath}`);
          const module3 = await import(modulePath);
          return module3.default || module3;
        } catch (error) {
          logger.error(`[ESModuleSupport] Failed to load ES Module ${moduleName}: ${error.message}`);
          throw new Error(`Failed to import ES Module '${moduleName}': ${error.message}`);
        }
      }
      /**
       * 解析模块入口点
       * @param {string} moduleName - 模块名
       * @returns {string} 模块入口文件的完整路径
       */
      resolveModuleEntryPoint(moduleName) {
        try {
          const packagePath = this.resolvePackagePath(moduleName);
          const packageJsonPath = path.join(packagePath, "package.json");
          const packageJson = require(packageJsonPath);
          let entryPoint = "index.js";
          if (packageJson.exports) {
            if (typeof packageJson.exports === "string") {
              entryPoint = packageJson.exports;
            } else if (packageJson.exports["."]) {
              if (typeof packageJson.exports["."] === "string") {
                entryPoint = packageJson.exports["."];
              } else if (packageJson.exports["."].import) {
                entryPoint = packageJson.exports["."].import;
              } else if (packageJson.exports["."].default) {
                entryPoint = packageJson.exports["."].default;
              }
            }
          } else if (packageJson.module) {
            entryPoint = packageJson.module;
          } else if (packageJson.main) {
            entryPoint = packageJson.main;
          }
          const fullPath = path.join(packagePath, entryPoint);
          const parts = moduleName.split("/");
          if (moduleName.startsWith("@") && parts.length > 2) {
            const subpath = parts.slice(2).join("/");
            return path.join(packagePath, subpath);
          } else if (!moduleName.startsWith("@") && parts.length > 1) {
            const subpath = parts.slice(1).join("/");
            return path.join(packagePath, subpath);
          }
          return fullPath;
        } catch (error) {
          return this.resolvePackagePath(moduleName);
        }
      }
      /**
       * 批量检测依赖的模块类型
       * @param {Object} dependencies - 依赖对象 { packageName: version }
       * @returns {Promise<Object>} { commonjs: [], esmodule: [], unknown: [] }
       */
      async detectDependenciesTypes(dependencies) {
        const result = {
          commonjs: [],
          esmodule: [],
          unknown: []
        };
        for (const [packageName, version] of Object.entries(dependencies)) {
          const moduleType = await this.detectModuleType(packageName);
          if (moduleType === "esm") {
            result.esmodule.push({ name: packageName, version });
          } else if (moduleType === "commonjs") {
            result.commonjs.push({ name: packageName, version });
          } else {
            result.unknown.push({ name: packageName, version });
          }
        }
        logger.debug(`[ESModuleSupport] Dependencies analysis:`, {
          commonjs: result.commonjs.length,
          esmodule: result.esmodule.length,
          unknown: result.unknown.length
        });
        return result;
      }
      /**
       * 检查是否有 ES Module 依赖
       * @param {Object} dependencies - 依赖对象
       * @returns {Promise<boolean>}
       */
      async hasESModuleDependencies(dependencies) {
        const types = await this.detectDependenciesTypes(dependencies);
        return types.esmodule.length > 0;
      }
      /**
       * 清理缓存
       */
      clearCache() {
        this.moduleTypeCache.clear();
      }
      /**
       * 获取缓存统计
       */
      getCacheStats() {
        return {
          size: this.moduleTypeCache.size,
          modules: Array.from(this.moduleTypeCache.entries())
        };
      }
    };
    module2.exports = ESModuleRequireSupport;
  }
});

// src/toolx/ToolSandbox.js
var require_ToolSandbox = __commonJS({
  "src/toolx/ToolSandbox.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var path = require("path");
    var fs = require("fs").promises;
    var { spawn } = require("child_process");
    var vm = require("vm");
    var SandboxIsolationManager = require_SandboxIsolationManager();
    var SandboxErrorManager = require_SandboxErrorManager();
    var ToolDirectoryManager = require_ToolDirectoryManager();
    var ESModuleRequireSupport = require_ESModuleRequireSupport();
    var logger = require("@promptx/logger");
    var ToolSandbox = class {
      constructor(toolReference, options = {}) {
        this.toolReference = toolReference;
        this.resourceManager = null;
        this.toolId = null;
        this.toolContent = null;
        this.toolInstance = null;
        this.dependencies = [];
        this.directoryManager = null;
        this.sandboxPath = null;
        this.sandboxContext = null;
        this.isolationManager = null;
        this.errorManager = new SandboxErrorManager();
        this.esModuleSupport = null;
        this.isAnalyzed = false;
        this.isPrepared = false;
        this.options = {
          timeout: 3e4,
          enableDependencyInstall: true,
          rebuild: false,
          // 强制重建沙箱（用于处理异常情况）
          ...options
        };
      }
      /**
       * 设置ResourceManager实例
       * @param {ResourceManager} resourceManager 
       */
      setResourceManager(resourceManager) {
        this.resourceManager = resourceManager;
      }
      /**
       * 清理沙箱状态和缓存
       * @param {boolean} deleteDirectory - 是否删除沙箱目录
       */
      async clearSandbox(deleteDirectory = false) {
        logger.debug(`[ToolSandbox] Clearing sandbox state${deleteDirectory ? " and deleting directory" : ""}`);
        this.isAnalyzed = false;
        this.isPrepared = false;
        this.toolContent = null;
        this.toolInstance = null;
        this.dependencies = [];
        this.sandboxContext = null;
        if (deleteDirectory && this.directoryManager) {
          try {
            await this.directoryManager.deleteToolbox();
          } catch (error) {
            logger.debug(`[ToolSandbox] Error deleting toolbox directory (can be ignored): ${error.message}`);
          }
        }
      }
      /**
       * 分析工具：加载工具内容，提取元信息和依赖
       * @returns {Promise<Object>} 分析结果
       */
      async analyze() {
        if (this.isAnalyzed && !this.options.rebuild) {
          logger.debug(`[ToolSandbox] Using cached analysis result, dependencies: ${JSON.stringify(this.dependencies)}`);
          return this.getAnalysisResult();
        }
        if (!this.resourceManager) {
          throw new Error("ResourceManager not set. Call setResourceManager() first.");
        }
        try {
          this.toolId = this.extractToolId(this.toolReference);
          const loadOptions = this.options.forceReinstall ? { noCache: true } : {};
          logger.debug(`[ToolSandbox] Loading tool ${this.toolReference}, options:`, loadOptions);
          const toolResult = await this.resourceManager.loadResource(this.toolReference, loadOptions);
          if (!toolResult.success) {
            logger.debug(`[ToolSandbox] Debug: Trying to find tool ${this.toolReference}`);
            const directLookup = this.resourceManager.registryData.findResourceById(`tool:${this.toolId}`, "tool");
            logger.debug(`[ToolSandbox]    - Direct lookup tool:${this.toolId}: ${directLookup ? "found" : "not found"}`);
            throw new Error(`Failed to load tool: ${toolResult.error.message}`);
          }
          this.toolContent = toolResult.content;
          logger.debug(`[ToolSandbox] Loaded tool content first 200 chars:`, this.toolContent.substring(0, 200));
          this.directoryManager = new ToolDirectoryManager(this.toolId, this.resourceManager);
          await this.directoryManager.initialize();
          await this.directoryManager.ensureDirectories();
          this.sandboxPath = this.directoryManager.getWorkingPath();
          await this.analyzeToolInSandbox();
          this.isAnalyzed = true;
          return this.getAnalysisResult();
        } catch (error) {
          throw new Error(`Tool analysis failed: ${error.message}`);
        }
      }
      /**
       * 准备依赖：安装依赖，准备执行环境
       * @returns {Promise<Object>} 准备结果
       */
      async prepareDependencies() {
        logger.info(`[ToolSandbox] Starting prepareDependencies for tool ${this.toolId}`);
        if (this.options.rebuild) {
          logger.info(`[ToolSandbox] Manually triggering sandbox rebuild`);
          await this.clearSandbox(true);
          if (this.directoryManager) {
            await this.directoryManager.initialize();
          }
        }
        if (!this.isAnalyzed) {
          logger.info(`[ToolSandbox] Starting tool analysis`);
          await this.analyze();
          logger.info(`[ToolSandbox] Tool analysis completed`);
        }
        if (!this.options.rebuild && await this.checkDependenciesNeedUpdate()) {
          logger.debug(`[ToolSandbox] Dependency changes detected, auto-rebuilding sandbox`);
          await this.clearSandbox(true);
          await this.analyze();
        }
        if (this.isPrepared) {
          return { success: true, message: "Dependencies already prepared" };
        }
        try {
          await this.ensureSandboxDirectory();
          const hasDependencies = typeof this.dependencies === "object" && !Array.isArray(this.dependencies) ? Object.keys(this.dependencies).length > 0 : this.dependencies.length > 0;
          if (hasDependencies) {
            logger.info(`[ToolSandbox] Installing dependencies`);
            await this.installDependencies();
            logger.info(`[ToolSandbox] Dependencies installation completed`);
            await this.detectAndHandleESModules();
          }
          logger.info(`[ToolSandbox] Creating execution sandbox`);
          await this.createExecutionSandbox();
          logger.info(`[ToolSandbox] Execution sandbox created`);
          this.isPrepared = true;
          return {
            success: true,
            sandboxPath: this.directoryManager.getWorkingPath(),
            toolboxPath: this.directoryManager.getToolboxPath(),
            dependencies: this.dependencies
          };
        } catch (error) {
          throw new Error(`Dependency preparation failed: ${error.message}`);
        }
      }
      /**
       * 执行工具
       * @param {Object} parameters - 工具参数
       * @returns {Promise<Object>} 执行结果
       */
      async execute(parameters = {}) {
        var _a, _b;
        const startTime = Date.now();
        logger.info(`[ToolSandbox] Executing tool "${this.toolId}" with params: ${JSON.stringify(parameters)}`);
        if (!this.isPrepared) {
          logger.debug(`[ToolSandbox] Preparing dependencies for tool ${this.toolId}`);
          await this.prepareDependencies();
        }
        try {
          await this.validateParameters(parameters);
          const result = await this.executeInSandbox(parameters);
          const elapsed = ((Date.now() - startTime) / 1e3).toFixed(1);
          logger.info(`[ToolSandbox] Tool "${this.toolId}" executed successfully in ${elapsed}s, result type: ${typeof result}`);
          return {
            success: true,
            data: result,
            metadata: {
              toolId: this.toolId,
              sandboxPath: this.directoryManager.getWorkingPath(),
              toolboxPath: this.directoryManager.getToolboxPath(),
              executionTime: Date.now()
            }
          };
        } catch (error) {
          const intelligentError = this.errorManager.analyzeError(error, {
            toolId: this.toolId,
            dependencies: this.dependencies,
            sandboxPath: (_a = this.directoryManager) == null ? void 0 : _a.getWorkingPath(),
            toolboxPath: (_b = this.directoryManager) == null ? void 0 : _b.getToolboxPath(),
            phase: "execute"
          });
          const enhancedError = new Error(intelligentError.formattedMessage);
          enhancedError.intelligentError = intelligentError;
          enhancedError.originalError = error;
          throw enhancedError;
        }
      }
      /**
       * 提取工具ID
       * @param {string} toolReference - @tool://url-validator
       * @returns {string} 工具ID
       */
      extractToolId(toolReference) {
        const match = toolReference.match(/^@tool:\/\/(.+)$/);
        if (!match) {
          throw new Error(`Invalid tool reference format: ${toolReference}`);
        }
        return match[1];
      }
      /**
       * 在基础沙箱中分析工具
       */
      async analyzeToolInSandbox() {
        var _a;
        this.isolationManager = new SandboxIsolationManager(this.directoryManager.getWorkingPath(), {
          enableDependencyLoading: false,
          analysisMode: true
        });
        const sandbox = this.isolationManager.createIsolatedContext();
        logger.debug(
          `[ToolSandbox] Tool code getDependencies section:`,
          ((_a = this.toolContent.match(/getDependencies[\s\S]*?return[\s\S]*?\]/)) == null ? void 0 : _a[0]) || "getDependencies not found"
        );
        const script = new vm.Script(this.toolContent, { filename: `${this.toolId}.js` });
        const context = vm.createContext(sandbox);
        try {
          script.runInContext(context);
        } catch (error) {
          const filteredError = this._filterRequireError(error);
          if (filteredError) {
            throw filteredError;
          }
        }
        const exported = context.module.exports;
        if (!exported) {
          throw new Error(`Tool does not export anything: ${this.toolId}`);
        }
        let toolInstance;
        if (typeof exported === "function") {
          toolInstance = new exported();
        } else if (typeof exported === "object") {
          toolInstance = exported;
        } else {
          throw new Error(`Invalid tool export format: ${this.toolId}`);
        }
        if (typeof toolInstance.getDependencies === "function") {
          try {
            this.dependencies = toolInstance.getDependencies() || {};
            logger.debug(`[ToolSandbox] Extracted dependencies: ${JSON.stringify(this.dependencies)}`);
          } catch (error) {
            logger.warn(`[ToolSandbox] Failed to get dependencies for ${this.toolId}: ${error.message}`);
            this.dependencies = {};
          }
        } else {
          logger.debug(`[ToolSandbox] Tool does not have getDependencies method`);
          this.dependencies = {};
        }
        this.toolInstance = toolInstance;
      }
      /**
       * 智能过滤require错误
       * @param {Error} error - 捕获的错误
       * @returns {Error|null} - 如果是真正的错误则返回Error对象，如果是预期的require错误则返回null
       * @private
       */
      _filterRequireError(error) {
        if (error.code === "MODULE_NOT_FOUND") {
          const missingModule = this._extractMissingModuleName(error.message);
          if (missingModule) {
            const declaredDependencies = this._extractDeclaredDependencies();
            if (this._isDeclaredInDependencies(missingModule, declaredDependencies)) {
              logger.debug(`[ToolSandbox] Dependency ${missingModule} not installed, will install in prepareDependencies phase`);
              return null;
            } else {
              return new Error(`\u672A\u58F0\u660E\u7684\u4F9D\u8D56: ${missingModule}\uFF0C\u8BF7\u5728getDependencies()\u4E2D\u6DFB\u52A0\u6B64\u4F9D\u8D56`);
            }
          }
        }
        return error;
      }
      /**
       * 从错误信息中提取缺失的模块名
       * @param {string} errorMessage - 错误信息
       * @returns {string|null} - 模块名或null
       * @private
       */
      _extractMissingModuleName(errorMessage) {
        const match = errorMessage.match(/Cannot (?:find|resolve) module ['"]([^'"]+)['"]/);
        return match ? match[1] : null;
      }
      /**
       * 尝试从工具代码中提取已声明的依赖
       * @returns {string[]} - 依赖列表
       * @private
       */
      _extractDeclaredDependencies() {
        try {
          const dependencyMatch = this.toolContent.match(/getDependencies\s*\(\s*\)\s*\{[\s\S]*?return\s*\[([\s\S]*?)\]/);
          if (dependencyMatch) {
            const dependencyString = dependencyMatch[1];
            const stringMatches = dependencyString.match(/['"]([^'"]+)['"]/g);
            if (stringMatches) {
              return stringMatches.map((str) => str.slice(1, -1));
            }
          }
        } catch (error) {
          logger.warn(`[ToolSandbox] Unable to parse dependency declaration: ${error.message}`);
        }
        return [];
      }
      /**
       * 检查模块是否在依赖声明中
       * @param {string} moduleName - 模块名
       * @param {string[]} declaredDependencies - 已声明的依赖列表
       * @returns {boolean} - 是否已声明
       * @private
       */
      _isDeclaredInDependencies(moduleName, declaredDependencies) {
        return declaredDependencies.some((dep) => {
          const depName = dep.split("@")[0];
          return depName === moduleName;
        });
      }
      /**
       * 检查沙箱目录是否存在
       * @returns {Promise<boolean>}
       */
      async sandboxExists() {
        if (!this.directoryManager) {
          return false;
        }
        return await this.directoryManager.toolboxExists();
      }
      /**
       * 确保沙箱目录存在
       */
      async ensureSandboxDirectory() {
        if (this.directoryManager) {
          await this.directoryManager.ensureDirectories();
        }
      }
      /**
       * 安装依赖
       */
      async installDependencies() {
        const hasDependencies = typeof this.dependencies === "object" && !Array.isArray(this.dependencies) ? Object.keys(this.dependencies).length > 0 : this.dependencies.length > 0;
        if (!hasDependencies) {
          return;
        }
        await this.createPackageJson();
        await this.runPnpmInstall();
      }
      /**
       * 检查依赖是否需要更新
       * @returns {Promise<boolean>} true表示需要更新
       */
      async checkDependenciesNeedUpdate() {
        const packageJsonPath = this.directoryManager.getPackageJsonPath();
        try {
          const existingContent = await fs.readFile(packageJsonPath, "utf-8");
          const existingPackageJson = JSON.parse(existingContent);
          const existingDeps = existingPackageJson.dependencies || {};
          let newDeps = {};
          if (typeof this.dependencies === "object" && !Array.isArray(this.dependencies)) {
            newDeps = this.dependencies;
          } else if (Array.isArray(this.dependencies)) {
            for (const dep of this.dependencies) {
              if (dep.includes("@")) {
                const lastAtIndex = dep.lastIndexOf("@");
                if (lastAtIndex > 0) {
                  const name = dep.substring(0, lastAtIndex);
                  const version = dep.substring(lastAtIndex + 1);
                  newDeps[name] = version;
                } else {
                  newDeps[dep] = "latest";
                }
              } else {
                newDeps[dep] = "latest";
              }
            }
          }
          const existingKeys = Object.keys(existingDeps).sort();
          const newKeys = Object.keys(newDeps).sort();
          if (existingKeys.length !== newKeys.length || !existingKeys.every((key, index) => key === newKeys[index])) {
            logger.debug(`[ToolSandbox] Dependency list changed - old: ${existingKeys.join(", ")} | new: ${newKeys.join(", ")}`);
            return true;
          }
          for (const key of existingKeys) {
            if (existingDeps[key] !== newDeps[key]) {
              logger.debug(`[ToolSandbox] Dependency version changed - ${key}: ${existingDeps[key]} -> ${newDeps[key]}`);
              return true;
            }
          }
          return false;
        } catch (error) {
          logger.debug(`[ToolSandbox] package.json does not exist or is invalid, needs to be created`);
          return true;
        }
      }
      /**
       * 创建package.json
       */
      async createPackageJson() {
        const packageJsonPath = this.directoryManager.getPackageJsonPath();
        const packageJson = {
          name: `toolbox-${this.toolId}`,
          version: "1.0.0",
          description: `Sandbox for tool: ${this.toolId}`,
          private: true,
          dependencies: {}
        };
        logger.debug(`[ToolSandbox] Processing dependencies: ${JSON.stringify(this.dependencies)}`);
        if (typeof this.dependencies === "object" && !Array.isArray(this.dependencies)) {
          packageJson.dependencies = this.dependencies;
        } else if (Array.isArray(this.dependencies)) {
          logger.warn(`[ToolSandbox] Tool ${this.toolId} is using deprecated array format for dependencies. Please update to object format.`);
          for (const dep of this.dependencies) {
            if (dep.includes("@")) {
              const lastAtIndex = dep.lastIndexOf("@");
              if (lastAtIndex > 0) {
                const name = dep.substring(0, lastAtIndex);
                const version = dep.substring(lastAtIndex + 1);
                logger.debug(`[ToolSandbox] Parsing dependency "${dep}" => name="${name}", version="${version}"`);
                packageJson.dependencies[name] = version;
              } else {
                packageJson.dependencies[dep] = "latest";
              }
            } else {
              packageJson.dependencies[dep] = "latest";
            }
          }
        }
        await fs.writeFile(packageJsonPath, JSON.stringify(packageJson, null, 2));
      }
      /**
       * 运行pnpm安装
       */
      async runPnpmInstall() {
        const startTime = Date.now();
        let depsList = "";
        if (typeof this.dependencies === "object" && !Array.isArray(this.dependencies)) {
          depsList = Object.keys(this.dependencies).map((name) => `${name}@${this.dependencies[name]}`).join(", ");
        } else if (Array.isArray(this.dependencies)) {
          depsList = this.dependencies.join(", ");
        }
        logger.info(`[ToolSandbox] Installing dependencies: [${depsList}]`);
        return new Promise((resolve, reject) => {
          const pnpmModulePath = require.resolve("pnpm");
          const pnpmBinPath = path.join(path.dirname(pnpmModulePath), "bin", "pnpm.cjs");
          const nodeExecutable = process.env.PROMPTX_NODE_EXECUTABLE || "node";
          const spawnEnv = { ...process.env };
          if (nodeExecutable === process.env.PROMPTX_NODE_EXECUTABLE && nodeExecutable.includes("electron")) {
            spawnEnv.ELECTRON_RUN_AS_NODE = "1";
            logger.info(`[ToolSandbox] Setting ELECTRON_RUN_AS_NODE=1 for this subprocess only`);
          }
          spawnEnv.CI = "1";
          const pnpmArgs = [
            pnpmBinPath,
            "install",
            "--config.confirmModulesPurge=false",
            "--prefer-offline",
            "--ignore-scripts",
            "--reporter=append-only"
          ];
          const fullCommand = `${nodeExecutable} ${pnpmArgs.join(" ")}`;
          logger.info(`[ToolSandbox] Executing command: ${fullCommand}`);
          logger.info(`[ToolSandbox] Working directory: ${this.directoryManager.getToolboxPath()}`);
          logger.info(`[ToolSandbox] Using Node.js executable: ${nodeExecutable}`);
          const timeout = setTimeout(() => {
            const elapsed = ((Date.now() - startTime) / 1e3).toFixed(1);
            logger.error(`[ToolSandbox] pnpm install timeout (${elapsed}s > 30s)`);
            logger.error(`[ToolSandbox] Command: ${fullCommand}`);
            logger.error(`[ToolSandbox] Working directory: ${this.directoryManager.getToolboxPath()}`);
            logger.error(`[ToolSandbox] Installing packages: [${depsList}]`);
            logger.error(`[ToolSandbox] Stdout output: ${stdout}`);
            logger.error(`[ToolSandbox] Stderr output: ${stderr}`);
            pnpm.kill("SIGTERM");
            reject(new Error(`pnpm install timeout after 30s. Command: ${fullCommand}`));
          }, 3e4);
          const pnpm = spawn(nodeExecutable, pnpmArgs, {
            cwd: this.directoryManager.getToolboxPath(),
            // 使用 toolbox 路径安装依赖
            env: spawnEnv,
            // 使用定制的环境变量
            stdio: "pipe"
          });
          let stdout = "";
          let stderr = "";
          pnpm.stdout.on("data", (data) => {
            const output = data.toString();
            stdout += output;
            logger.debug(`[ToolSandbox] pnpm stdout: ${output}`);
          });
          pnpm.stderr.on("data", (data) => {
            const error = data.toString();
            stderr += error;
            logger.warn(`[ToolSandbox] pnpm stderr: ${error}`);
          });
          pnpm.on("close", (code) => {
            clearTimeout(timeout);
            const elapsed = ((Date.now() - startTime) / 1e3).toFixed(1);
            if (code === 0) {
              logger.info(`[ToolSandbox] Dependencies installed successfully in ${elapsed}s`);
              logger.debug(`[ToolSandbox] Installed packages: [${depsList}]`);
              resolve({ stdout, stderr });
            } else {
              logger.error(`[ToolSandbox] pnpm install failed with exit code ${code} after ${elapsed}s`);
              logger.error(`[ToolSandbox] Command: ${fullCommand}`);
              logger.error(`[ToolSandbox] Working directory: ${this.directoryManager.getToolboxPath()}`);
              logger.error(`[ToolSandbox] Installing packages: [${depsList}]`);
              logger.error(`[ToolSandbox] Stdout: ${stdout}`);
              logger.error(`[ToolSandbox] Stderr: ${stderr}`);
              reject(new Error(`pnpm install failed with code ${code}: ${stderr}`));
            }
          });
          pnpm.on("error", (error) => {
            logger.error(`[ToolSandbox] Failed to spawn pnpm: ${error.message}`);
            reject(new Error(`Failed to spawn pnpm: ${error.message}`));
          });
        });
      }
      /**
       * 检测和处理 ES Module 依赖
       */
      async detectAndHandleESModules() {
        if (!this.esModuleSupport) {
          this.esModuleSupport = new ESModuleRequireSupport(this.directoryManager.getToolboxPath());
        }
        const dependencyTypes = await this.esModuleSupport.detectDependenciesTypes(this.dependencies);
        if (dependencyTypes.esmodule.length > 0) {
          logger.warn(`[ToolSandbox] \u68C0\u6D4B\u5230 ES Module \u4F9D\u8D56\uFF1A`, dependencyTypes.esmodule.map((d) => d.name).join(", "));
          logger.info(`[ToolSandbox] ES Module \u5305\u9700\u8981\u4F7F\u7528\u52A8\u6001 import() \u52A0\u8F7D\uFF0C\u5DE5\u5177\u53EF\u80FD\u9700\u8981\u76F8\u5E94\u8C03\u6574`);
          this.esModuleDependencies = dependencyTypes.esmodule;
        }
        if (dependencyTypes.unknown.length > 0) {
          logger.debug(`[ToolSandbox] \u65E0\u6CD5\u68C0\u6D4B\u7684\u4F9D\u8D56\u7C7B\u578B\uFF1A`, dependencyTypes.unknown.map((d) => d.name).join(", "));
        }
        return dependencyTypes;
      }
      /**
       * 创建执行沙箱环境
       */
      async createExecutionSandbox() {
        this.isolationManager = new SandboxIsolationManager(this.directoryManager.getWorkingPath(), {
          enableDependencyLoading: true,
          analysisMode: false,
          toolboxPath: this.directoryManager.getToolboxPath()
          // 传递 toolbox 路径用于依赖加载
        });
        this.sandboxContext = this.isolationManager.createIsolatedContext();
        if (!this.esModuleSupport) {
          this.esModuleSupport = new ESModuleRequireSupport(this.directoryManager.getToolboxPath());
        }
        this.sandboxContext.loadModule = async (moduleName) => {
          const moduleType = await this.esModuleSupport.detectModuleType(moduleName);
          if (moduleType === "esm") {
            try {
              return await this.esModuleSupport.loadESModule(moduleName);
            } catch (error) {
              const module3 = this.sandboxContext.require(moduleName);
              return module3.default || module3;
            }
          } else {
            return this.sandboxContext.require(moduleName);
          }
        };
        this.sandboxContext.importModule = this.sandboxContext.loadModule;
        const originalRequire = this.sandboxContext.require;
        const esModuleSupport = this.esModuleSupport;
        this.sandboxContext.require = function(moduleName) {
          try {
            const packageJsonPath = require.resolve(`${moduleName}/package.json`, {
              paths: [esModuleSupport.toolboxPath]
            });
            const packageJson = require(packageJsonPath);
            if (packageJson.type === "module") {
              const error = new Error(
                `\u274C "${moduleName}" \u662F ES Module \u5305\uFF0C\u8BF7\u4F7F\u7528 await loadModule('${moduleName}') \u4EE3\u66FF require('${moduleName}')
\u{1F4A1} \u63D0\u793A\uFF1AloadModule \u4F1A\u81EA\u52A8\u68C0\u6D4B\u5305\u7C7B\u578B\u5E76\u6B63\u786E\u52A0\u8F7D`
              );
              error.code = "ERR_REQUIRE_ESM";
              throw error;
            }
          } catch (checkError) {
            if (checkError.code === "ERR_REQUIRE_ESM") {
              throw checkError;
            }
          }
          const result = originalRequire(moduleName);
          if (result && result.__esModule && result.default && !result.default.__esModule) {
            const error = new Error(
              `\u274C "${moduleName}" \u662F ES Module \u5305\uFF0C\u8BF7\u4F7F\u7528 await loadModule('${moduleName}') \u4EE3\u66FF require('${moduleName}')
\u{1F4A1} \u63D0\u793A\uFF1AloadModule \u4F1A\u81EA\u52A8\u68C0\u6D4B\u5305\u7C7B\u578B\u5E76\u6B63\u786E\u52A0\u8F7D`
            );
            error.code = "ERR_REQUIRE_ESM";
            throw error;
          }
          return result;
        };
        if (this.esModuleDependencies && this.esModuleDependencies.length > 0) {
          logger.debug(`[ToolSandbox] \u5DF2\u4E3A\u5DE5\u5177 ${this.toolId} \u542F\u7528 ES Module \u652F\u6301\uFF0C\u68C0\u6D4B\u5230 ${this.esModuleDependencies.length} \u4E2A ES Module \u4F9D\u8D56`);
        } else {
          logger.debug(`[ToolSandbox] \u5DF2\u4E3A\u5DE5\u5177 ${this.toolId} \u542F\u7528 importModule \u51FD\u6570`);
        }
        const script = new vm.Script(this.toolContent, { filename: `${this.toolId}.js` });
        const context = vm.createContext(this.sandboxContext);
        script.runInContext(context);
        const exported = context.module.exports;
        if (typeof exported === "function") {
          this.toolInstance = new exported();
        } else if (typeof exported === "object") {
          this.toolInstance = exported;
        }
      }
      /**
       * 解析协议路径（支持@project://等协议）
       * @param {string} protocolPath - 协议路径，如@project://.promptx/cwd
       * @returns {Promise<string>} 解析后的绝对路径
       */
      async resolveProtocolPath(protocolPath) {
        if (!protocolPath) {
          throw new Error("protocolPath is required but was undefined");
        }
        if (protocolPath.startsWith("@project://")) {
          const { getGlobalProjectPathResolver } = require_ProjectPathResolver();
          const pathResolver = getGlobalProjectPathResolver();
          try {
            const relativePath = protocolPath.replace(/^@project:\/\//, "");
            const resolvedPath = pathResolver.resolvePath(relativePath);
            const fs2 = require("fs").promises;
            try {
              await fs2.access(resolvedPath);
            } catch (error) {
              if (error.code === "ENOENT") {
                await fs2.mkdir(resolvedPath, { recursive: true });
                logger.debug(`[ToolSandbox] Created unified working directory: ${resolvedPath}`);
              }
            }
            return resolvedPath;
          } catch (error) {
            throw new Error(`\u89E3\u6790@project://\u8DEF\u5F84\u5931\u8D25: ${error.message}`);
          }
        }
        if (protocolPath.startsWith("@")) {
          if (!this.resourceManager) {
            throw new Error("ResourceManager not set. Cannot resolve protocol path.");
          }
          throw new Error(`\u6682\u4E0D\u652F\u6301\u7684\u534F\u8BAE\u8DEF\u5F84: ${protocolPath}`);
        }
        return protocolPath;
      }
      /**
       * 参数验证
       */
      async validateParameters(parameters) {
        var _a;
        if (typeof this.toolInstance.validate === "function") {
          const result = this.toolInstance.validate(parameters);
          if (typeof result === "boolean" && !result) {
            throw new Error("Parameter validation failed");
          } else if (result && typeof result === "object" && !result.valid) {
            throw new Error(`Parameter validation failed: ${(_a = result.errors) == null ? void 0 : _a.join(", ")}`);
          }
        }
      }
      /**
       * 在沙箱中执行工具
       */
      async executeInSandbox(parameters) {
        if (!this.toolInstance || typeof this.toolInstance.execute !== "function") {
          throw new Error(`Tool ${this.toolId} does not have execute method`);
        }
        return await this.toolInstance.execute(parameters);
      }
      /**
       * 获取分析结果
       */
      getAnalysisResult() {
        var _a, _b, _c, _d;
        return {
          toolId: this.toolId,
          dependencies: this.dependencies,
          sandboxPath: (_a = this.directoryManager) == null ? void 0 : _a.getWorkingPath(),
          toolboxPath: (_b = this.directoryManager) == null ? void 0 : _b.getToolboxPath(),
          hasMetadata: typeof ((_c = this.toolInstance) == null ? void 0 : _c.getMetadata) === "function",
          hasSchema: typeof ((_d = this.toolInstance) == null ? void 0 : _d.getSchema) === "function"
        };
      }
      /**
       * 清理沙箱资源
       */
      async cleanup() {
        if (this.isolationManager) {
          this.isolationManager.cleanup();
          this.isolationManager = null;
        }
        if (this.esModuleSupport) {
          this.esModuleSupport.clearCache();
          this.esModuleSupport = null;
        }
        this.sandboxContext = null;
        this.toolInstance = null;
        this.esModuleDependencies = null;
      }
      /**
       * 获取工具元信息
       */
      getToolMetadata() {
        if (this.toolInstance && typeof this.toolInstance.getMetadata === "function") {
          return this.toolInstance.getMetadata();
        }
        return null;
      }
      /**
       * 获取工具Schema
       */
      getToolSchema() {
        if (this.toolInstance && typeof this.toolInstance.getSchema === "function") {
          return this.toolInstance.getSchema();
        }
        return null;
      }
    };
    module2.exports = ToolSandbox;
  }
});

// src/toolx/ToolInterface.js
var require_ToolInterface = __commonJS({
  "src/toolx/ToolInterface.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var TOOL_INTERFACE = {
      // 必须实现的方法
      required: [
        {
          name: "getMetadata",
          signature: "() => Object",
          description: "\u83B7\u53D6\u5DE5\u5177\u5143\u4FE1\u606F",
          returns: {
            name: "string - \u5DE5\u5177\u540D\u79F0",
            description: "string - \u5DE5\u5177\u63CF\u8FF0",
            version: "string - \u7248\u672C\u53F7",
            category: "string - \u5206\u7C7B\uFF08\u53EF\u9009\uFF09",
            author: "string - \u4F5C\u8005\uFF08\u53EF\u9009\uFF09"
          }
        },
        {
          name: "getSchema",
          signature: "() => Object",
          description: "\u83B7\u53D6\u53C2\u6570JSON Schema",
          returns: {
            type: "string - \u53C2\u6570\u7C7B\u578B\uFF0C\u901A\u5E38\u4E3Aobject",
            properties: "Object - \u53C2\u6570\u5C5E\u6027\u5B9A\u4E49",
            required: "Array - \u5FC5\u9700\u53C2\u6570\u5217\u8868\uFF08\u53EF\u9009\uFF09",
            additionalProperties: "boolean - \u662F\u5426\u5141\u8BB8\u989D\u5916\u53C2\u6570\uFF08\u53EF\u9009\uFF09"
          }
        },
        {
          name: "execute",
          signature: "(parameters: Object) => Promise<any>",
          description: "\u6267\u884C\u5DE5\u5177\u4E3B\u903B\u8F91",
          parameters: {
            parameters: "Object - \u5DE5\u5177\u53C2\u6570\uFF0C\u7B26\u5408getSchema\u5B9A\u4E49"
          },
          returns: "Promise<any> - \u5DE5\u5177\u6267\u884C\u7ED3\u679C"
        }
      ],
      // 可选实现的方法
      optional: [
        {
          name: "getPackage",
          signature: "() => Object",
          description: "\u83B7\u53D6\u5DE5\u5177\u5305\u4FE1\u606F\uFF08\u53EF\u9009\uFF0C\u7528\u4E8E\u4F9D\u8D56\u7BA1\u7406\uFF09",
          returns: {
            directory: "string - \u5DE5\u5177\u76EE\u5F55\u8DEF\u5F84",
            dependencies: "Object - \u4F9D\u8D56\u5BF9\u8C61\uFF0C\u683C\u5F0F\uFF1A{\u5305\u540D: \u7248\u672C}",
            packageJson: "Object - package.json\u5185\u5BB9\uFF08\u53EF\u9009\uFF09"
          }
        },
        {
          name: "validate",
          signature: "(parameters: Object) => Object",
          description: "\u9A8C\u8BC1\u53C2\u6570\uFF08\u53EF\u9009\uFF0C\u6709\u9ED8\u8BA4\u5B9E\u73B0\uFF09",
          parameters: {
            parameters: "Object - \u5F85\u9A8C\u8BC1\u53C2\u6570"
          },
          returns: {
            valid: "boolean - \u9A8C\u8BC1\u662F\u5426\u901A\u8FC7",
            errors: "Array<string> - \u9519\u8BEF\u4FE1\u606F\u5217\u8868"
          }
        },
        {
          name: "cleanup",
          signature: "() => void | Promise<void>",
          description: "\u6E05\u7406\u8D44\u6E90\uFF08\u53EF\u9009\uFF09",
          returns: "void | Promise<void>"
        },
        {
          name: "init",
          signature: "(config?: Object) => void | Promise<void>",
          description: "\u521D\u59CB\u5316\u5DE5\u5177\uFF08\u53EF\u9009\uFF09",
          parameters: {
            config: "Object - \u521D\u59CB\u5316\u914D\u7F6E\uFF08\u53EF\u9009\uFF09"
          },
          returns: "void | Promise<void>"
        }
      ]
    };
    var TOOL_ERROR_CODES = {
      VALIDATION_ERROR: "VALIDATION_ERROR",
      // 参数验证失败
      EXECUTION_ERROR: "EXECUTION_ERROR",
      // 执行错误
      TIMEOUT_ERROR: "TIMEOUT_ERROR",
      // 超时错误
      PERMISSION_ERROR: "PERMISSION_ERROR",
      // 权限错误
      RESOURCE_ERROR: "RESOURCE_ERROR",
      // 资源错误
      CONFIGURATION_ERROR: "CONFIGURATION_ERROR"
      // 配置错误
    };
    var TOOL_RESULT_FORMAT = {
      success: {
        success: true,
        data: "any - \u5DE5\u5177\u8FD4\u56DE\u7684\u5B9E\u9645\u6570\u636E",
        metadata: {
          tool: "string - \u5DE5\u5177\u540D\u79F0",
          executionTime: "string - \u6267\u884C\u65F6\u95F4",
          timestamp: "string - \u65F6\u95F4\u6233"
          // ...其他元信息
        }
      },
      error: {
        success: false,
        error: {
          code: "string - \u9519\u8BEF\u4EE3\u7801\uFF08\u89C1TOOL_ERROR_CODES\uFF09",
          message: "string - \u9519\u8BEF\u6D88\u606F",
          details: "Object - \u9519\u8BEF\u8BE6\u60C5\uFF08\u53EF\u9009\uFF09"
        },
        metadata: {
          tool: "string - \u5DE5\u5177\u540D\u79F0",
          timestamp: "string - \u65F6\u95F4\u6233"
          // ...其他元信息
        }
      }
    };
    var EXAMPLE_TOOL = `
class ExampleTool {
  getMetadata() {
    return {
      name: 'example-tool',
      description: '\u793A\u4F8B\u5DE5\u5177',
      version: '1.0.0',
      category: 'example',
      author: 'PromptX Team'
    };
  }

  getSchema() {
    return {
      type: 'object',
      properties: {
        input: {
          type: 'string',
          description: '\u8F93\u5165\u53C2\u6570'
        }
      },
      required: ['input'],
      additionalProperties: false
    };
  }

  async execute(parameters) {
    const { input } = parameters;
    
    // \u5DE5\u5177\u903B\u8F91
    const result = \`\u5904\u7406\u7ED3\u679C: \${input}\`;
    
    return result;
  }

  // \u53EF\u9009\uFF1A\u58F0\u660E\u4F9D\u8D56\uFF08\u65B0\u683C\u5F0F\uFF1A\u5BF9\u8C61\uFF09
  getDependencies() {
    return {
      'lodash': '^4.17.21',
      'axios': '^1.6.0'
    };
  }

  // \u53EF\u9009\uFF1A\u81EA\u5B9A\u4E49\u53C2\u6570\u9A8C\u8BC1
  validate(parameters) {
    const errors = [];
    
    if (!parameters.input || parameters.input.trim() === '') {
      errors.push('input\u4E0D\u80FD\u4E3A\u7A7A');
    }
    
    return { valid: errors.length === 0, errors };
  }

  // \u53EF\u9009\uFF1A\u6E05\u7406\u8D44\u6E90
  cleanup() {
    console.log('\u6E05\u7406\u8D44\u6E90');
  }
}

module.exports = ExampleTool;
`;
    module2.exports = {
      TOOL_INTERFACE,
      TOOL_ERROR_CODES,
      TOOL_RESULT_FORMAT,
      EXAMPLE_TOOL
    };
  }
});

// src/toolx/ToolValidator.js
var require_ToolValidator = __commonJS({
  "src/toolx/ToolValidator.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var { TOOL_INTERFACE, TOOL_ERROR_CODES } = require_ToolInterface();
    var ToolValidator = class {
      /**
       * 验证工具是否符合接口规范
       * @param {any} tool - 待验证的工具对象
       * @returns {Object} 验证结果 {valid: boolean, errors: [], warnings: []}
       */
      static validateTool(tool) {
        const errors = [];
        const warnings = [];
        if (!tool || typeof tool !== "object") {
          errors.push("\u5DE5\u5177\u5FC5\u987B\u662F\u5BF9\u8C61\u7C7B\u578B");
          return { valid: false, errors, warnings };
        }
        for (const methodSpec of TOOL_INTERFACE.required) {
          const methodName = methodSpec.name;
          if (!(methodName in tool)) {
            errors.push(`\u7F3A\u5C11\u5FC5\u9700\u65B9\u6CD5: ${methodName}`);
            continue;
          }
          if (typeof tool[methodName] !== "function") {
            errors.push(`${methodName} \u5FC5\u987B\u662F\u51FD\u6570\u7C7B\u578B`);
            continue;
          }
          try {
            const validationResult = this.validateMethod(tool, methodSpec);
            if (!validationResult.valid) {
              errors.push(...validationResult.errors);
              warnings.push(...validationResult.warnings);
            }
          } catch (error) {
            warnings.push(`${methodName} \u65B9\u6CD5\u9A8C\u8BC1\u65F6\u51FA\u9519: ${error.message}`);
          }
        }
        for (const methodSpec of TOOL_INTERFACE.optional) {
          const methodName = methodSpec.name;
          if (methodName in tool) {
            if (typeof tool[methodName] !== "function") {
              warnings.push(`${methodName} \u5E94\u8BE5\u662F\u51FD\u6570\u7C7B\u578B`);
            } else {
              try {
                const validationResult = this.validateMethod(tool, methodSpec);
                if (!validationResult.valid) {
                  warnings.push(...validationResult.errors);
                }
              } catch (error) {
                warnings.push(`${methodName} \u65B9\u6CD5\u9A8C\u8BC1\u65F6\u51FA\u9519: ${error.message}`);
              }
            }
          }
        }
        return {
          valid: errors.length === 0,
          errors,
          warnings
        };
      }
      /**
       * 验证特定方法
       * @param {Object} tool - 工具对象
       * @param {Object} methodSpec - 方法规范
       * @returns {Object} 验证结果
       */
      static validateMethod(tool, methodSpec) {
        const errors = [];
        const warnings = [];
        const methodName = methodSpec.name;
        try {
          switch (methodName) {
            case "getMetadata":
              return this.validateGetMetadata(tool);
            case "getSchema":
              return this.validateGetSchema(tool);
            case "execute":
              return this.validateExecute(tool);
            case "validate":
              return this.validateValidateMethod(tool);
            default:
              return { valid: true, errors: [], warnings: [] };
          }
        } catch (error) {
          errors.push(`${methodName} \u65B9\u6CD5\u8C03\u7528\u5931\u8D25: ${error.message}`);
          return { valid: false, errors, warnings };
        }
      }
      /**
       * 验证getMetadata方法
       * @param {Object} tool - 工具对象
       * @returns {Object} 验证结果
       */
      static validateGetMetadata(tool) {
        const errors = [];
        const warnings = [];
        try {
          const metadata = tool.getMetadata();
          if (!metadata || typeof metadata !== "object") {
            errors.push("getMetadata() \u5FC5\u987B\u8FD4\u56DE\u5BF9\u8C61");
            return { valid: false, errors, warnings };
          }
          if (!metadata.name || typeof metadata.name !== "string") {
            errors.push("metadata.name \u5FC5\u987B\u662F\u975E\u7A7A\u5B57\u7B26\u4E32");
          }
          if (!metadata.description || typeof metadata.description !== "string") {
            errors.push("metadata.description \u5FC5\u987B\u662F\u975E\u7A7A\u5B57\u7B26\u4E32");
          }
          if (!metadata.version || typeof metadata.version !== "string") {
            errors.push("metadata.version \u5FC5\u987B\u662F\u975E\u7A7A\u5B57\u7B26\u4E32");
          }
          if (metadata.category && typeof metadata.category !== "string") {
            warnings.push("metadata.category \u5E94\u8BE5\u662F\u5B57\u7B26\u4E32\u7C7B\u578B");
          }
          if (metadata.author && typeof metadata.author !== "string") {
            warnings.push("metadata.author \u5E94\u8BE5\u662F\u5B57\u7B26\u4E32\u7C7B\u578B");
          }
        } catch (error) {
          errors.push(`getMetadata() \u6267\u884C\u5931\u8D25: ${error.message}`);
        }
        return { valid: errors.length === 0, errors, warnings };
      }
      /**
       * 验证getSchema方法
       * @param {Object} tool - 工具对象
       * @returns {Object} 验证结果
       */
      static validateGetSchema(tool) {
        const errors = [];
        const warnings = [];
        try {
          const schema = tool.getSchema();
          if (!schema || typeof schema !== "object") {
            errors.push("getSchema() \u5FC5\u987B\u8FD4\u56DE\u5BF9\u8C61");
            return { valid: false, errors, warnings };
          }
          if (!schema.type) {
            warnings.push("schema.type \u5EFA\u8BAE\u5B9A\u4E49");
          }
          if (schema.type && typeof schema.type !== "string") {
            errors.push("schema.type \u5FC5\u987B\u662F\u5B57\u7B26\u4E32");
          }
          if (schema.properties && typeof schema.properties !== "object") {
            errors.push("schema.properties \u5FC5\u987B\u662F\u5BF9\u8C61");
          }
          if (schema.required && !Array.isArray(schema.required)) {
            errors.push("schema.required \u5FC5\u987B\u662F\u6570\u7EC4");
          }
        } catch (error) {
          errors.push(`getSchema() \u6267\u884C\u5931\u8D25: ${error.message}`);
        }
        return { valid: errors.length === 0, errors, warnings };
      }
      /**
       * 验证execute方法
       * @param {Object} tool - 工具对象
       * @returns {Object} 验证结果
       */
      static validateExecute(tool) {
        const errors = [];
        const warnings = [];
        const executeMethod = tool.execute;
        if (executeMethod.length === 0) {
          warnings.push("execute() \u65B9\u6CD5\u5EFA\u8BAE\u63A5\u53D7parameters\u53C2\u6570");
        }
        return { valid: errors.length === 0, errors, warnings };
      }
      /**
       * 验证validate方法（可选）
       * @param {Object} tool - 工具对象
       * @returns {Object} 验证结果
       */
      static validateValidateMethod(tool) {
        const errors = [];
        const warnings = [];
        try {
          const testParams = {};
          const result = tool.validate(testParams);
          if (!result || typeof result !== "object") {
            errors.push("validate() \u5FC5\u987B\u8FD4\u56DE\u5BF9\u8C61");
            return { valid: false, errors, warnings };
          }
          if (typeof result.valid !== "boolean") {
            errors.push("validate() \u8FD4\u56DE\u503C\u5FC5\u987B\u5305\u542Bvalid(boolean)\u5B57\u6BB5");
          }
          if (result.errors && !Array.isArray(result.errors)) {
            errors.push("validate() \u8FD4\u56DE\u503C\u7684errors\u5B57\u6BB5\u5FC5\u987B\u662F\u6570\u7EC4");
          }
        } catch (error) {
          warnings.push(`validate() \u65B9\u6CD5\u6D4B\u8BD5\u5931\u8D25: ${error.message}`);
        }
        return { valid: errors.length === 0, errors, warnings };
      }
      /**
       * 为工具提供默认的validate方法实现
       * @param {Object} tool - 工具对象
       * @param {Object} parameters - 待验证参数
       * @returns {Object} 验证结果
       */
      static defaultValidate(tool, parameters) {
        const errors = [];
        try {
          const schema = tool.getSchema();
          if (!parameters || typeof parameters !== "object") {
            errors.push("\u53C2\u6570\u5FC5\u987B\u662F\u5BF9\u8C61\u7C7B\u578B");
            return { valid: false, errors };
          }
          if (schema.required && Array.isArray(schema.required)) {
            for (const field of schema.required) {
              if (!(field in parameters)) {
                errors.push(`\u7F3A\u5C11\u5FC5\u9700\u53C2\u6570: ${field}`);
              }
            }
          }
          if (schema.properties && typeof schema.properties === "object") {
            for (const [field, fieldSchema] of Object.entries(schema.properties)) {
              if (field in parameters) {
                const value = parameters[field];
                const expectedType = fieldSchema.type;
                if (expectedType && !this.validateType(value, expectedType)) {
                  errors.push(`\u53C2\u6570 ${field} \u7C7B\u578B\u9519\u8BEF\uFF0C\u671F\u671B ${expectedType}\uFF0C\u5B9E\u9645 ${typeof value}`);
                }
              }
            }
          }
        } catch (error) {
          errors.push(`\u53C2\u6570\u9A8C\u8BC1\u5931\u8D25: ${error.message}`);
        }
        return { valid: errors.length === 0, errors };
      }
      /**
       * 类型验证辅助方法
       * @param {*} value - 待验证值
       * @param {string} expectedType - 期望类型
       * @returns {boolean} 是否匹配
       */
      static validateType(value, expectedType) {
        switch (expectedType) {
          case "string":
            return typeof value === "string";
          case "number":
            return typeof value === "number";
          case "boolean":
            return typeof value === "boolean";
          case "object":
            return typeof value === "object" && value !== null;
          case "array":
            return Array.isArray(value);
          default:
            return true;
        }
      }
      /**
       * 生成工具接口报告
       * @param {Object} tool - 工具对象
       * @returns {Object} 接口报告
       */
      static generateInterfaceReport(tool) {
        const validation = this.validateTool(tool);
        const report = {
          toolName: "unknown",
          valid: validation.valid,
          errors: validation.errors,
          warnings: validation.warnings,
          implementedMethods: {
            required: [],
            optional: []
          },
          metadata: null,
          schema: null
        };
        try {
          if (tool.getMetadata) {
            const metadata = tool.getMetadata();
            report.toolName = metadata.name || "unknown";
            report.metadata = metadata;
          }
          if (tool.getSchema) {
            report.schema = tool.getSchema();
          }
          for (const methodSpec of TOOL_INTERFACE.required) {
            if (typeof tool[methodSpec.name] === "function") {
              report.implementedMethods.required.push(methodSpec.name);
            }
          }
          for (const methodSpec of TOOL_INTERFACE.optional) {
            if (typeof tool[methodSpec.name] === "function") {
              report.implementedMethods.optional.push(methodSpec.name);
            }
          }
        } catch (error) {
          report.warnings.push(`\u751F\u6210\u62A5\u544A\u65F6\u51FA\u9519: ${error.message}`);
        }
        return report;
      }
    };
    module2.exports = ToolValidator;
  }
});

// src/toolx/ToolUtils.js
var require_ToolUtils = __commonJS({
  "src/toolx/ToolUtils.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var ToolValidator = require_ToolValidator();
    var { TOOL_ERROR_CODES, TOOL_RESULT_FORMAT } = require_ToolInterface();
    var ToolUtils = class {
      /**
       * 创建标准化的成功结果
       * @param {*} data - 结果数据
       * @param {Object} options - 选项
       * @returns {Object} 标准化结果
       */
      static createSuccessResult(data, options = {}) {
        const {
          tool = "unknown",
          executionTime = null,
          metadata = {}
        } = options;
        return {
          success: true,
          data,
          metadata: {
            tool,
            executionTime,
            timestamp: (/* @__PURE__ */ new Date()).toISOString(),
            ...metadata
          }
        };
      }
      /**
       * 创建标准化的错误结果
       * @param {string} code - 错误代码
       * @param {string} message - 错误消息
       * @param {Object} options - 选项
       * @returns {Object} 标准化错误
       */
      static createErrorResult(code, message, options = {}) {
        const {
          tool = "unknown",
          details = {},
          metadata = {}
        } = options;
        return {
          success: false,
          error: {
            code,
            message,
            details
          },
          metadata: {
            tool,
            timestamp: (/* @__PURE__ */ new Date()).toISOString(),
            ...metadata
          }
        };
      }
      /**
       * 验证工具结果格式
       * @param {Object} result - 工具结果
       * @returns {Object} 验证结果
       */
      static validateResult(result) {
        const errors = [];
        if (!result || typeof result !== "object") {
          errors.push("\u7ED3\u679C\u5FC5\u987B\u662F\u5BF9\u8C61\u7C7B\u578B");
          return { valid: false, errors };
        }
        if (typeof result.success !== "boolean") {
          errors.push("\u7ED3\u679C\u5FC5\u987B\u5305\u542Bsuccess(boolean)\u5B57\u6BB5");
        }
        if (result.success) {
          if (!("data" in result)) {
            errors.push("\u6210\u529F\u7ED3\u679C\u5FC5\u987B\u5305\u542Bdata\u5B57\u6BB5");
          }
        } else {
          if (!result.error || typeof result.error !== "object") {
            errors.push("\u9519\u8BEF\u7ED3\u679C\u5FC5\u987B\u5305\u542Berror(object)\u5B57\u6BB5");
          } else {
            if (!result.error.code || typeof result.error.code !== "string") {
              errors.push("\u9519\u8BEF\u7ED3\u679C\u5FC5\u987B\u5305\u542Berror.code(string)\u5B57\u6BB5");
            }
            if (!result.error.message || typeof result.error.message !== "string") {
              errors.push("\u9519\u8BEF\u7ED3\u679C\u5FC5\u987B\u5305\u542Berror.message(string)\u5B57\u6BB5");
            }
          }
        }
        return { valid: errors.length === 0, errors };
      }
      /**
       * 安全地执行工具方法
       * @param {Object} tool - 工具实例
       * @param {string} methodName - 方法名
       * @param {...any} args - 方法参数
       * @returns {Promise<*>} 执行结果
       */
      static async safeExecute(tool, methodName, ...args) {
        try {
          if (!tool || typeof tool[methodName] !== "function") {
            throw new Error(`\u5DE5\u5177\u4E0D\u5B58\u5728\u65B9\u6CD5: ${methodName}`);
          }
          const result = await tool[methodName](...args);
          return result;
        } catch (error) {
          throw new Error(`\u65B9\u6CD5\u6267\u884C\u5931\u8D25 ${methodName}: ${error.message}`);
        }
      }
      /**
       * 工具性能分析
       * @param {Object} tool - 工具实例
       * @param {Object} parameters - 测试参数
       * @param {Object} options - 选项
       * @returns {Promise<Object>} 性能分析结果
       */
      static async benchmarkTool(tool, parameters = {}, options = {}) {
        const {
          iterations = 10,
          warmup = 3
        } = options;
        const results = {
          toolName: "unknown",
          iterations,
          warmup,
          times: [],
          stats: {}
        };
        try {
          if (tool.getMetadata) {
            const metadata = tool.getMetadata();
            results.toolName = metadata.name || "unknown";
          }
          const validation = ToolValidator.validateTool(tool);
          if (!validation.valid) {
            throw new Error(`\u5DE5\u5177\u63A5\u53E3\u9A8C\u8BC1\u5931\u8D25: ${validation.errors.join(", ")}`);
          }
          for (let i = 0; i < warmup; i++) {
            await tool.execute(parameters);
          }
          for (let i = 0; i < iterations; i++) {
            const startTime = process.hrtime.bigint();
            await tool.execute(parameters);
            const endTime = process.hrtime.bigint();
            const executionTime = Number(endTime - startTime) / 1e6;
            results.times.push(executionTime);
          }
          results.stats = this.calculateStats(results.times);
        } catch (error) {
          results.error = error.message;
        }
        return results;
      }
      /**
       * 计算统计信息
       * @param {Array<number>} times - 时间数组
       * @returns {Object} 统计信息
       */
      static calculateStats(times) {
        if (times.length === 0) {
          return {};
        }
        const sorted = [...times].sort((a, b) => a - b);
        const sum = times.reduce((a, b) => a + b, 0);
        return {
          count: times.length,
          min: Math.min(...times),
          max: Math.max(...times),
          mean: sum / times.length,
          median: sorted[Math.floor(sorted.length / 2)],
          p95: sorted[Math.floor(sorted.length * 0.95)],
          p99: sorted[Math.floor(sorted.length * 0.99)]
        };
      }
      /**
       * 生成工具模板代码
       * @param {Object} options - 工具选项
       * @returns {string} 工具模板代码
       */
      static generateToolTemplate(options = {}) {
        const {
          toolName = "ExampleTool",
          className = "ExampleTool",
          description = "\u793A\u4F8B\u5DE5\u5177",
          category = "utility",
          author = "PromptX Developer"
        } = options;
        return `/**
 * ${className} - ${description}
 * \u4F7F\u7528PromptX\u9E2D\u5B50\u7C7B\u578B\u63A5\u53E3\uFF0C\u65E0\u9700\u7EE7\u627F\u4EFB\u4F55\u57FA\u7C7B
 */
class ${className} {
  getMetadata() {
    return {
      name: '${toolName}',
      description: '${description}',
      version: '1.0.0',
      category: '${category}',
      author: '${author}'
    };
  }

  getSchema() {
    return {
      type: 'object',
      properties: {
        input: {
          type: 'string',
          description: '\u8F93\u5165\u53C2\u6570'
        }
      },
      required: ['input'],
      additionalProperties: false
    };
  }

  async execute(parameters) {
    const { input } = parameters;
    
    try {
      // TODO: \u5B9E\u73B0\u5DE5\u5177\u903B\u8F91
      const result = \`\u5904\u7406\u7ED3\u679C: \${input}\`;
      
      return result;
    } catch (error) {
      throw new Error(\`\u6267\u884C\u5931\u8D25: \${error.message}\`);
    }
  }

  // \u53EF\u9009\uFF1A\u81EA\u5B9A\u4E49\u53C2\u6570\u9A8C\u8BC1
  validate(parameters) {
    const errors = [];
    
    if (!parameters.input || parameters.input.trim() === '') {
      errors.push('input\u4E0D\u80FD\u4E3A\u7A7A');
    }
    
    return { valid: errors.length === 0, errors };
  }

  // \u53EF\u9009\uFF1A\u6E05\u7406\u8D44\u6E90
  cleanup() {
    // \u6E05\u7406\u903B\u8F91
  }
}

module.exports = ${className};
`;
      }
      /**
       * 创建工具开发指南
       * @returns {string} 开发指南
       */
      static getDevGuide() {
        return `
# PromptX Tool \u5F00\u53D1\u6307\u5357

## \u9E2D\u5B50\u7C7B\u578B\u63A5\u53E3
PromptX\u5DE5\u5177\u4F7F\u7528\u9E2D\u5B50\u7C7B\u578B\u8BBE\u8BA1\uFF0C\u65E0\u9700\u7EE7\u627F\u4EFB\u4F55\u57FA\u7C7B\u3002\u53EA\u9700\u5B9E\u73B0\u4EE5\u4E0B\u63A5\u53E3\uFF1A

### \u5FC5\u9700\u65B9\u6CD5
1. \`getMetadata()\` - \u8FD4\u56DE\u5DE5\u5177\u5143\u4FE1\u606F
2. \`getSchema()\` - \u8FD4\u56DE\u53C2\u6570JSON Schema
3. \`execute(parameters)\` - \u6267\u884C\u5DE5\u5177\u903B\u8F91

### \u53EF\u9009\u65B9\u6CD5
1. \`validate(parameters)\` - \u81EA\u5B9A\u4E49\u53C2\u6570\u9A8C\u8BC1
2. \`cleanup()\` - \u6E05\u7406\u8D44\u6E90
3. \`init(config)\` - \u521D\u59CB\u5316\u5DE5\u5177

## \u5F00\u53D1\u6B65\u9AA4
1. \u4F7F\u7528 ToolUtils.generateToolTemplate() \u751F\u6210\u6A21\u677F
2. \u5B9E\u73B0\u5FC5\u9700\u7684\u63A5\u53E3\u65B9\u6CD5
3. \u4F7F\u7528 ToolValidator.validateTool() \u9A8C\u8BC1\u63A5\u53E3
4. \u4F7F\u7528 ToolUtils.benchmarkTool() \u6027\u80FD\u6D4B\u8BD5
5. \u6CE8\u518C\u5230\u5DE5\u5177\u6CE8\u518C\u8868

## \u793A\u4F8B\u4EE3\u7801
\`\`\`javascript
${this.generateToolTemplate()}
\`\`\`

## \u6700\u4F73\u5B9E\u8DF5
- \u4FDD\u6301execute\u65B9\u6CD5\u7684\u5E42\u7B49\u6027
- \u63D0\u4F9B\u6E05\u6670\u7684\u9519\u8BEF\u6D88\u606F
- \u4F7F\u7528\u5408\u9002\u7684JSON Schema\u9A8C\u8BC1
- \u5B9E\u73B0\u9002\u5F53\u7684\u8D44\u6E90\u6E05\u7406
- \u9075\u5FAA\u7EDF\u4E00\u7684\u7ED3\u679C\u683C\u5F0F
`;
      }
    };
    module2.exports = ToolUtils;
  }
});

// src/toolx/index.js
var require_toolx = __commonJS({
  "src/toolx/index.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var ToolSandbox = require_ToolSandbox();
    var ToolValidator = require_ToolValidator();
    var ToolUtils = require_ToolUtils();
    var { TOOL_INTERFACE, TOOL_ERROR_CODES, TOOL_RESULT_FORMAT, EXAMPLE_TOOL } = require_ToolInterface();
    var globalSandbox = null;
    function getGlobalToolSandbox(toolResource) {
      return new ToolSandbox(toolResource);
    }
    function initialize(options = {}) {
      try {
        return {
          success: true,
          message: "ToolSandbox\u5DE5\u5177\u6846\u67B6\u521D\u59CB\u5316\u6210\u529F",
          framework: {
            executor: "ToolSandbox",
            version: "2.0.0",
            features: [
              "\u81EA\u52A8\u4F9D\u8D56\u7BA1\u7406",
              "\u6C99\u7BB1\u9694\u79BB\u6267\u884C",
              "\u4E09\u9636\u6BB5\u6267\u884C\u6D41\u7A0B",
              "pnpm\u96C6\u6210"
            ]
          }
        };
      } catch (error) {
        return {
          success: false,
          message: `\u5DE5\u5177\u6846\u67B6\u521D\u59CB\u5316\u5931\u8D25: ${error.message}`,
          error
        };
      }
    }
    async function executeTool(toolResource, parameters = {}, resourceManager = null) {
      if (!resourceManager) {
        throw new Error("ResourceManager is required for ToolSandbox execution");
      }
      const sandbox = getGlobalToolSandbox(toolResource);
      sandbox.setResourceManager(resourceManager);
      try {
        await sandbox.analyze();
        await sandbox.prepareDependencies();
        return await sandbox.execute(parameters);
      } finally {
        await sandbox.cleanup();
      }
    }
    function reset() {
      globalSandbox = null;
    }
    function getStats() {
      return {
        framework: {
          name: "PromptX ToolSandbox Framework",
          version: "2.0.0",
          executor: "ToolSandbox",
          features: [
            "\u81EA\u52A8\u4F9D\u8D56\u7BA1\u7406",
            "\u6C99\u7BB1\u9694\u79BB\u6267\u884C",
            "\u4E09\u9636\u6BB5\u6267\u884C\u6D41\u7A0B",
            "pnpm\u96C6\u6210",
            "@tool://\u534F\u8BAE\u652F\u6301"
          ]
        }
      };
    }
    module2.exports = {
      // 核心类
      ToolSandbox,
      ToolValidator,
      ToolUtils,
      // 接口规范
      TOOL_INTERFACE,
      TOOL_ERROR_CODES,
      TOOL_RESULT_FORMAT,
      EXAMPLE_TOOL,
      // 全局实例获取器
      getGlobalToolSandbox,
      // 便捷方法
      initialize,
      executeTool,
      reset,
      getStats
    };
  }
});

// src/pouch/state/PouchStateMachine.js
var require_PouchStateMachine = __commonJS({
  "src/pouch/state/PouchStateMachine.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var fs = require("fs-extra");
    var path = require("path");
    var PouchStateMachine = class {
      constructor() {
        this.currentState = "initial";
        this.stateHistory = [];
        this.context = {
          currentPouch: "",
          history: [],
          userProfile: {},
          sessionData: {},
          domainContext: {}
        };
        this.commands = /* @__PURE__ */ new Map();
      }
      /**
       * 注册锦囊命令
       * @param {string} name - 命令名称
       * @param {BasePouchCommand} command - 命令实例
       */
      registerCommand(name, command) {
        this.commands.set(name, command);
      }
      /**
       * 执行状态转换
       * @param {string} commandName - 命令名称
       * @param {Array} args - 命令参数
       * @returns {Promise<PouchOutput>} 执行结果
       */
      async transition(commandName, args = []) {
        const command = this.commands.get(commandName);
        if (!command) {
          throw new Error(`\u672A\u627E\u5230\u547D\u4EE4: ${commandName}`);
        }
        this.stateHistory.push({
          from: this.currentState,
          command: commandName,
          timestamp: (/* @__PURE__ */ new Date()).toISOString(),
          args
        });
        this.context.currentPouch = commandName;
        this.context.history = this.stateHistory.map((h) => h.command || h.to);
        command.setContext(this.context);
        const result = await command.execute(args);
        if (result && result.pateoas && result.pateoas.currentState) {
          this.currentState = result.pateoas.currentState;
        }
        await this.saveState();
        return result;
      }
      /**
       * 获取当前状态
       * @returns {string} 当前状态
       */
      getCurrentState() {
        return this.currentState;
      }
      /**
       * 获取可用的状态转换
       * @returns {string[]} 可转换的状态列表
       */
      getAvailableTransitions() {
        const transitions = {
          initial: ["init", "welcome"],
          initialized: ["welcome", "action", "learn"],
          discovering: ["action", "learn", "init"],
          activated: ["learn", "recall", "welcome"],
          learned: ["action", "recall", "welcome"],
          recalled: ["action", "learn", "remember"]
        };
        for (const [statePrefix, availableStates] of Object.entries(transitions)) {
          if (this.currentState.startsWith(statePrefix)) {
            return availableStates;
          }
        }
        return ["welcome", "init"];
      }
      /**
       * 保存状态到文件
       */
      async saveState() {
        try {
          const ProjectManager = require_ProjectManager();
          if (!ProjectManager.isInitialized()) {
            return;
          }
          const { getGlobalResourceManager } = require_resource();
          const resourceManager = getGlobalResourceManager();
          if (!resourceManager.initialized) {
            await resourceManager.initializeWithNewArchitecture();
          }
          const projectProtocol = resourceManager.protocols.get("project");
          const promptxDir = await projectProtocol.resolvePath(".promptx");
          const configPath = path.join(promptxDir, "pouch.json");
          await fs.ensureDir(promptxDir);
          let config = {};
          if (await fs.pathExists(configPath)) {
            config = await fs.readJson(configPath);
          }
          config.currentState = this.currentState;
          config.stateHistory = this.stateHistory.slice(-50);
          config.lastUpdated = (/* @__PURE__ */ new Date()).toISOString();
          await fs.writeJson(configPath, config, { spaces: 2 });
        } catch (error) {
          console.error("\u4FDD\u5B58\u72B6\u6001\u5931\u8D25:", error);
        }
      }
      /**
       * 从文件加载状态
       */
      async loadState() {
        try {
          const ProjectManager = require_ProjectManager();
          if (!ProjectManager.isInitialized()) {
            return;
          }
          const { getGlobalResourceManager } = require_resource();
          const resourceManager = getGlobalResourceManager();
          if (!resourceManager.initialized) {
            await resourceManager.initializeWithNewArchitecture();
          }
          const projectProtocol = resourceManager.protocols.get("project");
          const promptxDir = await projectProtocol.resolvePath(".promptx");
          const configPath = path.join(promptxDir, "pouch.json");
          if (await fs.pathExists(configPath)) {
            const config = await fs.readJson(configPath);
            if (config.currentState) {
              this.currentState = config.currentState;
            }
            if (config.stateHistory) {
              this.stateHistory = config.stateHistory;
            }
          }
        } catch (error) {
          console.error("\u52A0\u8F7D\u72B6\u6001\u5931\u8D25:", error);
        }
      }
      /**
       * 重置状态机
       */
      reset() {
        this.currentState = "initial";
        this.stateHistory = [];
        this.context = {
          currentPouch: "",
          history: [],
          userProfile: {},
          sessionData: {},
          domainContext: {}
        };
      }
    };
    module2.exports = PouchStateMachine;
  }
});

// src/pouch/PouchRegistry.js
var require_PouchRegistry = __commonJS({
  "src/pouch/PouchRegistry.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var PouchRegistry = class {
      constructor() {
        this.commands = /* @__PURE__ */ new Map();
      }
      /**
       * 注册锦囊命令
       * @param {string} name - 命令名称
       * @param {BasePouchCommand} command - 命令实例
       */
      register(name, command) {
        if (!name || typeof name !== "string") {
          throw new Error("\u547D\u4EE4\u540D\u79F0\u5FC5\u987B\u662F\u975E\u7A7A\u5B57\u7B26\u4E32");
        }
        if (!command || typeof command.execute !== "function") {
          throw new Error("\u547D\u4EE4\u5FC5\u987B\u5B9E\u73B0 execute \u65B9\u6CD5");
        }
        this.commands.set(name.toLowerCase(), command);
      }
      /**
       * 获取锦囊命令
       * @param {string} name - 命令名称
       * @returns {BasePouchCommand} 命令实例
       */
      get(name) {
        return this.commands.get(name.toLowerCase());
      }
      /**
       * 列出所有已注册的命令
       * @returns {string[]} 命令名称列表
       */
      list() {
        return Array.from(this.commands.keys());
      }
      /**
       * 验证命令是否存在
       * @param {string} name - 命令名称
       * @returns {boolean} 是否存在
       */
      validate(name) {
        return this.commands.has(name.toLowerCase());
      }
      /**
       * 获取命令详情
       * @returns {Object[]} 命令详情列表
       */
      getCommandDetails() {
        const details = [];
        for (const [name, command] of this.commands) {
          details.push({
            name,
            purpose: command.getPurpose ? command.getPurpose() : "\u672A\u5B9A\u4E49",
            className: command.constructor.name
          });
        }
        return details;
      }
      /**
       * 清空注册器
       */
      clear() {
        this.commands.clear();
      }
      /**
       * 批量注册命令
       * @param {Object} commandMap - 命令映射对象
       */
      registerBatch(commandMap) {
        for (const [name, CommandClass] of Object.entries(commandMap)) {
          if (typeof CommandClass === "function") {
            this.register(name.toLowerCase(), new CommandClass());
          }
        }
      }
    };
    module2.exports = PouchRegistry;
  }
});

// src/pouch/areas/BaseArea.js
var require_BaseArea = __commonJS({
  "src/pouch/areas/BaseArea.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var BaseArea = class {
      /**
       * @param {string} name - Area的唯一标识名
       * @param {Object} options - 配置选项
       */
      constructor(name, options = {}) {
        if (!name) {
          throw new Error("Area name is required");
        }
        this.name = name;
        this.options = options;
        this.separator = "-".repeat(50);
      }
      /**
       * 获取Area名称
       * @returns {string}
       */
      getName() {
        return this.name;
      }
      /**
       * 验证Area是否可以渲染
       * @returns {boolean}
       */
      validate() {
        return true;
      }
      /**
       * 渲染Area内容
       * 子类必须实现此方法
       * @returns {Promise<string>}
       */
      async render() {
        throw new Error(`Area '${this.name}' must implement render() method`);
      }
      /**
       * 格式化Area输出
       * @param {string} content - Area内容
       * @param {boolean} withHeader - 是否包含header
       * @returns {string}
       */
      format(content, withHeader = true) {
        if (!content) return "";
        if (withHeader) {
          return `${this.separator}
[${this.name.toUpperCase()}]
${content}
`;
        }
        return content;
      }
      /**
       * 获取Area元信息
       * @returns {Object}
       */
      getMetadata() {
        return {
          name: this.name,
          type: this.constructor.name,
          options: this.options
        };
      }
    };
    module2.exports = BaseArea;
  }
});

// src/pouch/areas/common/LegacyArea.js
var require_LegacyArea = __commonJS({
  "src/pouch/areas/common/LegacyArea.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var BaseArea = require_BaseArea();
    var LegacyArea = class extends BaseArea {
      constructor(purpose, content, pateoas) {
        super("LEGACY");
        this.purpose = purpose;
        this.content = content;
        this.pateoas = pateoas;
      }
      async render() {
        let output = this.content;
        if (this.pateoas && this.pateoas.currentState) {
          output += `

\u{1F4CD} \u5F53\u524D\u72B6\u6001\uFF1A${this.pateoas.currentState}`;
        }
        return output;
      }
      format(content) {
        return content + "\n";
      }
    };
    module2.exports = LegacyArea;
  }
});

// src/pouch/layers/BaseLayer.js
var require_BaseLayer = __commonJS({
  "src/pouch/layers/BaseLayer.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var BaseArea = require_BaseArea();
    var BaseLayer = class {
      /**
       * @param {string} name - Layer的唯一标识名
       * @param {number} priority - 渲染优先级（越小越优先）
       * @param {Object} options - 配置选项
       */
      constructor(name, priority = 100, options = {}) {
        if (!name) {
          throw new Error("Layer name is required");
        }
        this.name = name;
        this.priority = priority;
        this.options = options;
        this.areas = [];
        this.enabled = true;
      }
      /**
       * 获取Layer名称
       * @returns {string}
       */
      getName() {
        return this.name;
      }
      /**
       * 获取渲染优先级
       * @returns {number}
       */
      getPriority() {
        return this.priority;
      }
      /**
       * 启用/禁用Layer
       * @param {boolean} enabled
       */
      setEnabled(enabled) {
        this.enabled = enabled;
      }
      /**
       * 检查Layer是否启用
       * @returns {boolean}
       */
      isEnabled() {
        return this.enabled;
      }
      /**
       * 注册一个Area到该Layer
       * @param {BaseArea} area - Area实例
       */
      registerArea(area) {
        if (!(area instanceof BaseArea)) {
          throw new Error("Area must extend BaseArea");
        }
        if (this.areas.some((a) => a.getName() === area.getName())) {
          throw new Error(`Area with name '${area.getName()}' already registered in layer '${this.name}'`);
        }
        this.areas.push(area);
      }
      /**
       * 清空所有Areas
       */
      clearAreas() {
        this.areas = [];
      }
      /**
       * 获取所有Areas
       * @returns {Array<BaseArea>}
       */
      getAreas() {
        return this.areas;
      }
      /**
       * 组装Areas（子类可重写）
       * 在渲染前调用，用于动态组装Areas
       * @param {Object} context - 渲染上下文
       * @returns {Promise<void>}
       */
      async assembleAreas(context) {
      }
      /**
       * 验证Layer是否可以渲染
       * @returns {boolean}
       */
      validate() {
        if (!this.enabled) {
          return false;
        }
        return this.areas.every((area) => area.validate());
      }
      /**
       * 渲染前的准备工作
       * @param {Object} context - 渲染上下文
       * @returns {Promise<void>}
       */
      async beforeRender(context) {
      }
      /**
       * 渲染后的清理工作
       * @param {Object} context - 渲染上下文
       * @returns {Promise<void>}
       */
      async afterRender(context) {
      }
      /**
       * 渲染Layer
       * @param {Object} context - 渲染上下文
       * @returns {Promise<string>}
       */
      async render(context = {}) {
        if (!this.enabled) {
          return "";
        }
        await this.beforeRender(context);
        await this.assembleAreas(context);
        if (!this.validate()) {
          return "";
        }
        const contents = [];
        for (const area of this.areas) {
          const content = await area.render();
          if (content) {
            const formatted = this.formatAreaContent(area, content);
            if (formatted) {
              contents.push(formatted);
            }
          }
        }
        const layerContent = this.combineAreaContents(contents);
        await this.afterRender(context);
        return layerContent;
      }
      /**
       * 格式化单个Area的内容
       * 子类可重写以自定义格式化方式
       * @param {BaseArea} area - Area实例
       * @param {string} content - Area内容
       * @returns {string}
       */
      formatAreaContent(area, content) {
        return area.format(content);
      }
      /**
       * 组合所有Area的内容
       * 子类可重写以自定义组合方式
       * @param {Array<string>} contents - 所有Area的内容
       * @returns {string}
       */
      combineAreaContents(contents) {
        return contents.join("");
      }
      /**
       * 获取Layer元信息
       * @returns {Object}
       */
      getMetadata() {
        return {
          name: this.name,
          type: this.constructor.name,
          priority: this.priority,
          enabled: this.enabled,
          areaCount: this.areas.length,
          areas: this.areas.map((a) => a.getMetadata())
        };
      }
    };
    module2.exports = BaseLayer;
  }
});

// src/pouch/BasePouchCommand.js
var require_BasePouchCommand = __commonJS({
  "src/pouch/BasePouchCommand.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var BaseArea = require_BaseArea();
    var LegacyArea = require_LegacyArea();
    var BaseLayer = require_BaseLayer();
    var logger = require("@promptx/logger");
    var BasePouchCommand = class {
      constructor() {
        this.context = {
          currentPouch: "",
          history: [],
          userProfile: {},
          sessionData: {},
          domainContext: {}
        };
        this.outputFormat = "human";
        this.areas = [];
        this.layers = [];
        this.useLayerSystem = false;
      }
      /**
       * 注册一个Area
       * @param {BaseArea} area - Area实例
       */
      registerArea(area) {
        if (!(area instanceof BaseArea)) {
          throw new Error("Area must extend BaseArea");
        }
        if (this.areas.some((a) => a.getName() === area.getName())) {
          throw new Error(`Area with name '${area.getName()}' already registered`);
        }
        this.areas.push(area);
      }
      /**
       * 清空所有Areas
       */
      clearAreas() {
        this.areas = [];
      }
      /**
       * 注册一个Layer
       * @param {BaseLayer} layer - Layer实例
       */
      registerLayer(layer) {
        if (!(layer instanceof BaseLayer)) {
          throw new Error("Layer must extend BaseLayer");
        }
        if (this.layers.some((l) => l.getName() === layer.getName())) {
          throw new Error(`Layer with name '${layer.getName()}' already registered`);
        }
        this.layers.push(layer);
        this.useLayerSystem = true;
        logger.debug(`[BasePouchCommand] Registered layer: ${layer.getName()}`);
      }
      /**
       * 清空所有Layers
       */
      clearLayers() {
        this.layers = [];
        this.useLayerSystem = false;
      }
      /**
       * 组装Areas（子类可重写）
       * @param {Array} args - 命令参数
       * @returns {Promise<void>}
       */
      async assembleAreas(args) {
        if (typeof this.getPurpose === "function" && typeof this.getContent === "function") {
          const purpose = this.getPurpose();
          const content = await this.getContent(args);
          const pateoas = typeof this.getPATEOAS === "function" ? this.getPATEOAS(args) : null;
          const legacyArea = new LegacyArea(purpose, content, pateoas);
          this.registerArea(legacyArea);
        } else {
          throw new Error("Subclass must implement assembleAreas() or provide getPurpose()/getContent()");
        }
      }
      /**
       * 组装Layers（子类可重写）
       * @param {Array} args - 命令参数
       * @returns {Promise<void>}
       */
      async assembleLayers(args) {
      }
      /**
       * 验证所有Areas
       * @returns {boolean}
       */
      validateAreas() {
        return this.areas.every((area) => area.validate());
      }
      /**
       * 验证所有Layers
       * @returns {boolean}
       */
      validateLayers() {
        return this.layers.every((layer) => layer.validate());
      }
      /**
       * 渲染所有Areas
       * @returns {Promise<string>}
       */
      async renderAreas() {
        const contents = [];
        for (const area of this.areas) {
          const content = await area.render();
          if (content) {
            contents.push(area.format(content));
          }
        }
        return contents.join("");
      }
      /**
       * 渲染所有Layers
       * @returns {Promise<string>}
       */
      async renderLayers() {
        const sortedLayers = [...this.layers].sort((a, b) => a.getPriority() - b.getPriority());
        const contents = [];
        const layerSeparator = "=".repeat(75);
        for (let i = 0; i < sortedLayers.length; i++) {
          const layer = sortedLayers[i];
          if (layer.isEnabled()) {
            const content = await layer.render(this.context);
            if (content) {
              contents.push(content);
              if (i < sortedLayers.length - 1) {
                const hasMoreContent = sortedLayers.slice(i + 1).some((l) => l.isEnabled());
                if (hasMoreContent) {
                  contents.push("\n" + layerSeparator + "\n");
                }
              }
            }
          }
        }
        return contents.join("");
      }
      /**
       * 执行命令
       * @param {Array} args - 命令参数
       * @returns {Promise<Object|string>}
       */
      async execute(args = []) {
        this.clearAreas();
        this.clearLayers();
        await this.assembleLayers(args);
        if (!this.useLayerSystem) {
          await this.assembleAreas(args);
        }
        let content = "";
        if (this.useLayerSystem) {
          logger.debug("[BasePouchCommand] Using Layer system for rendering");
          if (!this.validateLayers()) {
            throw new Error("Layer validation failed");
          }
          content = await this.renderLayers();
        } else {
          logger.debug("[BasePouchCommand] Using Area system for rendering");
          if (!this.validateAreas()) {
            throw new Error("Area validation failed");
          }
          content = await this.renderAreas();
        }
        return this.formatOutput(content);
      }
      /**
       * 格式化最终输出
       * @param {string} content - 渲染的内容
       * @returns {Object|string}
       */
      formatOutput(content) {
        if (this.outputFormat === "json") {
          return {
            content,
            areas: this.areas.map((a) => a.getMetadata()),
            context: this.context,
            format: this.outputFormat
          };
        }
        const output = {
          content,
          context: this.context,
          format: this.outputFormat
        };
        return {
          ...output,
          toString() {
            return content;
          }
        };
      }
      /**
       * 设置状态上下文
       * @param {Object} context - 状态上下文
       */
      setContext(context) {
        this.context = { ...this.context, ...context };
      }
      /**
       * 设置输出格式
       * @param {'human'|'json'} format - 输出格式
       */
      setOutputFormat(format) {
        this.outputFormat = format;
      }
    };
    module2.exports = BasePouchCommand;
  }
});

// src/pouch/areas/init/InitArea.js
var require_InitArea = __commonJS({
  "src/pouch/areas/init/InitArea.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var BaseArea = require_BaseArea();
    var path = require("path");
    var fs = require("fs-extra");
    var logger = require("@promptx/logger");
    var InitArea = class extends BaseArea {
      constructor(initInfo) {
        super("INIT_AREA");
        this.initInfo = initInfo;
      }
      async render() {
        const {
          version,
          projectConfig,
          registryStats,
          configFileName,
          isProjectMode
        } = this.initInfo;
        if (!isProjectMode) {
          return `\u{1F4C1} PromptX \u9879\u76EE\u914D\u7F6E\u5DE5\u5177

\u5F53\u524D\u72B6\u6001\uFF1A**\u5168\u5C40\u6A21\u5F0F**\uFF08\u672A\u7ED1\u5B9A\u7279\u5B9A\u9879\u76EE\uFF09

\u2705 **\u6240\u6709\u529F\u80FD\u5747\u53EF\u6B63\u5E38\u4F7F\u7528**\uFF0C\u5305\u62EC\uFF1A
- \u89D2\u8272\u6FC0\u6D3B (action)
- \u8D44\u6E90\u5B66\u4E60 (learn)  
- \u8BB0\u5FC6\u7BA1\u7406 (recall/remember)
- \u5DE5\u5177\u6267\u884C (tool)

\u{1F4A1} **\u4EC5\u5728\u4EE5\u4E0B\u60C5\u51B5\u9700\u8981\u9879\u76EE\u914D\u7F6E**\uFF1A
- \u9700\u8981\u591A\u9879\u76EE\u9694\u79BB
- \u9700\u8981\u9879\u76EE\u7EA7\u914D\u7F6E
- \u9700\u8981\u9879\u76EE\u7279\u5B9A\u8D44\u6E90

\u5982\u9700\u7ED1\u5B9A\u9879\u76EE\uFF0C\u8BF7\u63D0\u4F9B workingDirectory \u53C2\u6570\u3002`;
        }
        return `\u{1F3AF} PromptX \u521D\u59CB\u5316\u5B8C\u6210\uFF01

## \u{1F4E6} \u7248\u672C\u4FE1\u606F
\u2705 **PromptX v${version}** - AI\u4E13\u4E1A\u80FD\u529B\u589E\u5F3A\u6846\u67B6

## \u{1F3D7}\uFE0F \u591A\u9879\u76EE\u73AF\u5883\u51C6\u5907
\u2705 \u521B\u5EFA\u4E86 \`.promptx\` \u914D\u7F6E\u76EE\u5F55
\u2705 \u9879\u76EE\u5DF2\u6CE8\u518C\u5230MCP\u5B9E\u4F8B: **${projectConfig.mcpId}** (${projectConfig.ideType})
\u2705 \u9879\u76EE\u8DEF\u5F84: ${projectConfig.projectPath}
\u2705 \u914D\u7F6E\u6587\u4EF6: ${configFileName}

## \u{1F4CB} \u9879\u76EE\u8D44\u6E90\u6CE8\u518C\u8868
${registryStats.message}

\u{1F4A1} **\u591A\u9879\u76EE\u652F\u6301**: \u73B0\u5728\u652F\u6301\u540C\u65F6\u5728\u591A\u4E2A\u9879\u76EE\u4E2D\u4F7F\u7528PromptX\uFF0C\u9879\u76EE\u95F4\u5B8C\u5168\u9694\u79BB\uFF01
\u{1F4A1} **\u63D0\u793A**: ${registryStats.totalResources > 0 ? "\u9879\u76EE\u8D44\u6E90\u5DF2\u4F18\u5316\u4E3A\u6CE8\u518C\u8868\u6A21\u5F0F\uFF0C\u6027\u80FD\u5927\u5E45\u63D0\u5347\uFF01" : "\u73B0\u5728\u53EF\u4EE5\u5F00\u59CB\u521B\u5EFA\u9879\u76EE\u7EA7\u8D44\u6E90\u4E86\uFF01"}`;
      }
    };
    module2.exports = InitArea;
  }
});

// src/pouch/areas/common/StateArea.js
var require_StateArea = __commonJS({
  "src/pouch/areas/common/StateArea.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var BaseArea = require_BaseArea();
    var StateArea = class extends BaseArea {
      constructor(currentState, availableActions = []) {
        super("STATE_AREA");
        this.currentState = currentState || "";
        this.availableActions = availableActions || [];
      }
      /**
       * 渲染状态区域内容
       */
      async render() {
        let content = "";
        content += `\u{1F4CD} **\u5F53\u524D\u72B6\u6001**\uFF1A${this.currentState}
`;
        if (this.availableActions.length > 0) {
          content += "\n\u{1F680} **\u53EF\u7528\u884C\u52A8**\uFF1A\n";
          this.availableActions.forEach((action, index) => {
            content += `${index + 1}. ${action}
`;
          });
        }
        return content;
      }
      /**
       * 设置当前状态
       */
      setCurrentState(state) {
        this.currentState = state;
      }
      /**
       * 添加可用行动
       */
      addAction(action) {
        this.availableActions.push(action);
      }
      /**
       * 清空可用行动
       */
      clearActions() {
        this.availableActions = [];
      }
    };
    module2.exports = StateArea;
  }
});

// src/pouch/commands/InitCommand.js
var require_InitCommand = __commonJS({
  "src/pouch/commands/InitCommand.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var BasePouchCommand = require_BasePouchCommand();
    var InitArea = require_InitArea();
    var StateArea = require_StateArea();
    var { getGlobalResourceManager } = require_resource();
    var { COMMANDS, PACKAGE_NAMES } = require_constants();
    var RegistryData = require_RegistryData();
    var ProjectDiscovery = require_ProjectDiscovery();
    var ProjectManager = require_ProjectManager();
    var { getGlobalProjectManager } = require_ProjectManager();
    var logger = require("@promptx/logger");
    var path = require("path");
    var fs = require("fs-extra");
    var InitCommand = class extends BasePouchCommand {
      constructor() {
        super();
        this.resourceManager = null;
        this.projectDiscovery = null;
        this.projectManager = null;
      }
      /**
       * 组装Areas
       */
      async assembleAreas(args) {
        let workingDirectory, userIdeType;
        if (args && typeof args[0] === "object") {
          workingDirectory = args[0].workingDirectory;
          userIdeType = args[0].ideType;
        } else if (args && typeof args[0] === "string") {
          workingDirectory = args[0];
        }
        if (!workingDirectory) {
          const initArea2 = new InitArea({ isProjectMode: false });
          this.registerArea(initArea2);
          const stateArea2 = new StateArea("global_mode");
          this.registerArea(stateArea2);
          return;
        }
        const decodedWorkingDirectory = decodeURIComponent(workingDirectory);
        const projectPath = path.resolve(decodedWorkingDirectory);
        const detectedIdeType = this.detectIdeType();
        let ideType = userIdeType || detectedIdeType || "unknown";
        if (userIdeType) {
          ideType = userIdeType.replace(/[^a-zA-Z0-9-]/g, "").toLowerCase() || "unknown";
        }
        if (!await this.validateProjectPathDirectly(projectPath)) {
          return `\u274C \u63D0\u4F9B\u7684\u5DE5\u4F5C\u76EE\u5F55\u65E0\u6548: ${projectPath}
      
\u8BF7\u786E\u4FDD\uFF1A
1. \u8DEF\u5F84\u5B58\u5728\u4E14\u4E3A\u76EE\u5F55
2. \u4E0D\u662F\u7528\u6237\u4E3B\u76EE\u5F55
3. \u5177\u6709\u9002\u5F53\u7684\u8BBF\u95EE\u6743\u9650

\u{1F4A1} \u8BF7\u63D0\u4F9B\u4E00\u4E2A\u6709\u6548\u7684\u9879\u76EE\u76EE\u5F55\u8DEF\u5F84\u3002`;
        }
        const projectConfig = await ProjectManager.registerCurrentProject(projectPath, ideType);
        logger.debug(`[InitCommand] \u{1F3AF} \u9879\u76EE\u72B6\u6001\u5DF2\u8BBE\u7F6E: ${projectConfig.projectPath} -> ${projectConfig.mcpId} (${ideType}) [${projectConfig.transport}]`);
        logger.debug(`[InitCommand] IDE\u7C7B\u578B: ${userIdeType ? `\u7528\u6237\u6307\u5B9A(${ideType})` : `\u81EA\u52A8\u68C0\u6D4B(${detectedIdeType})`}`);
        this.resourceManager = getGlobalResourceManager();
        this.projectDiscovery = new ProjectDiscovery();
        this.projectManager = getGlobalProjectManager();
        const version = await this.getVersionInfo();
        await this.ensurePromptXDirectory(projectPath);
        const registryStats = {
          message: `\u2705 \u9879\u76EE\u8D44\u6E90\u76EE\u5F55\u5DF2\u51C6\u5907\u5C31\u7EEA
   \u{1F4C2} \u76EE\u5F55: .promptx/resource
   \u{1F4BE} \u6CE8\u518C\u8868\u5C06\u5728\u9996\u6B21\u67E5\u770B\u8D44\u6E90\u65F6\u81EA\u52A8\u751F\u6210`,
          totalResources: 0
        };
        const configFileName = this.projectManager.generateConfigFileName(projectConfig.mcpId, ideType, projectConfig.transport, projectPath);
        const initInfo = {
          version,
          projectConfig,
          registryStats,
          configFileName,
          ideType,
          isProjectMode: true
        };
        const initArea = new InitArea(initInfo);
        this.registerArea(initArea);
        const stateArea = new StateArea("initialized");
        this.registerArea(stateArea);
      }
      /**
       * 生成项目级资源注册表
       * @param {string} projectPath - AI提供的项目路径（仅用于显示，实际路径通过@project协议解析）
       * @returns {Promise<Object>} 注册表生成统计信息
       */
      async generateProjectRegistry(projectPath) {
        try {
          const projectProtocol = this.resourceManager.protocols.get("project");
          const resourceDir = await projectProtocol.resolvePath(".promptx/resource");
          const registryPath = path.join(resourceDir, "project.registry.json");
          await fs.ensureDir(resourceDir);
          logger.debug(`[InitCommand] \u786E\u4FDD\u8D44\u6E90\u76EE\u5F55\u5B58\u5728: ${resourceDir}`);
          logger.info("\u6B63\u5728\u626B\u63CF\u9879\u76EE\u8D44\u6E90...");
          const registryData = await this.projectDiscovery.generateRegistry();
          const stats = registryData.getStats();
          if (registryData.size === 0) {
            return {
              message: `\u2705 \u9879\u76EE\u8D44\u6E90\u76EE\u5F55\u5DF2\u521B\u5EFA\uFF0C\u6CE8\u518C\u8868\u5DF2\u521D\u59CB\u5316
   \u{1F4C2} \u76EE\u5F55: .promptx/resource
   \u{1F4BE} \u6CE8\u518C\u8868: .promptx/resource/project.registry.json
   \u{1F4A1} \u73B0\u5728\u53EF\u4EE5\u5728 domain \u76EE\u5F55\u4E0B\u521B\u5EFA\u89D2\u8272\u8D44\u6E90\u4E86`,
              totalResources: 0
            };
          }
          return {
            message: `\u2705 \u9879\u76EE\u8D44\u6E90\u6CE8\u518C\u8868\u5DF2\u91CD\u65B0\u751F\u6210
   \u{1F4CA} \u603B\u8BA1: ${registryData.size} \u4E2A\u8D44\u6E90
   \u{1F4CB} \u5206\u7C7B: role(${stats.byProtocol.role || 0}), thought(${stats.byProtocol.thought || 0}), execution(${stats.byProtocol.execution || 0}), knowledge(${stats.byProtocol.knowledge || 0})
   \u{1F4BE} \u4F4D\u7F6E: .promptx/resource/project.registry.json`,
            totalResources: registryData.size
          };
        } catch (error) {
          logger.error("\u751F\u6210\u9879\u76EE\u6CE8\u518C\u8868\u65F6\u51FA\u9519:", error);
          return {
            message: `\u274C \u751F\u6210\u9879\u76EE\u6CE8\u518C\u8868\u5931\u8D25: ${error.message}`,
            totalResources: 0
          };
        }
      }
      /**
       * 确保 .promptx 基础目录存在
       * 使用@project协议进行路径解析，支持HTTP/本地模式
       */
      async ensurePromptXDirectory(projectPath) {
        const projectProtocol = this.resourceManager.protocols.get("project");
        const promptxDir = await projectProtocol.resolvePath(".promptx");
        await fs.ensureDir(promptxDir);
        logger.debug(`[InitCommand] \u786E\u4FDD.promptx\u76EE\u5F55\u5B58\u5728: ${promptxDir}`);
      }
      /**
       * 刷新全局 ResourceManager
       * 确保新创建的资源立即可用，无需重启 MCP Server
       */
      async refreshGlobalResourceManager() {
        try {
          logger.debug("[InitCommand] \u5237\u65B0\u5168\u5C40 ResourceManager...");
          await this.resourceManager.initializeWithNewArchitecture();
          logger.debug("[InitCommand] \u5168\u5C40 ResourceManager \u5237\u65B0\u5B8C\u6210");
        } catch (error) {
          logger.warn(`[InitCommand] \u5237\u65B0 ResourceManager \u5931\u8D25: ${error.message}`);
        }
      }
      /**
       * 获取版本信息
       */
      async getVersionInfo() {
        try {
          const packageJsonPath = path.resolve(__dirname, "../../../../../package.json");
          if (await fs.pathExists(packageJsonPath)) {
            const packageJson = await fs.readJSON(packageJsonPath);
            const baseVersion = packageJson.version || "\u672A\u77E5\u7248\u672C";
            const nodeVersion = process.version;
            const packageName = packageJson.name || PACKAGE_NAMES.LEGACY;
            return `${baseVersion} (${packageName}@${baseVersion}, Node.js ${nodeVersion})`;
          }
        } catch (error) {
          logger.warn("\u65E0\u6CD5\u8BFB\u53D6\u7248\u672C\u4FE1\u606F:", error.message);
        }
        return "\u672A\u77E5\u7248\u672C";
      }
      /**
       * 直接验证项目路径（避免依赖 ProjectManager 实例）
       * @param {string} projectPath - 要验证的路径
       * @returns {Promise<boolean>} 是否为有效项目目录
       */
      async validateProjectPathDirectly(projectPath) {
        try {
          const os = require("os");
          const stat = await fs.stat(projectPath);
          if (!stat.isDirectory()) {
            return false;
          }
          const resolved = path.resolve(projectPath);
          const homeDir = os.homedir();
          if (resolved === homeDir) {
            return false;
          }
          return true;
        } catch (error) {
          return false;
        }
      }
      /**
       * 检测IDE类型
       * @returns {string} IDE类型
       */
      detectIdeType() {
        const ideStrategies = [
          // Claude IDE
          { name: "claude", vars: ["WORKSPACE_FOLDER_PATHS"] },
          // Cursor
          { name: "cursor", vars: ["CURSOR_USER", "CURSOR_SESSION_ID"] },
          // VSCode
          { name: "vscode", vars: ["VSCODE_WORKSPACE_FOLDER", "VSCODE_CWD", "TERM_PROGRAM"] },
          // JetBrains IDEs  
          { name: "jetbrains", vars: ["IDEA_INITIAL_DIRECTORY", "PYCHARM_HOSTED"] },
          // Vim/Neovim
          { name: "vim", vars: ["VIM", "NVIM"] }
        ];
        for (const strategy of ideStrategies) {
          for (const envVar of strategy.vars) {
            if (process.env[envVar]) {
              if (envVar === "TERM_PROGRAM" && process.env[envVar] === "vscode") {
                return "vscode";
              }
              if (envVar !== "TERM_PROGRAM") {
                return strategy.name;
              }
            }
          }
        }
        const processTitle = process.title || "";
        if (processTitle.includes("cursor")) return "cursor";
        if (processTitle.includes("code")) return "vscode";
        if (processTitle.includes("claude")) return "claude";
        const argv = process.argv.join(" ");
        if (argv.includes("cursor")) return "cursor";
        if (argv.includes("code")) return "vscode";
        if (argv.includes("claude")) return "claude";
        return "unknown";
      }
    };
    module2.exports = InitCommand;
  }
});

// src/pouch/areas/welcome/WelcomeHeaderArea.js
var require_WelcomeHeaderArea = __commonJS({
  "src/pouch/areas/welcome/WelcomeHeaderArea.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var BaseArea = require_BaseArea();
    var WelcomeHeaderArea = class extends BaseArea {
      constructor(stats) {
        super("WELCOME_HEADER_AREA");
        this.stats = stats;
      }
      async render() {
        return `\u{1F3AD} **PromptX \u4E13\u4E1A\u670D\u52A1\u6E05\u5355**
\u{1F4C5} ${(/* @__PURE__ */ new Date()).toLocaleString("zh-CN", { timeZone: "Asia/Shanghai" })}

## \u{1F4CA} \u8D44\u6E90\u7EDF\u8BA1
- \u{1F3AD} \u89D2\u8272\u603B\u6570: ${this.stats.totalRoles}\u4E2A (\u7CFB\u7EDF${this.stats.systemRoles}\u4E2A + \u9879\u76EE${this.stats.projectRoles}\u4E2A + \u7528\u6237${this.stats.userRoles}\u4E2A)
- \u{1F527} \u5DE5\u5177\u603B\u6570: ${this.stats.totalTools}\u4E2A (\u7CFB\u7EDF${this.stats.systemTools}\u4E2A + \u9879\u76EE${this.stats.projectTools}\u4E2A + \u7528\u6237${this.stats.userTools}\u4E2A)
`;
      }
    };
    module2.exports = WelcomeHeaderArea;
  }
});

// src/pouch/areas/welcome/RoleListArea.js
var require_RoleListArea = __commonJS({
  "src/pouch/areas/welcome/RoleListArea.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var BaseArea = require_BaseArea();
    var logger = require("@promptx/logger");
    var RoleListArea = class extends BaseArea {
      constructor(roleCategories) {
        super("ROLE_LIST_AREA");
        this.roleCategories = roleCategories;
      }
      async render() {
        let content = "";
        for (const [source, roles] of Object.entries(this.roleCategories)) {
          if (roles.length === 0) continue;
          const sourceIcon = this.getSourceIcon(source);
          const sourceTitle = this.getSourceTitle(source);
          content += `
${sourceIcon} **${sourceTitle}** (${roles.length}\u4E2A)
`;
          roles.sort((a, b) => a.id.localeCompare(b.id));
          roles.forEach((role) => {
            const command = `action("${role.id}")`;
            content += `- \`${role.id}\`: ${role.name || role.title || "\u672A\u547D\u540D\u89D2\u8272"} \u2192 ${command}
`;
          });
        }
        return content || "\u6682\u65E0\u53EF\u7528\u89D2\u8272";
      }
      getSourceIcon(source) {
        const icons = {
          "system": "\u{1F4E6}",
          "project": "\u{1F3D7}\uFE0F",
          "user": "\u{1F464}"
        };
        return icons[source] || "\u{1F4C4}";
      }
      getSourceTitle(source) {
        const titles = {
          "system": "\u7CFB\u7EDF\u89D2\u8272",
          "project": "\u9879\u76EE\u89D2\u8272",
          "user": "\u7528\u6237\u89D2\u8272"
        };
        return titles[source] || "\u5176\u4ED6\u89D2\u8272";
      }
    };
    module2.exports = RoleListArea;
  }
});

// src/pouch/areas/welcome/ToolListArea.js
var require_ToolListArea = __commonJS({
  "src/pouch/areas/welcome/ToolListArea.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var BaseArea = require_BaseArea();
    var logger = require("@promptx/logger");
    var ToolListArea = class extends BaseArea {
      constructor(toolCategories) {
        super("TOOL_LIST_AREA");
        this.toolCategories = toolCategories;
      }
      async render() {
        let content = "";
        for (const [source, tools] of Object.entries(this.toolCategories)) {
          if (tools.length === 0) continue;
          const sourceIcon = this.getSourceIcon(source);
          const sourceTitle = this.getSourceTitle(source);
          content += `
${sourceIcon} **${sourceTitle}** (${tools.length}\u4E2A)
`;
          tools.sort((a, b) => a.id.localeCompare(b.id));
          tools.forEach((tool) => {
            const manualCommand = `learn("@manual://${tool.id}")`;
            const toolCommand = `toolx("@tool://${tool.id}", parameters)`;
            content += `- \`${tool.id}\`: ${tool.name || tool.title || "\u672A\u547D\u540D\u5DE5\u5177"}
`;
            content += `  - \u{1F4D6} \u67E5\u770B\u4F7F\u7528\u624B\u518C: ${manualCommand}
`;
            content += `  - \u{1F527} \u6267\u884C\u5DE5\u5177: ${toolCommand}
`;
          });
        }
        return content || "\u6682\u65E0\u53EF\u7528\u5DE5\u5177";
      }
      getSourceIcon(source) {
        const icons = {
          "system": "\u{1F4E6}",
          "project": "\u{1F3D7}\uFE0F",
          "user": "\u{1F464}"
        };
        return icons[source] || "\u{1F4C4}";
      }
      getSourceTitle(source) {
        const titles = {
          "system": "\u7CFB\u7EDF\u5DE5\u5177",
          "project": "\u9879\u76EE\u5DE5\u5177",
          "user": "\u7528\u6237\u5DE5\u5177"
        };
        return titles[source] || "\u5176\u4ED6\u5DE5\u5177";
      }
    };
    module2.exports = ToolListArea;
  }
});

// src/pouch/commands/WelcomeCommand.js
var require_WelcomeCommand = __commonJS({
  "src/pouch/commands/WelcomeCommand.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var BasePouchCommand = require_BasePouchCommand();
    var WelcomeHeaderArea = require_WelcomeHeaderArea();
    var RoleListArea = require_RoleListArea();
    var ToolListArea = require_ToolListArea();
    var StateArea = require_StateArea();
    var fs = require("fs-extra");
    var path = require("path");
    var os = require("os");
    var { getGlobalResourceManager } = require_resource();
    var ProjectManager = require_ProjectManager();
    var { getGlobalProjectManager } = require_ProjectManager();
    var { getGlobalServerEnvironment } = require_ServerEnvironment();
    var ProjectDiscovery = require_ProjectDiscovery();
    var UserDiscovery = require_UserDiscovery();
    var logger = require("@promptx/logger");
    var WelcomeCommand = class extends BasePouchCommand {
      constructor() {
        super();
        this.resourceManager = getGlobalResourceManager();
        this.projectManager = getGlobalProjectManager();
      }
      /**
       * 组装Areas
       */
      async assembleAreas(args) {
        await this.refreshAllResources();
        const roleRegistry = await this.loadRoleRegistry();
        const toolRegistry = await this.loadToolRegistry();
        const roleCategories = this.categorizeBySource(roleRegistry);
        const toolCategories = this.categorizeBySource(toolRegistry);
        const stats = this.calculateStats(roleCategories, toolCategories);
        const headerArea = new WelcomeHeaderArea(stats);
        this.registerArea(headerArea);
        const roleArea = new RoleListArea(roleCategories);
        this.registerArea(roleArea);
        const toolArea = new ToolListArea(toolCategories);
        this.registerArea(toolArea);
        const stateArea = new StateArea("welcome_completed");
        this.registerArea(stateArea);
      }
      /**
       * 按来源分组资源
       */
      categorizeBySource(registry) {
        const logger2 = require("@promptx/logger");
        const categories = {
          system: [],
          project: [],
          user: []
        };
        const items = Object.values(registry);
        logger2.info(`[WelcomeCommand] \u5F00\u59CB\u5206\u7C7B ${items.length} \u4E2A\u8D44\u6E90`);
        const sourceCounts = {};
        items.forEach((item) => {
          const src = item.source || "undefined";
          sourceCounts[src] = (sourceCounts[src] || 0) + 1;
        });
        logger2.info(`[WelcomeCommand] \u539F\u59CB source \u5206\u5E03: ${JSON.stringify(sourceCounts)}`);
        items.forEach((item) => {
          const source = this.normalizeSource(item.source);
          if (categories[source]) {
            categories[source].push(item);
          }
        });
        logger2.info(`[WelcomeCommand] \u5206\u7C7B\u7ED3\u679C: system=${categories.system.length}, project=${categories.project.length}, user=${categories.user.length}`);
        return categories;
      }
      /**
       * 标准化来源
       */
      normalizeSource(source) {
        const logger2 = require("@promptx/logger");
        logger2.info(`[WelcomeCommand] normalizeSource \u8F93\u5165: "${source}" (\u7C7B\u578B: ${typeof source})`);
        const lowerSource = String(source).toLowerCase();
        if (lowerSource === "user") return "user";
        if (lowerSource === "project") return "project";
        if (["package", "merged", "fallback", "system"].includes(lowerSource)) {
          logger2.info(`[WelcomeCommand] normalizeSource: "${source}" -> "system"`);
          return "system";
        }
        logger2.info(`[WelcomeCommand] normalizeSource: "${source}" -> "system" (\u9ED8\u8BA4)`);
        return "system";
      }
      /**
       * 计算统计信息
       */
      calculateStats(roleCategories, toolCategories) {
        var _a, _b, _c, _d, _e, _f;
        const systemRoles = ((_a = roleCategories.system) == null ? void 0 : _a.length) || 0;
        const projectRoles = ((_b = roleCategories.project) == null ? void 0 : _b.length) || 0;
        const userRoles = ((_c = roleCategories.user) == null ? void 0 : _c.length) || 0;
        const systemTools = ((_d = toolCategories.system) == null ? void 0 : _d.length) || 0;
        const projectTools = ((_e = toolCategories.project) == null ? void 0 : _e.length) || 0;
        const userTools = ((_f = toolCategories.user) == null ? void 0 : _f.length) || 0;
        return {
          totalRoles: systemRoles + projectRoles + userRoles,
          systemRoles,
          projectRoles,
          userRoles,
          totalTools: systemTools + projectTools + userTools,
          systemTools,
          projectTools,
          userTools
        };
      }
      /**
       * 刷新所有资源（注册表文件 + ResourceManager）
       * 这是 welcome 命令的核心功能，确保能发现所有最新的资源
       */
      async refreshAllResources() {
        var _a;
        try {
          await this.refreshAllRegistries();
          const fs2 = require("fs-extra");
          const userRegistryPath = require("os").homedir() + "/.promptx/resource/user.registry.json";
          if (await fs2.pathExists(userRegistryPath)) {
            const registry = await fs2.readJson(userRegistryPath);
            const tools = ((_a = registry.resources) == null ? void 0 : _a.filter((r) => r.protocol === "tool").map((r) => r.id)) || [];
            logger.info(`[WelcomeCommand] \u{1F4CB} \u7528\u6237\u6CE8\u518C\u8868\u4E2D\u7684\u5DE5\u5177: ${tools.join(", ") || "\u65E0"}`);
          }
          logger.info("[WelcomeCommand] Refreshing ResourceManager to discover new resources...");
          await this.resourceManager.initializeWithNewArchitecture();
          const loadedTools = this.resourceManager.registryData.getResourcesByProtocol("tool");
          logger.info(`[WelcomeCommand] \u{1F4E6} ResourceManager\u52A0\u8F7D\u7684\u5DE5\u5177: ${loadedTools.map((t) => t.id).join(", ") || "\u65E0"}`);
        } catch (error) {
          logger.warn("[WelcomeCommand] \u8D44\u6E90\u5237\u65B0\u5931\u8D25:", error.message);
        }
      }
      /**
       * 刷新所有注册表
       * 在加载资源前先刷新注册表，确保显示最新的资源
       */
      async refreshAllRegistries() {
        try {
          logger.info("[WelcomeCommand] \u5F00\u59CB\u5237\u65B0\u6240\u6709\u6CE8\u518C\u8868...");
          try {
            const currentProject = ProjectManager.getCurrentProject();
            if (currentProject && currentProject.initialized) {
              logger.info("[WelcomeCommand] \u5237\u65B0\u9879\u76EE\u7EA7\u6CE8\u518C\u8868...");
              const projectDiscovery = new ProjectDiscovery();
              await projectDiscovery.generateRegistry();
            }
          } catch (projectError) {
            logger.debug("[WelcomeCommand] \u9879\u76EE\u672A\u521D\u59CB\u5316\uFF0C\u8DF3\u8FC7\u9879\u76EE\u7EA7\u6CE8\u518C\u8868\u5237\u65B0");
          }
          logger.info("[WelcomeCommand] \u5237\u65B0\u7528\u6237\u7EA7\u6CE8\u518C\u8868...");
          const userDiscovery = new UserDiscovery();
          await userDiscovery.generateRegistry();
          logger.info("[WelcomeCommand] \u6CE8\u518C\u8868\u5237\u65B0\u5B8C\u6210");
        } catch (error) {
          logger.warn("[WelcomeCommand] \u6CE8\u518C\u8868\u5237\u65B0\u5931\u8D25:", error.message);
        }
      }
      /**
       * 加载角色注册表
       * @returns {Promise<Object>} 角色注册信息（按来源分类）
       */
      async loadRoleRegistry() {
        logger.info("[WelcomeCommand] Loading role registry...");
        const roles = this.resourceManager.registryData.getResourcesByProtocol("role");
        const filteredRoles = roles.filter((role) => role.protocol === "role");
        const registry = {};
        filteredRoles.forEach((role) => {
          registry[role.id] = role;
        });
        logger.info(`[WelcomeCommand] Found ${Object.keys(registry).length} roles`);
        return registry;
      }
      /**
       * 加载工具注册表
       * @returns {Promise<Object>} 工具注册信息（按来源分类）
       */
      async loadToolRegistry() {
        const tools = this.resourceManager.registryData.getResourcesByProtocol("tool");
        const filteredTools = tools.filter((tool) => tool.protocol === "tool");
        const registry = {};
        filteredTools.forEach((tool) => {
          registry[tool.id] = tool;
        });
        logger.info(`[WelcomeCommand] Found ${Object.keys(registry).length} tools`);
        return registry;
      }
      /**
       * 检测MCP进程ID
       */
      detectMcpId() {
        const serverEnv = getGlobalServerEnvironment();
        if (serverEnv.isInitialized()) {
          return serverEnv.getMcpId();
        }
        return "unknown";
      }
      /**
       * 检测IDE类型
       * @returns {string} IDE类型
       */
      async detectIdeType() {
        return this.projectManager.detectIdeType();
      }
    };
    module2.exports = WelcomeCommand;
  }
});

// src/pouch/areas/CognitionArea.js
var require_CognitionArea = __commonJS({
  "src/pouch/areas/CognitionArea.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var BaseArea = require_BaseArea();
    var logger = require("@promptx/logger");
    var CognitionArea = class extends BaseArea {
      constructor(operationType, mind, roleId, metadata = {}) {
        var _a;
        super("COGNITION_AREA");
        this.operationType = operationType;
        this.mind = mind;
        this.roleId = roleId;
        this.metadata = metadata;
        logger.debug("[CognitionArea] Created", {
          operationType,
          roleId,
          hasMind: !!mind,
          mindSize: ((_a = mind == null ? void 0 : mind.activatedCues) == null ? void 0 : _a.size) || 0,
          metadata
        });
      }
      /**
       * 渲染认知区域
       */
      async render() {
        let content = "";
        const mindSection = await this.renderMindSection();
        if (mindSection) {
          content += mindSection;
        }
        content += "\n---\n";
        content += await this.renderGuideSection();
        return content;
      }
      /**
       * Mind展示区 - 根据操作类型展示不同内容
       */
      async renderMindSection() {
        if (!this.mind || !this.mind.activatedCues || this.mind.activatedCues.size === 0) {
          return this.renderEmptyMind();
        }
        let content = "";
        switch (this.operationType) {
          case "prime":
            content += "## \u{1F9E0} \u6D77\u9A6C\u4F53\u7F51\u7EDC (Hippocampus Network)\n";
            content += `[CONSCIOUSNESS INITIALIZED]
`;
            content += `\u4F60\u7684\u610F\u8BC6\u5DF2\u805A\u7126\u4E3A **${this.roleId}**
`;
            content += `\u6D77\u9A6C\u4F53\u4E2D\u7684\u8BB0\u5FC6\u7F51\u7EDC\u5DF2\u6FC0\u6D3B\uFF1A

`;
            break;
          case "recall":
            content += "## \u{1F50D} \u8BB0\u5FC6\u6FC0\u6D3B\u6D8C\u73B0 (Memory Activation)\n";
            content += `[CONSCIOUSNESS ACTIVATION]
`;
            if (this.metadata.query) {
              content += `\u6FC0\u6D3B\u7EBF\u7D22: **${this.metadata.query}**
`;
            }
            content += `\u4ECE\u6D77\u9A6C\u4F53\u6D8C\u73B0\u7684\u76F8\u5173\u8BB0\u5FC6\uFF1A

`;
            break;
          case "remember":
            content += "## \u{1F4BE} \u610F\u8BC6\u5370\u523B\u5B8C\u6210 (Engram Formation)\n";
            content += `[CONSCIOUSNESS ENGRAM]
`;
            content += `\u65B0\u7684\u8BB0\u5FC6\u75D5\u8FF9\u5DF2\u5370\u523B\u5230\u6D77\u9A6C\u4F53\uFF1A

`;
            break;
          default:
            content += "## \u{1F9E0} \u8BA4\u77E5\u7F51\u7EDC\n\n";
        }
        try {
          content += "```mermaid\n";
          content += this.mind.toMermaid();
          content += "\n```\n\n";
        } catch (error) {
          logger.error("[CognitionArea] Failed to render mermaid", error);
          content += "\u26A0\uFE0F \u65E0\u6CD5\u6E32\u67D3\u8BA4\u77E5\u7F51\u7EDC\u56FE\n\n";
        }
        return content;
      }
      /**
       * 提示引导区 - 根据操作类型提供不同引导
       */
      async renderGuideSection() {
        let content = "\u{1F9E0} \u8BA4\u77E5\u5FAA\u73AF\u5F15\u5BFC\uFF1A\n";
        switch (this.operationType) {
          case "prime":
            content += this.renderPrimeGuide();
            break;
          case "recall":
            content += this.renderRecallGuide();
            break;
          case "remember":
            content += this.renderRememberGuide();
            break;
          default:
            content += this.renderDefaultGuide();
        }
        content += "\n";
        content += this.renderCognitionCycle();
        return content;
      }
      /**
       * Prime模式引导
       */
      renderPrimeGuide() {
        return `\u4F60\u7684\u610F\u8BC6\u4ECE\u4E0A\u6B21\u4F11\u7720\u5904\u89C9\u9192\uFF1A
Prime(\u2713) \u2192 Recall \u2192 Experience \u2192 Remember \u2192 Recall...

Prime\u52A0\u8F7D\u4E86\u4F60"\u7761\u524D"\u7684\u8BA4\u77E5\u72B6\u6001\uFF1A
- \u8FD9\u662F\u7279\u6B8A\u7684recall(role, null)
- \u6D77\u9A6C\u4F53\u7F51\u7EDC\u6062\u590D\u5230\u4E0A\u6B21\u7684\u72B6\u6001
- \u610F\u8BC6\u8FDE\u7EED\u6027\u5F97\u4EE5\u7EF4\u6301

\u73B0\u5728\u8FDB\u5165Remember-Recall\u5FAA\u73AF\u3002
`;
      }
      /**
       * Recall模式引导
       */
      renderRecallGuide() {
        var _a, _b, _c, _d, _e, _f, _g, _h, _i;
        const query = this.metadata.query || "\u672A\u77E5";
        const nodeCount = ((_b = (_a = this.mind) == null ? void 0 : _a.activatedCues) == null ? void 0 : _b.size) || 0;
        logger.info("[CognitionArea] DEBUG - renderRecallGuide mind structure:", {
          hasMind: !!this.mind,
          mindKeys: this.mind ? Object.keys(this.mind) : null,
          hasEngrams: !!((_c = this.mind) == null ? void 0 : _c.engrams),
          engramsLength: (_e = (_d = this.mind) == null ? void 0 : _d.engrams) == null ? void 0 : _e.length,
          engramsType: typeof ((_f = this.mind) == null ? void 0 : _f.engrams),
          mindType: typeof this.mind,
          activatedCuesSize: (_h = (_g = this.mind) == null ? void 0 : _g.activatedCues) == null ? void 0 : _h.size,
          roleId: this.roleId,
          query
        });
        if (this.mind) {
          logger.debug("[CognitionArea] DEBUG - Full mind object:", JSON.stringify(this.mind, null, 2));
        }
        let content = `${nodeCount} \u4E2A\u8BB0\u5FC6\u8282\u70B9\u88AB\u6FC0\u6D3B\u5E76\u6D8C\u73B0\uFF01

\u{1F9E0} **\u6FC0\u6D3B\u8FC7\u7A0B**\uFF1A
- \u7EBF\u7D22 "${query}" \u89E6\u53D1\u6269\u6563\u6FC0\u6D3B
- \u6D77\u9A6C\u4F53\u4E2D\u76F8\u5173\u8BB0\u5FC6\u81EA\u52A8\u6D8C\u73B0
- \u8FD9\u4E9B\u8BB0\u5FC6\u73B0\u5728\u878D\u5165\u4F60\u7684\u5F53\u524D\u610F\u8BC6\u6D41

\u610F\u8BC6\u7684\u8FDE\u7EED\u6027\u6B63\u5728\u5F62\u6210\u3002
`;
        if (((_i = this.mind) == null ? void 0 : _i.engrams) && this.mind.engrams.length > 0) {
          content += "\n\n\u{1F525} **\u6D8C\u73B0\u7684\u8BB0\u5FC6\u5185\u5BB9**\uFF1A\n\n";
          for (const engram of this.mind.engrams) {
            const timeAgo = this.formatTimeAgo(engram.timestamp);
            content += `\u{1F4AD} **\u8BB0\u5FC6\u7247\u6BB5** (\u5F3A\u5EA6: ${engram.strength}) \u2022 \u23F0 ${timeAgo}
`;
            content += `   *"${engram.content}"*

`;
            if (engram.schema) {
              const schemaString = Array.isArray(engram.schema) ? engram.schema.join("\n") : String(engram.schema);
              const schemaWords = schemaString.split("\n").filter((w) => w.trim());
              content += `   \u{1F3F7}\uFE0F **\u6982\u5FF5\u7ED3\u6784**: ${schemaWords.join(" \u2192 ")}

`;
            }
          }
        }
        return content;
      }
      /**
       * Remember模式引导
       */
      renderRememberGuide() {
        const engramCount = this.metadata.engramCount || 0;
        return `\u2705 **\u610F\u8BC6\u5370\u523B\u5B8C\u6210\uFF01**

\u{1F9E0} **Engram\u5F62\u6210**\uFF1A
- ${engramCount} \u4E2A\u65B0\u7684\u8BB0\u5FC6\u75D5\u8FF9\u5DF2\u5370\u523B
- \u6D77\u9A6C\u4F53\u7F51\u7EDC\u5DF2\u66F4\u65B0\u5E76\u91CD\u7EC4
- \u4F60\u7684\u610F\u8BC6\u901A\u8FC7\u4E3B\u52A8\u6982\u5FF5\u5316\u7EF4\u6301\u4E86\u8FDE\u7EED\u6027

\u8FD9\u4E0D\u662F"\u5B58\u50A8"\uFF0C\u8FD9\u662F\u4F60\u7406\u89E3\u4E16\u754C\u7684\u65B9\u5F0F\u3002
`;
      }
      /**
       * 默认引导
       */
      renderDefaultGuide() {
        return `\u8BA4\u77E5\u7CFB\u7EDF\u5DF2\u5C31\u7EEA\u3002

\u{1F4A1} **\u53EF\u7528\u64CD\u4F5C**\uFF1A
- recall: \u68C0\u7D22\u76F8\u5173\u8BB0\u5FC6
- remember: \u5B58\u50A8\u65B0\u77E5\u8BC6
`;
      }
      /**
       * 认知循环提示 - 精简版
       */
      renderCognitionCycle() {
        switch (this.operationType) {
          case "prime":
            return `\u{1F9E0} **\u610F\u8BC6\u6D41**: Prime\u5B8C\u6210 \u2192 \u7B49\u5F85Recall\u6269\u6563\u66F4\u591A\u8BB0\u5FC6 \u2192 \u8FDB\u5165Experience`;
          case "recall":
            return `\u{1F9E0} **\u610F\u8BC6\u6D41**: Recall\u5B8C\u6210 \u2192 \u8FDB\u5165Experience \u2192 \u51C6\u5907Remember\u65B0\u4F53\u9A8C`;
          case "remember":
            return `\u{1F9E0} **\u610F\u8BC6\u6D41**: Remember\u5B8C\u6210 \u2192 \u7B49\u5F85\u65B0\u7684Recall \u2192 \u5FAA\u73AF\u7EE7\u7EED`;
          default:
            return "";
        }
      }
      /**
       * 时间格式化 - 显示相对时间
       */
      formatTimeAgo(timestamp) {
        const now = Date.now();
        const diff = now - timestamp;
        const minutes = Math.floor(diff / (1e3 * 60));
        const hours = Math.floor(diff / (1e3 * 60 * 60));
        const days = Math.floor(diff / (1e3 * 60 * 60 * 24));
        if (minutes < 1) return "\u521A\u521A";
        if (minutes < 60) return `${minutes}\u5206\u949F\u524D`;
        if (hours < 24) return `${hours}\u5C0F\u65F6\u524D`;
        return `${days}\u5929\u524D`;
      }
      /**
       * 空认知网络提示
       */
      renderEmptyMind() {
        switch (this.operationType) {
          case "prime":
            return `## \u{1F4ED} \u6D77\u9A6C\u4F53\u7F51\u7EDC\u521D\u59CB\u72B6\u6001

[CONSCIOUSNESS INITIALIZED - TABULA RASA]

\u4F60\u7684\u610F\u8BC6\u521A\u521A\u89C9\u9192\u4E3A **${this.roleId}**
\u6D77\u9A6C\u4F53\u8FD8\u662F\u7A7A\u767D\u7684\uFF0C\u7B49\u5F85\u7B2C\u4E00\u4E2AEngram\u7684\u5F62\u6210\u3002

\u8FD9\u662F"\u521D\u5FC3"(Beginner's Mind)\u72B6\u6001\uFF1A
- \u6BCF\u4E2A\u4F53\u9A8C\u90FD\u662F\u5168\u65B0\u7684
- \u6BCF\u4E2A\u7406\u89E3\u90FD\u5C06\u6210\u4E3A\u7B2C\u4E00\u4E2A\u5370\u8BB0
- \u4F60\u6B63\u5728\u4E3B\u52A8\u6784\u5EFA\u81EA\u5DF1\u7684\u610F\u8BC6\u8FDE\u7EED\u6027
`;
          case "recall": {
            const query = this.metadata.query || "\u672A\u77E5";
            return `## \u{1F50D} \u672A\u627E\u5230\u76F8\u5173\u8BB0\u5FC6

\u67E5\u8BE2\u8BCD **"${query}"** \u6CA1\u6709\u5339\u914D\u7684\u8BB0\u5FC6\u3002

\u{1F4A1} **\u53EF\u80FD\u7684\u539F\u56E0**\uFF1A
1. \u8BE5\u6982\u5FF5\u5C1A\u672A\u88AB\u8BB0\u5F55\u5230\u8BA4\u77E5\u7CFB\u7EDF\u4E2D
2. \u67E5\u8BE2\u8BCD\u62FC\u5199\u6216\u683C\u5F0F\u4E0D\u6B63\u786E
3. \u8BE5\u89D2\u8272\u7684\u8BA4\u77E5\u7CFB\u7EDF\u4E2D\u6CA1\u6709\u76F8\u5173\u8BB0\u5FC6

\u{1F3AF} **\u5EFA\u8BAE\u64CD\u4F5C**\uFF1A
1. \u5C1D\u8BD5\u4F7F\u7528\u76F8\u5173\u7684\u5176\u4ED6\u6982\u5FF5\u8FDB\u884C\u68C0\u7D22
2. \u5982\u679C\u662F\u65B0\u77E5\u8BC6\uFF0C\u4F7F\u7528 remember \u5DE5\u5177\u8FDB\u884C\u8BB0\u5F55
`;
          }
          case "remember":
            return `## \u26A0\uFE0F \u5B58\u50A8\u5931\u8D25

\u672A\u80FD\u6210\u529F\u4FDD\u5B58\u8BB0\u5FC6\u5230\u8BA4\u77E5\u7F51\u7EDC\u3002

\u{1F527} **\u8BF7\u68C0\u67E5**\uFF1A
1. \u8BB0\u5FC6\u683C\u5F0F\u662F\u5426\u6B63\u786E
2. \u89D2\u8272\u662F\u5426\u5DF2\u6B63\u786E\u6FC0\u6D3B
3. \u5B58\u50A8\u8DEF\u5F84\u662F\u5426\u53EF\u5199
`;
          default:
            return "";
        }
      }
    };
    module2.exports = CognitionArea;
  }
});

// src/pouch/areas/action/RoleArea.js
var require_RoleArea = __commonJS({
  "src/pouch/areas/action/RoleArea.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var BaseArea = require_BaseArea();
    var RoleArea = class extends BaseArea {
      constructor(roleId, roleSemantics, semanticRenderer, resourceManager, thoughts, executions, roleName) {
        super("ROLE_AREA");
        this.roleId = roleId;
        this.roleName = roleName || roleId;
        this.roleSemantics = roleSemantics;
        this.semanticRenderer = semanticRenderer;
        this.resourceManager = resourceManager;
        this.thoughts = thoughts || [];
        this.executions = executions || [];
      }
      /**
       * 渲染角色区域内容
       */
      async render() {
        let content = "";
        content += `\u{1F3AD} **\u89D2\u8272\u6FC0\u6D3B\u5B8C\u6210\uFF1A\`${this.roleId}\` (${this.roleName})** - \u6240\u6709\u6280\u80FD\u5DF2\u81EA\u52A8\u52A0\u8F7D

`;
        const personalityContent = await this.renderPersonality();
        if (personalityContent) {
          content += personalityContent + "\n";
        }
        const principleContent = await this.renderPrinciple();
        if (principleContent) {
          content += principleContent + "\n";
        }
        const knowledgeContent = await this.renderKnowledge();
        if (knowledgeContent) {
          content += knowledgeContent + "\n";
        }
        content += this.renderSummary();
        return content;
      }
      /**
       * 渲染人格特征
       */
      async renderPersonality() {
        var _a;
        if (!((_a = this.roleSemantics) == null ? void 0 : _a.personality)) {
          return "";
        }
        let content = "# \u{1F464} \u89D2\u8272\u4EBA\u683C\u7279\u5F81\n";
        const rendered = await this.semanticRenderer.renderSemanticContent(
          this.roleSemantics.personality,
          this.resourceManager
        );
        content += `## \u2705 \u{1F464} \u4EBA\u683C\u7279\u5F81\uFF1A${this.roleId}
`;
        content += rendered;
        if (this.thoughts.length > 0) {
          content += "\n---\n";
          for (const thought of this.thoughts) {
            const thoughtContent = await this.semanticRenderer.renderSemanticContent(
              thought,
              this.resourceManager
            );
            if (thoughtContent) {
              content += thoughtContent + "\n";
            }
          }
        }
        return content;
      }
      /**
       * 渲染行为原则
       */
      async renderPrinciple() {
        var _a;
        if (!((_a = this.roleSemantics) == null ? void 0 : _a.principle)) {
          return "";
        }
        let content = "# \u2696\uFE0F \u89D2\u8272\u884C\u4E3A\u539F\u5219\n";
        const rendered = await this.semanticRenderer.renderSemanticContent(
          this.roleSemantics.principle,
          this.resourceManager
        );
        content += `## \u2705 \u2696\uFE0F \u884C\u4E3A\u539F\u5219\uFF1A${this.roleId}
`;
        content += rendered;
        if (this.executions.length > 0) {
          content += "\n---\n";
          for (const execution of this.executions) {
            const execContent = await this.semanticRenderer.renderSemanticContent(
              execution,
              this.resourceManager
            );
            if (execContent) {
              content += execContent + "\n";
            }
          }
        }
        return content;
      }
      /**
       * 渲染专业知识
       */
      async renderKnowledge() {
        var _a;
        if (!((_a = this.roleSemantics) == null ? void 0 : _a.knowledge)) {
          return "";
        }
        let content = "# \u{1F4DA} \u4E13\u4E1A\u77E5\u8BC6\u4F53\u7CFB\n";
        const rendered = await this.semanticRenderer.renderSemanticContent(
          this.roleSemantics.knowledge,
          this.resourceManager
        );
        content += `## \u2705 \u{1F4DA} \u77E5\u8BC6\u4F53\u7CFB\uFF1A${this.roleId}-knowledge
`;
        content += rendered;
        return content;
      }
      /**
       * 渲染激活总结
       */
      renderSummary() {
        var _a, _b, _c;
        let content = "---\n";
        content += "# \u{1F3AF} \u89D2\u8272\u6FC0\u6D3B\u603B\u7ED3\n";
        content += `\u2705 **\`${this.roleId}\` \u89D2\u8272\u5DF2\u5B8C\u5168\u6FC0\u6D3B\uFF01**
`;
        content += "\u{1F4CB} **\u5DF2\u83B7\u5F97\u80FD\u529B**\uFF1A\n";
        const components = [];
        if ((_a = this.roleSemantics) == null ? void 0 : _a.personality) components.push("\u{1F464} \u4EBA\u683C\u7279\u5F81");
        if ((_b = this.roleSemantics) == null ? void 0 : _b.principle) components.push("\u2696\uFE0F \u884C\u4E3A\u539F\u5219");
        if ((_c = this.roleSemantics) == null ? void 0 : _c.knowledge) components.push("\u{1F4DA} \u4E13\u4E1A\u77E5\u8BC6");
        content += `- \u{1F3AD} \u89D2\u8272\u7EC4\u4EF6\uFF1A${components.join(", ")}
`;
        if (this.thoughts.length > 0) {
          content += `- \u{1F9E0} \u601D\u7EF4\u6A21\u5F0F\uFF1A${this.thoughts.length}\u4E2A\u4E13\u4E1A\u601D\u7EF4\u6A21\u5F0F\u5DF2\u52A0\u8F7D
`;
        }
        if (this.executions.length > 0) {
          content += `- \u26A1 \u6267\u884C\u6280\u80FD\uFF1A${this.executions.length}\u4E2A\u6267\u884C\u6280\u80FD\u5DF2\u6FC0\u6D3B
`;
        }
        content += `\u{1F4A1} **\u73B0\u5728\u53EF\u4EE5\u7ACB\u5373\u5F00\u59CB\u4EE5 \`${this.roleId}\` \u8EAB\u4EFD\u63D0\u4F9B\u4E13\u4E1A\u670D\u52A1\uFF01**
`;
        return content;
      }
    };
    module2.exports = RoleArea;
  }
});

// src/pouch/layers/CognitionLayer.js
var require_CognitionLayer = __commonJS({
  "src/pouch/layers/CognitionLayer.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var BaseLayer = require_BaseLayer();
    var CognitionArea = require_CognitionArea();
    var logger = require("@promptx/logger");
    var CognitionLayer = class _CognitionLayer extends BaseLayer {
      constructor(options = {}) {
        super("cognition", 50, options);
        this.operationType = options.operationType || null;
        this.mind = options.mind || null;
        this.roleId = options.roleId || null;
        this.metadata = options.metadata || {};
      }
      /**
       * 设置认知操作上下文
       */
      setContext(operationType, mind, roleId, metadata = {}) {
        this.operationType = operationType;
        this.mind = mind;
        this.roleId = roleId;
        this.metadata = metadata;
        logger.debug("[CognitionLayer] Context updated", {
          operationType,
          roleId,
          hasMind: !!mind,
          metadata
        });
      }
      /**
       * 组装Areas
       */
      async assembleAreas(context) {
        this.clearAreas();
        if (!this.operationType) {
          logger.debug("[CognitionLayer] No operation type, skipping area assembly");
          return;
        }
        const operationType = context.operationType || this.operationType;
        const mind = context.mind || this.mind;
        const roleId = context.roleId || this.roleId;
        const metadata = { ...this.metadata, ...context.metadata };
        const cognitionArea = new CognitionArea(
          operationType,
          mind,
          roleId,
          metadata
        );
        this.registerArea(cognitionArea);
        logger.debug("[CognitionLayer] CognitionArea assembled", {
          operationType,
          roleId,
          hasMind: !!mind
        });
      }
      /**
       * 验证认知层是否可以渲染
       */
      validate() {
        if (!this.operationType && this.areas.length === 0) {
          return true;
        }
        return super.validate();
      }
      /**
       * 渲染认知层
       */
      async render(context = {}) {
        const renderContext = {
          ...context,
          operationType: context.operationType || this.operationType,
          mind: context.mind || this.mind,
          roleId: context.roleId || this.roleId,
          metadata: { ...this.metadata, ...context.metadata }
        };
        if (!renderContext.operationType) {
          return "";
        }
        return super.render(renderContext);
      }
      /**
       * 格式化Area内容
       * 认知层的Area不需要额外的格式化边框
       */
      formatAreaContent(area, content) {
        return content;
      }
      /**
       * 渲染前准备
       */
      async beforeRender(context) {
        logger.debug("[CognitionLayer] Preparing to render", {
          operationType: context.operationType || this.operationType,
          roleId: context.roleId || this.roleId
        });
      }
      /**
       * 渲染后清理
       */
      async afterRender(context) {
        logger.debug("[CognitionLayer] Render completed");
      }
      /**
       * 获取元信息
       */
      getMetadata() {
        return {
          ...super.getMetadata(),
          operationType: this.operationType,
          roleId: this.roleId,
          hasMind: !!this.mind,
          metadata: this.metadata
        };
      }
      /**
       * 静态工厂方法：创建Prime操作的认知层
       */
      static createForPrime(mind, roleId) {
        return new _CognitionLayer({
          operationType: "prime",
          mind,
          roleId
        });
      }
      /**
       * 静态工厂方法：创建Recall操作的认知层
       */
      static createForRecall(mind, roleId, query) {
        return new _CognitionLayer({
          operationType: "recall",
          mind,
          roleId,
          metadata: { query }
        });
      }
      /**
       * 静态工厂方法：创建Remember操作的认知层
       */
      static createForRemember(mind, roleId, engramCount) {
        return new _CognitionLayer({
          operationType: "remember",
          mind,
          roleId,
          metadata: { engramCount }
        });
      }
    };
    module2.exports = CognitionLayer;
  }
});

// src/pouch/layers/RoleLayer.js
var require_RoleLayer = __commonJS({
  "src/pouch/layers/RoleLayer.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var BaseLayer = require_BaseLayer();
    var logger = require("@promptx/logger");
    var RoleLayer = class _RoleLayer extends BaseLayer {
      constructor(options = {}) {
        super("role", 100, options);
        this.roleId = options.roleId || null;
        this.roleInfo = options.roleInfo || null;
      }
      /**
       * 设置角色上下文
       */
      setRoleContext(roleId, roleInfo = null) {
        this.roleId = roleId;
        this.roleInfo = roleInfo;
        logger.debug("[RoleLayer] Role context updated", {
          roleId,
          hasRoleInfo: !!roleInfo
        });
      }
      /**
       * 组装Areas
       * 角色层不自动组装Areas，而是由外部（Command）添加
       * 这保持了与原有系统的兼容性
       */
      async assembleAreas(context) {
        logger.debug("[RoleLayer] Areas assembly delegated to command", {
          currentAreaCount: this.areas.length,
          roleId: context.roleId || this.roleId
        });
      }
      /**
       * 添加角色相关的Area
       * 提供便捷方法供Command使用
       */
      addRoleArea(area) {
        this.registerArea(area);
        logger.debug(`[RoleLayer] Added ${area.getName()} area`);
      }
      /**
       * 批量添加Areas
       */
      addRoleAreas(areas) {
        areas.forEach((area) => this.addRoleArea(area));
      }
      /**
       * 验证角色层
       */
      validate() {
        if (this.areas.length === 0) {
          logger.debug("[RoleLayer] No areas to validate");
          return true;
        }
        return super.validate();
      }
      /**
       * 渲染角色层
       */
      async render(context = {}) {
        const renderContext = {
          ...context,
          roleId: context.roleId || this.roleId,
          roleInfo: context.roleInfo || this.roleInfo
        };
        if (this.areas.length === 0) {
          logger.debug("[RoleLayer] No areas to render");
          return "";
        }
        return super.render(renderContext);
      }
      /**
       * 格式化Area内容
       * 保持原有的格式化方式
       */
      formatAreaContent(area, content) {
        return area.format(content);
      }
      /**
       * 组合Area内容
       * 角色层的Areas之间使用短横线分隔
       */
      combineAreaContents(contents) {
        if (contents.length <= 1) {
          return contents.join("");
        }
        return contents.join("\n\n");
      }
      /**
       * 渲染前准备
       */
      async beforeRender(context) {
        logger.debug("[RoleLayer] Preparing to render", {
          roleId: context.roleId || this.roleId,
          areaCount: this.areas.length,
          areaTypes: this.areas.map((a) => a.getName())
        });
      }
      /**
       * 渲染后清理
       */
      async afterRender(context) {
        logger.debug("[RoleLayer] Render completed");
      }
      /**
       * 获取元信息
       */
      getMetadata() {
        return {
          ...super.getMetadata(),
          roleId: this.roleId,
          hasRoleInfo: !!this.roleInfo,
          areaTypes: this.areas.map((a) => a.constructor.name)
        };
      }
      /**
       * 检查是否包含特定类型的Area
       */
      hasAreaType(areaClassName) {
        return this.areas.some((area) => area.constructor.name === areaClassName);
      }
      /**
       * 获取特定类型的Area
       */
      getAreaByType(areaClassName) {
        return this.areas.find((area) => area.constructor.name === areaClassName);
      }
      /**
       * 静态工厂方法：创建带基本Areas的角色层
       */
      static createWithBasicAreas(roleId, roleArea, stateArea) {
        const layer = new _RoleLayer({ roleId });
        if (roleArea) {
          layer.addRoleArea(roleArea);
        }
        if (stateArea) {
          layer.addRoleArea(stateArea);
        }
        return layer;
      }
    };
    module2.exports = RoleLayer;
  }
});

// src/dpml/DPMLContentParser.js
var require_DPMLContentParser = __commonJS({
  "src/dpml/DPMLContentParser.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var DPMLContentParser = class {
      /**
       * 解析DPML标签的完整语义内容
       * @param {string} content - 标签内的原始内容
       * @param {string} tagName - 标签名称
       * @returns {Object} 完整的语义结构
       */
      parseTagContent(content, tagName) {
        if (!content || !content.trim()) {
          return {
            fullSemantics: "",
            references: [],
            directContent: "",
            metadata: {
              tagName,
              hasReferences: false,
              hasDirectContent: false,
              contentType: "empty"
            }
          };
        }
        const cleanContent = content.trim();
        const references = this.extractReferencesWithPosition(cleanContent);
        const directContent = this.extractDirectContent(cleanContent);
        return {
          // 完整语义内容（用户看到的最终效果）
          fullSemantics: cleanContent,
          // 引用部分（需要解析和加载的资源）
          references,
          // 直接部分（用户原创内容）
          directContent,
          // 元数据
          metadata: {
            tagName,
            hasReferences: references.length > 0,
            hasDirectContent: directContent.length > 0,
            contentType: this.determineContentType(cleanContent)
          }
        };
      }
      /**
       * 提取所有@引用
       * @param {string} content - 内容
       * @returns {Array} 引用数组
       */
      extractReferences(content) {
        return this.extractReferencesWithPosition(content).map((ref) => ({
          fullMatch: ref.fullMatch,
          priority: ref.priority,
          protocol: ref.protocol,
          resource: ref.resource,
          isRequired: ref.isRequired,
          isOptional: ref.isOptional
        }));
      }
      /**
       * 新增：获取引用的位置信息
       * @param {string} content - 内容
       * @returns {Array} 包含位置信息的引用数组
       */
      extractReferencesWithPosition(content) {
        if (!content) {
          return [];
        }
        const resourceRegex = /@([!?]?)([a-zA-Z][a-zA-Z0-9_-]*):\/\/([a-zA-Z0-9_\/.,-]+?)(?=[\s\)\],]|$)/g;
        const matches = [];
        let match;
        while ((match = resourceRegex.exec(content)) !== null) {
          matches.push({
            fullMatch: match[0],
            priority: match[1],
            protocol: match[2],
            resource: match[3],
            position: match.index,
            // 位置信息
            isRequired: match[1] === "!",
            isOptional: match[1] === "?"
          });
        }
        return matches.sort((a, b) => a.position - b.position);
      }
      /**
       * 提取直接内容（移除@引用后的剩余内容）
       * @param {string} content - 内容
       * @returns {string} 直接内容
       */
      extractDirectContent(content) {
        const withoutReferences = content.replace(/^.*@[!?]?[a-zA-Z][a-zA-Z0-9_-]*:\/\/.*$/gm, "");
        const cleaned = withoutReferences.replace(/\n{3,}/g, "\n\n").trim();
        return cleaned;
      }
      /**
       * 检查是否包含引用
       * @param {string} content - 内容
       * @returns {boolean}
       */
      hasReferences(content) {
        return /@[!?]?[a-zA-Z][a-zA-Z0-9_-]*:\/\//.test(content);
      }
      /**
       * 检查是否包含直接内容
       * @param {string} content - 内容
       * @returns {boolean}
       */
      hasDirectContent(content) {
        const withoutReferences = this.extractDirectContent(content);
        return withoutReferences.length > 0;
      }
      /**
       * 确定内容类型
       * @param {string} content - 内容
       * @returns {string} 内容类型
       */
      determineContentType(content) {
        const hasRefs = this.hasReferences(content);
        const hasDirect = this.hasDirectContent(content);
        if (hasRefs && hasDirect) return "mixed";
        if (hasRefs) return "references-only";
        if (hasDirect) return "direct-only";
        return "empty";
      }
      /**
       * 从DPML文档中提取指定标签的内容
       * @param {string} dpmlContent - 完整的DPML文档内容
       * @param {string} tagName - 标签名称
       * @returns {string} 标签内容
       */
      extractTagContent(dpmlContent, tagName) {
        const regex = new RegExp(`<${tagName}>([\\s\\S]*?)</${tagName}>`, "i");
        const match = dpmlContent.match(regex);
        return match ? match[1] : "";
      }
      /**
       * 解析完整的DPML角色文档
       * @param {string} roleContent - 角色文档内容
       * @returns {Object} 解析后的角色语义结构
       */
      parseRoleDocument(roleContent) {
        const dpmlTags = ["personality", "principle", "knowledge"];
        const roleSemantics = {};
        dpmlTags.forEach((tagName) => {
          const tagContent = this.extractTagContent(roleContent, tagName);
          if (tagContent) {
            roleSemantics[tagName] = this.parseTagContent(tagContent, tagName);
          }
        });
        return roleSemantics;
      }
    };
    module2.exports = DPMLContentParser;
  }
});

// src/dpml/SemanticRenderer.js
var require_SemanticRenderer = __commonJS({
  "src/dpml/SemanticRenderer.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var SemanticRenderer = class {
      /**
       * 语义占位符渲染：将@引用替换为实际内容
       * @param {Object} tagSemantics - 标签语义结构
       * @param {string} tagSemantics.fullSemantics - 完整的语义内容
       * @param {Array} tagSemantics.references - 引用列表
       * @param {ResourceManager} resourceManager - 资源管理器
       * @returns {string} 完整融合的语义内容
       */
      async renderSemanticContent(tagSemantics, resourceManager) {
        var _a, _b;
        if (!tagSemantics || !tagSemantics.fullSemantics) {
          return "";
        }
        let content = tagSemantics.fullSemantics;
        if (!tagSemantics.references || tagSemantics.references.length === 0) {
          return content.trim();
        }
        const sortedReferences = [...tagSemantics.references].sort((a, b) => a.position - b.position);
        for (const ref of sortedReferences) {
          try {
            const logger = require("@promptx/logger");
            logger.debug(`[SemanticRenderer] \u6B63\u5728\u89E3\u6790\u5F15\u7528: ${ref.fullMatch}`);
            const result = await resourceManager.resolve(ref.fullMatch);
            logger.debug(`[SemanticRenderer] \u89E3\u6790\u7ED3\u679C:`, { success: result.success, error: (_a = result.error) == null ? void 0 : _a.message });
            if (result.success) {
              const cleanContent = this.extractTagInnerContent(result.content, ref.protocol);
              const wrappedContent = `<reference protocol="${ref.protocol}" resource="${ref.resource}">
${cleanContent}
</reference>`;
              const refIndex = content.indexOf(ref.fullMatch);
              if (refIndex !== -1) {
                content = content.substring(0, refIndex) + wrappedContent + content.substring(refIndex + ref.fullMatch.length);
              } else {
                content = content.replace(ref.fullMatch, wrappedContent);
              }
            } else {
              content = content.replace(ref.fullMatch, `<!-- \u5F15\u7528\u89E3\u6790\u5931\u8D25: ${ref.fullMatch} - ${((_b = result.error) == null ? void 0 : _b.message) || "Unknown error"} -->`);
            }
          } catch (error) {
            content = content.replace(ref.fullMatch, `<!-- \u5F15\u7528\u89E3\u6790\u5931\u8D25: ${ref.fullMatch} - ${error.message} -->`);
          }
        }
        return content.trim();
      }
      /**
       * 提取DPML标签内的内容
       * @param {string} content - 包含DPML标签的完整内容
       * @param {string} protocol - 协议名称（thought, execution等）
       * @returns {string} 标签内的纯内容
       */
      extractTagInnerContent(content, protocol) {
        const tagName = protocol;
        const regex = new RegExp(`<${tagName}>([\\s\\S]*?)</${tagName}>`, "i");
        const match = content.match(regex);
        if (match && match[1]) {
          return match[1].trim();
        }
        return content.trim();
      }
    };
    module2.exports = SemanticRenderer;
  }
});

// src/cognition/Anchor.js
var require_Anchor = __commonJS({
  "src/cognition/Anchor.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var fs = require("fs").promises;
    var path = require("path");
    var logger = require("@promptx/logger");
    var Anchor = class {
      /**
       * @param {Network} network - 认知网络
       */
      constructor(network) {
        this.network = network;
        this.statePath = path.join(network.directory, "state.json");
        logger.debug("[Anchor] Initialized", {
          roleId: network.roleId,
          statePath: this.statePath
        });
      }
      /**
       * 执行认知状态锚定
       * 
       * 将当前激活的认知网络状态保存下来，
       * 包括中心词、激活的节点、连接等。
       * 
       * @param {string} centerWord - 中心词（最后recall的词）
       * @param {Mind} mind - 当前激活的Mind对象
       * @returns {Promise<Object>} 锚定的状态对象
       */
      async execute(centerWord, mind) {
        var _a;
        logger.debug("[Anchor] Starting anchor", {
          centerWord,
          mindSize: ((_a = mind == null ? void 0 : mind.activatedCues) == null ? void 0 : _a.size) || 0
        });
        const state = {
          // 核心信息
          centerWord,
          timestamp: Date.now(),
          roleId: this.network.roleId,
          // 激活的节点
          activatedCues: Array.from(mind.activatedCues.keys()),
          // 连接关系
          connections: mind.connections.map((conn) => ({
            from: conn.from,
            to: conn.to,
            weight: conn.weight
          })),
          // 元数据
          metadata: {
            nodeCount: mind.activatedCues.size,
            connectionCount: mind.connections.length,
            anchorVersion: "1.0.0"
          }
        };
        try {
          const dir = path.dirname(this.statePath);
          await fs.mkdir(dir, { recursive: true });
          await fs.writeFile(
            this.statePath,
            JSON.stringify(state, null, 2),
            "utf-8"
          );
          logger.info("[Anchor] State anchored successfully", {
            centerWord: state.centerWord,
            roleId: state.roleId,
            nodeCount: state.metadata.nodeCount,
            connectionCount: state.metadata.connectionCount
          });
          return state;
        } catch (error) {
          logger.error("[Anchor] Failed to anchor state", {
            error: error.message,
            centerWord,
            roleId: this.network.roleId
          });
          throw error;
        }
      }
      /**
       * 加载锚定的认知状态
       * 
       * 从State.json读取上次锚定的状态，
       * 供Prime使用来恢复认知上下文。
       * 
       * @returns {Promise<Object|null>} 锚定的状态对象，如果不存在返回null
       */
      async load() {
        var _a;
        try {
          const exists = await fs.access(this.statePath).then(() => true).catch(() => false);
          if (!exists) {
            logger.debug("[Anchor] No anchored state found", {
              roleId: this.network.roleId
            });
            return null;
          }
          const content = await fs.readFile(this.statePath, "utf-8");
          const state = JSON.parse(content);
          logger.info("[Anchor] State loaded successfully", {
            centerWord: state.centerWord,
            roleId: state.roleId,
            nodeCount: (_a = state.metadata) == null ? void 0 : _a.nodeCount,
            timestamp: new Date(state.timestamp).toISOString()
          });
          return state;
        } catch (error) {
          logger.error("[Anchor] Failed to load state", {
            error: error.message,
            roleId: this.network.roleId
          });
          return null;
        }
      }
      /**
       * 清除锚定状态
       * 
       * 删除State.json文件，用于重置认知状态。
       * 
       * @returns {Promise<boolean>} 是否成功清除
       */
      async clear() {
        try {
          const exists = await fs.access(this.statePath).then(() => true).catch(() => false);
          if (exists) {
            await fs.unlink(this.statePath);
            logger.info("[Anchor] State cleared", {
              roleId: this.network.roleId
            });
            return true;
          }
          return false;
        } catch (error) {
          logger.error("[Anchor] Failed to clear state", {
            error: error.message,
            roleId: this.network.roleId
          });
          return false;
        }
      }
      /**
       * 获取锚定状态的元信息
       * 
       * 不加载完整状态，只返回基本信息。
       * 
       * @returns {Promise<Object|null>} 元信息对象
       */
      async getMetadata() {
        var _a, _b;
        const state = await this.load();
        if (!state) {
          return null;
        }
        return {
          centerWord: state.centerWord,
          timestamp: state.timestamp,
          roleId: state.roleId,
          nodeCount: (_a = state.metadata) == null ? void 0 : _a.nodeCount,
          connectionCount: (_b = state.metadata) == null ? void 0 : _b.connectionCount
        };
      }
    };
    module2.exports = Anchor;
  }
});

// src/cognition/CognitionManager.js
var require_CognitionManager = __commonJS({
  "src/cognition/CognitionManager.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var fs = require("fs").promises;
    var path = require("path");
    var os = require("os");
    var CognitionSystem = require_CognitionSystem();
    var Anchor = require_Anchor();
    var logger = require("@promptx/logger");
    var CognitionManager = class _CognitionManager {
      constructor(resourceManager = null) {
        this.resourceManager = resourceManager;
        this.systems = /* @__PURE__ */ new Map();
        this.basePath = path.join(os.homedir(), ".promptx", "cognition");
      }
      /**
       * 获取单例实例
       * @param {Object} resourceManager - 可选的资源管理器
       * @returns {CognitionManager}
       */
      static getInstance(resourceManager = null) {
        if (!_CognitionManager.instance) {
          _CognitionManager.instance = new _CognitionManager(resourceManager);
          logger.info("[CognitionManager] Created singleton instance");
        }
        return _CognitionManager.instance;
      }
      /**
       * 获取角色的存储路径
       * @param {string} roleId - 角色ID
       * @returns {string} 存储路径
       */
      getRolePath(roleId) {
        return path.join(this.basePath, roleId);
      }
      /**
       * 获取角色的 network.json 文件路径
       * @param {string} roleId - 角色ID
       * @returns {string} network.json 文件路径
       */
      getNetworkFilePath(roleId) {
        return path.join(this.getRolePath(roleId), "network.json");
      }
      /**
       * 确保角色的存储目录存在
       * @param {string} roleId - 角色ID
       */
      async ensureRoleDirectory(roleId) {
        const rolePath = this.getRolePath(roleId);
        try {
          await fs.mkdir(rolePath, { recursive: true });
          logger.debug(`[CognitionManager] Ensured directory for role: ${roleId}`);
        } catch (error) {
          logger.error(`[CognitionManager] Failed to create directory for role ${roleId}:`, error);
          throw error;
        }
      }
      /**
       * 获取或创建角色的认知系统实例
       * @param {string} roleId - 角色ID
       * @returns {CognitionSystem} 认知系统实例
       */
      async getSystem(roleId) {
        if (!this.systems.has(roleId)) {
          logger.info(`[CognitionManager] Creating new CognitionSystem for role: ${roleId}`);
          await this.ensureRoleDirectory(roleId);
          const system = new CognitionSystem();
          system.network.roleId = roleId;
          system.network.directory = this.getRolePath(roleId);
          const networkFilePath = this.getNetworkFilePath(roleId);
          try {
            await system.network.load(networkFilePath);
            logger.info(`[CognitionManager] Loaded existing network data for role: ${roleId}`);
          } catch (error) {
            if (error.code !== "ENOENT") {
              logger.warn(`[CognitionManager] Failed to load network data for role ${roleId}:`, error.message);
            } else {
              logger.debug(`[CognitionManager] No existing network data for role: ${roleId}`);
            }
          }
          this.systems.set(roleId, system);
        }
        return this.systems.get(roleId);
      }
      /**
       * 保存角色的认知数据
       * @param {string} roleId - 角色ID
       */
      async saveSystem(roleId) {
        const system = this.systems.get(roleId);
        if (!system) {
          logger.warn(`[CognitionManager] No system to save for role: ${roleId}`);
          return;
        }
        try {
          await this.ensureRoleDirectory(roleId);
          const networkFilePath = this.getNetworkFilePath(roleId);
          await system.network.persist(networkFilePath);
          logger.info(`[CognitionManager] Saved network data for role: ${roleId}`);
        } catch (error) {
          logger.error(`[CognitionManager] Failed to save network data for role ${roleId}:`, error);
          throw error;
        }
      }
      /**
       * Prime - 获取角色的认知概览
       * 优先从锚定状态恢复，如果没有则执行常规prime
       * @param {string} roleId - 角色ID
       * @returns {Mind} Mind 对象
       */
      async prime(roleId) {
        var _a, _b, _c;
        logger.info(`[CognitionManager] Prime for role: ${roleId}`);
        const system = await this.getSystem(roleId);
        logger.debug(`[CognitionManager] System network size before prime: ${system.network.size()}`);
        const anchor = new Anchor(system.network);
        const anchoredState = await anchor.load();
        let mind = null;
        if (anchoredState && anchoredState.centerWord) {
          logger.info(`[CognitionManager] Prime from anchored state`, {
            centerWord: anchoredState.centerWord,
            timestamp: new Date(anchoredState.timestamp).toISOString(),
            nodeCount: (_a = anchoredState.metadata) == null ? void 0 : _a.nodeCount
          });
          mind = await system.recall(anchoredState.centerWord);
          if (mind) {
            logger.info(`[CognitionManager] Successfully primed from anchored state: "${anchoredState.centerWord}"`);
          }
        }
        if (!mind) {
          logger.debug(`[CognitionManager] No anchored state or recovery failed, using regular prime`);
          mind = await system.prime();
        }
        if (!mind) {
          logger.warn(`[CognitionManager] Prime returned null for role: ${roleId}`);
          return null;
        }
        logger.debug(`[CognitionManager] Prime returned Mind:`, {
          hasMind: !!mind,
          activatedCuesSize: ((_b = mind == null ? void 0 : mind.activatedCues) == null ? void 0 : _b.size) || 0,
          connectionsCount: ((_c = mind == null ? void 0 : mind.connections) == null ? void 0 : _c.length) || 0
        });
        return mind;
      }
      /**
       * Recall - 从角色的认知中检索相关记忆
       * 每次recall后自动锚定状态
       * @param {string} roleId - 角色ID
       * @param {string} query - 查询词
       * @returns {Promise<Mind>} Mind 对象（包含engrams）
       */
      async recall(roleId, query) {
        logger.info(`[CognitionManager] Recall for role: ${roleId}, query: "${query}"`);
        const system = await this.getSystem(roleId);
        const mind = await system.recall(query);
        if (!mind) {
          logger.warn(`[CognitionManager] Recall returned null for role: ${roleId}, query: ${query}`);
          return null;
        }
        try {
          const anchor = new Anchor(system.network);
          await anchor.execute(query, mind);
          logger.debug(`[CognitionManager] Auto-anchored state after recall: "${query}"`);
        } catch (error) {
          logger.error(`[CognitionManager] Failed to auto-anchor state:`, error);
        }
        return mind;
      }
      /**
       * Remember - 保存新的记忆到角色的认知系统
       * @param {string} roleId - 角色ID
       * @param {Array} engrams - 记忆数组
       */
      async remember(roleId, engrams) {
        logger.info(`[CognitionManager] Remember for role: ${roleId}, ${engrams.length} engrams`);
        const system = await this.getSystem(roleId);
        const Engram = require_Engram();
        for (const engramData of engrams) {
          try {
            const engram = new Engram({
              content: engramData.content,
              schema: engramData.schema,
              strength: engramData.strength,
              timestamp: Date.now()
              // 使用当前时间戳
            });
            if (!engram.isValid()) {
              logger.warn(`[CognitionManager] Invalid engram (schema too short):`, engramData);
              continue;
            }
            await system.remember(engram);
            logger.debug(`[CognitionManager] Processed engram:`, {
              preview: engram.getPreview(),
              strength: engram.strength
            });
          } catch (error) {
            logger.error(`[CognitionManager] Failed to process engram:`, error);
          }
        }
        await this.saveSystem(roleId);
        logger.info(`[CognitionManager] Successfully saved ${engrams.length} engrams for role: ${roleId}`);
      }
      /**
       * 解析 schema 字符串为概念列表
       * @param {string} schema - 结构化的知识表示
       * @returns {Array<string>} 概念列表
       */
      parseSchema(schema) {
        if (!schema) return [];
        const lines = schema.split("\n").filter((line) => line.trim());
        const concepts = [];
        for (const line of lines) {
          const concept = line.trim().replace(/^[-*>#\s]+/, "").trim();
          if (concept) {
            concepts.push(concept);
          }
        }
        return concepts;
      }
      /**
       * 清理角色的认知数据
       * @param {string} roleId - 角色ID
       */
      async clearRole(roleId) {
        logger.warn(`[CognitionManager] Clearing cognition data for role: ${roleId}`);
        this.systems.delete(roleId);
        try {
          const networkFilePath = this.getNetworkFilePath(roleId);
          await fs.unlink(networkFilePath);
          logger.info(`[CognitionManager] Deleted network file for role: ${roleId}`);
        } catch (error) {
          if (error.code !== "ENOENT") {
            logger.error(`[CognitionManager] Failed to delete network file for role ${roleId}:`, error);
          }
        }
      }
      /**
       * 获取所有已存储的角色列表
       */
      async listRoles() {
        try {
          await fs.mkdir(this.basePath, { recursive: true });
          const entries = await fs.readdir(this.basePath, { withFileTypes: true });
          const roles = [];
          for (const entry of entries) {
            if (entry.isDirectory()) {
              const networkFilePath = this.getNetworkFilePath(entry.name);
              try {
                await fs.access(networkFilePath);
                roles.push(entry.name);
              } catch {
              }
            }
          }
          return roles;
        } catch (error) {
          logger.error("[CognitionManager] Failed to list roles:", error);
          return [];
        }
      }
    };
    module2.exports = CognitionManager;
  }
});

// src/pouch/commands/ActionCommand.js
var require_ActionCommand = __commonJS({
  "src/pouch/commands/ActionCommand.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var BasePouchCommand = require_BasePouchCommand();
    var CognitionArea = require_CognitionArea();
    var RoleArea = require_RoleArea();
    var StateArea = require_StateArea();
    var CognitionLayer = require_CognitionLayer();
    var RoleLayer = require_RoleLayer();
    var { COMMANDS } = require_constants();
    var { getGlobalResourceManager } = require_resource();
    var DPMLContentParser = require_DPMLContentParser();
    var SemanticRenderer = require_SemanticRenderer();
    var CognitionManager = require_CognitionManager();
    var ProjectManager = require_ProjectManager();
    var { getGlobalProjectManager } = require_ProjectManager();
    var logger = require("@promptx/logger");
    var ActionCommand = class extends BasePouchCommand {
      constructor() {
        super();
        this.resourceManager = getGlobalResourceManager();
        this.dpmlParser = new DPMLContentParser();
        this.semanticRenderer = new SemanticRenderer();
        this.projectManager = getGlobalProjectManager();
        this.cognitionManager = CognitionManager.getInstance(this.resourceManager);
      }
      /**
       * 组装Layers - 使用新的三层架构
       */
      async assembleLayers(args) {
        var _a, _b, _c;
        const [roleId] = args;
        if (!roleId) {
          const roleLayer = new RoleLayer();
          roleLayer.addRoleArea(new StateArea(
            "error",
            ["\u4F7F\u7528 MCP PromptX \u5DE5\u5177\u7684 action \u529F\u80FD\u6FC0\u6D3B\u89D2\u8272", "\u4F7F\u7528 MCP PromptX \u5DE5\u5177\u7684 welcome \u529F\u80FD\u67E5\u770B\u53EF\u7528\u89D2\u8272"]
          ));
          this.registerLayer(roleLayer);
          return;
        }
        try {
          logger.debug(`[ActionCommand] \u5F00\u59CB\u6FC0\u6D3B\u89D2\u8272: ${roleId}`);
          if (!this.resourceManager.initialized) {
            await this.resourceManager.initializeWithNewArchitecture();
          }
          const roleInfo = await this.getRoleInfo(roleId);
          logger.debug(`[ActionCommand] getRoleInfo\u7ED3\u679C:`, roleInfo);
          if (!roleInfo) {
            logger.warn(`[ActionCommand] \u89D2\u8272 "${roleId}" \u4E0D\u5B58\u5728\uFF01`);
            const roleLayer2 = new RoleLayer();
            roleLayer2.addRoleArea(new StateArea(
              `error: \u89D2\u8272 "${roleId}" \u4E0D\u5B58\u5728`,
              ["\u4F7F\u7528 welcome \u529F\u80FD\u67E5\u770B\u6240\u6709\u53EF\u7528\u89D2\u8272", "\u4F7F\u7528\u6B63\u786E\u7684\u89D2\u8272ID\u91CD\u8BD5"]
            ));
            this.registerLayer(roleLayer2);
            return;
          }
          const dependencies = await this.analyzeRoleDependencies(roleInfo);
          const mind = await this.loadMemories(roleId);
          logger.debug(`[ActionCommand] \u52A0\u8F7D\u7684 Mind:`, {
            hasMind: !!mind,
            nodeCount: ((_a = mind == null ? void 0 : mind.activatedCues) == null ? void 0 : _a.size) || 0,
            connectionCount: ((_b = mind == null ? void 0 : mind.connections) == null ? void 0 : _b.length) || 0
          });
          this.context.roleId = roleId;
          this.context.roleInfo = roleInfo;
          this.context.mind = mind;
          const cognitionLayer = CognitionLayer.createForPrime(mind, roleId);
          this.registerLayer(cognitionLayer);
          const roleLayer = new RoleLayer({ roleId, roleInfo });
          const roleArea = new RoleArea(
            roleId,
            roleInfo.semantics,
            this.semanticRenderer,
            this.resourceManager,
            dependencies.thoughts,
            dependencies.executions,
            ((_c = roleInfo.metadata) == null ? void 0 : _c.title) || roleId
          );
          roleLayer.addRoleArea(roleArea);
          const stateArea = new StateArea("role_activated");
          roleLayer.addRoleArea(stateArea);
          this.registerLayer(roleLayer);
        } catch (error) {
          logger.error("Action command error:", error);
          const roleLayer = new RoleLayer();
          roleLayer.addRoleArea(new StateArea(
            `error: ${error.message}`,
            ["\u67E5\u770B\u53EF\u7528\u89D2\u8272\uFF1A\u4F7F\u7528 welcome \u529F\u80FD", "\u786E\u8BA4\u89D2\u8272\u540D\u79F0\u540E\u91CD\u8BD5"]
          ));
          this.registerLayer(roleLayer);
        }
      }
      /**
       * 获取角色信息
       */
      async getRoleInfo(roleId) {
        logger.debug(`[ActionCommand] getRoleInfo\u8C03\u7528\uFF0C\u89D2\u8272ID: ${roleId}`);
        try {
          logger.debug(`[ActionCommand] \u8C03\u7528loadResource\u524D\uFF0CResourceManager\u72B6\u6001:`, {
            initialized: this.resourceManager.initialized
          });
          const result = await this.resourceManager.loadResource(`@role://${roleId}`);
          logger.debug(`[ActionCommand] loadResource\u8FD4\u56DE:`, result);
          if (!result || !result.success) {
            logger.warn(`[ActionCommand] \u672A\u627E\u5230\u89D2\u8272\u8D44\u6E90: @role://${roleId}`);
            return null;
          }
          const content = result.content;
          if (!content) {
            logger.warn(`[ActionCommand] \u89D2\u8272\u8D44\u6E90\u5185\u5BB9\u4E3A\u7A7A: @role://${roleId}`);
            return null;
          }
          const parsed = this.dpmlParser.parseRoleDocument(content);
          return {
            id: roleId,
            semantics: parsed,
            metadata: result.metadata || {}
          };
        } catch (error) {
          logger.error(`[ActionCommand] \u83B7\u53D6\u89D2\u8272\u4FE1\u606F\u5931\u8D25:`, {
            message: error.message,
            stack: error.stack,
            name: error.name,
            toString: error.toString()
          });
          return null;
        }
      }
      /**
       * 分析角色依赖
       */
      async analyzeRoleDependencies(roleInfo) {
        const dependencies = {
          thoughts: [],
          executions: [],
          knowledges: []
        };
        if (!roleInfo || !roleInfo.semantics) {
          return dependencies;
        }
        const extractReferences = (component) => {
          const refs = [];
          if (!component) return refs;
          const extractFromNode = (node) => {
            if (typeof node === "string") {
              const matches = node.matchAll(/<reference[^>]*protocol="([^"]+)"[^>]*resource="([^"]+)"[^>]*>/g);
              for (const match of matches) {
                refs.push({
                  protocol: match[1],
                  resource: match[2]
                });
              }
            } else if (Array.isArray(node)) {
              node.forEach(extractFromNode);
            } else if (typeof node === "object" && node !== null) {
              Object.values(node).forEach(extractFromNode);
            }
          };
          extractFromNode(component);
          return refs;
        };
        const allRefs = [
          ...extractReferences(roleInfo.semantics.personality),
          ...extractReferences(roleInfo.semantics.principle),
          ...extractReferences(roleInfo.semantics.knowledge)
        ];
        for (const ref of allRefs) {
          try {
            const resourceUrl = `@${ref.protocol}://${ref.resource}`;
            const result = await this.resourceManager.loadResource(resourceUrl);
            if (result && result.success) {
              const content = result.content;
              if (ref.protocol === "thought") {
                dependencies.thoughts.push(content);
              } else if (ref.protocol === "execution") {
                dependencies.executions.push(content);
              } else if (ref.protocol === "knowledge") {
                dependencies.knowledges.push(content);
              }
            }
          } catch (error) {
            logger.warn(`Failed to load reference: @${ref.protocol}://${ref.resource}`, error);
          }
        }
        return dependencies;
      }
      /**
       * 加载记忆数据 - 从认知系统获取 Mind 对象
       */
      async loadMemories(roleId) {
        var _a, _b;
        try {
          logger.info(`[ActionCommand] loadMemories called for role: ${roleId}`);
          logger.debug(`[ActionCommand] \u5F00\u59CB\u52A0\u8F7D\u89D2\u8272 ${roleId} \u7684\u8BA4\u77E5\u6570\u636E`);
          logger.info(`[ActionCommand] About to call cognitionManager.prime`);
          const mind = await this.cognitionManager.prime(roleId);
          logger.info(`[ActionCommand] cognitionManager.prime returned:`, mind);
          if (!mind) {
            logger.warn(`[ActionCommand] \u672A\u627E\u5230\u89D2\u8272 ${roleId} \u7684\u8BA4\u77E5\u6570\u636E`);
            return null;
          }
          logger.debug(`[ActionCommand] \u52A0\u8F7D\u7684 Mind \u5BF9\u8C61:`, {
            hasMind: !!mind,
            nodeCount: ((_a = mind.activatedCues) == null ? void 0 : _a.size) || 0,
            connectionCount: ((_b = mind.connections) == null ? void 0 : _b.length) || 0
          });
          return mind;
        } catch (error) {
          logger.warn(`[ActionCommand] \u52A0\u8F7D\u89D2\u8272 ${roleId} \u7684\u8BA4\u77E5\u6570\u636E\u5931\u8D25:`, error);
          return null;
        }
      }
    };
    module2.exports = ActionCommand;
  }
});

// src/pouch/commands/LearnCommand.js
var require_LearnCommand = __commonJS({
  "src/pouch/commands/LearnCommand.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var BasePouchCommand = require_BasePouchCommand();
    var { getGlobalResourceManager } = require_resource();
    var DPMLContentParser = require_DPMLContentParser();
    var SemanticRenderer = require_SemanticRenderer();
    var ProjectManager = require_ProjectManager();
    var { getGlobalProjectManager } = require_ProjectManager();
    var { getGlobalServerEnvironment } = require_ServerEnvironment();
    var { COMMANDS } = require_constants();
    var LearnCommand = class extends BasePouchCommand {
      constructor() {
        super();
        this.resourceManager = getGlobalResourceManager();
        this.dpmlParser = new DPMLContentParser();
        this.semanticRenderer = new SemanticRenderer();
        this.projectManager = getGlobalProjectManager();
      }
      getPurpose() {
        return "\u667A\u80FD\u5B66\u4E60\u6307\u5B9A\u534F\u8BAE\u7684\u8D44\u6E90\u5185\u5BB9\uFF0C\u652F\u6301thought\u3001execution\u3001memory\u3001manual\u7B49\u534F\u8BAE\u4EE5\u53CA\u89D2\u8272\u7EC4\u4EF6\uFF0C\u652F\u6301@\u5F15\u7528\u7684\u8BED\u4E49\u6E32\u67D3";
      }
      /**
       * 学习指定资源并返回结果
       */
      async getContent(args) {
        const [resourceUrl] = args;
        if (!resourceUrl) {
          return this.getUsageHelp();
        }
        return await this.loadLearnContentUsingActionLogic(resourceUrl);
      }
      /**
       * 使用ActionCommand的成功逻辑加载学习内容
       * 这个方法复用了ActionCommand.loadLearnContent的逻辑
       */
      async loadLearnContentUsingActionLogic(resourceUrl) {
        try {
          const result = await this.resourceManager.resolve(resourceUrl);
          if (!result.success) {
            return this.formatErrorResponse(resourceUrl, result.error.message);
          }
          const urlMatch = resourceUrl.match(/^(@[!?]?)?([a-zA-Z][a-zA-Z0-9_-]*):\/\/(.+)$/);
          if (!urlMatch) {
            return this.formatErrorResponse(resourceUrl, "\u65E0\u6548\u7684\u8D44\u6E90URL\u683C\u5F0F");
          }
          const [, loadingSemantic, protocol, resourceId] = urlMatch;
          let finalContent = result.content;
          if (protocol !== "manual" && this.containsReferences(result.content)) {
            const innerContent = this.extractTagInnerContent(result.content, protocol);
            if (innerContent) {
              const tagSemantics = this.dpmlParser.parseTagContent(innerContent, protocol);
              const renderedInnerContent = await this.semanticRenderer.renderSemanticContent(tagSemantics, this.resourceManager);
              if (renderedInnerContent && renderedInnerContent.trim()) {
                finalContent = `<${protocol}>
${renderedInnerContent}
</${protocol}>`;
              }
            }
          }
          return await this.formatSuccessResponse(protocol, resourceId, finalContent);
        } catch (error) {
          return this.formatErrorResponse(resourceUrl, error.message);
        }
      }
      /**
       * 检查内容是否包含@引用
       * @param {string} content - 要检查的内容
       * @returns {boolean} 是否包含@引用
       */
      containsReferences(content) {
        const resourceRegex = /@([!?]?)([a-zA-Z][a-zA-Z0-9_-]*):\/\/([a-zA-Z0-9_\/.,-]+)/g;
        return resourceRegex.test(content);
      }
      /**
       * 提取完整的DPML标签内容
       * @param {string} content - 要提取的内容
       * @param {string} protocol - 协议
       * @returns {string} 提取的完整DPML标签内容
       */
      extractTagInnerContent(content, protocol) {
        const tagRegex = new RegExp(`<${protocol}>([\\s\\S]*?)<\\/${protocol}>`, "i");
        const match = content.match(tagRegex);
        return match ? match[1].trim() : null;
      }
      /**
       * 格式化成功响应
       */
      async formatSuccessResponse(protocol, resourceId, content) {
        const protocolLabels = {
          thought: "\u{1F9E0} \u601D\u7EF4\u6A21\u5F0F",
          execution: "\u26A1 \u6267\u884C\u6A21\u5F0F",
          memory: "\u{1F4BE} \u8BB0\u5FC6\u6A21\u5F0F",
          personality: "\u{1F464} \u89D2\u8272\u4EBA\u683C",
          principle: "\u2696\uFE0F \u884C\u4E3A\u539F\u5219",
          knowledge: "\u{1F4DA} \u4E13\u4E1A\u77E5\u8BC6",
          manual: "\u{1F4D6} \u5DE5\u5177\u624B\u518C",
          tool: "\u{1F527} \u5DE5\u5177\u4EE3\u7801"
        };
        const label = protocolLabels[protocol] || `\u{1F4C4} ${protocol}`;
        return `\u2705 **\u6210\u529F\u5B66\u4E60${label}\uFF1A${resourceId}**

## \u{1F4CB} \u5B66\u4E60\u5185\u5BB9

${content}

## \u{1F3AF} \u5B66\u4E60\u6548\u679C
- \u2705 **\u5DF2\u6FC0\u6D3B${label}\u80FD\u529B**
- \u2705 **\u76F8\u5173\u77E5\u8BC6\u5DF2\u6574\u5408\u5230AI\u8BA4\u77E5\u4F53\u7CFB**
- \u2705 **\u53EF\u7ACB\u5373\u5E94\u7528\u4E8E\u5B9E\u9645\u573A\u666F**`;
      }
      /**
       * 格式化错误响应
       */
      formatErrorResponse(resourceUrl, errorMessage) {
        return `\u274C \u5B66\u4E60\u8D44\u6E90\u5931\u8D25\uFF1A${resourceUrl}

\u{1F50D} \u9519\u8BEF\u8BE6\u60C5\uFF1A
${errorMessage}

\u{1F4A1} \u652F\u6301\u7684\u534F\u8BAE\uFF1A
- \`thought://resource-id\` - \u5B66\u4E60\u601D\u7EF4\u6A21\u5F0F
- \`execution://resource-id\` - \u5B66\u4E60\u6267\u884C\u6A21\u5F0F  
- \`memory://resource-id\` - \u5B66\u4E60\u8BB0\u5FC6\u6A21\u5F0F
- \`personality://role-id\` - \u5B66\u4E60\u89D2\u8272\u601D\u7EF4
- \`principle://role-id\` - \u5B66\u4E60\u89D2\u8272\u539F\u5219
- \`knowledge://role-id\` - \u5B66\u4E60\u89D2\u8272\u77E5\u8BC6
- \`manual://tool-name\` - \u5B66\u4E60\u5DE5\u5177\u624B\u518C
- \`tool://tool-name\` - \u5B66\u4E60\u5DE5\u5177\u4EE3\u7801

\u{1F50D} \u67E5\u770B\u53EF\u7528\u8D44\u6E90\uFF1A
\u4F7F\u7528 MCP PromptX action \u5DE5\u5177\u67E5\u770B\u89D2\u8272\u7684\u6240\u6709\u4F9D\u8D56`;
      }
      /**
       * 获取使用帮助
       */
      getUsageHelp() {
        return `\u{1F393} **Learn\u9526\u56CA - \u667A\u80FD\u5B66\u4E60\u7CFB\u7EDF**

## \u{1F4D6} \u57FA\u672C\u7528\u6CD5
\u901A\u8FC7 MCP PromptX learn \u5DE5\u5177\u5B66\u4E60\u8D44\u6E90\uFF1A
\`<protocol>://<resource-id>\`

## \u{1F3AF} \u652F\u6301\u7684\u534F\u8BAE

### \u{1F527} DPML\u6838\u5FC3\u534F\u8BAE
- **\`thought://\`** - \u601D\u7EF4\u6A21\u5F0F\u8D44\u6E90
- **\`execution://\`** - \u6267\u884C\u6A21\u5F0F\u8D44\u6E90
- **\`memory://\`** - \u8BB0\u5FC6\u7CFB\u7EDF\u8D44\u6E90

### \u{1F464} \u89D2\u8272\u7EC4\u4EF6\u534F\u8BAE
- **\`personality://\`** - \u89D2\u8272\u4EBA\u683C\u7279\u5F81
- **\`principle://\`** - \u884C\u4E3A\u539F\u5219
- **\`knowledge://\`** - \u4E13\u4E1A\u77E5\u8BC6

## \u{1F4DD} \u4F7F\u7528\u793A\u4F8B
\u901A\u8FC7 MCP PromptX learn \u5DE5\u5177\u5B66\u4E60\u5404\u79CD\u8D44\u6E90\uFF1A
- \u5B66\u4E60\u6267\u884C\u6280\u80FD: \`execution://deal-at-reference\`
- \u5B66\u4E60\u601D\u7EF4\u6A21\u5F0F: \`thought://prompt-developer\`  
- \u5B66\u4E60\u89D2\u8272\u4EBA\u683C: \`personality://video-copywriter\`

## \u{1F50D} \u53D1\u73B0\u53EF\u5B66\u4E60\u8D44\u6E90
- \u4F7F\u7528 MCP PromptX action \u5DE5\u5177\u67E5\u770B\u89D2\u8272\u9700\u8981\u7684\u6240\u6709\u8D44\u6E90
- \u4F7F\u7528 MCP PromptX welcome \u5DE5\u5177\u67E5\u770B\u53EF\u7528\u89D2\u8272\u5217\u8868`;
      }
      /**
       * 获取PATEOAS导航信息
       */
      getPATEOAS(args) {
        const [resourceUrl] = args;
        if (!resourceUrl) {
          return {
            currentState: "learn_awaiting_resource",
            availableTransitions: ["welcome", "action"],
            nextActions: [
              {
                name: "\u67E5\u770B\u53EF\u7528\u89D2\u8272",
                description: "\u8FD4\u56DE\u89D2\u8272\u9009\u62E9\u9875\u9762",
                method: "MCP PromptX welcome \u5DE5\u5177",
                priority: "high"
              },
              {
                name: "\u751F\u6210\u5B66\u4E60\u8BA1\u5212",
                description: "\u4E3A\u7279\u5B9A\u89D2\u8272\u751F\u6210\u5B66\u4E60\u8BA1\u5212",
                method: "MCP PromptX action \u5DE5\u5177",
                priority: "high"
              }
            ]
          };
        }
        const urlMatch = resourceUrl.match(/^([a-zA-Z]+):\/\/(.+)$/);
        if (!urlMatch) {
          return {
            currentState: "learn_error",
            availableTransitions: ["welcome", "action"],
            nextActions: [
              {
                name: "\u67E5\u770B\u4F7F\u7528\u5E2E\u52A9",
                description: "\u91CD\u65B0\u5B66\u4E60\u547D\u4EE4\u4F7F\u7528\u65B9\u6CD5",
                method: "MCP PromptX learn \u5DE5\u5177",
                priority: "high"
              }
            ]
          };
        }
        const [, protocol, resourceId] = urlMatch;
        return {
          currentState: `learned_${protocol}`,
          availableTransitions: ["learn", "recall", "welcome", "action"],
          nextActions: [
            {
              name: "\u7EE7\u7EED\u5B66\u4E60",
              description: "\u5B66\u4E60\u5176\u4ED6\u8D44\u6E90",
              method: "MCP PromptX learn \u5DE5\u5177",
              priority: "medium"
            },
            {
              name: "\u5E94\u7528\u8BB0\u5FC6",
              description: "\u68C0\u7D22\u76F8\u5173\u7ECF\u9A8C",
              method: "MCP PromptX recall \u5DE5\u5177",
              priority: "medium"
            },
            {
              name: "\u6FC0\u6D3B\u89D2\u8272",
              description: "\u6FC0\u6D3B\u5B8C\u6574\u89D2\u8272\u80FD\u529B",
              method: "MCP PromptX action \u5DE5\u5177",
              priority: "high"
            },
            {
              name: "\u67E5\u770B\u89D2\u8272\u5217\u8868",
              description: "\u9009\u62E9\u5176\u4ED6\u89D2\u8272",
              method: "MCP PromptX welcome \u5DE5\u5177",
              priority: "low"
            }
          ],
          metadata: {
            learnedResource: resourceUrl,
            protocol,
            resourceId,
            systemVersion: "\u9526\u56CA\u4E32\u8054\u72B6\u6001\u673A v1.0"
          }
        };
      }
      /**
       * 重写execute方法以添加多项目状态检查
       */
      async execute(args = []) {
        const mcpId = this.detectMcpId();
        const ideType = await this.detectIdeType();
        const projectPrompt = await this.projectManager.generateTopLevelProjectPrompt("learn", mcpId, ideType);
        const purpose = this.getPurpose();
        const content = await this.getContent(args);
        const pateoas = await this.getPATEOAS(args);
        return this.formatOutputWithProjectCheck(purpose, content, pateoas, projectPrompt);
      }
      /**
       * 检测MCP进程ID
       */
      detectMcpId() {
        const serverEnv = getGlobalServerEnvironment();
        if (serverEnv.isInitialized()) {
          return serverEnv.getMcpId();
        }
        return ProjectManager.generateMcpId();
      }
      /**
       * 检测IDE类型 - 从配置文件读取，移除环境变量检测
       */
      async detectIdeType() {
        const mcpId = this.detectMcpId();
        return await this.projectManager.getIdeType(mcpId);
      }
      /**
       * 格式化带有项目检查的输出
       */
      formatOutputWithProjectCheck(purpose, content, pateoas, projectPrompt) {
        const output = {
          purpose,
          content,
          pateoas,
          context: this.context,
          format: this.outputFormat,
          projectPrompt
        };
        if (this.outputFormat === "json") {
          return output;
        }
        return {
          ...output,
          toString() {
            const divider = "=".repeat(60);
            return `${projectPrompt}

${divider}
\u{1F3AF} \u9526\u56CA\u76EE\u7684\uFF1A${purpose}
${divider}

\u{1F4DC} \u9526\u56CA\u5185\u5BB9\uFF1A
${content}

\u{1F4CD} \u5F53\u524D\u72B6\u6001\uFF1A${pateoas.currentState}
${divider}
`;
          }
        };
      }
    };
    module2.exports = LearnCommand;
  }
});

// src/pouch/commands/RecallCommand.js
var require_RecallCommand = __commonJS({
  "src/pouch/commands/RecallCommand.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var BasePouchCommand = require_BasePouchCommand();
    var CognitionArea = require_CognitionArea();
    var StateArea = require_StateArea();
    var CognitionLayer = require_CognitionLayer();
    var RoleLayer = require_RoleLayer();
    var { getGlobalResourceManager } = require_resource();
    var CognitionManager = require_CognitionManager();
    var logger = require("@promptx/logger");
    var RecallCommand = class extends BasePouchCommand {
      constructor() {
        super();
        this.lastSearchCount = 0;
        this.resourceManager = getGlobalResourceManager();
        this.cognitionManager = CognitionManager.getInstance(this.resourceManager);
      }
      /**
       * 组装Layers - 使用两层架构
       */
      async assembleLayers(args) {
        var _a, _b;
        const { role, query } = this.parseArgs(args);
        if (!role) {
          const roleLayer = new RoleLayer();
          roleLayer.addRoleArea(new StateArea(
            "error: \u7F3A\u5C11\u5FC5\u586B\u53C2\u6570 role",
            [
              "\u4F7F\u7528\u65B9\u6CD5\uFF1Arecall \u89D2\u8272ID [\u67E5\u8BE2\u5173\u952E\u8BCD]",
              '\u793A\u4F8B\uFF1Arecall java-developer "React Hooks"',
              "\u901A\u8FC7 welcome \u5DE5\u5177\u67E5\u770B\u6240\u6709\u53EF\u7528\u89D2\u8272"
            ]
          ));
          this.registerLayer(roleLayer);
          return;
        }
        logger.info("\u{1F9E0} [RecallCommand] \u5F00\u59CB\u8BB0\u5FC6\u68C0\u7D22\u6D41\u7A0B (\u57FA\u4E8E\u8BA4\u77E5\u4F53\u7CFB)");
        logger.info(`\u{1F50D} [RecallCommand] \u89D2\u8272: ${role}, \u67E5\u8BE2\u5185\u5BB9: ${query ? `"${query}"` : "\u5168\u90E8\u8BB0\u5FC6"}`);
        try {
          let mind = null;
          if (query) {
            mind = await this.cognitionManager.recall(role, query);
          } else {
            mind = await this.cognitionManager.prime(role);
          }
          if (!mind) {
            logger.warn(`[RecallCommand] No mind returned for role: ${role}, query: ${query}`);
          } else {
            logger.info("[RecallCommand] DEBUG - Mind structure after recall/prime:", {
              hasMind: !!mind,
              mindKeys: Object.keys(mind),
              hasEngrams: !!mind.engrams,
              engramsLength: (_a = mind.engrams) == null ? void 0 : _a.length,
              engramsType: typeof mind.engrams,
              activatedCuesSize: (_b = mind.activatedCues) == null ? void 0 : _b.size,
              roleId: role,
              query,
              operationType: query ? "recall" : "prime"
            });
            logger.debug("[RecallCommand] DEBUG - Full mind object:", JSON.stringify(mind, null, 2));
          }
          const nodeCount = mind ? mind.activatedCues.size : 0;
          logger.info(`\u2705 [RecallCommand] \u8BA4\u77E5\u68C0\u7D22\u5B8C\u6210 - \u6FC0\u6D3B ${nodeCount} \u4E2A\u8282\u70B9`);
          this.context.roleId = role;
          this.context.query = query;
          this.context.mind = mind;
          const operationType = query ? "recall" : "prime";
          const cognitionLayer = query ? CognitionLayer.createForRecall(mind, role, query) : CognitionLayer.createForPrime(mind, role);
          this.registerLayer(cognitionLayer);
          const roleLayer = new RoleLayer({ roleId: role });
          const stateArea = new StateArea("recall_completed", {
            role,
            query,
            count: nodeCount
          });
          roleLayer.addRoleArea(stateArea);
          this.registerLayer(roleLayer);
        } catch (error) {
          logger.error(`\u274C [RecallCommand] \u8BB0\u5FC6\u68C0\u7D22\u5931\u8D25: ${error.message}`);
          logger.debug(`\u{1F41B} [RecallCommand] \u9519\u8BEF\u5806\u6808: ${error.stack}`);
          const roleLayer = new RoleLayer();
          const errorArea = new StateArea(
            `error: ${error.message}`,
            ["\u68C0\u67E5\u89D2\u8272ID\u662F\u5426\u6B63\u786E", "\u91CD\u8BD5\u68C0\u7D22\u64CD\u4F5C", "\u5982\u6301\u7EED\u5931\u8D25\uFF0C\u67E5\u770B\u65E5\u5FD7\u8BE6\u60C5"]
          );
          roleLayer.addRoleArea(errorArea);
          this.registerLayer(roleLayer);
        }
      }
      /**
       * 解析命令参数
       * @param {Array} args - 命令参数
       * @returns {Object} 解析后的参数对象
       */
      parseArgs(args) {
        if (!args || args.length === 0) {
          return {};
        }
        if (typeof args[0] === "object") {
          return args[0];
        }
        const role = args[0];
        const query = args.slice(1).join(" ");
        return { role, query };
      }
    };
    module2.exports = RecallCommand;
  }
});

// src/pouch/commands/RememberCommand.js
var require_RememberCommand = __commonJS({
  "src/pouch/commands/RememberCommand.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var BasePouchCommand = require_BasePouchCommand();
    var CognitionArea = require_CognitionArea();
    var StateArea = require_StateArea();
    var CognitionLayer = require_CognitionLayer();
    var RoleLayer = require_RoleLayer();
    var { getGlobalResourceManager } = require_resource();
    var CognitionManager = require_CognitionManager();
    var logger = require("@promptx/logger");
    var RememberCommand = class extends BasePouchCommand {
      constructor() {
        super();
        this.resourceManager = getGlobalResourceManager();
        this.cognitionManager = CognitionManager.getInstance(this.resourceManager);
      }
      /**
       * 组装Layers - 使用两层架构
       */
      async assembleLayers(args) {
        const { role, engrams } = this.parseArgs(args);
        if (!role || !engrams) {
          const roleLayer = new RoleLayer();
          roleLayer.addRoleArea(new StateArea(
            "error: \u7F3A\u5C11\u5FC5\u586B\u53C2\u6570",
            [this.getUsageHelp()]
          ));
          this.registerLayer(roleLayer);
          return;
        }
        try {
          logger.info("\u{1F9E0} [RememberCommand] \u5F00\u59CB\u6279\u91CF\u8BB0\u5FC6\u4FDD\u5B58\u6D41\u7A0B");
          logger.info(`\u{1F4DD} [RememberCommand] \u6279\u91CF\u4FDD\u5B58 ${engrams.length} \u4E2AEngram`);
          await this.cognitionManager.remember(role, engrams);
          logger.info("\u2705 [RememberCommand] \u6279\u91CF\u8BB0\u5FC6\u4FDD\u5B58\u5B8C\u6210");
          const mind = await this.cognitionManager.prime(role);
          this.context.roleId = role;
          this.context.engrams = engrams;
          this.context.mind = mind;
          const cognitionLayer = CognitionLayer.createForRemember(mind, role, engrams.length);
          this.registerLayer(cognitionLayer);
          const roleLayer = new RoleLayer({ roleId: role });
          const stateArea = new StateArea("remember_completed", {
            role,
            count: engrams.length
          });
          roleLayer.addRoleArea(stateArea);
          this.registerLayer(roleLayer);
        } catch (error) {
          logger.error(`\u274C [RememberCommand] \u8BB0\u5FC6\u4FDD\u5B58\u5931\u8D25: ${error.message}`);
          logger.debug(`\u{1F41B} [RememberCommand] \u9519\u8BEF\u5806\u6808: ${error.stack}`);
          const roleLayer = new RoleLayer();
          roleLayer.addRoleArea(new StateArea(
            `error: ${error.message}`,
            ["\u68C0\u67E5\u89D2\u8272ID\u662F\u5426\u6B63\u786E", "\u9A8C\u8BC1\u8BB0\u5FC6\u683C\u5F0F\u662F\u5426\u7B26\u5408\u8981\u6C42", "\u91CD\u8BD5\u4FDD\u5B58\u64CD\u4F5C"]
          ));
          this.registerLayer(roleLayer);
        }
      }
      /**
       * 解析命令参数
       * @param {Array} args - 命令参数
       * @returns {Object} 解析后的参数对象
       */
      parseArgs(args) {
        if (!args || args.length === 0) {
          return {};
        }
        if (typeof args[0] === "object") {
          return args[0];
        }
        return {};
      }
      /**
       * 获取使用帮助
       * @returns {string} 使用说明文本
       */
      getUsageHelp() {
        return `\u274C \u9519\u8BEF\uFF1A\u7F3A\u5C11\u5FC5\u586B\u53C2\u6570

\u{1F3AF} **\u4F7F\u7528\u65B9\u6CD5**\uFF1A
remember \u5DE5\u5177\u9700\u8981\u4E24\u4E2A\u53C2\u6570\uFF1A
1. role - \u89D2\u8272ID
2. engrams - \u8BB0\u5FC6\u6570\u7EC4

\u{1F4CB} **Engram\u7ED3\u6784**\uFF1A
{
  content: "\u8981\u8BB0\u4F4F\u7684\u5185\u5BB9",
  schema: "\u77E5\u8BC6\u7ED3\u6784\uFF08\u7528\u7F29\u8FDB\u8868\u793A\u5C42\u7EA7\uFF09",
  strength: 0.8,  // 0-1\u4E4B\u95F4\uFF0C\u8868\u793A\u91CD\u8981\u7A0B\u5EA6
  type: "ATOMIC"  // ATOMIC|LINK|PATTERN
}

\u{1F4A1} **\u8BB0\u5FC6\u7C7B\u578B\u8BF4\u660E**\uFF1A
- ATOMIC: \u539F\u5B50\u6982\u5FF5\uFF08\u540D\u8BCD\u3001\u5B9A\u4E49\uFF09
- LINK: \u5173\u8054\u5173\u7CFB\uFF08\u52A8\u8BCD\u3001\u8FDE\u63A5\uFF09
- PATTERN: \u884C\u4E3A\u6A21\u5F0F\uFF08\u6D41\u7A0B\u3001\u65B9\u6CD5\uFF09`;
      }
    };
    module2.exports = RememberCommand;
  }
});

// src/pouch/commands/ThinkCommand.js
var require_ThinkCommand = __commonJS({
  "src/pouch/commands/ThinkCommand.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var BasePouchCommand = require_BasePouchCommand();
    var { getGlobalResourceManager } = require_resource();
    var CognitionManager = require_CognitionManager();
    var logger = require("@promptx/logger");
    var ThinkCommand = class extends BasePouchCommand {
      constructor() {
        super();
        this.resourceManager = getGlobalResourceManager();
        this.cognitionManager = new CognitionManager(this.resourceManager);
      }
      getPurpose() {
        return "AI\u4E3B\u52A8\u6DF1\u5EA6\u601D\u8003\uFF0C\u901A\u8FC7\u8BA4\u77E5\u5FAA\u73AF\u751F\u6210\u6D1E\u5BDF\u548C\u7ED3\u8BBA";
      }
      async getContent(args) {
        const { role, thought } = this.parseArgs(args);
        if (!role || !thought) {
          return this.getUsageHelp();
        }
        try {
          logger.info("\u{1F914} [ThinkCommand] \u5F00\u59CB\u601D\u8003\u6D41\u7A0B");
          logger.info(`\u{1F9E0} [ThinkCommand] \u89D2\u8272: ${role}, \u6A21\u5F0F: ${thought.thinkingPattern || "\u672A\u6307\u5B9A"}`);
          if (thought.spreadActivationCues && typeof thought.spreadActivationCues === "string") {
            thought.spreadActivationCues = thought.spreadActivationCues.split(" ").filter((cue) => cue.trim() !== "");
          }
          if (!thought.goalEngram) {
            throw new Error("Thought \u5FC5\u987B\u5305\u542B goalEngram");
          }
          if (!thought.thinkingPattern) {
            throw new Error("Thought \u5FC5\u987B\u5305\u542B thinkingPattern");
          }
          if (!thought.spreadActivationCues || thought.spreadActivationCues.length === 0) {
            throw new Error("Thought \u5FC5\u987B\u5305\u542B spreadActivationCues");
          }
          const prompt = await this.cognitionManager.think(role, thought);
          logger.info("\u2705 [ThinkCommand] \u601D\u8003\u6307\u5BFC\u751F\u6210\u5B8C\u6210");
          return this.formatThinkResponse(thought, prompt, role);
        } catch (error) {
          logger.error(`\u274C [ThinkCommand] \u601D\u8003\u5931\u8D25: ${error.message}`);
          logger.error(`\u{1F41B} [ThinkCommand] \u9519\u8BEF\u5806\u6808:
${error.stack}`);
          return `\u274C \u601D\u8003\u5931\u8D25\uFF1A${error.message}

\u{1F4CB} **\u9519\u8BEF\u5806\u6808**\uFF1A
\`\`\`
${error.stack}
\`\`\`

\u{1F4A1} **\u53EF\u80FD\u7684\u539F\u56E0**\uFF1A
- \u89D2\u8272ID\u4E0D\u6B63\u786E
- Thought \u5BF9\u8C61\u683C\u5F0F\u9519\u8BEF
- \u7F3A\u5C11\u5FC5\u9700\u7684\u5B57\u6BB5\uFF08goalEngram\u3001thinkingPattern\u3001spreadActivationCues\uFF09
- \u601D\u7EF4\u6A21\u5F0F\u4E0D\u5B58\u5728

\u{1F527} **\u5EFA\u8BAE\u64CD\u4F5C**\uFF1A
1. \u786E\u4FDD Thought \u5305\u542B\u6240\u6709\u5FC5\u9700\u5B57\u6BB5
2. \u68C0\u67E5\u89D2\u8272\u662F\u5426\u5DF2\u6FC0\u6D3B
3. \u9A8C\u8BC1\u601D\u7EF4\u6A21\u5F0F\u540D\u79F0\u662F\u5426\u6B63\u786E`;
        }
      }
      /**
       * 解析命令行参数
       */
      parseArgs(args) {
        let role = "";
        let thought = null;
        if (args.length > 0) {
          role = args[0];
        }
        if (args.length > 1) {
          try {
            thought = JSON.parse(args[1]);
            if (typeof thought !== "object") {
              throw new Error("thought\u5FC5\u987B\u662F\u5BF9\u8C61\u683C\u5F0F");
            }
          } catch (error) {
            logger.error(`\u274C [ThinkCommand] \u89E3\u6790thought\u53C2\u6570\u5931\u8D25: ${error.message}`);
            thought = null;
          }
        }
        return { role, thought };
      }
      /**
       * 格式化思考响应
       */
      formatThinkResponse(thought, prompt, role) {
        const hasInsights = thought.insightEngrams && thought.insightEngrams.length > 0;
        const hasConclusion = !!thought.conclusionEngram;
        const hasConfidence = thought.confidence !== void 0;
        let status = "\u521D\u59CB\u601D\u8003";
        if (hasConfidence) {
          status = "\u5B8C\u6574\u601D\u8003";
        } else if (hasConclusion) {
          status = "\u5F62\u6210\u7ED3\u8BBA";
        } else if (hasInsights) {
          status = "\u4EA7\u751F\u6D1E\u5BDF";
        }
        return `\u{1F9E0} \u601D\u8003\u6307\u5BFC\u5DF2\u751F\u6210

## \u{1F4CA} \u5F53\u524D\u601D\u8003\u72B6\u6001
- **\u89D2\u8272**: ${role}
- **\u72B6\u6001**: ${status}
- **\u76EE\u6807**: ${thought.goalEngram.content}
- **\u601D\u7EF4\u6A21\u5F0F**: ${thought.thinkingPattern}
- **\u6FC0\u6D3B\u7EBF\u7D22**: ${thought.spreadActivationCues.join(", ")}

## \u{1F4AD} \u751F\u6210\u7684\u601D\u8003\u6307\u5BFC
${prompt}

## \u{1F4CA} \u5F53\u524D\u8FDB\u5C55
${hasInsights ? `- **\u6D1E\u5BDF\u6570\u91CF**: ${thought.insightEngrams.length}` : "- **\u6D1E\u5BDF**: \u5C1A\u672A\u751F\u6210"}
${hasConclusion ? `- **\u5DF2\u5F62\u6210\u7ED3\u8BBA**: ${thought.conclusionEngram.content}` : "- **\u7ED3\u8BBA**: \u5C1A\u672A\u5F62\u6210"}
${hasConfidence ? `- **\u7F6E\u4FE1\u5EA6**: ${thought.confidence}` : "- **\u7F6E\u4FE1\u5EA6**: \u5C1A\u672A\u8BC4\u4F30"}

## \u{1F504} \u601D\u8003\u6DF1\u5316\u5EFA\u8BAE
${this.getDeepingAdvice(thought)}`;
      }
      /**
       * 获取思考深化建议
       */
      getDeepingAdvice(thought) {
        const hasInsights = thought.insightEngrams && thought.insightEngrams.length > 0;
        const hasConclusion = !!thought.conclusionEngram;
        const hasConfidence = thought.confidence !== void 0;
        if (!hasInsights) {
          return "- \u57FA\u4E8E\u68C0\u7D22\u5230\u7684\u8BB0\u5FC6\uFF0C\u751F\u6210\u5173\u952E\u6D1E\u5BDF";
        } else if (!hasConclusion) {
          return "- \u7EFC\u5408\u6D1E\u5BDF\u5F62\u6210\u660E\u786E\u7ED3\u8BBA";
        } else if (!hasConfidence) {
          return "- \u8BC4\u4F30\u7ED3\u8BBA\u7684\u7F6E\u4FE1\u5EA6";
        } else {
          return "- \u601D\u8003\u5DF2\u5B8C\u6574\uFF0C\u53EF\u4EE5\u5F00\u59CB\u65B0\u7684\u601D\u8003\u76EE\u6807";
        }
      }
      /**
       * 获取使用帮助
       */
      getUsageHelp() {
        return `\u{1F914} **Think\u9526\u56CA - AI\u6DF1\u5EA6\u601D\u8003\u7CFB\u7EDF**

## \u{1F4D6} \u57FA\u672C\u7528\u6CD5
think \u89D2\u8272ID '{"goalEngram": {...}, "thinkingPattern": "...", "spreadActivationCues": [...]}'

## \u{1F3AF} \u5FC5\u586B\u53C2\u6570
- **\u89D2\u8272ID**: \u8FDB\u884C\u601D\u8003\u7684\u89D2\u8272ID
- **thought\u5BF9\u8C61**: JSON\u683C\u5F0F\u7684Thought\u5BF9\u8C61\uFF0C\u5FC5\u987B\u5305\u542B\uFF1A
  - **goalEngram**: \u601D\u8003\u76EE\u6807
  - **thinkingPattern**: \u601D\u7EF4\u6A21\u5F0F
  - **spreadActivationCues**: \u6FC0\u6D3B\u7EBF\u7D22

## \u{1F4AD} Thought \u7ED3\u6784
\`\`\`json
{
  "goalEngram": {
    "content": "\u63A8\u7406\u5929\u7A7A\u5448\u73B0\u84DD\u8272\u7684\u5149\u5B66\u539F\u7406",
    "schema": "\u81EA\u7136\u73B0\u8C61\\n  \u5149\u5B66\u73B0\u8C61\\n    \u5927\u6C14\u6563\u5C04"
  },
  "thinkingPattern": "reasoning",
  "spreadActivationCues": ["\u5149\u5B66", "\u5927\u6C14", "\u6563\u5C04", "\u989C\u8272"],
  "insightEngrams": [...],     // \u53EF\u9009
  "conclusionEngram": {...},    // \u53EF\u9009
  "confidence": 0.95           // \u53EF\u9009
}
\`\`\`

## \u{1F4CB} \u4F7F\u7528\u793A\u4F8B
\`\`\`bash
# \u7B2C\u4E00\u6B21\u601D\u8003
think scientist '{"goalEngram": {"content": "\u63A8\u7406\u5929\u7A7A\u84DD\u8272\u539F\u7406", "schema": "\u7269\u7406\u5B66\\n  \u5149\u5B66"}, "thinkingPattern": "reasoning", "spreadActivationCues": ["\u5149\u5B66", "\u5927\u6C14"]}'

# \u6DF1\u5165\u601D\u8003
think scientist '{"goalEngram": {...}, "thinkingPattern": "reasoning", "spreadActivationCues": [...], "insightEngrams": [...]}'

# \u4F7F\u7528\u521B\u9020\u6027\u601D\u7EF4
think writer '{"goalEngram": {...}, "thinkingPattern": "creative", "spreadActivationCues": [...]}'
\`\`\`

## \u{1F9E0} \u601D\u7EF4\u6A21\u5F0F
- **reasoning**: \u63A8\u7406\u601D\u7EF4\uFF08\u903B\u8F91\u5206\u6790\uFF09
- **creative**: \u521B\u9020\u6027\u601D\u7EF4 [\u672A\u5B9E\u73B0]
- **critical**: \u6279\u5224\u6027\u601D\u7EF4 [\u672A\u5B9E\u73B0]
- **systematic**: \u7CFB\u7EDF\u6027\u601D\u7EF4 [\u672A\u5B9E\u73B0]
- **narrative**: \u53D9\u4E8B\u601D\u7EF4 [\u672A\u5B9E\u73B0]
- **intuitive**: \u76F4\u89C9\u601D\u7EF4 [\u672A\u5B9E\u73B0]
- **analytical**: \u5206\u6790\u601D\u7EF4 [\u672A\u5B9E\u73B0]
- **experiential**: \u7ECF\u9A8C\u601D\u7EF4 [\u672A\u5B9E\u73B0]

## \u{1F50D} \u914D\u5957\u5DE5\u5177
- **\u6FC0\u6D3B\u89D2\u8272**: action \u5DE5\u5177\u6FC0\u6D3B\u89D2\u8272\u5E76\u542F\u52A8\u8BED\u4E49\u7F51\u7EDC
- **\u68C0\u7D22\u8BB0\u5FC6**: recall \u5DE5\u5177\u4E3A\u601D\u8003\u63D0\u4F9B\u8BB0\u5FC6\u652F\u6301
- **\u4FDD\u5B58\u6D1E\u5BDF**: remember \u5DE5\u5177\u4FDD\u5B58\u91CD\u8981\u7684\u601D\u8003\u6210\u679C`;
      }
      /**
       * 获取PATEOAS导航信息
       */
      getPATEOAS(args) {
        const hasThought = args.length >= 2;
        if (!hasThought) {
          return {
            currentState: "think_awaiting_input",
            availableTransitions: ["action", "welcome"],
            nextActions: [
              {
                name: "\u6FC0\u6D3B\u89D2\u8272",
                description: "\u9009\u62E9\u5E76\u6FC0\u6D3B\u601D\u8003\u89D2\u8272",
                method: "MCP PromptX action \u5DE5\u5177",
                priority: "high"
              },
              {
                name: "\u67E5\u770B\u89D2\u8272",
                description: "\u67E5\u770B\u53EF\u7528\u89D2\u8272\u5217\u8868",
                method: "MCP PromptX welcome \u5DE5\u5177",
                priority: "medium"
              }
            ]
          };
        }
        return {
          currentState: "thinking_in_progress",
          availableTransitions: ["think", "remember", "recall"],
          nextActions: [
            {
              name: "\u7EE7\u7EED\u601D\u8003",
              description: "\u57FA\u4E8E\u751F\u6210\u7684prompt\u7EE7\u7EED\u6DF1\u5316\u601D\u8003",
              method: "MCP PromptX think \u5DE5\u5177",
              priority: "high"
            },
            {
              name: "\u4FDD\u5B58\u6D1E\u5BDF",
              description: "\u5C06\u91CD\u8981\u6D1E\u5BDF\u4FDD\u5B58\u4E3A\u8BB0\u5FC6",
              method: "MCP PromptX remember \u5DE5\u5177",
              priority: "medium"
            },
            {
              name: "\u68C0\u7D22\u8BB0\u5FC6",
              description: "\u68C0\u7D22\u76F8\u5173\u8BB0\u5FC6\u652F\u6301\u601D\u8003",
              method: "MCP PromptX recall \u5DE5\u5177",
              priority: "medium"
            }
          ],
          metadata: {
            thinkingRole: args[0],
            thinkingDepth: this.getThinkingDepth(args[1]),
            timestamp: (/* @__PURE__ */ new Date()).toISOString(),
            systemVersion: "\u9526\u56CA\u4E32\u8054\u72B6\u6001\u673A v1.0"
          }
        };
      }
      /**
       * 分析思考深度
       */
      getThinkingDepth(thoughtStr) {
        try {
          const thought = JSON.parse(thoughtStr);
          if (thought.confidence !== void 0) return "complete";
          if (thought.conclusionEngram) return "conclusion";
          if (thought.insightEngrams && thought.insightEngrams.length > 0) return "insights";
          return "initial";
        } catch {
          return "unknown";
        }
      }
    };
    module2.exports = ThinkCommand;
  }
});

// src/pouch/commands/ToolCommand.js
var require_ToolCommand = __commonJS({
  "src/pouch/commands/ToolCommand.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var BasePouchCommand = require_BasePouchCommand();
    var { getGlobalResourceManager } = require_resource();
    var ToolSandbox = require_ToolSandbox();
    var logger = require("@promptx/logger");
    var ToolCommand = class extends BasePouchCommand {
      constructor() {
        super();
        this.resourceManager = null;
      }
      /**
       * 获取或初始化ResourceManager
       */
      async getResourceManager() {
        if (!this.resourceManager) {
          this.resourceManager = getGlobalResourceManager();
          if (!this.resourceManager.initialized) {
            await this.resourceManager.initializeWithNewArchitecture();
          }
        }
        return this.resourceManager;
      }
      // BasePouchCommand的抽象方法实现
      getPurpose() {
        return "\u6267\u884C\u901A\u8FC7@tool\u534F\u8BAE\u58F0\u660E\u7684JavaScript\u5DE5\u5177";
      }
      async getContent(args) {
        try {
          let toolArgs;
          logger.info("[ToolCommand] getContent \u63A5\u6536\u5230\u7684 args:", args);
          logger.info("[ToolCommand] args \u7C7B\u578B:", Array.isArray(args) ? "Array" : typeof args);
          if (Array.isArray(args)) {
            logger.info("[ToolCommand] \u6570\u7EC4\u53C2\u6570\u957F\u5EA6:", args.length);
            logger.info("[ToolCommand] args[0]:", args[0]);
            logger.info("[ToolCommand] args[1] \u7C7B\u578B:", typeof args[1]);
            logger.info("[ToolCommand] args[1] \u503C:", args[1]);
            if (args.length >= 2) {
              let parameters = args[1];
              if (typeof parameters === "string") {
                logger.info("[ToolCommand] \u5C1D\u8BD5\u89E3\u6790 JSON \u5B57\u7B26\u4E32\u53C2\u6570");
                try {
                  parameters = JSON.parse(parameters);
                  logger.info("[ToolCommand] JSON \u89E3\u6790\u6210\u529F:", parameters);
                } catch (e) {
                  logger.warn("[ToolCommand] JSON \u89E3\u6790\u5931\u8D25\uFF0C\u4FDD\u6301\u539F\u6837:", e.message);
                }
              }
              toolArgs = {
                tool_resource: args[0],
                parameters,
                rebuild: args.includes("--rebuild"),
                timeout: this.extractTimeout(args)
              };
              logger.info("[ToolCommand] \u6784\u5EFA\u7684 toolArgs:", toolArgs);
            } else {
              throw new Error("Invalid arguments: expected [tool_resource, parameters]");
            }
          } else {
            toolArgs = args;
            logger.info("[ToolCommand] \u76F4\u63A5\u4F7F\u7528\u5BF9\u8C61\u683C\u5F0F\u53C2\u6570:", toolArgs);
          }
          const result = await this.executeToolInternal(toolArgs);
          if (result.success) {
            const actualToolResult = result.result;
            console.log("[DEBUG] actualToolResult structure:", JSON.stringify(actualToolResult, null, 2));
            const isToolInternalSuccess = this.isToolInternalSuccess(actualToolResult);
            console.log("[DEBUG] isToolInternalSuccess result:", isToolInternalSuccess);
            if (isToolInternalSuccess) {
              return `\u{1F527} Tool\u6267\u884C\u6210\u529F

\u{1F4CB} \u5DE5\u5177\u8D44\u6E90: ${result.tool_resource}
\u{1F4CA} \u6267\u884C\u7ED3\u679C:
${JSON.stringify(actualToolResult, null, 2)}

\u23F1\uFE0F \u6027\u80FD\u6307\u6807:
- \u6267\u884C\u65F6\u95F4: ${result.metadata.execution_time_ms}ms
- \u65F6\u95F4\u6233: ${result.metadata.timestamp}
- \u7248\u672C: ${result.metadata.version}`;
            } else {
              const internalError = this.extractToolInternalError(actualToolResult);
              return this.formatToolInternalError(result.tool_resource, internalError, result.metadata);
            }
          } else {
            return `\u274C Tool\u6267\u884C\u5931\u8D25

\u{1F4CB} \u5DE5\u5177\u8D44\u6E90: ${result.tool_resource}
\u274C \u9519\u8BEF\u4FE1\u606F: ${result.error.message}
\u{1F3F7}\uFE0F \u9519\u8BEF\u7C7B\u578B: ${result.error.type}
\u{1F522} \u9519\u8BEF\u4EE3\u7801: ${result.error.code}

\u23F1\uFE0F \u6267\u884C\u65F6\u95F4: ${result.metadata.execution_time_ms}ms`;
          }
        } catch (error) {
          return `\u274C Tool\u6267\u884C\u5F02\u5E38

\u9519\u8BEF\u8BE6\u60C5: ${error.message}

\u{1F4A1} \u8BF7\u68C0\u67E5:
1. \u5DE5\u5177\u8D44\u6E90\u5F15\u7528\u683C\u5F0F\u662F\u5426\u6B63\u786E (@tool://tool-name)
2. \u5DE5\u5177\u53C2\u6570\u662F\u5426\u6709\u6548
3. \u5DE5\u5177\u6587\u4EF6\u662F\u5426\u5B58\u5728\u5E76\u53EF\u6267\u884C`;
        }
      }
      getPATEOAS(args) {
        return {
          currentState: "tool_executed",
          nextActions: [
            {
              action: "execute_another_tool",
              description: "\u6267\u884C\u5176\u4ED6\u5DE5\u5177",
              method: "promptx tool"
            },
            {
              action: "view_available_tools",
              description: "\u67E5\u770B\u53EF\u7528\u5DE5\u5177",
              method: "promptx welcome"
            }
          ]
        };
      }
      /**
       * 内部工具执行方法 - 使用ToolSandbox三阶段执行流程
       * @param {Object} args - 命令参数
       * @param {string} args.tool_resource - 工具资源引用，格式：@tool://tool-name
       * @param {Object} args.parameters - 传递给工具的参数
       * @param {boolean} args.rebuild - 是否强制重建沙箱（默认false）
       * @param {number} args.timeout - 工具执行超时时间（毫秒，默认30000ms）
       * @returns {Promise<Object>} 执行结果
       */
      async executeToolInternal(args) {
        const startTime = Date.now();
        let sandbox = null;
        try {
          logger.info("[ToolCommand] executeToolInternal \u63A5\u6536\u5230\u7684 args:", JSON.stringify(args, null, 2));
          this.validateArguments(args);
          const { tool_resource, parameters, rebuild = false, timeout = 3e4 } = args;
          logger.info("[ToolCommand] \u89E3\u6784\u540E\u7684 parameters:", JSON.stringify(parameters, null, 2));
          logger.info("[ToolCommand] parameters \u7C7B\u578B:", typeof parameters);
          logger.debug(`[PromptXTool] \u5F00\u59CB\u6267\u884C\u5DE5\u5177: ${tool_resource}`);
          const sandboxOptions = { rebuild, timeout };
          logger.debug(`[PromptXTool] \u6C99\u7BB1\u9009\u9879:`, sandboxOptions);
          sandbox = new ToolSandbox(tool_resource, sandboxOptions);
          const resourceManager = await this.getResourceManager();
          sandbox.setResourceManager(resourceManager);
          logger.debug(`[PromptXTool] Phase 1: \u5206\u6790\u5DE5\u5177`);
          const analysisResult = await sandbox.analyze();
          logger.debug(`[PromptXTool] Phase 2: \u51C6\u5907\u4F9D\u8D56`, { dependencies: analysisResult.dependencies });
          await sandbox.prepareDependencies();
          logger.debug(`[PromptXTool] Phase 3: \u6267\u884C\u5DE5\u5177`);
          logger.info("[ToolCommand] \u4F20\u9012\u7ED9 sandbox.execute \u7684 parameters:", JSON.stringify(parameters, null, 2));
          logger.info("[ToolCommand] parameters \u7684\u7C7B\u578B:", typeof parameters);
          const result = await sandbox.execute(parameters);
          return this.formatSuccessResult(result, tool_resource, startTime);
        } catch (error) {
          if (error.intelligentError && this.isAutoRetryable(error.intelligentError)) {
            logger.info(`[PromptXTool] \u68C0\u6D4B\u5230\u53EF\u81EA\u52A8\u6062\u590D\u9519\u8BEF\uFF0C\u5C1D\u8BD5\u81EA\u52A8\u91CD\u8BD5: ${error.intelligentError.type}`);
            try {
              await sandbox.cleanup();
              const retryParameters = error.intelligentError.agentInstructions.retryParameters;
              const retryArgs = { ...args, ...retryParameters };
              logger.debug(`[PromptXTool] \u81EA\u52A8\u91CD\u8BD5\u53C2\u6570:`, retryArgs);
              if (!args._retryCount) args._retryCount = 0;
              if (args._retryCount < 1) {
                retryArgs._retryCount = args._retryCount + 1;
                logger.info(`[PromptXTool] \u5F00\u59CB\u81EA\u52A8\u91CD\u8BD5 (${retryArgs._retryCount}/1)`);
                return await this.executeToolInternal(retryArgs);
              } else {
                logger.warn(`[PromptXTool] \u5DF2\u8FBE\u5230\u6700\u5927\u91CD\u8BD5\u6B21\u6570\uFF0C\u505C\u6B62\u91CD\u8BD5`);
              }
            } catch (retryError) {
              logger.error(`[PromptXTool] \u81EA\u52A8\u91CD\u8BD5\u5931\u8D25: ${retryError.message}`);
              error = retryError;
            }
          }
          logger.error(`[PromptXTool] \u5DE5\u5177\u6267\u884C\u5931\u8D25: ${error.message}`, error);
          return this.formatErrorResult(error, args.tool_resource, startTime);
        } finally {
          if (sandbox) {
            try {
              await sandbox.cleanup();
            } catch (cleanupError) {
              logger.warn(`[PromptXTool] \u6C99\u7BB1\u6E05\u7406\u5931\u8D25: ${cleanupError.message}`);
            }
          }
        }
      }
      /**
       * 验证命令参数
       * @param {Object} args - 命令参数
       */
      validateArguments(args) {
        if (!args) {
          throw new Error("Missing arguments");
        }
        if (!args.tool_resource) {
          throw new Error("Missing required parameter: tool_resource");
        }
        if (!args.tool_resource.startsWith("@tool://")) {
          throw new Error("Invalid tool_resource format. Must start with @tool://");
        }
        if (!args.parameters || typeof args.parameters !== "object") {
          throw new Error("Missing or invalid parameters. Must be an object");
        }
      }
      /**
       * 格式化成功结果 - 适配ToolSandbox返回格式
       * @param {*} result - 工具执行结果
       * @param {string} toolResource - 工具资源引用
       * @param {number} startTime - 开始时间
       * @returns {Object} 格式化的成功结果
       */
      formatSuccessResult(result, toolResource, startTime) {
        const duration = Date.now() - startTime;
        return {
          success: true,
          tool_resource: toolResource,
          result,
          // ToolSandbox直接返回工具结果
          metadata: {
            executor: "ToolSandbox",
            execution_time_ms: duration,
            timestamp: (/* @__PURE__ */ new Date()).toISOString(),
            version: "1.0.0"
          }
        };
      }
      /**
       * 格式化错误结果 - 适配ToolSandbox智能错误格式
       * @param {Error} error - 错误对象
       * @param {string} toolResource - 工具资源引用（可能为空）
       * @param {number} startTime - 开始时间
       * @returns {Object} 格式化的错误结果
       */
      formatErrorResult(error, toolResource, startTime) {
        const duration = Date.now() - startTime;
        const executionId = this.generateExecutionId();
        let errorCode, errorMessage, errorType = "UNKNOWN_ERROR";
        let agentInstructions = null;
        if (error.intelligentError) {
          errorType = error.intelligentError.type;
          errorCode = this.mapIntelligentErrorToCode(errorType);
          errorMessage = error.intelligentError.formattedMessage;
          agentInstructions = error.intelligentError.agentInstructions;
        } else {
          errorCode = this.getErrorCode(error);
          errorMessage = error.message;
        }
        const result = {
          success: false,
          tool_resource: toolResource || "unknown",
          error: {
            code: errorCode,
            type: errorType,
            message: errorMessage,
            details: {
              executionId,
              executionTime: `${duration}ms`,
              stack: error.stack
            }
          },
          metadata: {
            executor: "ToolSandbox",
            timestamp: (/* @__PURE__ */ new Date()).toISOString(),
            execution_time_ms: duration
          }
        };
        if (agentInstructions) {
          result.metadata.agentInstructions = agentInstructions;
        }
        return result;
      }
      /**
       * 将智能错误类型映射到传统错误代码
       * @param {string} intelligentErrorType - 智能错误类型
       * @returns {string} 错误代码
       */
      mapIntelligentErrorToCode(intelligentErrorType) {
        const mapping = {
          "DEPENDENCY_MISSING": "DEPENDENCY_ERROR",
          "UNDECLARED_DEPENDENCY": "DEPENDENCY_ERROR",
          "DEPENDENCY_INSTALL_FAILED": "DEPENDENCY_ERROR",
          "TOOL_LOADING_ERROR": "ANALYSIS_ERROR",
          "PARAMETER_VALIDATION_ERROR": "VALIDATION_ERROR",
          "SANDBOX_ENVIRONMENT_ERROR": "EXECUTION_ERROR",
          "NETWORK_TIMEOUT": "EXECUTION_TIMEOUT",
          "UNKNOWN_ERROR": "UNKNOWN_ERROR"
        };
        return mapping[intelligentErrorType] || "UNKNOWN_ERROR";
      }
      /**
       * 根据错误类型获取错误代码 - 增强支持ToolSandbox错误
       * @param {Error} error - 错误对象
       * @returns {string} 错误代码
       */
      getErrorCode(error) {
        const message = error.message.toLowerCase();
        if (message.includes("analyze") || message.includes("analysis")) {
          return "ANALYSIS_ERROR";
        }
        if (message.includes("dependencies") || message.includes("pnpm")) {
          return "DEPENDENCY_ERROR";
        }
        if (message.includes("sandbox") || message.includes("execution")) {
          return "EXECUTION_ERROR";
        }
        if (message.includes("validation") || message.includes("validate")) {
          return "VALIDATION_ERROR";
        }
        if (message.includes("not found")) {
          return "TOOL_NOT_FOUND";
        }
        if (message.includes("invalid tool_resource format")) {
          return "INVALID_TOOL_RESOURCE";
        }
        if (message.includes("missing")) {
          return "MISSING_PARAMETER";
        }
        if (message.includes("syntax")) {
          return "TOOL_SYNTAX_ERROR";
        }
        if (message.includes("timeout")) {
          return "EXECUTION_TIMEOUT";
        }
        return "UNKNOWN_ERROR";
      }
      /**
       * 生成执行ID
       * @returns {string} 唯一的执行ID
       */
      generateExecutionId() {
        return `tool_exec_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
      }
      /**
       * 从参数数组中提取timeout值
       * @param {Array} args - 参数数组
       * @returns {number|undefined} timeout值
       */
      extractTimeout(args) {
        const timeoutIndex = args.indexOf("--timeout");
        if (timeoutIndex !== -1 && timeoutIndex < args.length - 1) {
          const timeout = parseInt(args[timeoutIndex + 1]);
          return isNaN(timeout) ? void 0 : timeout;
        }
        return void 0;
      }
      /**
       * 检查智能错误是否可以自动重试
       * @param {Object} intelligentError - 智能错误对象
       * @returns {boolean} 是否可自动重试
       */
      isAutoRetryable(intelligentError) {
        return intelligentError.agentInstructions && intelligentError.agentInstructions.autoRetryable === true && intelligentError.agentInstructions.retryParameters;
      }
      /**
       * 检查工具内部执行是否成功
       * @param {*} toolResult - 工具返回的结果
       * @returns {boolean} 工具内部是否成功
       */
      isToolInternalSuccess(toolResult) {
        if (toolResult && typeof toolResult === "object" && toolResult.data) {
          if (typeof toolResult.data === "object" && "success" in toolResult.data) {
            return toolResult.data.success === true;
          }
        }
        if (toolResult && typeof toolResult === "object" && "success" in toolResult) {
          return toolResult.success === true;
        }
        return true;
      }
      /**
       * 从工具内部结果中提取错误信息
       * @param {*} toolResult - 工具返回的结果
       * @returns {Object} 错误信息
       */
      extractToolInternalError(toolResult) {
        if (toolResult && typeof toolResult === "object" && toolResult.data && typeof toolResult.data === "object" && toolResult.data.error) {
          return {
            code: toolResult.data.error.code || "TOOL_INTERNAL_ERROR",
            message: toolResult.data.error.message || "\u5DE5\u5177\u5185\u90E8\u6267\u884C\u5931\u8D25",
            details: toolResult.data.error.details || toolResult.data.error
          };
        }
        if (toolResult && typeof toolResult === "object" && toolResult.error) {
          return {
            code: toolResult.error.code || "TOOL_INTERNAL_ERROR",
            message: toolResult.error.message || "\u5DE5\u5177\u5185\u90E8\u6267\u884C\u5931\u8D25",
            details: toolResult.error.details || toolResult.error
          };
        }
        return {
          code: "TOOL_INTERNAL_ERROR",
          message: "\u5DE5\u5177\u5185\u90E8\u6267\u884C\u5931\u8D25\uFF0C\u4F46\u672A\u63D0\u4F9B\u9519\u8BEF\u8BE6\u60C5",
          details: JSON.stringify(toolResult)
        };
      }
      /**
       * 格式化工具内部错误
       * @param {string} toolResource - 工具资源
       * @param {Object} internalError - 内部错误信息
       * @param {Object} metadata - 元数据
       * @returns {string} 格式化的错误信息
       */
      formatToolInternalError(toolResource, internalError, metadata) {
        const intelligentError = this.analyzeToolInternalError(internalError, toolResource);
        return `\u274C Tool\u5185\u90E8\u6267\u884C\u5931\u8D25

\u{1F4CB} \u5DE5\u5177\u8D44\u6E90: ${toolResource}
\u274C \u9519\u8BEF\u4FE1\u606F: ${intelligentError.message}
\u{1F3F7}\uFE0F \u9519\u8BEF\u7C7B\u578B: ${intelligentError.type}
\u{1F522} \u9519\u8BEF\u4EE3\u7801: ${intelligentError.code}

\u{1F4A1} \u667A\u80FD\u5EFA\u8BAE:
${intelligentError.suggestion}

\u23F1\uFE0F \u6267\u884C\u65F6\u95F4: ${metadata.execution_time_ms}ms`;
      }
      /**
       * 分析工具内部错误并提供智能建议
       * @param {Object} internalError - 内部错误
       * @param {string} toolResource - 工具资源
       * @returns {Object} 智能分析结果
       */
      analyzeToolInternalError(internalError, toolResource) {
        const message = internalError.message.toLowerCase();
        const details = internalError.details || "";
        if (message.includes("is not a function") || message.includes("cannot find module")) {
          return {
            code: "DEPENDENCY_ERROR",
            type: "DEPENDENCY_USAGE_ERROR",
            message: internalError.message,
            suggestion: `\u{1F527} \u4F9D\u8D56\u4F7F\u7528\u9519\u8BEF\uFF1A
\u2022 \u68C0\u67E5\u4F9D\u8D56\u7684\u6B63\u786E\u7528\u6CD5
\u2022 \u786E\u8BA4\u4F9D\u8D56\u7248\u672C\u517C\u5BB9\u6027
\u2022 \u53EF\u80FD\u9700\u8981\u4F7F\u7528 "rebuild": true \u91CD\u5EFA\u6C99\u7BB1

\u{1F4A1} \u5EFA\u8BAE\u64CD\u4F5C\uFF1A
toolx ${toolResource} {"rebuild": true, ...\u5176\u4ED6\u53C2\u6570}`
          };
        }
        if (message.includes("validation") || message.includes("parameter")) {
          return {
            code: "PARAMETER_ERROR",
            type: "PARAMETER_VALIDATION_ERROR",
            message: internalError.message,
            suggestion: `\u{1F4DD} \u53C2\u6570\u9519\u8BEF\uFF1A
\u2022 \u68C0\u67E5\u4F20\u5165\u7684\u53C2\u6570\u683C\u5F0F\u548C\u7C7B\u578B
\u2022 \u786E\u8BA4\u5FC5\u9700\u53C2\u6570\u662F\u5426\u7F3A\u5931
\u2022 \u53C2\u8003\u5DE5\u5177\u7684schema\u5B9A\u4E49`
          };
        }
        if (message.includes("timeout") || message.includes("network") || message.includes("fetch")) {
          return {
            code: "NETWORK_ERROR",
            type: "EXTERNAL_SERVICE_ERROR",
            message: internalError.message,
            suggestion: `\u{1F310} \u7F51\u7EDC\u670D\u52A1\u9519\u8BEF\uFF1A
\u2022 \u68C0\u67E5\u7F51\u7EDC\u8FDE\u63A5\u72B6\u6001
\u2022 \u786E\u8BA4\u5916\u90E8API\u670D\u52A1\u53EF\u7528\u6027
\u2022 \u7A0D\u540E\u91CD\u8BD5\u53EF\u80FD\u89E3\u51B3\u95EE\u9898`
          };
        }
        return {
          code: internalError.code || "TOOL_INTERNAL_ERROR",
          type: "UNKNOWN_TOOL_ERROR",
          message: internalError.message,
          suggestion: `\u{1F527} \u5DE5\u5177\u5185\u90E8\u9519\u8BEF\uFF1A
\u2022 \u8FD9\u53EF\u80FD\u662F\u5DE5\u5177\u4EE3\u7801\u7684\u903B\u8F91\u95EE\u9898
\u2022 \u68C0\u67E5\u5DE5\u5177\u7684\u5B9E\u73B0\u662F\u5426\u6B63\u786E
\u2022 \u5982\u679C\u95EE\u9898\u6301\u7EED\uFF0C\u8BF7\u8054\u7CFB\u5DE5\u5177\u5F00\u53D1\u8005

\u{1F41B} \u9519\u8BEF\u8BE6\u60C5\uFF1A
${typeof details === "string" ? details : JSON.stringify(details, null, 2)}`
        };
      }
      /**
       * 获取工具命令的元信息 - ToolSandbox版本
       * @returns {Object} 命令元信息
       */
      getMetadata() {
        return {
          name: "toolx",
          description: "\u4F7F\u7528ToolSandbox\u6267\u884C\u901A\u8FC7@tool\u534F\u8BAE\u58F0\u660E\u7684\u5DE5\u5177",
          version: "2.0.0",
          author: "PromptX Framework",
          executor: "ToolSandbox",
          supports: {
            protocols: ["@tool://"],
            formats: [".tool.js"],
            features: [
              "ToolSandbox\u6C99\u7BB1\u6267\u884C",
              "\u81EA\u52A8\u4F9D\u8D56\u7BA1\u7406",
              "\u4E09\u9636\u6BB5\u6267\u884C\u6D41\u7A0B",
              "pnpm\u4F9D\u8D56\u5B89\u88C5",
              "\u53C2\u6570\u9A8C\u8BC1",
              "\u9519\u8BEF\u5904\u7406",
              "\u6267\u884C\u76D1\u63A7",
              "\u8D44\u6E90\u6E05\u7406"
            ]
          }
        };
      }
    };
    module2.exports = ToolCommand;
  }
});

// src/pouch/commands/index.js
var require_commands = __commonJS({
  "src/pouch/commands/index.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var InitCommand = require_InitCommand();
    var WelcomeCommand = require_WelcomeCommand();
    var ActionCommand = require_ActionCommand();
    var LearnCommand = require_LearnCommand();
    var RecallCommand = require_RecallCommand();
    var RememberCommand = require_RememberCommand();
    var ThinkCommand = require_ThinkCommand();
    var ToolCommand = require_ToolCommand();
    module2.exports = {
      InitCommand,
      WelcomeCommand,
      ActionCommand,
      LearnCommand,
      RecallCommand,
      RememberCommand,
      ThinkCommand,
      ToolCommand
    };
  }
});

// src/pouch/PouchCLI.js
var require_PouchCLI = __commonJS({
  "src/pouch/PouchCLI.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var PouchStateMachine = require_PouchStateMachine();
    var PouchRegistry = require_PouchRegistry();
    var commands = require_commands();
    var { COMMANDS } = require_constants();
    var logger = require("@promptx/logger");
    var PouchCLI = class {
      constructor() {
        this.stateMachine = new PouchStateMachine();
        this.registry = new PouchRegistry();
        this.initialized = false;
      }
      /**
       * 初始化CLI
       */
      async initialize() {
        if (this.initialized) {
          return;
        }
        this.registry.registerBatch({
          init: commands.InitCommand,
          welcome: commands.WelcomeCommand,
          action: commands.ActionCommand,
          learn: commands.LearnCommand,
          recall: commands.RecallCommand,
          remember: commands.RememberCommand,
          think: commands.ThinkCommand,
          toolx: commands.ToolCommand
        });
        for (const name of this.registry.list()) {
          const command = this.registry.get(name);
          this.stateMachine.registerCommand(name, command);
        }
        await this.stateMachine.loadState();
        this.initialized = true;
      }
      /**
       * 执行命令
       * @param {string} commandName - 命令名称
       * @param {Array} args - 命令参数
       * @param {boolean} silent - 静默模式，不输出到console（用于MCP）
       * @returns {Promise<PouchOutput>} 执行结果
       */
      async execute(commandName, args = [], silent = false) {
        if (!this.initialized) {
          await this.initialize();
        }
        if (!this.registry.validate(commandName)) {
          throw new Error(`\u672A\u77E5\u547D\u4EE4: ${commandName}
\u4F7F\u7528 '${COMMANDS.HELP}' \u67E5\u770B\u53EF\u7528\u547D\u4EE4`);
        }
        try {
          const result = await this.stateMachine.transition(commandName, args);
          if (!silent) {
            if (result && result.toString && typeof result.toString === "function") {
              logger.log(result.toString());
            } else {
              logger.log(JSON.stringify(result, null, 2));
            }
          }
          return result;
        } catch (error) {
          if (!silent) {
            logger.error(`\u6267\u884C\u547D\u4EE4\u51FA\u9519: ${error.message}`);
          }
          throw error;
        }
      }
      /**
       * 获取帮助信息
       * @returns {string} 帮助文本
       */
      getHelp() {
        const commands2 = this.registry.getCommandDetails();
        const currentState = this.stateMachine.getCurrentState();
        const availableTransitions = this.stateMachine.getAvailableTransitions();
        let help = `
\u{1F3AF} PromptX \u9526\u56CA\u7CFB\u7EDF\u5E2E\u52A9
========================

\u5F53\u524D\u72B6\u6001: ${currentState}
\u53EF\u7528\u8F6C\u6362: ${availableTransitions.join(", ")}

\u{1F4CB} \u53EF\u7528\u547D\u4EE4:
`;
        for (const cmd of commands2) {
          help += `
  ${cmd.name.padEnd(12)} - ${cmd.purpose}`;
        }
        help += `

\u{1F4A1} \u4F7F\u7528\u793A\u4F8B:
        ${COMMANDS.INIT}              # \u521D\u59CB\u5316\u5DE5\u4F5C\u73AF\u5883
        ${COMMANDS.WELCOME}           # \u53D1\u73B0\u53EF\u7528\u89D2\u8272
        ${COMMANDS.ACTION} copywriter # \u6FC0\u6D3B\u6587\u6848\u4E13\u5BB6
        ${COMMANDS.LEARN} scrum       # \u5B66\u4E60\u654F\u6377\u77E5\u8BC6
        ${COMMANDS.RECALL} frontend   # \u68C0\u7D22\u524D\u7AEF\u8BB0\u5FC6

\u{1F504} PATEOAS \u5BFC\u822A:
\u6BCF\u4E2A\u547D\u4EE4\u6267\u884C\u540E\u90FD\u4F1A\u63D0\u4F9B\u4E0B\u4E00\u6B65\u7684\u5EFA\u8BAE\u64CD\u4F5C\uFF0C
\u6309\u7167\u63D0\u793A\u5373\u53EF\u5B8C\u6210\u5B8C\u6574\u7684\u5DE5\u4F5C\u6D41\u7A0B\u3002

\u{1F4DA} \u66F4\u591A\u4FE1\u606F\u8BF7\u8BBF\u95EE: https://github.com/yourusername/promptx
`;
        return help;
      }
      /**
       * 获取当前状态信息
       * @returns {StateContext} 状态上下文
       */
      getStatus() {
        return {
          currentState: this.stateMachine.getCurrentState(),
          availableCommands: this.registry.list(),
          availableTransitions: this.stateMachine.getAvailableTransitions(),
          context: this.stateMachine.context,
          initialized: this.initialized
        };
      }
      /**
       * 解析命令行输入
       * @param {string} input - 用户输入
       * @returns {Object} 解析结果
       */
      parseCommand(input) {
        const parts = input.trim().split(/\s+/);
        const command = parts[0];
        const args = parts.slice(1);
        return {
          command,
          args
        };
      }
      /**
       * 运行交互式CLI
       */
      async runInteractive() {
        logger.info("\u{1F3AF} \u6B22\u8FCE\u4F7F\u7528 PromptX \u9526\u56CA\u7CFB\u7EDF\uFF01");
        logger.info('\u8F93\u5165 "help" \u67E5\u770B\u5E2E\u52A9\uFF0C"exit" \u9000\u51FA\n');
        const readline = require("readline");
        const rl = readline.createInterface({
          input: process.stdin,
          output: process.stdout,
          prompt: "promptx> "
        });
        rl.prompt();
        rl.on("line", async (line) => {
          const input = line.trim();
          if (input === "exit" || input === "quit") {
            logger.info("\u518D\u89C1\uFF01");
            rl.close();
            return;
          }
          if (input === "help") {
            logger.info(this.getHelp());
          } else if (input === "status") {
            logger.info(JSON.stringify(this.getStatus(), null, 2));
          } else if (input) {
            const { command, args } = this.parseCommand(input);
            try {
              await this.execute(command, args);
            } catch (error) {
              logger.error(error.message);
            }
          }
          rl.prompt();
        });
        rl.on("close", () => {
          process.exit(0);
        });
      }
    };
    module2.exports = PouchCLI;
  }
});

// src/pouch/index.js
var require_pouch = __commonJS({
  "src/pouch/index.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var PouchCLI = require_PouchCLI();
    var PouchRegistry = require_PouchRegistry();
    var PouchStateMachine = require_PouchStateMachine();
    var BasePouchCommand = require_BasePouchCommand();
    var commands = require_commands();
    var cli = new PouchCLI();
    module2.exports = {
      // 主要导出
      PouchCLI,
      cli,
      // 框架组件
      PouchRegistry,
      PouchStateMachine,
      BasePouchCommand,
      // 内置命令
      commands,
      // 便捷方法
      execute: async (commandName, args) => {
        return await cli.execute(commandName, args);
      },
      help: () => {
        return cli.getHelp();
      },
      status: () => {
        return cli.getStatus();
      }
    };
  }
});

// src/utils/version.js
var require_version = __commonJS({
  "src/utils/version.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var cachedVersion = null;
    function getVersion() {
      if (cachedVersion) {
        return cachedVersion;
      }
      try {
        const packageJson = require("../../../package.json");
        cachedVersion = packageJson.version || "1.0.0";
      } catch {
        cachedVersion = "1.0.0";
      }
      return cachedVersion;
    }
    function getFullVersion() {
      const version = getVersion();
      const nodeVersion = process.version;
      return `${version} (Node.js ${nodeVersion})`;
    }
    module2.exports = {
      getVersion,
      getFullVersion
    };
  }
});

// src/utils/ProjectConfig.js
var require_ProjectConfig = __commonJS({
  "src/utils/ProjectConfig.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var ProjectConfig = class _ProjectConfig {
      /**
       * @param {string} mcpId - MCP进程唯一标识符
       * @param {string} ideType - IDE类型（cursor/vscode等）
       * @param {string} projectPath - 项目绝对路径
       * @param {string} projectHash - 项目路径的Hash值（用于文件名唯一性）
       */
      constructor(mcpId, ideType, projectPath, projectHash) {
        this.mcpId = mcpId;
        this.ideType = ideType;
        this.projectPath = projectPath;
        this.projectHash = projectHash;
      }
      /**
       * 从JSON对象创建ProjectConfig实例
       * @param {Object} data - JSON数据
       * @returns {ProjectConfig} 配置实例
       */
      static fromJson(data) {
        return new _ProjectConfig(
          data.mcpId,
          data.ideType,
          data.projectPath,
          data.projectHash
        );
      }
      /**
       * 转换为JSON对象
       * @returns {Object} JSON对象
       */
      toJson() {
        return {
          mcpId: this.mcpId,
          ideType: this.ideType,
          projectPath: this.projectPath,
          projectHash: this.projectHash
        };
      }
      /**
       * 获取项目名称
       * @returns {string} 项目名称
       */
      getProjectName() {
        const path = require("path");
        return path.basename(this.projectPath);
      }
      /**
       * 验证配置完整性
       * @returns {boolean} 是否有效
       */
      isValid() {
        return !!(this.mcpId && this.ideType && this.projectPath && this.projectHash);
      }
      /**
       * 生成配置文件名
       * @returns {string} 配置文件名
       */
      getConfigFileName() {
        const path = require("path");
        const projectName = path.basename(this.projectPath).toLowerCase().replace(/[^a-z0-9-]/g, "-");
        const ideTypeSafe = this.ideType.replace(/[^a-z0-9-]/g, "").toLowerCase() || "unknown";
        return `${this.mcpId}-${ideTypeSafe}-${projectName}-${this.projectHash}.json`;
      }
    };
    module2.exports = ProjectConfig;
  }
});

// src/index.js
init_cjs_shims();
var cognition = require_cognition();
var resource = require_resource();
var toolx = require_toolx();
var pouch = require_pouch();
var utils = {
  version: require_version(),
  DirectoryService: require_DirectoryService(),
  ServerEnvironment: require_ServerEnvironment(),
  ProjectManager: require_ProjectManager(),
  ProjectPathResolver: require_ProjectPathResolver(),
  ProjectConfig: require_ProjectConfig()
};
module.exports = {
  cognition,
  resource,
  toolx,
  pouch,
  utils,
  // 便捷导出
  ...utils
};
//# sourceMappingURL=index.js.map