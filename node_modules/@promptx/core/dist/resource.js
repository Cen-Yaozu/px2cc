"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));

// ../../node_modules/.pnpm/tsup@8.5.0_jiti@2.5.1_postcss@8.5.6_tsx@4.20.5_typescript@5.9.2_yaml@2.8.1/node_modules/tsup/assets/cjs_shims.js
var init_cjs_shims = __esm({
  "../../node_modules/.pnpm/tsup@8.5.0_jiti@2.5.1_postcss@8.5.6_tsx@4.20.5_typescript@5.9.2_yaml@2.8.1/node_modules/tsup/assets/cjs_shims.js"() {
    "use strict";
  }
});

// src/utils/ServerEnvironment.js
var require_ServerEnvironment = __commonJS({
  "src/utils/ServerEnvironment.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var ServerEnvironment = class {
      constructor() {
        this.transport = null;
        this.host = null;
        this.port = null;
        this.processId = null;
        this.initialized = false;
      }
      /**
       * åˆå§‹åŒ–æœåŠ¡ç¯å¢ƒï¼ˆå„å¯åŠ¨æ¸ é“è°ƒç”¨ä¸€æ¬¡ï¼‰
       * @param {Object} config - é…ç½®å¯¹è±¡
       * @param {string} config.transport - ä¼ è¾“åè®®
       * @param {string} config.host - ä¸»æœºåœ°å€ï¼ˆå¯é€‰ï¼‰
       * @param {number} config.port - ç«¯å£å·ï¼ˆå¯é€‰ï¼‰
       */
      initialize(config) {
        this.transport = config.transport;
        this.host = config.host || null;
        this.port = config.port || null;
        this.processId = process.pid;
        this.initialized = true;
      }
      /**
       * è·å–MCP IDï¼ˆåŸºäºprocessIdç”Ÿæˆï¼‰
       * @returns {string} MCPè¿›ç¨‹ID
       */
      getMcpId() {
        if (!this.initialized) {
          throw new Error("ServerEnvironment not initialized");
        }
        return `mcp-${this.processId}`;
      }
      /**
       * è·å–ä¼ è¾“åè®®
       * @returns {string} transportç±»å‹
       */
      getTransport() {
        if (!this.initialized) {
          throw new Error("ServerEnvironment not initialized");
        }
        return this.transport;
      }
      /**
       * è·å–æœåŠ¡å™¨åœ°å€ä¿¡æ¯ï¼ˆä»…HTTP/SSEæ¨¡å¼ï¼‰
       * @returns {Object|null} {host, port} æˆ– null
       */
      getServerAddress() {
        if (!this.initialized) {
          throw new Error("ServerEnvironment not initialized");
        }
        if (this.transport === "stdio") {
          return null;
        }
        return {
          host: this.host,
          port: this.port
        };
      }
      /**
       * æ£€æŸ¥æ˜¯å¦å·²åˆå§‹åŒ–
       * @returns {boolean}
       */
      isInitialized() {
        return this.initialized;
      }
    };
    var globalServerEnvironment = null;
    function getGlobalServerEnvironment() {
      if (!globalServerEnvironment) {
        globalServerEnvironment = new ServerEnvironment();
      }
      return globalServerEnvironment;
    }
    module2.exports = ServerEnvironment;
    module2.exports.getGlobalServerEnvironment = getGlobalServerEnvironment;
  }
});

// src/utils/ProjectManager.js
var require_ProjectManager = __commonJS({
  "src/utils/ProjectManager.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var fs = require("fs-extra");
    var path = require("path");
    var os = require("os");
    var crypto = require("crypto");
    var { getGlobalServerEnvironment } = require_ServerEnvironment();
    var logger = require("@promptx/logger");
    var ProjectManager = class {
      constructor() {
        this.promptxHomeDir = path.join(os.homedir(), ".promptx");
        this.projectsDir = path.join(this.promptxHomeDir, "project");
      }
      // ğŸ¯ æ–°æ¶æ„ï¼šå½“å‰é¡¹ç›®çŠ¶æ€ç®¡ç†
      static currentProject = {
        workingDirectory: null,
        mcpId: null,
        ideType: null,
        transport: null,
        initialized: false
      };
      /**
       * è®¾ç½®å½“å‰é¡¹ç›®ï¼ˆinitæ—¶è°ƒç”¨ï¼‰
       * @param {string} workingDirectory - é¡¹ç›®å·¥ä½œç›®å½•ç»å¯¹è·¯å¾„
       * @param {string} mcpId - MCPè¿›ç¨‹ID
       * @param {string} ideType - IDEç±»å‹
       * @param {string} transport - ä¼ è¾“åè®®ç±»å‹
       */
      static setCurrentProject(workingDirectory, mcpId, ideType, transport) {
        this.currentProject = {
          workingDirectory: path.resolve(workingDirectory),
          mcpId,
          ideType,
          transport,
          initialized: true
        };
      }
      /**
       * è·å–å½“å‰é¡¹ç›®è·¯å¾„ï¼ˆ@projectåè®®ä½¿ç”¨ï¼‰
       * @returns {string} å½“å‰é¡¹ç›®å·¥ä½œç›®å½•
       */
      static getCurrentProjectPath() {
        logger.debug(`[ProjectManager DEBUG] getCurrentProjectPath\u88AB\u8C03\u7528`);
        logger.debug(`[ProjectManager DEBUG] currentProject.initialized: ${this.currentProject.initialized}`);
        logger.debug(`[ProjectManager DEBUG] currentProject\u72B6\u6001:`, JSON.stringify(this.currentProject, null, 2));
        const stack = new Error().stack;
        const stackLines = stack.split("\n").slice(1, 8);
        logger.error(`[ProjectManager DEBUG] \u5B8C\u6574\u8C03\u7528\u6808:`);
        stackLines.forEach((line, index) => {
          logger.error(`[ProjectManager DEBUG]   ${index + 1}. ${line.trim()}`);
        });
        if (!this.currentProject.initialized) {
          logger.error(`[ProjectManager DEBUG] \u274C \u9879\u76EE\u672A\u521D\u59CB\u5316\uFF0C\u5C06\u629B\u51FA\u9519\u8BEF`);
          throw new Error("\u9879\u76EE\u672A\u521D\u59CB\u5316\uFF0C\u8BF7\u5148\u8C03\u7528 init \u547D\u4EE4");
        }
        logger.debug(`[ProjectManager DEBUG] \u2705 \u8FD4\u56DE\u9879\u76EE\u8DEF\u5F84: ${this.currentProject.workingDirectory}`);
        return this.currentProject.workingDirectory;
      }
      /**
       * è·å–å½“å‰é¡¹ç›®ä¿¡æ¯
       * @returns {Object} å½“å‰é¡¹ç›®å®Œæ•´ä¿¡æ¯
       */
      static getCurrentProject() {
        logger.debug(`[ProjectManager DEBUG] getCurrentProject\u88AB\u8C03\u7528`);
        logger.debug(`[ProjectManager DEBUG] currentProject.initialized: ${this.currentProject.initialized}`);
        logger.debug(`[ProjectManager DEBUG] currentProject\u72B6\u6001:`, JSON.stringify(this.currentProject, null, 2));
        if (!this.currentProject.initialized) {
          logger.error(`[ProjectManager DEBUG] \u274C \u9879\u76EE\u672A\u521D\u59CB\u5316\uFF0C\u5C06\u629B\u51FA\u9519\u8BEF`);
          throw new Error("\u9879\u76EE\u672A\u521D\u59CB\u5316\uFF0C\u8BF7\u5148\u8C03\u7528 init \u547D\u4EE4");
        }
        logger.debug(`[ProjectManager DEBUG] \u2705 \u8FD4\u56DE\u9879\u76EE\u4FE1\u606F`);
        return { ...this.currentProject };
      }
      /**
       * æ£€æŸ¥é¡¹ç›®æ˜¯å¦å·²åˆå§‹åŒ–
       * @returns {boolean} æ˜¯å¦å·²åˆå§‹åŒ–
       */
      static isInitialized() {
        return this.currentProject.initialized;
      }
      /**
       * æ³¨å†Œé¡¹ç›®åˆ°MCPå®ä¾‹ - ä½¿ç”¨Hashç›®å½•ç»“æ„
       * @param {string} projectPath - é¡¹ç›®ç»å¯¹è·¯å¾„
       * @param {string} mcpId - MCPè¿›ç¨‹ID
       * @param {string} ideType - IDEç±»å‹ï¼ˆcursor/vscodeç­‰ï¼‰
       * @param {string} transport - ä¼ è¾“åè®®ç±»å‹ï¼ˆstdio/http/sseï¼‰
       * @returns {Promise<Object>} é¡¹ç›®é…ç½®å¯¹è±¡
       */
      async registerProject(projectPath, mcpId, ideType, transport = "stdio") {
        if (!await this.validateProjectPath(projectPath)) {
          throw new Error(`\u65E0\u6548\u7684\u9879\u76EE\u8DEF\u5F84: ${projectPath}`);
        }
        const projectConfig = {
          mcpId,
          ideType: ideType.toLowerCase(),
          transport: transport.toLowerCase(),
          projectPath: path.resolve(projectPath),
          projectHash: this.generateProjectHash(projectPath)
        };
        const projectHash = this.generateProjectHash(projectPath);
        const projectConfigDir = path.join(this.projectsDir, projectHash);
        await fs.ensureDir(projectConfigDir);
        await fs.ensureDir(path.join(projectConfigDir, ".promptx"));
        await fs.ensureDir(path.join(projectConfigDir, ".promptx", "memory"));
        await fs.ensureDir(path.join(projectConfigDir, ".promptx", "resource"));
        const fileName = this.generateConfigFileName(mcpId, ideType, transport, projectPath);
        const configPath = path.join(projectConfigDir, fileName);
        await fs.writeJson(configPath, projectConfig, { spaces: 2 });
        return projectConfig;
      }
      /**
       * æ ¹æ®MCP IDè·å–å•ä¸ªé¡¹ç›®é…ç½®ï¼ˆå‡è®¾åªæœ‰ä¸€ä¸ªé¡¹ç›®ï¼‰
       * @param {string} mcpId - MCPè¿›ç¨‹ID
       * @returns {Promise<Object|null>} é¡¹ç›®é…ç½®å¯¹è±¡
       */
      async getProjectByMcpId(mcpId) {
        const projects = await this.getProjectsByMcpId(mcpId);
        return projects.length > 0 ? projects[0] : null;
      }
      /**
       * æ ¹æ®MCP IDè·å–æ‰€æœ‰ç»‘å®šçš„é¡¹ç›®é…ç½® - æ”¯æŒHashç›®å½•ç»“æ„
       * @param {string} mcpId - MCPè¿›ç¨‹ID
       * @returns {Promise<Array>} é¡¹ç›®é…ç½®æ•°ç»„
       */
      async getProjectsByMcpId(mcpId) {
        if (!await fs.pathExists(this.projectsDir)) {
          return [];
        }
        const hashDirs = await fs.readdir(this.projectsDir);
        const projects = [];
        for (const hashDir of hashDirs) {
          const hashDirPath = path.join(this.projectsDir, hashDir);
          if (!(await fs.stat(hashDirPath)).isDirectory()) {
            continue;
          }
          try {
            const configFiles = await fs.readdir(hashDirPath);
            for (const file of configFiles) {
              if (file.startsWith("mcp-") && file.endsWith(".json")) {
                try {
                  const configPath = path.join(hashDirPath, file);
                  const config = await fs.readJson(configPath);
                  if (config.mcpId === mcpId) {
                    projects.push(config);
                  }
                } catch (error) {
                  logger.warn(`\u8DF3\u8FC7\u635F\u574F\u7684\u914D\u7F6E\u6587\u4EF6: ${file}`);
                }
              }
            }
          } catch (error) {
            logger.warn(`\u8DF3\u8FC7\u65E0\u6CD5\u8BFB\u53D6\u7684\u76EE\u5F55: ${hashDir}`);
          }
        }
        return projects;
      }
      /**
       * è·å–ç‰¹å®šé¡¹ç›®çš„æ‰€æœ‰å®ä¾‹ï¼ˆä¸åŒIDE/MCPçš„ç»‘å®šï¼‰ - æ”¯æŒHashç›®å½•ç»“æ„
       * @param {string} projectPath - é¡¹ç›®è·¯å¾„
       * @returns {Promise<Array>} é¡¹ç›®å®ä¾‹æ•°ç»„
       */
      async getProjectInstances(projectPath) {
        if (!await fs.pathExists(this.projectsDir)) {
          return [];
        }
        const projectHash = this.generateProjectHash(projectPath);
        const projectConfigDir = path.join(this.projectsDir, projectHash);
        if (!await fs.pathExists(projectConfigDir)) {
          return [];
        }
        const instances = [];
        try {
          const configFiles = await fs.readdir(projectConfigDir);
          for (const file of configFiles) {
            if (file.startsWith("mcp-") && file.endsWith(".json")) {
              try {
                const configPath = path.join(projectConfigDir, file);
                const config = await fs.readJson(configPath);
                if (config.projectHash === projectHash) {
                  instances.push(config);
                }
              } catch (error) {
                logger.warn(`\u8DF3\u8FC7\u635F\u574F\u7684\u914D\u7F6E\u6587\u4EF6: ${file}`);
              }
            }
          }
        } catch (error) {
          logger.warn(`\u65E0\u6CD5\u8BFB\u53D6\u9879\u76EE\u914D\u7F6E\u76EE\u5F55: ${projectConfigDir}`);
        }
        return instances;
      }
      /**
       * åˆ é™¤é¡¹ç›®ç»‘å®š - æ”¯æŒHashç›®å½•ç»“æ„
       * @param {string} mcpId - MCPè¿›ç¨‹ID
       * @param {string} ideType - IDEç±»å‹
       * @param {string} transport - ä¼ è¾“åè®®ç±»å‹
       * @param {string} projectPath - é¡¹ç›®è·¯å¾„
       * @returns {Promise<boolean>} æ˜¯å¦åˆ é™¤æˆåŠŸ
       */
      async removeProject(mcpId, ideType, transport, projectPath) {
        const projectHash = this.generateProjectHash(projectPath);
        const projectConfigDir = path.join(this.projectsDir, projectHash);
        const fileName = this.generateConfigFileName(mcpId, ideType, transport, projectPath);
        const configPath = path.join(projectConfigDir, fileName);
        if (await fs.pathExists(configPath)) {
          await fs.remove(configPath);
          try {
            const remainingFiles = await fs.readdir(projectConfigDir);
            const mcpConfigFiles = remainingFiles.filter((file) => file.startsWith("mcp-") && file.endsWith(".json"));
            if (mcpConfigFiles.length === 0) {
              await fs.remove(projectConfigDir);
            }
          } catch (error) {
          }
          return true;
        }
        return false;
      }
      /**
       * æ¸…ç†è¿‡æœŸçš„é¡¹ç›®é…ç½® - æ”¯æŒHashç›®å½•ç»“æ„
       * @returns {Promise<number>} æ¸…ç†çš„é…ç½®æ–‡ä»¶æ•°é‡
       */
      async cleanupExpiredProjects() {
        if (!await fs.pathExists(this.projectsDir)) {
          return 0;
        }
        const hashDirs = await fs.readdir(this.projectsDir);
        let cleanedCount = 0;
        for (const hashDir of hashDirs) {
          const hashDirPath = path.join(this.projectsDir, hashDir);
          if (!(await fs.stat(hashDirPath)).isDirectory()) {
            continue;
          }
          try {
            const configFiles = await fs.readdir(hashDirPath);
            let hasValidConfig = false;
            for (const file of configFiles) {
              if (file.startsWith("mcp-") && file.endsWith(".json")) {
                try {
                  const configPath = path.join(hashDirPath, file);
                  const config = await fs.readJson(configPath);
                  if (!await fs.pathExists(config.projectPath)) {
                    await fs.remove(configPath);
                    cleanedCount++;
                    logger.info(`\u6E05\u7406\u8FC7\u671F\u9879\u76EE\u914D\u7F6E: ${file}`);
                  } else {
                    hasValidConfig = true;
                  }
                } catch (error) {
                  await fs.remove(path.join(hashDirPath, file));
                  cleanedCount++;
                  logger.info(`\u6E05\u7406\u635F\u574F\u914D\u7F6E\u6587\u4EF6: ${file}`);
                }
              }
            }
            if (!hasValidConfig) {
              await fs.remove(hashDirPath);
              logger.info(`\u6E05\u7406\u7A7A\u7684\u9879\u76EEHash\u76EE\u5F55: ${hashDir}`);
            }
          } catch (error) {
            await fs.remove(hashDirPath);
            cleanedCount++;
            logger.info(`\u6E05\u7406\u65E0\u6CD5\u8BBF\u95EE\u7684\u76EE\u5F55: ${hashDir}`);
          }
        }
        return cleanedCount;
      }
      /**
       * ç”Ÿæˆå¤šé¡¹ç›®ç¯å¢ƒä¸‹çš„AIæç¤ºè¯
       * @param {string} contextType - ä¸Šä¸‹æ–‡ç±»å‹ï¼š'list'/'action'/'learn'
       * @param {string} mcpId - MCPè¿›ç¨‹ID
       * @param {string} ideType - IDEç±»å‹
       * @returns {Promise<string>} æ ¼å¼åŒ–çš„AIæç¤ºè¯
       */
      async generateTopLevelProjectPrompt(contextType = "list", mcpId, ideType) {
        const projects = await this.getProjectsByMcpId(mcpId);
        if (projects.length === 0) {
          return "";
        }
        if (projects.length === 1) {
          const project = projects[0];
          const basePrompt = `\u{1F6D1} **\u9879\u76EE\u73AF\u5883\u9A8C\u8BC1** \u{1F6D1}
\u{1F4CD} \u5F53\u524D\u7ED1\u5B9A\u9879\u76EE: ${project.projectPath}
\u{1F517} MCP\u5B9E\u4F8B: ${mcpId} (${ideType})

\u26A0\uFE0F **\u6267\u884C\u524D\u786E\u8BA4**\uFF1A\u4E0A\u8FF0\u8DEF\u5F84\u662F\u5426\u4E3A\u4F60\u5F53\u524D\u5DE5\u4F5C\u7684\u9879\u76EE\uFF1F`;
          switch (contextType) {
            case "action":
              return `${basePrompt}
\u5982\u4E0D\u4E00\u81F4\uFF0C\u7ACB\u5373\u505C\u6B62\u6240\u6709\u64CD\u4F5C\u5E76\u4F7F\u7528 \`promptx_init\` \u66F4\u65B0\uFF01

\u{1F4A5} **\u4E25\u91CD\u8B66\u544A**\uFF1A\u5728\u9519\u8BEF\u9879\u76EE\u8DEF\u5F84\u4E0B\u64CD\u4F5C\u5C06\u5BFC\u81F4\u4E0D\u53EF\u9884\u77E5\u7684\u9519\u8BEF\uFF01`;
            case "learn":
              return `${basePrompt}
\u9519\u8BEF\u73AF\u5883\u5C06\u5BFC\u81F4\u77E5\u8BC6\u5173\u8054\u5931\u6548\uFF01

\u{1F4A5} **\u4E25\u91CD\u8B66\u544A**\uFF1A\u9879\u76EE\u73AF\u5883\u4E0D\u5339\u914D\u5C06\u5F71\u54CD\u5B66\u4E60\u6548\u679C\uFF01`;
            default:
              return `${basePrompt}
\u5982\u4E0D\u4E00\u81F4\uFF0C\u5FC5\u987B\u4F7F\u7528 \`promptx_init\` \u66F4\u65B0\u6B63\u786E\u8DEF\u5F84\uFF01

\u{1F4A5} **\u4E25\u91CD\u8B66\u544A**\uFF1A\u9519\u8BEF\u7684\u9879\u76EE\u73AF\u5883\u5C06\u5BFC\u81F4\u670D\u52A1\u5F02\u5E38\uFF01`;
          }
        }
        const projectList = projects.map(
          (proj, index) => `${index + 1}. ${path.basename(proj.projectPath)} (${proj.projectPath})`
        ).join("\n");
        return `\u{1F3AF} **\u591A\u9879\u76EE\u73AF\u5883\u68C0\u6D4B** \u{1F3AF}
\u{1F4CD} \u5F53\u524DMCP\u5B9E\u4F8B(${mcpId})\u5DF2\u7ED1\u5B9A ${projects.length} \u4E2A\u9879\u76EE\uFF1A

${projectList}

\u26A0\uFE0F **\u8BF7\u660E\u786E\u6307\u5B9A**\uFF1A\u4F60\u8981\u5728\u54EA\u4E2A\u9879\u76EE\u4E2D\u6267\u884C\u64CD\u4F5C\uFF1F
\u{1F4A1} **\u5EFA\u8BAE**\uFF1A\u5728\u5BF9\u8BDD\u4E2D\u660E\u786E\u8BF4\u660E\u9879\u76EE\u540D\u79F0\u6216\u8DEF\u5F84`;
      }
      /**
       * éªŒè¯è·¯å¾„æ˜¯å¦ä¸ºæœ‰æ•ˆçš„é¡¹ç›®ç›®å½•
       * @param {string} projectPath - è¦éªŒè¯çš„è·¯å¾„
       * @returns {Promise<boolean>} æ˜¯å¦ä¸ºæœ‰æ•ˆé¡¹ç›®ç›®å½•
       */
      async validateProjectPath(projectPath) {
        try {
          const stat = await fs.stat(projectPath);
          if (!stat.isDirectory()) {
            return false;
          }
          const resolved = path.resolve(projectPath);
          const homeDir = os.homedir();
          if (resolved === homeDir) {
            return false;
          }
          return true;
        } catch (error) {
          return false;
        }
      }
      /**
       * ç”Ÿæˆé…ç½®æ–‡ä»¶å
       * @param {string} mcpId - MCPè¿›ç¨‹ID
       * @param {string} ideType - IDEç±»å‹
       * @param {string} transport - ä¼ è¾“åè®®ç±»å‹
       * @param {string} projectPath - é¡¹ç›®è·¯å¾„
       * @returns {string} é…ç½®æ–‡ä»¶å
       */
      generateConfigFileName(mcpId, ideType, transport, projectPath) {
        const projectHash = this.generateProjectHash(projectPath);
        const projectName = path.basename(projectPath).toLowerCase().replace(/[^a-z0-9-]/g, "-");
        const ideTypeSafe = ideType.replace(/[^a-z0-9-]/g, "").toLowerCase() || "unknown";
        const transportSafe = transport.replace(/[^a-z0-9-]/g, "").toLowerCase() || "unknown";
        return `mcp-${transportSafe}-${mcpId.replace("mcp-", "")}-${ideTypeSafe}-${projectName}-${projectHash}.json`;
      }
      /**
       * ç”Ÿæˆé¡¹ç›®è·¯å¾„çš„Hashå€¼
       * @param {string} projectPath - é¡¹ç›®è·¯å¾„
       * @returns {string} 8ä½Hashå€¼
       */
      generateProjectHash(projectPath) {
        return crypto.createHash("md5").update(path.resolve(projectPath)).digest("hex").substr(0, 8);
      }
      /**
       * ä»é…ç½®æ–‡ä»¶ä¸­è·å–IDEç±»å‹
       * @param {string} mcpId - MCPè¿›ç¨‹ID
       * @returns {Promise<string>} IDEç±»å‹
       */
      async getIdeType(mcpId) {
        const project = await this.getProjectByMcpId(mcpId);
        return project ? project.ideType : "unknown";
      }
      /**
       * ç”ŸæˆMCPè¿›ç¨‹ID - åŸºäºè¿›ç¨‹IDç¡®ä¿å®ä¾‹å”¯ä¸€
       * @param {string} ideType - IDEç±»å‹ï¼ˆä¿ç•™å‚æ•°å…¼å®¹æ€§ï¼Œå®é™…ä¸ä½¿ç”¨ï¼‰
       * @returns {string} MCPè¿›ç¨‹ID
       */
      static generateMcpId(ideType = "unknown") {
        const serverEnv = getGlobalServerEnvironment();
        if (serverEnv.isInitialized()) {
          return serverEnv.getMcpId();
        }
        return `mcp-${process.pid}`;
      }
      /**
       * ç»Ÿä¸€é¡¹ç›®æ³¨å†Œæ–¹æ³• - æ–°æ¶æ„ï¼šè®¾ç½®å½“å‰é¡¹ç›®å¹¶æŒä¹…åŒ–é…ç½®
       * @param {string} workingDirectory - é¡¹ç›®å·¥ä½œç›®å½•
       * @param {string} ideType - IDEç±»å‹ï¼ˆå¯é€‰ï¼Œé»˜è®¤'unknown'ï¼‰
       * @returns {Promise<Object>} é¡¹ç›®é…ç½®å¯¹è±¡
       */
      static async registerCurrentProject(workingDirectory, ideType = "unknown") {
        logger.debug(`[ProjectManager DEBUG] ======= registerCurrentProject\u5F00\u59CB =======`);
        logger.debug(`[ProjectManager DEBUG] \u53C2\u6570 - workingDirectory: ${workingDirectory}`);
        logger.debug(`[ProjectManager DEBUG] \u53C2\u6570 - ideType: ${ideType}`);
        logger.debug(`[ProjectManager DEBUG] \u6CE8\u518C\u524D currentProject\u72B6\u6001:`, JSON.stringify(this.currentProject, null, 2));
        const serverEnv = getGlobalServerEnvironment();
        if (!serverEnv.isInitialized()) {
          logger.error(`[ProjectManager DEBUG] \u274C ServerEnvironment\u672A\u521D\u59CB\u5316`);
          throw new Error("ServerEnvironment not initialized");
        }
        const mcpId = serverEnv.getMcpId();
        const transport = serverEnv.getTransport();
        logger.debug(`[ProjectManager DEBUG] ServerEnvironment\u4FE1\u606F - mcpId: ${mcpId}, transport: ${transport}`);
        logger.debug(`[ProjectManager DEBUG] \u8C03\u7528 setCurrentProject...`);
        this.setCurrentProject(workingDirectory, mcpId, ideType, transport);
        logger.debug(`[ProjectManager DEBUG] setCurrentProject\u5B8C\u6210\u540E currentProject\u72B6\u6001:`, JSON.stringify(this.currentProject, null, 2));
        logger.debug(`[ProjectManager DEBUG] \u5F00\u59CB\u6301\u4E45\u5316\u9879\u76EE\u914D\u7F6E...`);
        const projectManager = getGlobalProjectManager();
        const result = await projectManager.registerProject(workingDirectory, mcpId, ideType, transport);
        logger.debug(`[ProjectManager DEBUG] \u9879\u76EE\u914D\u7F6E\u6301\u4E45\u5316\u5B8C\u6210:`, JSON.stringify(result, null, 2));
        logger.debug(`[ProjectManager DEBUG] ======= registerCurrentProject\u7ED3\u675F =======`);
        return result;
      }
    };
    var globalProjectManager = null;
    function getGlobalProjectManager() {
      if (!globalProjectManager) {
        globalProjectManager = new ProjectManager();
      }
      return globalProjectManager;
    }
    module2.exports = ProjectManager;
    module2.exports.ProjectManager = ProjectManager;
    module2.exports.getGlobalProjectManager = getGlobalProjectManager;
  }
});

// src/utils/DirectoryLocator.js
var require_DirectoryLocator = __commonJS({
  "src/utils/DirectoryLocator.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var fs = require("fs-extra");
    var path = require("path");
    var os = require("os");
    var ProjectManager = require_ProjectManager();
    var DirectoryLocator = class {
      constructor(options = {}) {
        this.options = options;
        this.cache = /* @__PURE__ */ new Map();
        this.platform = process.platform;
      }
      /**
       * æŠ½è±¡æ–¹æ³•ï¼šå®šä½ç›®å½•
       * @param {Object} context - å®šä½ä¸Šä¸‹æ–‡
       * @returns {Promise<string>} å®šä½åˆ°çš„ç›®å½•è·¯å¾„
       */
      async locate(context = {}) {
        throw new Error("\u5B50\u7C7B\u5FC5\u987B\u5B9E\u73B0 locate \u65B9\u6CD5");
      }
      /**
       * è·å–ç¼“å­˜
       */
      getCached(key) {
        return this.cache.get(key);
      }
      /**
       * è®¾ç½®ç¼“å­˜
       */
      setCached(key, value) {
        this.cache.set(key, value);
        return value;
      }
      /**
       * æ¸…é™¤ç¼“å­˜
       */
      clearCache() {
        this.cache.clear();
      }
      /**
       * æ£€æŸ¥è·¯å¾„æ˜¯å¦å­˜åœ¨ä¸”æ˜¯ç›®å½•
       */
      async isValidDirectory(dirPath) {
        try {
          const stat = await fs.stat(dirPath);
          return stat.isDirectory();
        } catch {
          return false;
        }
      }
      /**
       * è§„èŒƒåŒ–è·¯å¾„
       */
      normalizePath(inputPath) {
        if (!inputPath || typeof inputPath !== "string") {
          return null;
        }
        return path.resolve(inputPath);
      }
      /**
       * å±•å¼€å®¶ç›®å½•è·¯å¾„
       */
      expandHome(filepath) {
        if (!filepath || typeof filepath !== "string") {
          return "";
        }
        if (filepath.startsWith("~/") || filepath === "~") {
          return path.join(os.homedir(), filepath.slice(2));
        }
        return filepath;
      }
    };
    var ProjectRootLocator = class extends DirectoryLocator {
      constructor(options = {}) {
        super(options);
        this.projectManager = new ProjectManager();
        this.strategies = options.strategies || [
          "aiProvidedProjectPath",
          // 1. AIæä¾›çš„é¡¹ç›®è·¯å¾„ï¼ˆæœ€å¯é ï¼Œç”±AIå‘ŠçŸ¥ï¼‰
          "existingPromptxDirectory",
          // 2. ç°æœ‰.promptxç›®å½•ï¼ˆæœ€å¯é çš„é¡¹ç›®æ ‡è¯†ï¼‰
          "packageJsonDirectory",
          // 3. å‘ä¸ŠæŸ¥æ‰¾é¡¹ç›®æ ‡è¯†æ–‡ä»¶ï¼ˆæœ€å‡†ç¡®çš„é¡¹ç›®è¾¹ç•Œï¼‰
          "gitRootDirectory",
          // 4. Gitæ ¹ç›®å½•ï¼ˆé€šç”¨å¯é ï¼‰
          "currentWorkingDirectoryIfHasMarkers",
          // 5. å½“å‰ç›®å½•é¡¹ç›®æ ‡è¯†ï¼ˆé™çº§ç­–ç•¥ï¼‰
          "currentWorkingDirectory"
          // 6. çº¯å½“å‰ç›®å½•ï¼ˆæœ€åå›é€€ï¼‰
        ];
        this.projectMarkers = options.projectMarkers || [
          "package.json",
          ".git",
          "pyproject.toml",
          "Cargo.toml",
          "pom.xml",
          "build.gradle",
          "composer.json"
        ];
      }
      /**
       * å®šä½é¡¹ç›®æ ¹ç›®å½•
       */
      async locate(context = {}) {
        const { startDir = process.cwd() } = context;
        const cacheKey = `projectRoot:${startDir}`;
        const cached = this.getCached(cacheKey);
        if (cached) {
          return cached;
        }
        const strategies = context.strategies || this.strategies;
        for (const strategy of strategies) {
          const result = await this._executeStrategy(strategy, startDir, context);
          if (result && await this._validateProjectRoot(result, context)) {
            return this.setCached(cacheKey, result);
          }
        }
        return this.setCached(cacheKey, startDir);
      }
      /**
       * æ‰§è¡Œç‰¹å®šçš„æŸ¥æ‰¾ç­–ç•¥
       */
      async _executeStrategy(strategy, startDir, context) {
        switch (strategy) {
          case "aiProvidedProjectPath":
            return await this._findByAIProvidedPath();
          case "existingPromptxDirectory":
            return await this._findByExistingPromptx(startDir);
          case "currentWorkingDirectoryIfHasMarkers":
            return await this._checkCurrentDirForMarkers(startDir);
          case "packageJsonDirectory":
            return await this._findByProjectMarkers(startDir);
          case "gitRootDirectory":
            return await this._findByGitRoot(startDir);
          case "currentWorkingDirectory":
            return startDir;
          default:
            return null;
        }
      }
      /**
       * é€šè¿‡AIæä¾›çš„é¡¹ç›®è·¯å¾„æŸ¥æ‰¾ï¼ˆæœ€é«˜ä¼˜å…ˆçº§ï¼‰
       */
      async _findByAIProvidedPath() {
        try {
          const tempMcpId = process.env.PROMPTX_MCP_ID || `temp-${process.pid}`;
          const projects = await this.projectManager.getProjectsByMcpId(tempMcpId);
          const aiProvidedPath = projects.length > 0 ? projects[0].projectPath : null;
          if (aiProvidedPath && await this.isValidDirectory(aiProvidedPath)) {
            return aiProvidedPath;
          }
        } catch (error) {
        }
        return null;
      }
      /**
       * æ£€æŸ¥å½“å‰ç›®å½•æ˜¯å¦åŒ…å«é¡¹ç›®æ ‡è¯†æ–‡ä»¶
       */
      async _checkCurrentDirForMarkers(startDir) {
        const currentDir = path.resolve(startDir);
        for (const marker of this.projectMarkers) {
          const markerPath = path.join(currentDir, marker);
          if (await fs.pathExists(markerPath)) {
            return currentDir;
          }
        }
        return null;
      }
      /**
       * é€šè¿‡ç°æœ‰.promptxç›®å½•æŸ¥æ‰¾
       */
      async _findByExistingPromptx(startDir) {
        let currentDir = path.resolve(startDir);
        const root = path.parse(currentDir).root;
        while (currentDir !== root) {
          const promptxPath = path.join(currentDir, ".promptx");
          if (await this.isValidDirectory(promptxPath)) {
            return currentDir;
          }
          const parentDir = path.dirname(currentDir);
          if (parentDir === currentDir) break;
          currentDir = parentDir;
        }
        return null;
      }
      /**
       * é€šè¿‡é¡¹ç›®æ ‡è¯†æ–‡ä»¶æŸ¥æ‰¾
       */
      async _findByProjectMarkers(startDir) {
        let currentDir = path.resolve(startDir);
        const root = path.parse(currentDir).root;
        while (currentDir !== root) {
          for (const marker of this.projectMarkers) {
            const markerPath = path.join(currentDir, marker);
            if (await fs.pathExists(markerPath)) {
              return currentDir;
            }
          }
          const parentDir = path.dirname(currentDir);
          if (parentDir === currentDir) break;
          currentDir = parentDir;
        }
        return null;
      }
      /**
       * é€šè¿‡Gitæ ¹ç›®å½•æŸ¥æ‰¾
       */
      async _findByGitRoot(startDir) {
        let currentDir = path.resolve(startDir);
        const root = path.parse(currentDir).root;
        while (currentDir !== root) {
          const gitPath = path.join(currentDir, ".git");
          if (await fs.pathExists(gitPath)) {
            return currentDir;
          }
          const parentDir = path.dirname(currentDir);
          if (parentDir === currentDir) break;
          currentDir = parentDir;
        }
        return null;
      }
      /**
       * éªŒè¯é¡¹ç›®æ ¹ç›®å½•
       */
      async _validateProjectRoot(projectRoot, context = {}) {
        if (this.platform === "win32" && context.avoidUserHome !== false) {
          const homeDir = os.homedir();
          if (path.resolve(projectRoot) === path.resolve(homeDir)) {
            return false;
          }
        }
        return await this.isValidDirectory(projectRoot);
      }
    };
    var PromptXWorkspaceLocator = class extends DirectoryLocator {
      constructor(options = {}) {
        super(options);
        this.projectRootLocator = options.projectRootLocator || new ProjectRootLocator(options);
        this.projectManager = new ProjectManager();
      }
      /**
       * å®šä½PromptXå·¥ä½œç©ºé—´
       */
      async locate(context = {}) {
        const cacheKey = `promptxWorkspace:${JSON.stringify(context)}`;
        const cached = this.getCached(cacheKey);
        if (cached) {
          return cached;
        }
        const workspaceFromAI = await this._fromAIProvidedPath();
        if (workspaceFromAI) {
          return this.setCached(cacheKey, workspaceFromAI);
        }
        const workspaceFromIDE = await this._fromIDEEnvironment();
        if (workspaceFromIDE) {
          return this.setCached(cacheKey, workspaceFromIDE);
        }
        const workspaceFromEnv = await this._fromPromptXEnvironment();
        if (workspaceFromEnv) {
          return this.setCached(cacheKey, workspaceFromEnv);
        }
        if (context.strategies) {
          const workspaceFromProject2 = await this._fromProjectRoot(context);
          if (workspaceFromProject2) {
            return this.setCached(cacheKey, workspaceFromProject2);
          }
        }
        const workspaceFromExisting = await this._fromExistingDirectory(context.startDir);
        if (workspaceFromExisting) {
          return this.setCached(cacheKey, workspaceFromExisting);
        }
        const workspaceFromProject = await this._fromProjectRoot(context);
        if (workspaceFromProject) {
          return this.setCached(cacheKey, workspaceFromProject);
        }
        return this.setCached(cacheKey, await this._getSmartFallback(context));
      }
      /**
       * ä»AIæä¾›çš„é¡¹ç›®è·¯å¾„è·å–ï¼ˆæœ€é«˜ä¼˜å…ˆçº§ï¼‰
       */
      async _fromAIProvidedPath() {
        try {
          const tempMcpId = process.env.PROMPTX_MCP_ID || `temp-${process.pid}`;
          const projects = await this.projectManager.getProjectsByMcpId(tempMcpId);
          const aiProvidedPath = projects.length > 0 ? projects[0].projectPath : null;
          if (aiProvidedPath && await this.isValidDirectory(aiProvidedPath)) {
            return aiProvidedPath;
          }
        } catch (error) {
        }
        return null;
      }
      /**
       * ä»IDEç¯å¢ƒå˜é‡è·å–ï¼ˆæ”¯æŒå¤šç§IDEï¼‰
       */
      async _fromIDEEnvironment() {
        const ideStrategies = [
          // Claude IDE (ç°æœ‰æ ¼å¼)
          {
            name: "Claude IDE",
            vars: ["WORKSPACE_FOLDER_PATHS"],
            parse: (value, varName) => {
              try {
                const folders = JSON.parse(value);
                return Array.isArray(folders) && folders.length > 0 ? folders[0] : null;
              } catch {
                return null;
              }
            }
          },
          // VSCode
          {
            name: "VSCode",
            vars: ["VSCODE_WORKSPACE_FOLDER", "VSCODE_CWD"],
            parse: (value, varName) => value
          },
          // IntelliJ IDEA / WebStorm / PhpStorm
          {
            name: "JetBrains IDEs",
            vars: ["PROJECT_ROOT", "IDEA_INITIAL_DIRECTORY", "WEBSTORM_PROJECT_PATH"],
            parse: (value, varName) => value
          },
          // Sublime Text
          {
            name: "Sublime Text",
            vars: ["SUBLIME_PROJECT_PATH", "SUBL_PROJECT_DIR"],
            parse: (value, varName) => value
          },
          // Atom
          {
            name: "Atom",
            vars: ["ATOM_PROJECT_PATH", "ATOM_HOME_PROJECT"],
            parse: (value, varName) => value
          },
          // Vim/Neovim
          {
            name: "Vim/Neovim",
            vars: ["VIM_PROJECT_ROOT", "NVIM_PROJECT_ROOT"],
            parse: (value, varName) => value
          },
          // å­—èŠ‚è·³åŠ¨ Trae å’Œå…¶ä»–åŸºäºPWDçš„IDE
          {
            name: "ByteDance Trae & PWD-based IDEs",
            vars: ["PWD", "TRAE_WORKSPACE", "BYTEDANCE_WORKSPACE"],
            parse: (value, varName) => {
              if (varName === "TRAE_WORKSPACE" || varName === "BYTEDANCE_WORKSPACE") {
                return value;
              }
              if (varName === "PWD") {
                const currentCwd = process.cwd();
                if (value && value !== currentCwd) {
                  return value;
                }
              }
              return null;
            }
          },
          // é€šç”¨å·¥ä½œç›®å½•
          {
            name: "Generic",
            vars: ["WORKSPACE_ROOT", "PROJECT_DIR", "WORKING_DIRECTORY"],
            parse: (value, varName) => value
          }
        ];
        for (const strategy of ideStrategies) {
          for (const varName of strategy.vars) {
            const envValue = process.env[varName];
            if (envValue && envValue.trim() !== "") {
              const parsedPath = strategy.parse(envValue.trim(), varName);
              if (parsedPath) {
                const normalizedPath = this.normalizePath(this.expandHome(parsedPath));
                if (normalizedPath && await this.isValidDirectory(normalizedPath)) {
                  this._detectedIDE = strategy.name;
                  return normalizedPath;
                }
              }
            }
          }
        }
        return null;
      }
      /**
       * ä»PromptXç¯å¢ƒå˜é‡è·å–
       */
      async _fromPromptXEnvironment() {
        const promptxWorkspaceEnv = process.env.PROMPTX_WORKSPACE;
        if (promptxWorkspaceEnv && promptxWorkspaceEnv.trim() !== "") {
          const workspacePath = this.normalizePath(this.expandHome(promptxWorkspaceEnv));
          if (workspacePath && await this.isValidDirectory(workspacePath)) {
            return workspacePath;
          }
        }
        return null;
      }
      /**
       * ä»ç°æœ‰.promptxç›®å½•è·å–
       */
      async _fromExistingDirectory(startDir) {
        const projectRoot = await this.projectRootLocator._findByExistingPromptx(startDir || process.cwd());
        return projectRoot;
      }
      /**
       * ä»é¡¹ç›®æ ¹ç›®å½•è·å–
       */
      async _fromProjectRoot(context) {
        const projectRoot = await this.projectRootLocator.locate(context);
        return projectRoot;
      }
      /**
       * æ™ºèƒ½å›é€€ç­–ç•¥
       */
      async _getSmartFallback(context) {
        const argPath = await this._fromProcessArguments();
        if (argPath && await this.isValidDirectory(argPath)) {
          return argPath;
        }
        const processCwd = process.cwd();
        if (await this.isValidDirectory(processCwd)) {
          return processCwd;
        }
        return os.homedir();
      }
      /**
       * ä»è¿›ç¨‹å‚æ•°æ¨æ–­é¡¹ç›®è·¯å¾„
       */
      async _fromProcessArguments() {
        const args = process.argv;
        for (let i = 0; i < args.length; i++) {
          const arg = args[i];
          if (arg.startsWith("--project-path=")) {
            return arg.split("=")[1];
          }
          if (arg === "--project-path" && i + 1 < args.length) {
            return args[i + 1];
          }
          if (arg.startsWith("--cwd=")) {
            return arg.split("=")[1];
          }
          if (arg === "--cwd" && i + 1 < args.length) {
            return args[i + 1];
          }
        }
        return null;
      }
      /**
       * è·å–æ£€æµ‹è°ƒè¯•ä¿¡æ¯
       */
      getDetectionInfo() {
        return {
          detectedIDE: this._detectedIDE || "Unknown",
          availableEnvVars: this._getAvailableEnvVars(),
          platform: process.platform,
          cwd: process.cwd(),
          args: process.argv
        };
      }
      /**
       * è·å–å¯ç”¨çš„ç¯å¢ƒå˜é‡
       */
      _getAvailableEnvVars() {
        const relevantVars = [
          "WORKSPACE_FOLDER_PATHS",
          "VSCODE_WORKSPACE_FOLDER",
          "VSCODE_CWD",
          "PROJECT_ROOT",
          "IDEA_INITIAL_DIRECTORY",
          "WEBSTORM_PROJECT_PATH",
          "SUBLIME_PROJECT_PATH",
          "SUBL_PROJECT_DIR",
          "ATOM_PROJECT_PATH",
          "ATOM_HOME_PROJECT",
          "VIM_PROJECT_ROOT",
          "NVIM_PROJECT_ROOT",
          "PWD",
          "TRAE_WORKSPACE",
          "BYTEDANCE_WORKSPACE",
          "WORKSPACE_ROOT",
          "PROJECT_DIR",
          "WORKING_DIRECTORY",
          "PROMPTX_WORKSPACE"
        ];
        const available = {};
        for (const varName of relevantVars) {
          if (process.env[varName]) {
            available[varName] = process.env[varName];
          }
        }
        return available;
      }
    };
    var DirectoryLocatorFactory = class {
      /**
       * åˆ›å»ºé¡¹ç›®æ ¹ç›®å½•å®šä½å™¨
       */
      static createProjectRootLocator(options = {}) {
        const platform = process.platform;
        if (platform === "win32") {
          return new WindowsProjectRootLocator(options);
        } else {
          return new ProjectRootLocator(options);
        }
      }
      /**
       * åˆ›å»ºPromptXå·¥ä½œç©ºé—´å®šä½å™¨
       */
      static createPromptXWorkspaceLocator(options = {}) {
        const projectRootLocator = this.createProjectRootLocator(options);
        return new PromptXWorkspaceLocator({
          ...options,
          projectRootLocator
        });
      }
      /**
       * è·å–å¹³å°ä¿¡æ¯
       */
      static getPlatform() {
        return process.platform;
      }
    };
    var WindowsProjectRootLocator = class extends ProjectRootLocator {
      constructor(options = {}) {
        super({
          ...options,
          // Windowsé»˜è®¤é¿å…ç”¨æˆ·å®¶ç›®å½•
          avoidUserHome: options.avoidUserHome !== false
        });
      }
      /**
       * Windowsç‰¹æœ‰çš„é¡¹ç›®æ ¹ç›®å½•éªŒè¯
       */
      async _validateProjectRoot(projectRoot, context = {}) {
        const baseValid = await super._validateProjectRoot(projectRoot, context);
        if (!baseValid) {
          return false;
        }
        const systemPaths = [
          "C:\\Windows",
          "C:\\Program Files",
          "C:\\Program Files (x86)",
          "C:\\System Volume Information"
        ];
        const resolvedPath = path.resolve(projectRoot).toUpperCase();
        for (const systemPath of systemPaths) {
          if (resolvedPath.startsWith(systemPath.toUpperCase())) {
            return false;
          }
        }
        return true;
      }
    };
    module2.exports = {
      DirectoryLocator,
      ProjectRootLocator,
      PromptXWorkspaceLocator,
      DirectoryLocatorFactory,
      WindowsProjectRootLocator
    };
  }
});

// src/utils/DirectoryService.js
var require_DirectoryService = __commonJS({
  "src/utils/DirectoryService.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var { DirectoryLocatorFactory } = require_DirectoryLocator();
    var logger = require("@promptx/logger");
    var DirectoryService = class {
      constructor() {
        this.workspaceLocator = null;
        this.initialized = false;
      }
      /**
       * åˆå§‹åŒ–æœåŠ¡
       */
      async initialize(options = {}) {
        if (this.initialized) {
          return;
        }
        try {
          this.workspaceLocator = DirectoryLocatorFactory.createPromptXWorkspaceLocator(options);
          this.initialized = true;
          logger.debug("[DirectoryService] \u521D\u59CB\u5316\u5B8C\u6210");
        } catch (error) {
          logger.error("[DirectoryService] \u521D\u59CB\u5316\u5931\u8D25:", error);
          throw error;
        }
      }
      /**
       * è·å–IDEç¯å¢ƒæ£€æµ‹è°ƒè¯•ä¿¡æ¯
       */
      async getDebugInfo(context = {}) {
        var _a;
        await this._ensureInitialized();
        const ideDetectionInfo = ((_a = this.workspaceLocator) == null ? void 0 : _a.getDetectionInfo()) || {};
        return {
          platform: process.platform,
          ideDetection: {
            detectedIDE: ideDetectionInfo.detectedIDE,
            availableEnvVars: ideDetectionInfo.availableEnvVars,
            cwd: process.cwd(),
            args: process.argv.slice(2)
          },
          environment: {
            // ä¸»è¦IDEç¯å¢ƒå˜é‡
            WORKSPACE_FOLDER_PATHS: process.env.WORKSPACE_FOLDER_PATHS,
            VSCODE_WORKSPACE_FOLDER: process.env.VSCODE_WORKSPACE_FOLDER,
            PROJECT_ROOT: process.env.PROJECT_ROOT,
            SUBLIME_PROJECT_PATH: process.env.SUBLIME_PROJECT_PATH,
            // PromptXä¸“ç”¨
            PROMPTX_WORKSPACE: process.env.PROMPTX_WORKSPACE,
            // ç³»ç»Ÿç¯å¢ƒ
            PWD: process.env.PWD,
            NODE_ENV: process.env.NODE_ENV
          },
          recommendations: this._getPathRecommendations(ideDetectionInfo)
        };
      }
      /**
       * è·å–è·¯å¾„é…ç½®å»ºè®®
       */
      _getPathRecommendations(ideDetectionInfo = {}) {
        const recommendations = [];
        if (!ideDetectionInfo.detectedIDE || ideDetectionInfo.detectedIDE === "Unknown") {
          recommendations.push({
            type: "env_var",
            message: "\u672A\u68C0\u6D4B\u5230IDE\u73AF\u5883\u53D8\u91CF\uFF0C\u5EFA\u8BAE\u8BBE\u7F6E\u9879\u76EE\u8DEF\u5F84\u73AF\u5883\u53D8\u91CF",
            suggestions: [
              'export PROMPTX_WORKSPACE="/path/to/your/project"',
              'export PROJECT_ROOT="/path/to/your/project"',
              'export WORKSPACE_ROOT="/path/to/your/project"'
            ]
          });
        }
        if (!ideDetectionInfo.availableEnvVars || Object.keys(ideDetectionInfo.availableEnvVars).length === 0) {
          recommendations.push({
            type: "manual_config",
            message: "\u5EFA\u8BAE\u5728IDE\u4E2D\u914D\u7F6EMCP\u5DE5\u4F5C\u76EE\u5F55",
            suggestions: [
              "VSCode: \u5728settings.json\u4E2D\u8BBE\u7F6Eworkspace.folders",
              "IntelliJ: \u5728Run Configuration\u4E2D\u8BBE\u7F6EWorking directory",
              "Claude IDE: \u786E\u4FDDworkspace\u8DEF\u5F84\u6B63\u786E\u4F20\u9012"
            ]
          });
        }
        return recommendations;
      }
      /**
       * æ¸…é™¤ç¼“å­˜
       */
      clearCache() {
        if (this.workspaceLocator) {
          this.workspaceLocator.clearCache();
        }
        logger.debug("[DirectoryService] \u7F13\u5B58\u5DF2\u6E05\u9664");
      }
      /**
       * ç¡®ä¿æœåŠ¡å·²åˆå§‹åŒ–
       */
      async _ensureInitialized() {
        if (!this.initialized) {
          await this.initialize();
        }
      }
      /**
       * é‡æ–°åŠ è½½é…ç½®
       */
      async reload(options = {}) {
        this.initialized = false;
        this.clearCache();
        await this.initialize(options);
      }
    };
    var globalDirectoryService = new DirectoryService();
    function getDirectoryService() {
      return globalDirectoryService;
    }
    module2.exports = {
      DirectoryService,
      getDirectoryService
    };
  }
});

// src/constants.js
var require_constants = __commonJS({
  "src/constants.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var PACKAGE_NAMES = {
      CURRENT: "@promptx/cli",
      // å½“å‰ä½¿ç”¨çš„åŒ…å
      LEGACY: "dpml-prompt",
      // æ—§ç‰ˆåŒ…åï¼ˆå‘åå…¼å®¹ï¼‰
      ALL: ["@promptx/cli", "dpml-prompt"]
      // æ‰€æœ‰æ”¯æŒçš„åŒ…å
    };
    function getCommandPrefix() {
      const env = process.env.PROMPTX_ENV;
      if (env === "development") {
        return "pnpm start";
      } else {
        return `npx ${PACKAGE_NAMES.CURRENT}@snapshot`;
      }
    }
    var COMMAND_PREFIX = getCommandPrefix();
    var COMMANDS = {
      INIT: `${COMMAND_PREFIX} init`,
      WELCOME: `${COMMAND_PREFIX} welcome`,
      ACTION: `${COMMAND_PREFIX} action`,
      LEARN: `${COMMAND_PREFIX} learn`,
      RECALL: `${COMMAND_PREFIX} recall`,
      REMEMBER: `${COMMAND_PREFIX} remember`,
      HELP: `${COMMAND_PREFIX} help`
    };
    var buildCommand = {
      action: (roleId) => `${COMMAND_PREFIX} action ${roleId}`,
      learn: (resource) => `${COMMAND_PREFIX} learn ${resource}`,
      recall: (query = "") => `${COMMAND_PREFIX} recall${query ? " " + query : ""}`,
      remember: (content = "<content>") => `${COMMAND_PREFIX} remember${content !== "<content>" ? ' "' + content + '"' : " <content>"}`
    };
    function getCommands() {
      return COMMANDS;
    }
    function getBuildCommand() {
      return buildCommand;
    }
    function detectCommandPrefix() {
      return COMMAND_PREFIX;
    }
    var PATHS = {
      POUCH_DIR: ".promptx",
      MEMORY_DIR: ".promptx/memory",
      STATE_FILE: ".promptx/pouch.json",
      MEMORY_FILE: ".promptx/memory/declarative.md"
    };
    var VERSION = "0.0.1";
    var STATES = {
      INITIALIZED: "initialized",
      ROLE_DISCOVERY: "role_discovery",
      ACTION_PLAN_GENERATED: "action_plan_generated",
      LEARNED_ROLE: "learned_role",
      MEMORY_SAVED: "memory_saved",
      RECALL_WAITING: "recall-waiting"
    };
    module2.exports = {
      // å›ºå®šå‘½ä»¤å‰ç¼€
      COMMAND_PREFIX,
      // å‘½ä»¤å¸¸é‡
      COMMANDS,
      buildCommand,
      // å‘åå…¼å®¹çš„å‡½æ•°å¼API
      getCommands,
      getBuildCommand,
      detectCommandPrefix,
      // å…¶ä»–é™æ€å¸¸é‡
      PATHS,
      PACKAGE_NAMES,
      VERSION,
      STATES
    };
  }
});

// src/resource/ProtocolResolver.js
var require_ProtocolResolver = __commonJS({
  "src/resource/ProtocolResolver.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var path = require("path");
    var fs = require("fs");
    var { getDirectoryService } = require_DirectoryService();
    var { PACKAGE_NAMES } = require_constants();
    var ProtocolResolver = class {
      constructor() {
        this.packageRoot = null;
        this.__dirname = __dirname;
        this.directoryService = getDirectoryService();
      }
      parseReference(reference) {
        const match = reference.match(/^@([!?]?)(\w+):\/\/(.+)$/);
        if (!match) {
          throw new Error(`Invalid reference format: ${reference}`);
        }
        const loadingSemantic = match[1] || "";
        const protocol = match[2];
        const resourcePath = match[3];
        return {
          loadingSemantic,
          protocol,
          resourcePath,
          fullReference: reference
        };
      }
      async resolve(reference) {
        const { protocol, resourcePath, loadingSemantic } = this.parseReference(reference);
        switch (protocol) {
          case "package":
            return await this.resolvePackage(resourcePath);
          case "project":
            return await this.resolveProject(resourcePath);
          case "file":
            return await this.resolveFile(resourcePath);
          default:
            throw new Error(`Unsupported protocol: ${protocol}`);
        }
      }
      async resolvePackage(relativePath) {
        if (!this.packageRoot) {
          this.packageRoot = await this.findPackageRoot();
        }
        return path.resolve(this.packageRoot, relativePath);
      }
      async resolveProject(relativePath) {
        try {
          const context = {
            startDir: process.cwd(),
            platform: process.platform,
            avoidUserHome: true
          };
          const projectRoot = await this.directoryService.getProjectRoot(context);
          return path.resolve(projectRoot, relativePath);
        } catch (error) {
          return path.resolve(process.cwd(), relativePath);
        }
      }
      async resolveFile(filePath) {
        if (path.isAbsolute(filePath)) {
          return filePath;
        }
        try {
          const context = {
            startDir: process.cwd(),
            platform: process.platform,
            avoidUserHome: true
          };
          const projectRoot = await this.directoryService.getProjectRoot(context);
          return path.resolve(projectRoot, filePath);
        } catch (error) {
          return path.resolve(process.cwd(), filePath);
        }
      }
      async findPackageRoot() {
        let dir = this.__dirname;
        while (dir !== path.parse(dir).root) {
          const packageJson = path.join(dir, "package.json");
          if (fs.existsSync(packageJson)) {
            const pkg = JSON.parse(fs.readFileSync(packageJson, "utf8"));
            if (pkg.name === "promptx" || PACKAGE_NAMES.ALL.includes(pkg.name)) {
              return dir;
            }
          }
          dir = path.dirname(dir);
        }
        throw new Error("PromptX package root not found");
      }
    };
    module2.exports = ProtocolResolver;
  }
});

// src/resource/ResourceData.js
var require_ResourceData = __commonJS({
  "src/resource/ResourceData.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var ResourceData = class _ResourceData {
      /**
       * @param {Object} options - èµ„æºé…ç½®é€‰é¡¹
       * @param {string} options.id - èµ„æºå”¯ä¸€æ ‡è¯†
       * @param {string} options.source - èµ„æºæ¥æº ('package' | 'project' | 'user')
       * @param {string} options.protocol - èµ„æºåè®®/ç±»å‹ ('role' | 'thought' | 'execution' | 'knowledge')
       * @param {string} options.name - èµ„æºåç§°
       * @param {string} options.description - èµ„æºæè¿°
       * @param {string} options.reference - èµ„æºå¼•ç”¨è·¯å¾„
       * @param {Object} options.metadata - é¢å¤–å…ƒæ•°æ®
       */
      constructor({
        id,
        source,
        protocol,
        name,
        description,
        reference,
        metadata = {}
      }) {
        this.id = id;
        this.source = source;
        this.protocol = protocol;
        this.name = name;
        this.description = description;
        this.reference = reference;
        this.metadata = {
          createdAt: (/* @__PURE__ */ new Date()).toISOString(),
          updatedAt: (/* @__PURE__ */ new Date()).toISOString(),
          ...metadata
        };
      }
      /**
       * ä»åŸå§‹æ•°æ®åˆ›å»ºResourceDataå®ä¾‹
       * @param {Object} rawData - åŸå§‹æ•°æ®
       * @returns {ResourceData} ResourceDataå®ä¾‹
       */
      static fromRawData(rawData) {
        return new _ResourceData(rawData);
      }
      /**
       * ä»æ–‡ä»¶è·¯å¾„å’Œåè®®æ¨æ–­åˆ›å»ºResourceData
       * @param {string} filePath - æ–‡ä»¶è·¯å¾„ï¼ˆä»…ç”¨äºæå–IDï¼Œä¸ä¿å­˜ï¼‰
       * @param {string} source - èµ„æºæ¥æº
       * @param {string} protocol - èµ„æºåè®®
       * @param {string} reference - èµ„æºå¼•ç”¨
       * @returns {ResourceData} ResourceDataå®ä¾‹
       */
      static fromFilePath(filePath, source, protocol, reference) {
        const path = require("path");
        const fileName = path.basename(filePath, `.${protocol}.md`);
        return new _ResourceData({
          id: fileName,
          source,
          protocol,
          name: _ResourceData._generateDefaultName(fileName, protocol),
          description: _ResourceData._generateDefaultDescription(fileName, protocol),
          reference,
          metadata: {
            inferredFromFile: true
          }
        });
      }
      /**
       * ç”Ÿæˆé»˜è®¤åç§°
       * @param {string} id - èµ„æºID
       * @param {string} protocol - èµ„æºåè®®
       * @returns {string} é»˜è®¤åç§°
       * @private
       */
      static _generateDefaultName(id, protocol) {
        const nameMap = {
          "role": "\u89D2\u8272",
          "thought": "\u601D\u7EF4\u6A21\u5F0F",
          "execution": "\u6267\u884C\u6A21\u5F0F",
          "knowledge": "\u77E5\u8BC6\u5E93"
        };
        const readableName = id.split("-").map((word) => word.charAt(0).toUpperCase() + word.slice(1)).join(" ");
        return `${readableName} ${nameMap[protocol] || protocol}`;
      }
      /**
       * ç”Ÿæˆé»˜è®¤æè¿°
       * @param {string} id - èµ„æºID
       * @param {string} protocol - èµ„æºåè®®
       * @returns {string} é»˜è®¤æè¿°
       * @private
       */
      static _generateDefaultDescription(id, protocol) {
        const descMap = {
          "role": "\u4E13\u4E1A\u89D2\u8272\uFF0C\u63D0\u4F9B\u7279\u5B9A\u9886\u57DF\u7684\u4E13\u4E1A\u80FD\u529B",
          "thought": "\u601D\u7EF4\u6A21\u5F0F\uFF0C\u6307\u5BFCAI\u7684\u601D\u8003\u65B9\u5F0F",
          "execution": "\u6267\u884C\u6A21\u5F0F\uFF0C\u5B9A\u4E49\u5177\u4F53\u7684\u884C\u4E3A\u6A21\u5F0F",
          "knowledge": "\u77E5\u8BC6\u5E93\uFF0C\u63D0\u4F9B\u4E13\u4E1A\u77E5\u8BC6\u548C\u4FE1\u606F"
        };
        return descMap[protocol] || `${protocol}\u7C7B\u578B\u7684\u8D44\u6E90`;
      }
      /**
       * è·å–å®Œæ•´çš„èµ„æºIDï¼ˆåŒ…å«æ¥æºå‰ç¼€ï¼‰
       * @returns {string} å®Œæ•´èµ„æºID
       */
      getFullId() {
        const baseId = this.protocol === "role" ? this.id : `${this.protocol}:${this.id}`;
        return `${this.source}:${baseId}`;
      }
      /**
       * è·å–åŸºç¡€èµ„æºIDï¼ˆä¸åŒ…å«æ¥æºå‰ç¼€ï¼‰
       * @returns {string} åŸºç¡€èµ„æºID
       */
      getBaseId() {
        return this.protocol === "role" ? this.id : `${this.protocol}:${this.id}`;
      }
      /**
       * æ£€æŸ¥æ˜¯å¦åŒ¹é…æŒ‡å®šçš„è¿‡æ»¤æ¡ä»¶
       * @param {Object} filters - è¿‡æ»¤æ¡ä»¶
       * @returns {boolean} æ˜¯å¦åŒ¹é…
       */
      matches(filters = {}) {
        for (const [key, value] of Object.entries(filters)) {
          if (value !== void 0 && value !== null) {
            if (Array.isArray(value)) {
              if (!value.includes(this[key])) return false;
            } else {
              if (this[key] !== value) return false;
            }
          }
        }
        return true;
      }
      /**
       * æ›´æ–°èµ„æºå…ƒæ•°æ®
       * @param {Object} updates - æ›´æ–°æ•°æ®
       */
      update(updates) {
        Object.assign(this, updates);
        this.metadata.updatedAt = (/* @__PURE__ */ new Date()).toISOString();
      }
      /**
       * è½¬æ¢ä¸ºJSONå¯¹è±¡
       * @returns {Object} JSONå¯¹è±¡
       */
      toJSON() {
        return {
          id: this.id,
          source: this.source,
          protocol: this.protocol,
          name: this.name,
          description: this.description,
          reference: this.reference,
          metadata: this.metadata
        };
      }
      /**
       * è½¬æ¢ä¸ºç®€åŒ–çš„æ˜¾ç¤ºæ ¼å¼
       * @returns {Object} ç®€åŒ–æ ¼å¼
       */
      toDisplayFormat() {
        return {
          id: this.id,
          fullId: this.getFullId(),
          baseId: this.getBaseId(),
          name: this.name,
          description: this.description,
          source: this.source,
          protocol: this.protocol
        };
      }
      /**
       * åŠ¨æ€è·å–æ–‡ä»¶è·¯å¾„
       * é€šè¿‡è§£æ reference åŠ¨æ€è®¡ç®—å®é™…çš„æ–‡ä»¶è·¯å¾„
       * @returns {Promise<string>} æ–‡ä»¶è·¯å¾„
       */
      async getFilePath() {
        const ProtocolResolver = require_ProtocolResolver();
        const resolver = new ProtocolResolver();
        try {
          const resolvedPath = await resolver.resolve(this.reference);
          return resolvedPath;
        } catch (error) {
          throw new Error(`\u65E0\u6CD5\u89E3\u6790\u8D44\u6E90\u8DEF\u5F84 ${this.reference}: ${error.message}`);
        }
      }
      /**
       * å…‹éš†èµ„æºæ•°æ®
       * @returns {ResourceData} å…‹éš†çš„å®ä¾‹
       */
      clone() {
        return new _ResourceData(this.toJSON());
      }
    };
    module2.exports = ResourceData;
  }
});

// src/resource/RegistryData.js
var require_RegistryData = __commonJS({
  "src/resource/RegistryData.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var fs = require("fs-extra");
    var path = require("path");
    var ResourceData = require_ResourceData();
    var RegistryData = class _RegistryData {
      /**
       * @param {string} source - æ³¨å†Œè¡¨æ¥æº ('package' | 'project' | 'user')
       * @param {string} filePath - æ³¨å†Œè¡¨æ–‡ä»¶è·¯å¾„
       * @param {Array<ResourceData>} resources - èµ„æºæ•°æ®æ•°ç»„
       * @param {Object} metadata - æ³¨å†Œè¡¨å…ƒæ•°æ®
       */
      constructor(source, filePath, resources = [], metadata = {}) {
        this.source = source;
        this.filePath = filePath;
        this.resources = resources.map((r) => r instanceof ResourceData ? r : ResourceData.fromRawData(r));
        this.metadata = {
          version: "2.0.0",
          description: `${source} \u7EA7\u8D44\u6E90\u6CE8\u518C\u8868`,
          createdAt: (/* @__PURE__ */ new Date()).toISOString(),
          updatedAt: (/* @__PURE__ */ new Date()).toISOString(),
          ...metadata
        };
        this.cache = /* @__PURE__ */ new Map();
      }
      /**
       * ä»æ–‡ä»¶åŠ è½½æ³¨å†Œè¡¨æ•°æ®
       * @param {string} source - æ³¨å†Œè¡¨æ¥æº
       * @param {string} filePath - æ–‡ä»¶è·¯å¾„
       * @returns {Promise<RegistryData>} æ³¨å†Œè¡¨æ•°æ®å®ä¾‹
       */
      static async fromFile(source, filePath) {
        try {
          const data = await fs.readJSON(filePath);
          if (data.version === "2.0.0" && Array.isArray(data.resources)) {
            return new _RegistryData(source, filePath, data.resources, data.metadata);
          }
          if (data.resources && typeof data.resources === "object") {
            const resources = [];
            for (const [protocol, resourcesOfType] of Object.entries(data.resources)) {
              if (resourcesOfType && typeof resourcesOfType === "object") {
                for (const [id, reference] of Object.entries(resourcesOfType)) {
                  resources.push(ResourceData.fromFilePath(
                    reference.replace(/^@\w+:\/\//, ""),
                    source,
                    protocol,
                    reference
                  ));
                }
              }
            }
            return new _RegistryData(source, filePath, resources, {
              migratedFrom: "v1.0.0",
              originalTimestamp: data.timestamp
            });
          }
          throw new Error(`Unsupported registry format in ${filePath}`);
        } catch (error) {
          throw new Error(`Failed to load ${source} registry from ${filePath}: ${error.message}`);
        }
      }
      /**
       * åˆ›å»ºç©ºçš„æ³¨å†Œè¡¨æ•°æ®
       * @param {string} source - æ³¨å†Œè¡¨æ¥æº
       * @param {string} filePath - æ³¨å†Œè¡¨æ–‡ä»¶è·¯å¾„
       * @returns {RegistryData} ç©ºæ³¨å†Œè¡¨æ•°æ®å®ä¾‹
       */
      static createEmpty(source, filePath) {
        return new _RegistryData(source, filePath, [], {
          description: `${source} \u7EA7\u8D44\u6E90\u6CE8\u518C\u8868`,
          createdAt: (/* @__PURE__ */ new Date()).toISOString()
        });
      }
      /**
       * æ·»åŠ èµ„æº
       * @param {ResourceData|Object} resource - èµ„æºæ•°æ®
       */
      addResource(resource) {
        const resourceData = resource instanceof ResourceData ? resource : ResourceData.fromRawData(resource);
        if (this.source !== "merged" && resourceData.source !== this.source) {
          resourceData.source = this.source;
        }
        const existingIndex = this.resources.findIndex((r) => r.id === resourceData.id && r.protocol === resourceData.protocol);
        if (existingIndex >= 0) {
          this.resources[existingIndex] = resourceData;
        } else {
          this.resources.push(resourceData);
        }
        this._updateMetadata();
        this.cache.clear();
      }
      /**
       * ç§»é™¤èµ„æº
       * @param {string} id - èµ„æºID
       * @param {string} protocol - èµ„æºåè®®
       * @returns {boolean} æ˜¯å¦æˆåŠŸç§»é™¤
       */
      removeResource(id, protocol) {
        const initialLength = this.resources.length;
        this.resources = this.resources.filter((r) => !(r.id === id && r.protocol === protocol));
        const removed = this.resources.length < initialLength;
        if (removed) {
          this._updateMetadata();
          this.cache.clear();
        }
        return removed;
      }
      /**
       * æŸ¥æ‰¾èµ„æº
       * @param {Object} filters - è¿‡æ»¤æ¡ä»¶
       * @returns {Array<ResourceData>} åŒ¹é…çš„èµ„æºæ•°ç»„
       */
      findResources(filters = {}) {
        return this.resources.filter((resource) => resource.matches(filters));
      }
      /**
       * æ ¹æ®IDæŸ¥æ‰¾èµ„æº
       * @param {string} id - èµ„æºID
       * @param {string} protocol - èµ„æºåè®®ï¼ˆå¯é€‰ï¼‰
       * @returns {ResourceData|null} æ‰¾åˆ°çš„èµ„æº
       */
      findResourceById(id, protocol = null) {
        return this.resources.find((r) => {
          if (protocol) {
            return r.id === id && r.protocol === protocol;
          }
          return r.id === id;
        }) || null;
      }
      /**
       * è·å–æŒ‡å®šåè®®ç±»å‹çš„æ‰€æœ‰èµ„æº
       * @param {string} protocol - èµ„æºåè®®
       * @returns {Array<ResourceData>} èµ„æºæ•°ç»„
       */
      getResourcesByProtocol(protocol) {
        return this.resources.filter((r) => r.protocol === protocol);
      }
      /**
       * è·å–èµ„æºMapï¼ˆå…¼å®¹æ—§æ¥å£ï¼‰
       * @param {boolean} includeSourcePrefix - æ˜¯å¦åŒ…å«æºå‰ç¼€
       * @returns {Map<string, string>} èµ„æºIDåˆ°å¼•ç”¨çš„æ˜ å°„
       */
      getResourceMap(includeSourcePrefix = true) {
        const cacheKey = `resourceMap_${includeSourcePrefix}`;
        if (this.cache.has(cacheKey)) {
          return this.cache.get(cacheKey);
        }
        const registry = /* @__PURE__ */ new Map();
        for (const resource of this.resources) {
          if (includeSourcePrefix) {
            registry.set(resource.getFullId(), resource.reference);
            registry.set(resource.getBaseId(), resource.reference);
          } else {
            registry.set(resource.getBaseId(), resource.reference);
          }
        }
        this.cache.set(cacheKey, registry);
        return registry;
      }
      /**
       * è·å–æ‰€æœ‰èµ„æºæ•°æ®
       * @returns {Array<ResourceData>} æ‰€æœ‰èµ„æºæ•°ç»„
       */
      getAllResources() {
        return [...this.resources];
      }
      /**
       * è·å–ç»Ÿè®¡ä¿¡æ¯
       * @returns {Object} ç»Ÿè®¡ä¿¡æ¯
       */
      getStats() {
        const stats = {
          totalResources: this.resources.length,
          byProtocol: {},
          bySource: {}
        };
        for (const resource of this.resources) {
          stats.byProtocol[resource.protocol] = (stats.byProtocol[resource.protocol] || 0) + 1;
          stats.bySource[resource.source] = (stats.bySource[resource.source] || 0) + 1;
        }
        return stats;
      }
      /**
       * åˆå¹¶å…¶ä»–æ³¨å†Œè¡¨æ•°æ®
       * @param {RegistryData} otherRegistry - å…¶ä»–æ³¨å†Œè¡¨æ•°æ®
       * @param {boolean} overwrite - æ˜¯å¦è¦†ç›–ç°æœ‰èµ„æº
       */
      merge(otherRegistry, overwrite = false) {
        for (const resource of otherRegistry.resources) {
          const existing = this.findResourceById(resource.id, resource.protocol);
          if (!existing || overwrite) {
            this.addResource(resource.clone());
          }
        }
      }
      /**
       * ä¿å­˜æ³¨å†Œè¡¨åˆ°æ–‡ä»¶
       * @returns {Promise<void>}
       */
      async save() {
        try {
          await fs.ensureDir(path.dirname(this.filePath));
          this._updateMetadata();
          const saveData = {
            version: this.metadata.version,
            source: this.source,
            metadata: this.metadata,
            resources: this.resources.map((r) => r.toJSON()),
            stats: this.getStats()
          };
          await fs.writeJSON(this.filePath, saveData, { spaces: 2 });
        } catch (error) {
          throw new Error(`Failed to save ${this.source} registry to ${this.filePath}: ${error.message}`);
        }
      }
      /**
       * æ›´æ–°å…ƒæ•°æ®
       * @private
       */
      _updateMetadata() {
        this.metadata.updatedAt = (/* @__PURE__ */ new Date()).toISOString();
        this.metadata.resourceCount = this.resources.length;
      }
      /**
       * è·å–æ³¨å†Œè¡¨å¤§å°
       * @returns {number} èµ„æºæ•°é‡
       */
      get size() {
        return this.resources.length;
      }
      /**
       * æ£€æŸ¥æ³¨å†Œè¡¨æ˜¯å¦ä¸ºç©º
       * @returns {boolean} æ˜¯å¦ä¸ºç©º
       */
      isEmpty() {
        return this.resources.length === 0;
      }
      /**
       * æ¸…ç©ºæ‰€æœ‰èµ„æº
       */
      clear() {
        this.resources = [];
        this._updateMetadata();
        this.cache.clear();
      }
      /**
       * å…‹éš†æ³¨å†Œè¡¨æ•°æ®
       * @returns {RegistryData} å…‹éš†çš„æ³¨å†Œè¡¨æ•°æ®
       */
      clone() {
        const clonedResources = this.resources.map((r) => r.clone());
        return new _RegistryData(this.source, this.filePath, clonedResources, { ...this.metadata });
      }
      /**
       * è½¬æ¢ä¸ºJSONå¯¹è±¡
       * @returns {Object} JSONå¯¹è±¡
       */
      toJSON() {
        return {
          version: this.metadata.version,
          source: this.source,
          metadata: this.metadata,
          resources: this.resources.map((r) => r.toJSON()),
          stats: this.getStats()
        };
      }
    };
    module2.exports = RegistryData;
  }
});

// src/resource/types.js
var require_types = __commonJS({
  "src/resource/types.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var LoadingSemantics = {
      DEFAULT: "default",
      // @ - AIè‡ªè¡Œå†³å®šåŠ è½½æ—¶æœº
      HOT_LOAD: "hot_load",
      // @! - ç«‹å³åŠ è½½
      LAZY_LOAD: "lazy_load"
      // @? - æ‡’åŠ è½½
    };
    var ParsedReference = class {
      constructor() {
        this.loadingSemantics = LoadingSemantics.DEFAULT;
        this.protocol = "";
        this.path = "";
        this.queryParams = new QueryParams();
        this.isNested = false;
        this.nestedRef = null;
        this.originalRef = "";
      }
    };
    var QueryParams = class {
      constructor() {
        this.line = null;
        this.format = null;
        this.cache = null;
        this.params = /* @__PURE__ */ new Map();
      }
      /**
       * è®¾ç½®å‚æ•°
       */
      set(key, value) {
        if (["line", "format", "cache"].includes(key)) {
          this[key] = value;
        } else {
          this.params.set(key, value);
        }
      }
      /**
       * è·å–å‚æ•°
       */
      get(key) {
        if (["line", "format", "cache"].includes(key)) {
          return this[key];
        }
        return this.params.get(key);
      }
      /**
       * è·å–æ‰€æœ‰å‚æ•°
       */
      getAll() {
        const result = {};
        if (this.line !== null) {
          result.line = this.line;
        }
        if (this.format !== null) {
          result.format = this.format;
        }
        if (this.cache !== null) {
          result.cache = this.cache;
        }
        for (const [key, value] of this.params) {
          result[key] = value;
        }
        return result;
      }
      /**
       * è½¬æ¢ä¸ºå­—ç¬¦ä¸²ç”¨äºç¼“å­˜é”®
       */
      toString() {
        const params = [];
        if (this.line !== null) {
          params.push(`line=${this.line}`);
        }
        if (this.format !== null) {
          params.push(`format=${this.format}`);
        }
        if (this.cache !== null) {
          params.push(`cache=${this.cache}`);
        }
        const sortedParams = Array.from(this.params.entries()).sort();
        for (const [key, value] of sortedParams) {
          params.push(`${key}=${value}`);
        }
        return params.join("&");
      }
    };
    var NestedReference = class {
      constructor() {
        this.outer = null;
        this.inner = null;
        this.depth = 0;
      }
    };
    var ResourceContent = class {
      constructor(path, content, metadata = {}) {
        this.path = path;
        this.content = content;
        this.metadata = metadata;
        this.relativePath = "";
        this.lastModified = null;
        this.size = content ? content.length : 0;
      }
    };
    var LazyResource = class {
      constructor(path, loader) {
        this.path = path;
        this.loader = loader;
        this.loaded = false;
        this._content = null;
      }
      /**
       * åŠ è½½èµ„æº
       */
      async load() {
        if (!this.loaded) {
          this._content = await this.loader(this.path);
          this.loaded = true;
        }
        return this._content;
      }
    };
    var ProcessedResult = class {
      constructor() {
        this.content = "";
        this.metadata = {};
        this.format = "text";
        this.sources = [];
        this.cached = false;
      }
    };
    var ResourceResult = class _ResourceResult {
      constructor() {
        this.content = "";
        this.metadata = {};
        this.sources = [];
        this.format = "text";
        this.cached = false;
        this.loadTime = Date.now();
        this.success = true;
        this.error = null;
      }
      /**
       * åˆ›å»ºæˆåŠŸç»“æœ
       */
      static success(content, metadata = {}) {
        const result = new _ResourceResult();
        result.content = content;
        result.metadata = metadata;
        result.success = true;
        return result;
      }
      /**
       * åˆ›å»ºé”™è¯¯ç»“æœ
       */
      static error(error, metadata = {}) {
        const result = new _ResourceResult();
        result.success = false;
        result.error = error;
        result.metadata = metadata;
        return result;
      }
    };
    var ProtocolInfo = class {
      constructor() {
        this.name = "";
        this.description = "";
        this.location = "";
        this.params = {};
        this.registry = /* @__PURE__ */ new Map();
      }
    };
    module2.exports = {
      LoadingSemantics,
      ParsedReference,
      QueryParams,
      NestedReference,
      ResourceContent,
      LazyResource,
      ProcessedResult,
      ResourceResult,
      ProtocolInfo
    };
  }
});

// src/resource/resourceProtocolParser.js
var require_resourceProtocolParser = __commonJS({
  "src/resource/resourceProtocolParser.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var {
      LoadingSemantics,
      ParsedReference,
      QueryParams,
      NestedReference
    } = require_types();
    var ResourceProtocolParser = class {
      constructor() {
        this.resourceRefRegex = /^(@[!?]?|@)([a-zA-Z][a-zA-Z0-9_-]*):(.+)$/;
        this.nestedRefRegex = /^(@[!?]?|@)([a-zA-Z][a-zA-Z0-9_-]*):(@[!?]?|@)?(.+)$/;
        this.queryParamsRegex = /^([^?]+)(?:\?(.+))?$/;
      }
      /**
       * è§£æèµ„æºå¼•ç”¨
       * @param {string} resourceRef - èµ„æºå¼•ç”¨å­—ç¬¦ä¸²
       * @returns {ParsedReference} è§£æåçš„å¼•ç”¨å¯¹è±¡
       */
      parse(resourceRef) {
        if (!resourceRef || typeof resourceRef !== "string") {
          throw new Error("Invalid resource reference: must be a non-empty string");
        }
        const trimmedRef = resourceRef.trim();
        if (!this.validateSyntax(trimmedRef)) {
          throw new Error(`Invalid resource reference syntax: ${trimmedRef}`);
        }
        const parsed = new ParsedReference();
        parsed.originalRef = trimmedRef;
        if (this.isNestedReference(trimmedRef)) {
          return this.parseNestedReference(trimmedRef);
        }
        return this.parseBasicReference(trimmedRef);
      }
      /**
       * è§£æåŸºç¡€èµ„æºå¼•ç”¨
       * @param {string} ref - åŸºç¡€å¼•ç”¨
       * @returns {ParsedReference}
       */
      parseBasicReference(ref) {
        const parsed = new ParsedReference();
        parsed.originalRef = ref;
        parsed.loadingSemantics = this.parseLoadingSemantics(ref);
        const withoutSemantics = this.removeLoadingSemantics(ref);
        const match = withoutSemantics.match(/^([a-zA-Z][a-zA-Z0-9_-]*):(.+)$/);
        if (!match) {
          throw new Error(`Invalid protocol format: ${ref}`);
        }
        parsed.protocol = match[1];
        let pathAndParams = match[2];
        if (pathAndParams.startsWith("//")) {
          pathAndParams = pathAndParams.substring(2);
        }
        const pathMatch = pathAndParams.match(this.queryParamsRegex);
        if (pathMatch) {
          parsed.path = pathMatch[1];
          if (pathMatch[2]) {
            parsed.queryParams = this.parseQueryParams(pathMatch[2]);
          }
        } else {
          parsed.path = pathAndParams;
        }
        return parsed;
      }
      /**
       * è§£æåµŒå¥—å¼•ç”¨
       * @param {string} ref - åµŒå¥—å¼•ç”¨
       * @returns {ParsedReference}
       */
      parseNestedReference(ref) {
        const parsed = new ParsedReference();
        parsed.originalRef = ref;
        parsed.isNested = true;
        parsed.loadingSemantics = this.parseLoadingSemantics(ref);
        const withoutOuterSemantics = this.removeLoadingSemantics(ref);
        const match = withoutOuterSemantics.match(/^([a-zA-Z][a-zA-Z0-9_-]*):(.+)$/);
        if (!match) {
          throw new Error(`Invalid nested reference format: ${ref}`);
        }
        parsed.protocol = match[1];
        let innerRef = match[2];
        if (innerRef.startsWith("//")) {
          innerRef = innerRef.substring(2);
        }
        if (!innerRef.startsWith("@")) {
          innerRef = "@" + innerRef;
        }
        try {
          const innerParsed = this.parse(innerRef);
          const nested = new NestedReference();
          nested.outer = parsed;
          nested.inner = innerParsed;
          nested.depth = this.calculateNestingDepth(innerParsed);
          parsed.nestedRef = nested;
        } catch (error) {
          throw new Error(`Invalid nested inner reference: ${error.message}`);
        }
        return parsed;
      }
      /**
       * è§£æåŠ è½½è¯­ä¹‰
       * @param {string} ref - èµ„æºå¼•ç”¨
       * @returns {string} åŠ è½½è¯­ä¹‰
       */
      parseLoadingSemantics(ref) {
        if (ref.startsWith("@!")) {
          return LoadingSemantics.HOT_LOAD;
        } else if (ref.startsWith("@?")) {
          return LoadingSemantics.LAZY_LOAD;
        } else if (ref.startsWith("@")) {
          return LoadingSemantics.DEFAULT;
        }
        throw new Error(`Invalid loading semantics: ${ref}`);
      }
      /**
       * ç§»é™¤åŠ è½½è¯­ä¹‰å‰ç¼€
       * @param {string} ref - èµ„æºå¼•ç”¨
       * @returns {string} ç§»é™¤å‰ç¼€åçš„å¼•ç”¨
       */
      removeLoadingSemantics(ref) {
        if (ref.startsWith("@!") || ref.startsWith("@?")) {
          return ref.substring(2);
        } else if (ref.startsWith("@")) {
          return ref.substring(1);
        }
        return ref;
      }
      /**
       * è§£ææŸ¥è¯¢å‚æ•°
       * @param {string} queryString - æŸ¥è¯¢å­—ç¬¦ä¸²
       * @returns {QueryParams} æŸ¥è¯¢å‚æ•°å¯¹è±¡
       */
      parseQueryParams(queryString) {
        const params = new QueryParams();
        if (!queryString) {
          return params;
        }
        const pairs = queryString.split("&");
        for (const pair of pairs) {
          const [key, value] = pair.split("=").map(decodeURIComponent);
          if (key) {
            if (key === "cache") {
              params.set(key, value === "true" || value === "1");
            } else {
              params.set(key, value || "");
            }
          }
        }
        return params;
      }
      /**
       * éªŒè¯è¯­æ³•
       * @param {string} ref - èµ„æºå¼•ç”¨
       * @returns {boolean} æ˜¯å¦æœ‰æ•ˆ
       */
      validateSyntax(ref) {
        if (!ref) return false;
        if (!ref.startsWith("@")) return false;
        const withoutSemantics = this.removeLoadingSemantics(ref);
        return /^[a-zA-Z][a-zA-Z0-9_-]*:.+$/.test(withoutSemantics);
      }
      /**
       * æ£€æŸ¥æ˜¯å¦ä¸ºåµŒå¥—å¼•ç”¨
       * @param {string} ref - èµ„æºå¼•ç”¨
       * @returns {boolean} æ˜¯å¦ä¸ºåµŒå¥—å¼•ç”¨
       */
      isNestedReference(ref) {
        const withoutSemantics = this.removeLoadingSemantics(ref);
        const colonIndex = withoutSemantics.indexOf(":");
        if (colonIndex === -1) return false;
        const afterColon = withoutSemantics.substring(colonIndex + 1);
        return afterColon.includes("@") || afterColon.includes("://");
      }
      /**
       * è®¡ç®—åµŒå¥—æ·±åº¦
       * @param {ParsedReference} ref - è§£æåçš„å¼•ç”¨
       * @returns {number} åµŒå¥—æ·±åº¦
       */
      calculateNestingDepth(ref) {
        if (!ref.isNested) return 1;
        return 1 + this.calculateNestingDepth(ref.nestedRef.inner);
      }
      /**
       * æå–åè®®å
       * @param {string} ref - èµ„æºå¼•ç”¨
       * @returns {string} åè®®å
       */
      extractProtocol(ref) {
        const withoutSemantics = this.removeLoadingSemantics(ref);
        const colonIndex = withoutSemantics.indexOf(":");
        return colonIndex > 0 ? withoutSemantics.substring(0, colonIndex) : "";
      }
      /**
       * æå–è·¯å¾„
       * @param {string} ref - èµ„æºå¼•ç”¨
       * @returns {string} è·¯å¾„
       */
      extractPath(ref) {
        const withoutSemantics = this.removeLoadingSemantics(ref);
        const colonIndex = withoutSemantics.indexOf(":");
        if (colonIndex === -1) return "";
        let pathAndParams = withoutSemantics.substring(colonIndex + 1);
        if (pathAndParams.startsWith("//")) {
          pathAndParams = pathAndParams.substring(2);
        }
        const queryIndex = pathAndParams.indexOf("?");
        return queryIndex > 0 ? pathAndParams.substring(0, queryIndex) : pathAndParams;
      }
      /**
       * æå–æŸ¥è¯¢å‚æ•°å­—ç¬¦ä¸²
       * @param {string} ref - èµ„æºå¼•ç”¨
       * @returns {string} æŸ¥è¯¢å‚æ•°å­—ç¬¦ä¸²
       */
      extractParams(ref) {
        const queryIndex = ref.indexOf("?");
        return queryIndex > 0 ? ref.substring(queryIndex + 1) : "";
      }
    };
    module2.exports = ResourceProtocolParser;
  }
});

// src/resource/discovery/BaseDiscovery.js
var require_BaseDiscovery = __commonJS({
  "src/resource/discovery/BaseDiscovery.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var BaseDiscovery = class {
      /**
       * æ„é€ å‡½æ•°
       * @param {string} source - å‘ç°æºç±»å‹ (PACKAGE, PROJECT, USER, INTERNET)
       * @param {number} priority - ä¼˜å…ˆçº§ï¼Œæ•°å­—è¶Šå°ä¼˜å…ˆçº§è¶Šé«˜
       */
      constructor(source, priority = 0) {
        if (!source) {
          throw new Error("Discovery source is required");
        }
        this.source = source;
        this.priority = priority;
        this.cache = /* @__PURE__ */ new Map();
      }
      /**
       * æŠ½è±¡æ–¹æ³•ï¼šå‘ç°èµ„æº
       * å­ç±»å¿…é¡»å®ç°æ­¤æ–¹æ³•
       * @returns {Promise<Array>} å‘ç°çš„èµ„æºåˆ—è¡¨
       */
      async discover() {
        throw new Error("discover method must be implemented by subclass");
      }
      /**
       * è·å–å‘ç°å™¨ä¿¡æ¯
       * @returns {Object} å‘ç°å™¨å…ƒæ•°æ®
       */
      getDiscoveryInfo() {
        return {
          source: this.source,
          priority: this.priority,
          description: `${this.source} resource discovery`
        };
      }
      /**
       * éªŒè¯èµ„æºç»“æ„
       * @param {Object} resource - å¾…éªŒè¯çš„èµ„æºå¯¹è±¡
       * @throws {Error} å¦‚æœèµ„æºç»“æ„æ— æ•ˆ
       */
      validateResource(resource) {
        if (!resource || typeof resource !== "object") {
          throw new Error("Resource must be an object");
        }
        if (!resource.id || !resource.reference) {
          throw new Error("Resource must have id and reference");
        }
        if (typeof resource.id !== "string" || !resource.id.includes(":")) {
          throw new Error('Resource id must be in format "protocol:resourcePath"');
        }
        if (typeof resource.reference !== "string" || !resource.reference.startsWith("@")) {
          throw new Error('Resource reference must be in DPML format "@protocol://path"');
        }
      }
      /**
       * è§„èŒƒåŒ–èµ„æºå¯¹è±¡ï¼Œæ·»åŠ å…ƒæ•°æ®
       * @param {Object} resource - åŸå§‹èµ„æºå¯¹è±¡
       * @returns {Object} è§„èŒƒåŒ–åçš„èµ„æºå¯¹è±¡
       */
      normalizeResource(resource) {
        this.validateResource(resource);
        const normalizedResource = {
          id: resource.id,
          reference: resource.reference,
          metadata: {
            source: this.source,
            priority: this.priority,
            timestamp: /* @__PURE__ */ new Date(),
            ...resource.metadata
            // ä¿ç•™ç°æœ‰å…ƒæ•°æ®
          }
        };
        return normalizedResource;
      }
      /**
       * æ¸…ç†ç¼“å­˜
       */
      clearCache() {
        this.cache.clear();
      }
      /**
       * è·å–ç¼“å­˜å¤§å°
       * @returns {number} ç¼“å­˜æ¡ç›®æ•°é‡
       */
      getCacheSize() {
        return this.cache.size;
      }
      /**
       * ä»ç¼“å­˜è·å–èµ„æº
       * @param {string} key - ç¼“å­˜é”®
       * @returns {*} ç¼“å­˜çš„å€¼æˆ–undefined
       */
      getFromCache(key) {
        return this.cache.get(key);
      }
      /**
       * è®¾ç½®ç¼“å­˜
       * @param {string} key - ç¼“å­˜é”®
       * @param {*} value - ç¼“å­˜å€¼
       */
      setCache(key, value) {
        this.cache.set(key, value);
      }
    };
    module2.exports = BaseDiscovery;
  }
});

// src/resource/discovery/PackageDiscovery.js
var require_PackageDiscovery = __commonJS({
  "src/resource/discovery/PackageDiscovery.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var BaseDiscovery = require_BaseDiscovery();
    var logger = require("@promptx/logger");
    var PackageDiscovery = class extends BaseDiscovery {
      constructor(resourceManager) {
        super("PACKAGE");
        this.resourceManager = resourceManager;
      }
      /**
       * å‘ç°åŒ…çº§èµ„æº - ä» @promptx/resource åŒ…åŠ è½½
       * @returns {Promise<Array>} å‘ç°çš„èµ„æºåˆ—è¡¨
       */
      async discover() {
        var _a, _b, _c;
        try {
          const { registry } = require("@promptx/resource");
          if (!registry) {
            logger.warn("[PackageDiscovery] @promptx/resource \u6CE8\u518C\u8868\u672A\u6B63\u786E\u52A0\u8F7D");
            return [];
          }
          const resources = [];
          if (Array.isArray(registry.resources)) {
            for (const resource of registry.resources) {
              resources.push({
                id: resource.id,
                type: resource.protocol,
                // ä½¿ç”¨ protocol å­—æ®µ
                path: ((_a = resource.metadata) == null ? void 0 : _a.path) || resource.reference,
                name: resource.name || resource.id,
                metadata: {
                  description: resource.description,
                  modified: (_b = resource.metadata) == null ? void 0 : _b.modified,
                  size: (_c = resource.metadata) == null ? void 0 : _c.size,
                  source: "package",
                  // å°å†™ä»¥ä¿æŒä¸€è‡´
                  packageName: "@promptx/resource"
                }
              });
            }
          }
          logger.info(`[PackageDiscovery] \u2705 \u4ECE @promptx/resource \u52A0\u8F7D\u4E86 ${resources.length} \u4E2A\u7CFB\u7EDF\u8D44\u6E90`);
          return resources;
        } catch (error) {
          logger.warn(`[PackageDiscovery] \u26A0\uFE0F \u52A0\u8F7D @promptx/resource \u5931\u8D25: ${error.message}`);
          return [];
        }
      }
      /**
       * å‘ç°åŒ…çº§èµ„æºæ³¨å†Œè¡¨
       * @returns {Promise<Map>} èµ„æºæ³¨å†Œè¡¨ Map<resourceId, reference>
       */
      async discoverRegistry() {
        var _a;
        try {
          const { registry } = require("@promptx/resource");
          if (!registry) {
            logger.warn("[PackageDiscovery] @promptx/resource \u6CE8\u518C\u8868\u672A\u6B63\u786E\u52A0\u8F7D");
            return /* @__PURE__ */ new Map();
          }
          const registryMap = /* @__PURE__ */ new Map();
          if (Array.isArray(registry.resources)) {
            for (const resource of registry.resources) {
              const reference = resource.reference || `@package://resources/${(_a = resource.metadata) == null ? void 0 : _a.path}`;
              registryMap.set(resource.id, reference);
              registryMap.set(`package:${resource.id}`, reference);
            }
          }
          if (registryMap.size > 0) {
            logger.info(`[PackageDiscovery] \u2705 \u4ECE @promptx/resource \u52A0\u8F7D\u4E86 ${registryMap.size / 2} \u4E2A\u7CFB\u7EDF\u8D44\u6E90\u5230\u6CE8\u518C\u8868`);
          }
          return registryMap;
        } catch (error) {
          logger.warn(`[PackageDiscovery] \u26A0\uFE0F \u7CFB\u7EDF\u8D44\u6E90\u6CE8\u518C\u8868\u52A0\u8F7D\u5931\u8D25: ${error.message}`);
          return /* @__PURE__ */ new Map();
        }
      }
      /**
       * è·å–åŒ…èµ„æºçš„åŸºç¡€ç›®å½•ï¼ˆç”¨äºæ–‡ä»¶è®¿é—®ï¼‰
       * @returns {Promise<string>} åŒ…èµ„æºç›®å½•è·¯å¾„
       */
      async getPackageRoot() {
        try {
          const resourcePackagePath = require.resolve("@promptx/resource");
          const path = require("path");
          let currentDir = path.dirname(resourcePackagePath);
          while (currentDir !== path.dirname(currentDir)) {
            const packageJsonPath = path.join(currentDir, "package.json");
            try {
              const packageJson = require(packageJsonPath);
              if (packageJson.name === "@promptx/resource") {
                return currentDir;
              }
            } catch {
            }
            currentDir = path.dirname(currentDir);
          }
          throw new Error("\u65E0\u6CD5\u627E\u5230 @promptx/resource \u5305\u7684\u6839\u76EE\u5F55");
        } catch (error) {
          logger.error(`[PackageDiscovery] \u274C \u83B7\u53D6\u5305\u6839\u76EE\u5F55\u5931\u8D25: ${error.message}`);
          throw error;
        }
      }
      /**
       * è·å–æ³¨å†Œè¡¨æ•°æ®ï¼ˆResourceManager éœ€è¦çš„æ–¹æ³•ï¼‰
       * @returns {Promise<RegistryData>} æ³¨å†Œè¡¨æ•°æ®å®ä¾‹
       */
      async getRegistryData() {
        var _a;
        try {
          logger.info("[PackageDiscovery] Starting getRegistryData...");
          const { registry } = require("@promptx/resource");
          logger.info("[PackageDiscovery] @promptx/resource loaded successfully");
          const RegistryData = require_RegistryData();
          const ResourceData = require_ResourceData();
          if (!registry) {
            logger.warn("[PackageDiscovery] Registry is empty");
            return new RegistryData("package", "", []);
          }
          logger.info(`[PackageDiscovery] Registry loaded with ${((_a = registry.resources) == null ? void 0 : _a.length) || 0} resources`);
          const resources = [];
          if (Array.isArray(registry.resources)) {
            for (const resource of registry.resources) {
              resources.push(new ResourceData({
                id: resource.id,
                source: "package",
                // ä½¿ç”¨å°å†™ä¿æŒä¸€è‡´
                protocol: resource.protocol,
                // ç›´æ¥ä½¿ç”¨èµ„æºçš„ protocol å­—æ®µ
                name: resource.name || resource.id,
                description: resource.description || "",
                reference: resource.reference,
                metadata: resource.metadata || {}
              }));
            }
          }
          logger.info(`[PackageDiscovery] Successfully created ${resources.length} ResourceData objects`);
          return new RegistryData("package", "@promptx/resource", resources);
        } catch (error) {
          logger.error(`[PackageDiscovery] Error in getRegistryData: ${error.message}`);
          logger.error(`[PackageDiscovery] Stack trace: ${error.stack}`);
          logger.warn(`[PackageDiscovery] \u83B7\u53D6\u6CE8\u518C\u8868\u6570\u636E\u5931\u8D25: ${error.message}`);
          const RegistryData = require_RegistryData();
          return new RegistryData("package", "", []);
        }
      }
      /**
       * è·å–ç¯å¢ƒä¿¡æ¯ï¼ˆç”¨äºè°ƒè¯•ï¼‰
       */
      getEnvironmentInfo() {
        return {
          type: "PackageDiscovery",
          source: "@promptx/resource",
          loaded: this._tryRequirePackage() !== null
        };
      }
      /**
       * å°è¯•åŠ è½½åŒ…ï¼ˆå†…éƒ¨è¾…åŠ©æ–¹æ³•ï¼‰
       */
      _tryRequirePackage() {
        try {
          const { registry } = require("@promptx/resource");
          return registry ? { registry } : null;
        } catch {
          return null;
        }
      }
    };
    module2.exports = PackageDiscovery;
  }
});

// src/resource/discovery/ProjectDiscovery.js
var require_ProjectDiscovery = __commonJS({
  "src/resource/discovery/ProjectDiscovery.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var logger = require("@promptx/logger");
    var RegistryData = require_RegistryData();
    var ResourceData = require_ResourceData();
    var fs = require("fs-extra");
    var path = require("path");
    var ProjectDiscovery = class {
      constructor() {
        this.source = "PROJECT";
        this.priority = 2;
        this.projectProtocol = null;
      }
      /**
       * è·å–ProjectProtocolå®ä¾‹
       */
      getProjectProtocol() {
        if (!this.projectProtocol) {
          const { getGlobalResourceManager } = require_resource();
          const resourceManager = getGlobalResourceManager();
          this.projectProtocol = resourceManager.protocols.get("project");
        }
        return this.projectProtocol;
      }
      /**
       * å‘ç°é¡¹ç›®çº§èµ„æºæ³¨å†Œè¡¨
       * @returns {Promise<Map>} èµ„æºæ³¨å†Œè¡¨ Map<resourceId, reference>
       */
      async discoverRegistry() {
        try {
          const registryMap = await this.loadFromRegistry();
          if (registryMap.size > 0) {
            logger.debug(`ProjectDiscovery \u4ECE\u6CE8\u518C\u8868\u52A0\u8F7D ${registryMap.size} \u4E2A\u8D44\u6E90`);
            return registryMap;
          }
          logger.debug("ProjectDiscovery \u6CE8\u518C\u8868\u4E0D\u5B58\u5728\uFF0C\u4F7F\u7528\u52A8\u6001\u626B\u63CF");
          const resources = await this.scanProjectResources();
          return this.buildRegistryFromResources(resources);
        } catch (error) {
          logger.warn(`[ProjectDiscovery] Registry discovery failed: ${error.message}`);
          return /* @__PURE__ */ new Map();
        }
      }
      /**
       * ä»æ³¨å†Œè¡¨æ–‡ä»¶åŠ è½½èµ„æº
       * @returns {Promise<Map>} èµ„æºæ³¨å†Œè¡¨
       */
      async loadFromRegistry() {
        try {
          const protocol = this.getProjectProtocol();
          const registryPath = await protocol.resolvePath(".promptx/resource/project.registry.json");
          if (!await fs.pathExists(registryPath)) {
            return /* @__PURE__ */ new Map();
          }
          const registryData = await RegistryData.fromFile("project", registryPath);
          return registryData.getResourceMap(true);
        } catch (error) {
          logger.warn(`[ProjectDiscovery] Failed to load registry: ${error.message}`);
          return /* @__PURE__ */ new Map();
        }
      }
      /**
       * åŠ¨æ€æ‰«æé¡¹ç›®èµ„æº - æ¢å¤é‡æ„å‰çš„ä¸“ä¸šæ‰«æé€»è¾‘
       * @returns {Promise<Array>} èµ„æºåˆ—è¡¨
       */
      async scanProjectResources() {
        try {
          const protocol = this.getProjectProtocol();
          const resourceDir = await protocol.resolvePath(".promptx/resource");
          if (!await fs.pathExists(resourceDir)) {
            logger.debug("ProjectDiscovery \u9879\u76EE\u8D44\u6E90\u76EE\u5F55\u4E0D\u5B58\u5728");
            return [];
          }
          const tempRegistry = RegistryData.createEmpty("project", null);
          await this._scanDirectory(resourceDir, tempRegistry);
          const resources = [];
          for (const resource of tempRegistry.resources) {
            resources.push({
              id: resource.id,
              protocol: resource.protocol,
              reference: resource.reference,
              source: resource.source
            });
          }
          logger.info(`[ProjectDiscovery] \u2705 \u9879\u76EE\u626B\u63CF\u5B8C\u6210\uFF0C\u53D1\u73B0 ${resources.length} \u4E2A\u8D44\u6E90`);
          return resources;
        } catch (error) {
          logger.warn(`[ProjectDiscovery] \u626B\u63CF\u9879\u76EE\u8D44\u6E90\u5931\u8D25: ${error.message}`);
          return [];
        }
      }
      /**
       * æ‰«æç›®å½•å¹¶æ·»åŠ èµ„æºåˆ°æ³¨å†Œè¡¨ï¼ˆé€šç”¨é€’å½’æ‰«æï¼‰
       * @param {string} resourcesDir - èµ„æºç›®å½•
       * @param {RegistryData} registryData - æ³¨å†Œè¡¨æ•°æ®
       * @private
       */
      async _scanDirectory(resourcesDir, registryData) {
        try {
          await this._recursiveScan(resourcesDir, "", registryData);
        } catch (error) {
          logger.warn(`[ProjectDiscovery] \u626B\u63CF\u8D44\u6E90\u76EE\u5F55\u5931\u8D25: ${error.message}`);
        }
      }
      /**
       * é€’å½’æ‰«æç›®å½•
       * @param {string} currentPath - å½“å‰æ‰«æè·¯å¾„
       * @param {string} relativePath - ç›¸å¯¹äºresourceç›®å½•çš„è·¯å¾„
       * @param {RegistryData} registryData - æ³¨å†Œè¡¨æ•°æ®
       * @private
       */
      async _recursiveScan(currentPath, relativePath, registryData) {
        try {
          const items = await fs.readdir(currentPath);
          for (const item of items) {
            const itemPath = path.join(currentPath, item);
            const stat = await fs.stat(itemPath);
            const newRelativePath = relativePath ? `${relativePath}/${item}` : item;
            if (stat.isDirectory()) {
              await this._recursiveScan(itemPath, newRelativePath, registryData);
            } else {
              await this._processFile(itemPath, newRelativePath, registryData);
            }
          }
        } catch (error) {
          logger.warn(`[ProjectDiscovery] \u626B\u63CF${currentPath}\u5931\u8D25: ${error.message}`);
        }
      }
      /**
       * å¤„ç†å•ä¸ªæ–‡ä»¶
       * @param {string} filePath - æ–‡ä»¶å®Œæ•´è·¯å¾„
       * @param {string} relativePath - ç›¸å¯¹è·¯å¾„
       * @param {RegistryData} registryData - æ³¨å†Œè¡¨æ•°æ®
       * @private
       */
      async _processFile(filePath, relativePath, registryData) {
        const fileName = path.basename(filePath);
        let protocol = null;
        let resourceId = null;
        if (fileName.endsWith(".role.md")) {
          protocol = "role";
          resourceId = path.basename(fileName, ".role.md");
        } else if (fileName.endsWith(".thought.md")) {
          protocol = "thought";
          resourceId = path.basename(fileName, ".thought.md");
        } else if (fileName.endsWith(".execution.md")) {
          protocol = "execution";
          resourceId = path.basename(fileName, ".execution.md");
        } else if (fileName.endsWith(".knowledge.md")) {
          protocol = "knowledge";
          resourceId = path.basename(fileName, ".knowledge.md");
        } else if (fileName.endsWith(".tool.js")) {
          protocol = "tool";
          resourceId = path.basename(fileName, ".tool.js");
        } else if (fileName.endsWith(".manual.md")) {
          protocol = "manual";
          resourceId = path.basename(fileName, ".manual.md");
        }
        if (protocol && resourceId) {
          if (await this._validateResourceFile(filePath, protocol)) {
            const reference = `@project://.promptx/resource/${relativePath}`;
            const resourceData = new ResourceData({
              id: resourceId,
              source: "project",
              protocol,
              name: ResourceData._generateDefaultName(resourceId, protocol),
              description: ResourceData._generateDefaultDescription(resourceId, protocol),
              reference,
              metadata: {
                scannedAt: (/* @__PURE__ */ new Date()).toISOString(),
                path: relativePath
              }
            });
            registryData.addResource(resourceData);
            logger.debug(`[ProjectDiscovery] \u53D1\u73B0${protocol}\u8D44\u6E90: ${resourceId} at ${relativePath}`);
          }
        }
      }
      /**
       * éªŒè¯èµ„æºæ–‡ä»¶æ ¼å¼ï¼ˆæ¢å¤é‡æ„å‰é€»è¾‘ï¼‰
       * @param {string} filePath - æ–‡ä»¶è·¯å¾„
       * @param {string} protocol - åè®®ç±»å‹
       * @returns {Promise<boolean>} æ˜¯å¦æ˜¯æœ‰æ•ˆçš„èµ„æºæ–‡ä»¶
       */
      async _validateResourceFile(filePath, protocol) {
        try {
          const content = await fs.readFile(filePath, "utf8");
          if (!content || typeof content !== "string") {
            return false;
          }
          const trimmedContent = content.trim();
          if (trimmedContent.length === 0) {
            return false;
          }
          switch (protocol) {
            case "role":
              return trimmedContent.includes("<role>") && trimmedContent.includes("</role>");
            case "execution":
              return trimmedContent.includes("<execution>") && trimmedContent.includes("</execution>");
            case "thought":
              return trimmedContent.includes("<thought>") && trimmedContent.includes("</thought>");
            case "knowledge":
              return true;
            case "manual":
              return trimmedContent.includes("<manual>") && trimmedContent.includes("</manual>");
            case "tool":
              try {
                new Function(trimmedContent);
                return true;
              } catch (e) {
                logger.warn(`[ProjectDiscovery] Invalid JavaScript in tool file ${filePath}: ${e.message}`);
                return false;
              }
            default:
              return false;
          }
        } catch (error) {
          logger.warn(`[ProjectDiscovery] Failed to validate ${filePath}: ${error.message}`);
          return false;
        }
      }
      /**
       * ä»èµ„æºåˆ—è¡¨æ„å»ºæ³¨å†Œè¡¨Map
       * @param {Array} resources - èµ„æºåˆ—è¡¨
       * @returns {Map} èµ„æºæ³¨å†Œè¡¨
       */
      buildRegistryFromResources(resources) {
        const registryMap = /* @__PURE__ */ new Map();
        resources.forEach((resource) => {
          const key = `project:${resource.id}`;
          registryMap.set(key, resource.reference);
        });
        return registryMap;
      }
      /**
       * ç”Ÿæˆå¹¶ä¿å­˜é¡¹ç›®æ³¨å†Œè¡¨æ–‡ä»¶
       * @returns {Promise<RegistryData>} ç”Ÿæˆçš„æ³¨å†Œè¡¨æ•°æ®
       */
      async generateRegistry() {
        try {
          const protocol = this.getProjectProtocol();
          const registryPath = await protocol.resolvePath(".promptx/resource/project.registry.json");
          const registryData = RegistryData.createEmpty("project", registryPath);
          const resourceDir = await protocol.resolvePath(".promptx/resource");
          if (await fs.pathExists(resourceDir)) {
            await this._scanDirectory(resourceDir, registryData);
          }
          await fs.ensureDir(path.dirname(registryPath));
          await registryData.save();
          logger.info(`[ProjectDiscovery] \u2705 \u9879\u76EE\u6CE8\u518C\u8868\u751F\u6210\u5B8C\u6210\uFF0C\u53D1\u73B0 ${registryData.size} \u4E2A\u8D44\u6E90`);
          return registryData;
        } catch (error) {
          logger.error(`[ProjectDiscovery] \u751F\u6210\u6CE8\u518C\u8868\u5931\u8D25: ${error.message}`);
          return RegistryData.createEmpty("project");
        }
      }
      /**
       * è·å–æ³¨å†Œè¡¨æ•°æ®ï¼ˆå…¼å®¹æ—§æ¥å£ï¼‰
       * @returns {Promise<RegistryData>} æ³¨å†Œè¡¨æ•°æ®
       */
      async getRegistryData() {
        try {
          const protocol = this.getProjectProtocol();
          const registryPath = await protocol.resolvePath(".promptx/resource/project.registry.json");
          if (await fs.pathExists(registryPath)) {
            const registryData = await RegistryData.fromFile("project", registryPath);
            if (registryData.size > 0) {
              logger.info(`[ProjectDiscovery] \u{1F4CB} \u4ECE\u6CE8\u518C\u8868\u52A0\u8F7D ${registryData.size} \u4E2A\u8D44\u6E90`);
              return registryData;
            }
          }
          logger.info(`[ProjectDiscovery] \u{1F4CB} \u9879\u76EE\u6CE8\u518C\u8868\u65E0\u6548\uFF0C\u91CD\u65B0\u751F\u6210`);
          return await this.generateRegistry();
        } catch (error) {
          logger.error(`[ProjectDiscovery] \u83B7\u53D6\u6CE8\u518C\u8868\u6570\u636E\u5931\u8D25: ${error.message}`);
          return RegistryData.createEmpty("project");
        }
      }
    };
    module2.exports = ProjectDiscovery;
  }
});

// src/resource/discovery/UserDiscovery.js
var require_UserDiscovery = __commonJS({
  "src/resource/discovery/UserDiscovery.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var BaseDiscovery = require_BaseDiscovery();
    var logger = require("@promptx/logger");
    var RegistryData = require_RegistryData();
    var ResourceData = require_ResourceData();
    var fs = require("fs-extra");
    var path = require("path");
    var UserDiscovery = class extends BaseDiscovery {
      constructor() {
        super("USER", 3);
        this.userProtocol = null;
      }
      /**
       * è·å– UserProtocol å®ä¾‹
       */
      getUserProtocol() {
        if (!this.userProtocol) {
          const { getGlobalResourceManager } = require_resource();
          const resourceManager = getGlobalResourceManager();
          this.userProtocol = resourceManager.protocols.get("user");
        }
        return this.userProtocol;
      }
      /**
       * å‘ç° User çº§èµ„æºæ³¨å†Œè¡¨
       * @returns {Promise<Map>} èµ„æºæ³¨å†Œè¡¨ Map<resourceId, reference>
       */
      async discoverRegistry() {
        try {
          const registryMap = await this.loadFromRegistry();
          if (registryMap.size > 0) {
            logger.debug(`UserDiscovery \u4ECE\u6CE8\u518C\u8868\u52A0\u8F7D ${registryMap.size} \u4E2A\u8D44\u6E90`);
            return registryMap;
          }
          logger.debug("UserDiscovery \u6CE8\u518C\u8868\u4E0D\u5B58\u5728\uFF0C\u4F7F\u7528\u52A8\u6001\u626B\u63CF");
          const resources = await this.scanUserResources();
          return this.buildRegistryFromResources(resources);
        } catch (error) {
          logger.warn(`[UserDiscovery] Registry discovery failed: ${error.message}`);
          return /* @__PURE__ */ new Map();
        }
      }
      /**
       * ä»æ³¨å†Œè¡¨æ–‡ä»¶åŠ è½½èµ„æº
       * @returns {Promise<Map>} èµ„æºæ³¨å†Œè¡¨
       */
      async loadFromRegistry() {
        try {
          const protocol = this.getUserProtocol();
          const registryPath = await protocol.resolvePath(".promptx/resource/user.registry.json");
          if (!await fs.pathExists(registryPath)) {
            return /* @__PURE__ */ new Map();
          }
          const registryData = await RegistryData.fromFile("user", registryPath);
          return registryData.getResourceMap(true);
        } catch (error) {
          logger.warn(`[UserDiscovery] Failed to load registry: ${error.message}`);
          return /* @__PURE__ */ new Map();
        }
      }
      /**
       * åŠ¨æ€æ‰«æ User èµ„æº
       * @returns {Promise<Array>} èµ„æºåˆ—è¡¨
       */
      async scanUserResources() {
        try {
          const protocol = this.getUserProtocol();
          const resourceDir = await protocol.resolvePath(".promptx/resource");
          if (!await fs.pathExists(resourceDir)) {
            logger.debug("UserDiscovery User \u8D44\u6E90\u76EE\u5F55\u4E0D\u5B58\u5728");
            return [];
          }
          const tempRegistry = RegistryData.createEmpty("user", null);
          await this._scanDirectory(resourceDir, tempRegistry);
          const resources = [];
          for (const resource of tempRegistry.resources) {
            resources.push({
              id: resource.id,
              protocol: resource.protocol,
              reference: resource.reference,
              source: resource.source
            });
          }
          logger.info(`[UserDiscovery] \u2705 User \u626B\u63CF\u5B8C\u6210\uFF0C\u53D1\u73B0 ${resources.length} \u4E2A\u8D44\u6E90`);
          return resources;
        } catch (error) {
          logger.warn(`[UserDiscovery] \u626B\u63CF User \u8D44\u6E90\u5931\u8D25: ${error.message}`);
          return [];
        }
      }
      /**
       * æ‰«æç›®å½•å¹¶æ·»åŠ èµ„æºåˆ°æ³¨å†Œè¡¨
       * @param {string} resourcesDir - èµ„æºç›®å½•
       * @param {RegistryData} registryData - æ³¨å†Œè¡¨æ•°æ®
       * @private
       */
      async _scanDirectory(resourcesDir, registryData) {
        try {
          await this._recursiveScan(resourcesDir, "", registryData);
        } catch (error) {
          logger.warn(`[UserDiscovery] \u626B\u63CF\u8D44\u6E90\u76EE\u5F55\u5931\u8D25: ${error.message}`);
        }
      }
      /**
       * é€’å½’æ‰«æç›®å½•
       * @param {string} currentPath - å½“å‰æ‰«æè·¯å¾„
       * @param {string} relativePath - ç›¸å¯¹äº resource ç›®å½•çš„è·¯å¾„
       * @param {RegistryData} registryData - æ³¨å†Œè¡¨æ•°æ®
       * @private
       */
      async _recursiveScan(currentPath, relativePath, registryData) {
        try {
          const items = await fs.readdir(currentPath);
          for (const item of items) {
            const itemPath = path.join(currentPath, item);
            const stat = await fs.stat(itemPath);
            const newRelativePath = relativePath ? `${relativePath}/${item}` : item;
            if (stat.isDirectory()) {
              await this._recursiveScan(itemPath, newRelativePath, registryData);
            } else {
              await this._processFile(itemPath, newRelativePath, registryData);
            }
          }
        } catch (error) {
          logger.warn(`[UserDiscovery] \u626B\u63CF${currentPath}\u5931\u8D25: ${error.message}`);
        }
      }
      /**
       * å¤„ç†å•ä¸ªæ–‡ä»¶
       * @param {string} filePath - æ–‡ä»¶å®Œæ•´è·¯å¾„
       * @param {string} relativePath - ç›¸å¯¹è·¯å¾„
       * @param {RegistryData} registryData - æ³¨å†Œè¡¨æ•°æ®
       * @private
       */
      async _processFile(filePath, relativePath, registryData) {
        const fileName = path.basename(filePath);
        let protocol = null;
        let resourceId = null;
        logger.debug(`[UserDiscovery._processFile] Processing: ${relativePath} (file: ${fileName})`);
        if (fileName.endsWith(".role.md")) {
          protocol = "role";
          resourceId = path.basename(fileName, ".role.md");
        } else if (fileName.endsWith(".thought.md")) {
          protocol = "thought";
          resourceId = path.basename(fileName, ".thought.md");
        } else if (fileName.endsWith(".execution.md")) {
          protocol = "execution";
          resourceId = path.basename(fileName, ".execution.md");
        } else if (fileName.endsWith(".knowledge.md")) {
          protocol = "knowledge";
          resourceId = path.basename(fileName, ".knowledge.md");
        } else if (fileName.endsWith(".tool.js")) {
          protocol = "tool";
          resourceId = path.basename(fileName, ".tool.js");
        } else if (fileName.endsWith(".manual.md")) {
          protocol = "manual";
          resourceId = path.basename(fileName, ".manual.md");
        }
        if (protocol && resourceId) {
          logger.info(`[UserDiscovery._processFile] Found ${protocol} resource: ${resourceId}`);
          if (await this._validateResourceFile(filePath, protocol)) {
            const reference = `@user://.promptx/resource/${relativePath}`;
            const resourceData = new ResourceData({
              id: resourceId,
              source: "user",
              protocol,
              name: ResourceData._generateDefaultName(resourceId, protocol),
              description: ResourceData._generateDefaultDescription(resourceId, protocol),
              reference,
              metadata: {
                scannedAt: (/* @__PURE__ */ new Date()).toISOString(),
                path: relativePath
              }
            });
            registryData.addResource(resourceData);
            logger.info(`[UserDiscovery] \u2705 \u6210\u529F\u6DFB\u52A0${protocol}\u8D44\u6E90: ${resourceId} at ${relativePath}`);
          }
        }
      }
      /**
       * éªŒè¯èµ„æºæ–‡ä»¶æ ¼å¼
       * @param {string} filePath - æ–‡ä»¶è·¯å¾„
       * @param {string} protocol - åè®®ç±»å‹
       * @returns {Promise<boolean>} æ˜¯å¦æ˜¯æœ‰æ•ˆçš„èµ„æºæ–‡ä»¶
       */
      async _validateResourceFile(filePath, protocol) {
        try {
          const content = await fs.readFile(filePath, "utf8");
          if (!content || typeof content !== "string") {
            return false;
          }
          const trimmedContent = content.trim();
          if (trimmedContent.length === 0) {
            return false;
          }
          switch (protocol) {
            case "role":
              return trimmedContent.includes("<role>") && trimmedContent.includes("</role>");
            case "execution":
              return trimmedContent.includes("<execution>") && trimmedContent.includes("</execution>");
            case "thought":
              return trimmedContent.includes("<thought>") && trimmedContent.includes("</thought>");
            case "knowledge":
              return true;
            case "manual":
              return trimmedContent.includes("<manual>") && trimmedContent.includes("</manual>");
            case "tool":
              try {
                new Function(trimmedContent);
                return true;
              } catch (e) {
                logger.warn(`[UserDiscovery] Invalid JavaScript in tool file ${filePath}: ${e.message}`);
                return false;
              }
            default:
              return false;
          }
        } catch (error) {
          logger.warn(`[UserDiscovery] Failed to validate ${filePath}: ${error.message}`);
          return false;
        }
      }
      /**
       * ä»èµ„æºåˆ—è¡¨æ„å»ºæ³¨å†Œè¡¨ Map
       * @param {Array} resources - èµ„æºåˆ—è¡¨
       * @returns {Map} èµ„æºæ³¨å†Œè¡¨
       */
      buildRegistryFromResources(resources) {
        const registryMap = /* @__PURE__ */ new Map();
        resources.forEach((resource) => {
          const key = `user:${resource.id}`;
          registryMap.set(key, resource.reference);
        });
        return registryMap;
      }
      /**
       * ç”Ÿæˆå¹¶ä¿å­˜ User æ³¨å†Œè¡¨æ–‡ä»¶
       * @returns {Promise<RegistryData>} ç”Ÿæˆçš„æ³¨å†Œè¡¨æ•°æ®
       */
      async generateRegistry() {
        try {
          const protocol = this.getUserProtocol();
          const registryPath = await protocol.resolvePath(".promptx/resource/user.registry.json");
          const registryData = RegistryData.createEmpty("user", registryPath);
          const resourceDir = await protocol.resolvePath(".promptx/resource");
          if (await fs.pathExists(resourceDir)) {
            await this._scanDirectory(resourceDir, registryData);
          }
          await fs.ensureDir(path.dirname(registryPath));
          await registryData.save();
          logger.info(`[UserDiscovery] \u2705 User \u6CE8\u518C\u8868\u751F\u6210\u5B8C\u6210\uFF0C\u53D1\u73B0 ${registryData.size} \u4E2A\u8D44\u6E90`);
          return registryData;
        } catch (error) {
          logger.error(`[UserDiscovery] \u751F\u6210\u6CE8\u518C\u8868\u5931\u8D25: ${error.message}`);
          return RegistryData.createEmpty("user");
        }
      }
      /**
       * è·å–æ³¨å†Œè¡¨æ•°æ®ï¼ˆå…¼å®¹æ¥å£ï¼‰
       * @returns {Promise<RegistryData>} æ³¨å†Œè¡¨æ•°æ®
       */
      async getRegistryData() {
        try {
          const protocol = this.getUserProtocol();
          const registryPath = await protocol.resolvePath(".promptx/resource/user.registry.json");
          if (await fs.pathExists(registryPath)) {
            const registryData = await RegistryData.fromFile("user", registryPath);
            if (registryData.size > 0) {
              logger.info(`[UserDiscovery] \u{1F4CB} \u4ECE\u6CE8\u518C\u8868\u52A0\u8F7D ${registryData.size} \u4E2A\u8D44\u6E90`);
              return registryData;
            }
          }
          logger.info(`[UserDiscovery] \u{1F4CB} User \u6CE8\u518C\u8868\u65E0\u6548\uFF0C\u91CD\u65B0\u751F\u6210`);
          return await this.generateRegistry();
        } catch (error) {
          logger.error(`[UserDiscovery] \u83B7\u53D6\u6CE8\u518C\u8868\u6570\u636E\u5931\u8D25: ${error.message}`);
          return RegistryData.createEmpty("user");
        }
      }
      /**
       * å‘ç°èµ„æºï¼ˆBaseDiscovery è¦æ±‚çš„æŠ½è±¡æ–¹æ³•ï¼‰
       * @returns {Promise<Array>} å‘ç°çš„èµ„æºåˆ—è¡¨
       */
      async discover() {
        const registryMap = await this.discoverRegistry();
        const resources = [];
        for (const [key, reference] of registryMap) {
          const [source, id] = key.split(":");
          if (source === "user" && id) {
            resources.push({
              id,
              reference,
              source: "user"
            });
          }
        }
        return resources;
      }
    };
    module2.exports = UserDiscovery;
  }
});

// src/resource/discovery/DiscoveryManager.js
var require_DiscoveryManager = __commonJS({
  "src/resource/discovery/DiscoveryManager.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var PackageDiscovery = require_PackageDiscovery();
    var ProjectDiscovery = require_ProjectDiscovery();
    var UserDiscovery = require_UserDiscovery();
    var logger = require("@promptx/logger");
    var DiscoveryManager = class {
      /**
       * æ„é€ å‡½æ•°
       * @param {Array} discoveries - è‡ªå®šä¹‰å‘ç°å™¨åˆ—è¡¨ï¼Œå¦‚æœä¸æä¾›åˆ™ä½¿ç”¨é»˜è®¤é…ç½®
       */
      constructor(discoveries = null) {
        if (discoveries) {
          this.discoveries = [...discoveries];
        } else {
          this.discoveries = [
            new PackageDiscovery(),
            // ä¼˜å…ˆçº§: 1
            new ProjectDiscovery(),
            // ä¼˜å…ˆçº§: 2
            new UserDiscovery()
            // ä¼˜å…ˆçº§: 3 (æœ€é«˜)
          ];
        }
        this._sortDiscoveriesByPriority();
      }
      /**
       * æ·»åŠ å‘ç°å™¨
       * @param {Object} discovery - å®ç°äº†å‘ç°å™¨æ¥å£çš„å¯¹è±¡
       */
      addDiscovery(discovery) {
        if (!discovery || typeof discovery.discover !== "function") {
          throw new Error("Discovery must implement discover method");
        }
        this.discoveries.push(discovery);
        this._sortDiscoveriesByPriority();
      }
      /**
       * ç§»é™¤å‘ç°å™¨
       * @param {string} source - å‘ç°å™¨æºç±»å‹
       */
      removeDiscovery(source) {
        this.discoveries = this.discoveries.filter((discovery) => discovery.source !== source);
      }
      /**
       * å‘ç°æ‰€æœ‰èµ„æºï¼ˆå¹¶è¡Œæ¨¡å¼ï¼‰
       * @returns {Promise<Array>} æ‰€æœ‰å‘ç°çš„èµ„æºåˆ—è¡¨
       */
      async discoverAll() {
        const discoveryPromises = this.discoveries.map(async (discovery) => {
          try {
            const resources = await discovery.discover();
            return Array.isArray(resources) ? resources : [];
          } catch (error) {
            logger.warn(`[DiscoveryManager] ${discovery.source} discovery failed: ${error.message}`);
            return [];
          }
        });
        const discoveryResults = await Promise.allSettled(discoveryPromises);
        const allResources = [];
        discoveryResults.forEach((result, index) => {
          if (result.status === "fulfilled") {
            allResources.push(...result.value);
          } else {
            logger.warn(`[DiscoveryManager] ${this.discoveries[index].source} discovery rejected: ${result.reason}`);
          }
        });
        return allResources;
      }
      /**
       * å‘ç°å¹¶åˆå¹¶æ‰€æœ‰æ³¨å†Œè¡¨ï¼ˆRegistryDataæ¶æ„ï¼‰
       * @returns {Promise<Map>} åˆå¹¶åçš„èµ„æºæ³¨å†Œè¡¨ Map<resourceId, reference>
       */
      async discoverRegistries() {
        const registryPromises = this.discoveries.map(async (discovery) => {
          try {
            if (typeof discovery.discoverRegistry === "function") {
              const registry = await discovery.discoverRegistry();
              return registry instanceof Map ? registry : /* @__PURE__ */ new Map();
            } else {
              const resources = await discovery.discover();
              const registry = /* @__PURE__ */ new Map();
              if (Array.isArray(resources)) {
                resources.forEach((resource) => {
                  if (resource.id && resource.reference) {
                    registry.set(resource.id, resource.reference);
                  }
                });
              }
              return registry;
            }
          } catch (error) {
            logger.warn(`[DiscoveryManager] ${discovery.source} registry discovery failed: ${error.message}`);
            return /* @__PURE__ */ new Map();
          }
        });
        const registryResults = await Promise.allSettled(registryPromises);
        const registries = [];
        registryResults.forEach((result, index) => {
          if (result.status === "fulfilled") {
            registries.push(result.value);
          } else {
            logger.warn(`[DiscoveryManager] ${this.discoveries[index].source} registry discovery rejected: ${result.reason}`);
            registries.push(/* @__PURE__ */ new Map());
          }
        });
        return this._mergeRegistries(registries);
      }
      /**
       * æŒ‰æºç±»å‹å‘ç°æ³¨å†Œè¡¨
       * @param {string} source - å‘ç°å™¨æºç±»å‹
       * @returns {Promise<Map>} æŒ‡å®šæºçš„èµ„æºæ³¨å†Œè¡¨
       */
      async discoverRegistryBySource(source) {
        const discovery = this._findDiscoveryBySource(source);
        if (!discovery) {
          throw new Error(`Discovery source ${source} not found`);
        }
        if (typeof discovery.discoverRegistry === "function") {
          return await discovery.discoverRegistry();
        } else {
          const resources = await discovery.discover();
          const registry = /* @__PURE__ */ new Map();
          if (Array.isArray(resources)) {
            resources.forEach((resource) => {
              if (resource.id && resource.reference) {
                registry.set(resource.id, resource.reference);
              }
            });
          }
          return registry;
        }
      }
      /**
       * æŒ‰æºç±»å‹å‘ç°èµ„æº
       * @param {string} source - å‘ç°å™¨æºç±»å‹
       * @returns {Promise<Array>} æŒ‡å®šæºçš„èµ„æºåˆ—è¡¨
       */
      async discoverBySource(source) {
        const discovery = this._findDiscoveryBySource(source);
        if (!discovery) {
          throw new Error(`Discovery source ${source} not found`);
        }
        return await discovery.discover();
      }
      /**
       * è·å–æ‰€æœ‰å‘ç°å™¨ä¿¡æ¯
       * @returns {Array} å‘ç°å™¨ä¿¡æ¯åˆ—è¡¨
       */
      getDiscoveryInfo() {
        return this.discoveries.map((discovery) => {
          if (typeof discovery.getDiscoveryInfo === "function") {
            return discovery.getDiscoveryInfo();
          } else {
            return {
              source: discovery.source || "UNKNOWN",
              priority: discovery.priority || 0,
              description: "No description available"
            };
          }
        });
      }
      /**
       * æ¸…ç†æ‰€æœ‰å‘ç°å™¨ç¼“å­˜
       */
      clearCache() {
        this.discoveries.forEach((discovery) => {
          if (typeof discovery.clearCache === "function") {
            discovery.clearCache();
          }
        });
      }
      /**
       * è·å–å‘ç°å™¨æ•°é‡
       * @returns {number} æ³¨å†Œçš„å‘ç°å™¨æ•°é‡
       */
      getDiscoveryCount() {
        return this.discoveries.length;
      }
      /**
       * åˆå¹¶å¤šä¸ªæ³¨å†Œè¡¨ï¼ˆæ”¯æŒåˆ†å±‚çº§èµ„æºç®¡ç†ï¼‰
       * @param {Array<Map>} registries - æ³¨å†Œè¡¨æ•°ç»„ï¼ŒæŒ‰ä¼˜å…ˆçº§æ’åºï¼ˆæ•°å­—è¶Šå°ä¼˜å…ˆçº§è¶Šé«˜ï¼‰
       * @returns {Map} åˆå¹¶åçš„æ³¨å†Œè¡¨
       * @private
       */
      _mergeRegistries(registries) {
        const mergedRegistry = /* @__PURE__ */ new Map();
        for (let i = registries.length - 1; i >= 0; i--) {
          const registry = registries[i];
          if (registry instanceof Map) {
            for (const [key, value] of registry) {
              mergedRegistry.set(key, value);
            }
          }
        }
        const priorityLevels = ["package", "project", "user"];
        const baseResourceMap = /* @__PURE__ */ new Map();
        for (const [fullId, reference] of mergedRegistry) {
          const colonIndex = fullId.indexOf(":");
          let source = "unknown";
          let baseId = fullId;
          if (colonIndex !== -1) {
            const possibleSource = fullId.substring(0, colonIndex);
            if (priorityLevels.includes(possibleSource)) {
              source = possibleSource;
              baseId = fullId.substring(colonIndex + 1);
            }
          }
          const currentPriority = priorityLevels.indexOf(source);
          const existing = baseResourceMap.get(baseId);
          if (!existing || currentPriority > existing.priority) {
            baseResourceMap.set(baseId, {
              source,
              reference,
              priority: currentPriority,
              fullId
            });
          }
        }
        const finalRegistry = /* @__PURE__ */ new Map();
        for (const [key, value] of mergedRegistry) {
          if (key.includes(":") && priorityLevels.includes(key.split(":")[0])) {
            finalRegistry.set(key, value);
          }
        }
        for (const [baseId, info] of baseResourceMap) {
          finalRegistry.set(baseId, info.reference);
        }
        return finalRegistry;
      }
      /**
       * æŒ‰ä¼˜å…ˆçº§æ’åºå‘ç°å™¨
       * @private
       */
      _sortDiscoveriesByPriority() {
        this.discoveries.sort((a, b) => {
          const priorityA = a.priority || 0;
          const priorityB = b.priority || 0;
          return priorityA - priorityB;
        });
      }
      /**
       * æ ¹æ®æºç±»å‹æŸ¥æ‰¾å‘ç°å™¨
       * @param {string} source - å‘ç°å™¨æºç±»å‹
       * @returns {Object|undefined} æ‰¾åˆ°çš„å‘ç°å™¨æˆ–undefined
       * @private
       */
      _findDiscoveryBySource(source) {
        return this.discoveries.find((discovery) => discovery.source === source);
      }
    };
    module2.exports = DiscoveryManager;
  }
});

// src/resource/protocols/ResourceProtocol.js
var require_ResourceProtocol = __commonJS({
  "src/resource/protocols/ResourceProtocol.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var ResourceProtocol = class _ResourceProtocol {
      /**
       * æ„é€ å‡½æ•°
       * @param {string} name - åè®®åç§°
       * @param {object} options - é…ç½®é€‰é¡¹
       */
      constructor(name, options = {}) {
        if (new.target === _ResourceProtocol) {
          throw new Error("ResourceProtocol\u662F\u62BD\u8C61\u7C7B\uFF0C\u4E0D\u80FD\u76F4\u63A5\u5B9E\u4F8B\u5316");
        }
        this.name = name;
        this.options = options;
        this.cache = /* @__PURE__ */ new Map();
        this.enableCache = options.enableCache === true;
      }
      /**
       * åè®®ä¿¡æ¯ - éœ€è¦å­ç±»å®ç°
       * @returns {object} åè®®ä¿¡æ¯
       */
      getProtocolInfo() {
        throw new Error("\u5B50\u7C7B\u5FC5\u987B\u5B9E\u73B0 getProtocolInfo() \u65B9\u6CD5");
      }
      /**
       * è§£æèµ„æºè·¯å¾„ - éœ€è¦å­ç±»å®ç°
       * @param {string} resourcePath - åŸå§‹èµ„æºè·¯å¾„
       * @param {QueryParams} queryParams - æŸ¥è¯¢å‚æ•°
       * @returns {Promise<string>} è§£æåçš„è·¯å¾„
       */
      async resolvePath(resourcePath, queryParams) {
        throw new Error("\u5B50\u7C7B\u5FC5\u987B\u5B9E\u73B0 resolvePath() \u65B9\u6CD5");
      }
      /**
       * åŠ è½½èµ„æºå†…å®¹ - éœ€è¦å­ç±»å®ç°
       * @param {string} resolvedPath - è§£æåçš„è·¯å¾„
       * @param {QueryParams} queryParams - æŸ¥è¯¢å‚æ•°
       * @returns {Promise<string>} èµ„æºå†…å®¹
       */
      async loadContent(resolvedPath, queryParams) {
        throw new Error("\u5B50\u7C7B\u5FC5\u987B\u5B9E\u73B0 loadContent() \u65B9\u6CD5");
      }
      /**
       * éªŒè¯èµ„æºè·¯å¾„æ ¼å¼ - å¯é€‰å®ç°
       * @param {string} resourcePath - èµ„æºè·¯å¾„
       * @returns {boolean} æ˜¯å¦æœ‰æ•ˆ
       */
      validatePath(resourcePath) {
        return typeof resourcePath === "string" && resourcePath.length > 0;
      }
      /**
       * æ”¯æŒçš„æŸ¥è¯¢å‚æ•°åˆ—è¡¨ - å¯é€‰å®ç°
       * @returns {object} å‚æ•°è¯´æ˜
       */
      getSupportedParams() {
        return {
          line: 'string - \u884C\u8303\u56F4\uFF0C\u5982 "1-10"',
          format: "string - \u8F93\u51FA\u683C\u5F0F",
          cache: "boolean - \u662F\u5426\u7F13\u5B58"
        };
      }
      /**
       * ç»Ÿä¸€çš„èµ„æºè§£æå…¥å£ç‚¹
       * @param {string} resourcePath - èµ„æºè·¯å¾„
       * @param {QueryParams} queryParams - æŸ¥è¯¢å‚æ•°
       * @returns {Promise<string>} èµ„æºå†…å®¹
       */
      async resolve(resourcePath, queryParams) {
        if (!this.validatePath(resourcePath)) {
          const error = new Error(`\u65E0\u6548\u7684\u8D44\u6E90\u8DEF\u5F84: ${resourcePath}`);
          const logger = require("@promptx/logger");
          logger.error(`[ResourceProtocol] \u8DEF\u5F84\u9A8C\u8BC1\u5931\u8D25: ${resourcePath}`);
          logger.error(`[ResourceProtocol] \u8C03\u7528\u5806\u6808:`, error.stack);
          throw error;
        }
        const cacheKey = this.generateCacheKey(resourcePath, queryParams);
        if (this.enableCache && this.cache.has(cacheKey)) {
          return this.cache.get(cacheKey);
        }
        const resolvedPath = await this.resolvePath(resourcePath, queryParams);
        const content = await this.loadContent(resolvedPath, queryParams);
        const filteredContent = this.applyCommonParams(content, queryParams);
        if (this.enableCache) {
          this.cache.set(cacheKey, filteredContent);
        }
        return filteredContent;
      }
      /**
       * ç”Ÿæˆç¼“å­˜é”®
       * @param {string} resourcePath - èµ„æºè·¯å¾„
       * @param {QueryParams} queryParams - æŸ¥è¯¢å‚æ•°
       * @returns {string} ç¼“å­˜é”®
       */
      generateCacheKey(resourcePath, queryParams) {
        const params = queryParams ? queryParams.getAll() : {};
        return `${this.name}:${resourcePath}:${JSON.stringify(params)}`;
      }
      /**
       * åº”ç”¨é€šç”¨æŸ¥è¯¢å‚æ•°
       * @param {string} content - åŸå§‹å†…å®¹
       * @param {QueryParams} queryParams - æŸ¥è¯¢å‚æ•°
       * @returns {string} è¿‡æ»¤åçš„å†…å®¹
       */
      applyCommonParams(content, queryParams) {
        if (!queryParams) {
          return content;
        }
        let result = content;
        if (queryParams.line) {
          result = this.applyLineFilter(result, queryParams.line);
        }
        if (queryParams.format && queryParams.format !== "text") {
          result = this.applyFormat(result, queryParams.format);
        }
        return result;
      }
      /**
       * åº”ç”¨è¡Œè¿‡æ»¤
       * @param {string} content - å†…å®¹
       * @param {string} lineRange - è¡ŒèŒƒå›´ï¼Œå¦‚ "5-10" æˆ– "5"
       * @returns {string} è¿‡æ»¤åçš„å†…å®¹
       */
      applyLineFilter(content, lineRange) {
        const lines = content.split("\n");
        if (lineRange.includes("-")) {
          const [start, end] = lineRange.split("-").map((n) => parseInt(n.trim(), 10));
          const startIndex = Math.max(0, start - 1);
          const endIndex = Math.min(lines.length, end);
          return lines.slice(startIndex, endIndex).join("\n");
        } else {
          const lineNum = parseInt(lineRange, 10);
          const lineIndex = lineNum - 1;
          return lines[lineIndex] || "";
        }
      }
      /**
       * åº”ç”¨æ ¼å¼åŒ–
       * @param {string} content - å†…å®¹
       * @param {string} format - æ ¼å¼
       * @returns {string} æ ¼å¼åŒ–åçš„å†…å®¹
       */
      applyFormat(content, format) {
        switch (format) {
          case "json":
            try {
              return JSON.stringify(JSON.parse(content), null, 2);
            } catch {
              return content;
            }
          case "trim":
            return content.trim();
          default:
            return content;
        }
      }
      /**
       * æ¸…é™¤ç¼“å­˜
       */
      clearCache() {
        this.cache.clear();
      }
      /**
       * è·å–ç¼“å­˜ç»Ÿè®¡
       * @returns {object} ç¼“å­˜ç»Ÿè®¡ä¿¡æ¯
       */
      getCacheStats() {
        return {
          protocol: this.name,
          size: this.cache.size,
          enabled: this.enableCache
        };
      }
    };
    module2.exports = ResourceProtocol;
  }
});

// src/resource/protocols/PackageProtocol.js
var require_PackageProtocol = __commonJS({
  "src/resource/protocols/PackageProtocol.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var path = require("path");
    var fs = require("fs");
    var fsPromises = require("fs").promises;
    var ResourceProtocol = require_ResourceProtocol();
    var { QueryParams } = require_types();
    var logger = require("@promptx/logger");
    var { getDirectoryService } = require_DirectoryService();
    var PackageProtocol = class extends ResourceProtocol {
      constructor(options = {}) {
        super("package", options);
        this.directoryService = getDirectoryService();
      }
      /**
       * è®¾ç½®æ³¨å†Œè¡¨ï¼ˆä¿æŒä¸å…¶ä»–åè®®çš„ä¸€è‡´æ€§ï¼‰
       */
      setRegistry(registry) {
        this.registry = registry || {};
      }
      /**
       * è·å–åè®®ä¿¡æ¯
       */
      getProtocolInfo() {
        return {
          name: this.name,
          description: "\u5305\u534F\u8BAE - \u667A\u80FD\u8BBF\u95EENPM\u5305\u8D44\u6E90\uFF0C\u652F\u6301\u591A\u79CD\u5B89\u88C5\u6A21\u5F0F",
          examples: [
            "@package://package.json",
            "@package://src/index.js",
            "@package://docs/README.md",
            "@package://resource/core/thought.md",
            "@package://templates/basic/template.md"
          ],
          installModes: [
            "development",
            // å¼€å‘æ¨¡å¼
            "local",
            // æœ¬åœ°npm install
            "global",
            // å…¨å±€npm install -g
            "npx",
            // npxæ‰§è¡Œ
            "monorepo",
            // monorepo workspace
            "link"
            // npm link
          ]
        };
      }
      /**
       * è·å–åŒ…æ ¹ç›®å½• - å§‹ç»ˆä½¿ç”¨ dist ç›®å½•
       */
      async getPackageRoot() {
        try {
          const resourcePath = require.resolve("@promptx/resource");
          logger.info(`[PackageProtocol] require.resolve('@promptx/resource') returned: ${resourcePath}`);
          const distDir = path.dirname(resourcePath);
          logger.info(`[PackageProtocol] Using dist directory as package root: ${distDir}`);
          const resourcesDir = path.join(distDir, "resources");
          logger.info(`[PackageProtocol] Resources directory path: ${resourcesDir}`);
          logger.info(`[PackageProtocol] Resources directory exists: ${fs.existsSync(resourcesDir)}`);
          return distDir;
        } catch (error) {
          logger.error(`[PackageProtocol] Cannot locate @promptx/resource package: ${error.message}`);
          logger.error(`[PackageProtocol] Error stack:`, error.stack);
          logger.error(`[PackageProtocol] This is a critical system error, @promptx/resource must exist and be accessible via require`);
          throw error;
        }
      }
      /**
       * è§£æè·¯å¾„åˆ°å…·ä½“çš„æ–‡ä»¶ç³»ç»Ÿè·¯å¾„ - ä½¿ç”¨ PackageResource
       * @param {string} relativePath - ç›¸å¯¹äºåŒ…æ ¹ç›®å½•çš„è·¯å¾„
       * @param {QueryParams} params - æŸ¥è¯¢å‚æ•°
       * @returns {Promise<string>} è§£æåçš„ç»å¯¹è·¯å¾„
       */
      async resolvePath(relativePath, params = null) {
        logger.info(`[PackageProtocol] Resolving path: ${relativePath}`);
        try {
          const resourceModule = require("@promptx/resource");
          logger.info(`[PackageProtocol] Resource module loaded:`, Object.keys(resourceModule));
          const { packageResource } = resourceModule;
          logger.info(`[PackageProtocol] PackageResource type:`, typeof packageResource);
          logger.debug(`[PackageProtocol] Successfully loaded PackageResource`);
          const cleanPath = relativePath.replace(/^\/+/, "");
          logger.debug(`[PackageProtocol] Cleaned path: ${cleanPath}`);
          const fullPath = packageResource.resolvePath(cleanPath);
          logger.info(`[PackageProtocol] PackageResource resolved path: ${fullPath}`);
          const exists = packageResource.exists(cleanPath);
          logger.info(`[PackageProtocol] File exists: ${exists} (path: ${fullPath})`);
          if (!exists) {
            logger.error(`[PackageProtocol] Resource file not found: ${fullPath}`);
            return null;
          }
          return fullPath;
        } catch (error) {
          logger.error(`[PackageProtocol] Failed to resolve resource path: ${error.message}`);
          logger.error(`[PackageProtocol] Error stack:`, error.stack);
          throw error;
        }
      }
      /**
       * éªŒè¯æ–‡ä»¶è®¿é—®æƒé™ï¼ˆåŸºäºpackage.jsonçš„fileså­—æ®µï¼‰
       * @param {string} packageRoot - åŒ…æ ¹ç›®å½•
       * @param {string} relativePath - ç›¸å¯¹è·¯å¾„
       */
      validateFileAccess(packageRoot, relativePath) {
        logger.debug(`[PackageProtocol] Validating file access for: ${relativePath}`);
      }
      /**
       * æ£€æŸ¥èµ„æºæ˜¯å¦å­˜åœ¨
       */
      async exists(resourcePath, queryParams) {
        try {
          const resolvedPath = await this.resolvePath(resourcePath, queryParams);
          await fsPromises.access(resolvedPath);
          return true;
        } catch (error) {
          return false;
        }
      }
      /**
       * åŠ è½½èµ„æºå†…å®¹
       * @param {string} resolvedPath - å·²è§£æçš„è·¯å¾„
       * @param {QueryParams} [queryParams] - æŸ¥è¯¢å‚æ•°
       * @returns {Object} åŒ…å«å†…å®¹å’Œå…ƒæ•°æ®çš„å¯¹è±¡
       */
      async loadContent(resolvedPath, queryParams) {
        try {
          await fsPromises.access(resolvedPath);
          const content = await fsPromises.readFile(resolvedPath, "utf8");
          const stats = await fsPromises.stat(resolvedPath);
          const packageRoot = await this.getPackageRoot();
          return {
            content,
            path: resolvedPath,
            protocol: "package",
            metadata: {
              size: content.length,
              lastModified: stats.mtime,
              absolutePath: resolvedPath,
              relativePath: path.relative(packageRoot, resolvedPath)
            }
          };
        } catch (error) {
          if (error.code === "ENOENT") {
            throw new Error(`Package resource not found: ${resolvedPath}`);
          }
          throw new Error(`Failed to load package resource: ${error.message}`);
        }
      }
      /**
       * è·å–è°ƒè¯•ä¿¡æ¯
       */
      getDebugInfo() {
        return {
          protocol: this.name,
          packageRoot: this.getPackageRoot(),
          currentWorkingDirectory: process.cwd(),
          moduleDirectory: __dirname,
          cacheSize: this.cache.size
        };
      }
      /**
       * æ¸…ç†ç¼“å­˜
       */
      clearCache() {
        super.clearCache();
      }
    };
    module2.exports = PackageProtocol;
  }
});

// src/utils/ProjectPathResolver.js
var require_ProjectPathResolver = __commonJS({
  "src/utils/ProjectPathResolver.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var path = require("path");
    var ProjectManager = require_ProjectManager();
    var ProjectPathResolver = class {
      constructor() {
        this.projectDirs = {
          root: "",
          // é¡¹ç›®æ ¹ç›®å½•
          src: "src",
          // æºä»£ç ç›®å½•
          lib: "lib",
          // åº“ç›®å½•
          build: "build",
          // æ„å»ºè¾“å‡ºç›®å½•
          dist: "dist",
          // åˆ†å‘ç›®å½•
          docs: "docs",
          // æ–‡æ¡£ç›®å½•
          test: "test",
          // æµ‹è¯•ç›®å½•
          tests: "tests",
          // æµ‹è¯•ç›®å½•ï¼ˆå¤æ•°ï¼‰
          spec: "spec",
          // è§„èŒƒæµ‹è¯•ç›®å½•
          config: "config",
          // é…ç½®ç›®å½•
          scripts: "scripts",
          // è„šæœ¬ç›®å½•
          assets: "assets",
          // èµ„æºç›®å½•
          public: "public",
          // å…¬å…±èµ„æºç›®å½•
          static: "static",
          // é™æ€èµ„æºç›®å½•
          templates: "templates",
          // æ¨¡æ¿ç›®å½•
          examples: "examples",
          // ç¤ºä¾‹ç›®å½•
          tools: "tools",
          // å·¥å…·ç›®å½•
          ".promptx": ".promptx"
          // PromptXé…ç½®ç›®å½•
        };
      }
      /**
       * è§£æ@project://åè®®è·¯å¾„
       * @param {string} resourcePath - èµ„æºè·¯å¾„ï¼Œå¦‚ "src/index.js" æˆ– ".promptx/resource/..."
       * @returns {string} è§£æåçš„ç»å¯¹è·¯å¾„
       */
      resolvePath(resourcePath) {
        const projectRoot = ProjectManager.getCurrentProjectPath();
        if (resourcePath.startsWith(".promptx/")) {
          const fullPath2 = path.join(projectRoot, resourcePath);
          return this._validatePath(fullPath2, projectRoot);
        }
        const parts = resourcePath.split("/");
        const dirType = parts[0];
        const relativePath = parts.slice(1).join("/");
        if (!this.projectDirs.hasOwnProperty(dirType)) {
          throw new Error(`\u4E0D\u652F\u6301\u7684\u9879\u76EE\u76EE\u5F55\u7C7B\u578B: ${dirType}\u3002\u652F\u6301\u7684\u7C7B\u578B: ${Object.keys(this.projectDirs).join(", ")}`);
        }
        const projectDirPath = this.projectDirs[dirType];
        const targetDir = projectDirPath ? path.join(projectRoot, projectDirPath) : projectRoot;
        if (!relativePath) {
          return targetDir;
        }
        const fullPath = path.join(targetDir, relativePath);
        return this._validatePath(fullPath, projectRoot);
      }
      /**
       * è·å–é¡¹ç›®æ ¹ç›®å½•
       * @returns {string} å½“å‰é¡¹ç›®æ ¹ç›®å½•
       */
      getProjectRoot() {
        return ProjectManager.getCurrentProjectPath();
      }
      /**
       * è·å–PromptXé…ç½®ç›®å½•è·¯å¾„
       * @returns {string} .promptxç›®å½•è·¯å¾„
       */
      getPromptXDirectory() {
        const projectRoot = ProjectManager.getCurrentProjectPath();
        return path.join(projectRoot, ".promptx");
      }
      /**
       * è·å–é¡¹ç›®èµ„æºç›®å½•è·¯å¾„
       * @returns {string} é¡¹ç›®èµ„æºç›®å½•è·¯å¾„
       */
      getResourceDirectory() {
        const promptxDir = this.getPromptXDirectory();
        return path.join(promptxDir, "resource");
      }
      /**
       * è·å–é¡¹ç›®æ³¨å†Œè¡¨æ–‡ä»¶è·¯å¾„
       * @returns {string} æ³¨å†Œè¡¨æ–‡ä»¶è·¯å¾„
       */
      getRegistryPath() {
        const resourceDir = this.getResourceDirectory();
        return path.join(resourceDir, "project.registry.json");
      }
      /**
       * è·å–è®°å¿†ç›®å½•è·¯å¾„
       * @returns {string} è®°å¿†ç›®å½•è·¯å¾„
       */
      getMemoryDirectory() {
        const promptxDir = this.getPromptXDirectory();
        return path.join(promptxDir, "memory");
      }
      /**
       * éªŒè¯è·¯å¾„å®‰å…¨æ€§
       * @param {string} fullPath - å®Œæ•´è·¯å¾„
       * @param {string} projectRoot - é¡¹ç›®æ ¹ç›®å½•
       * @returns {string} éªŒè¯åçš„è·¯å¾„
       * @private
       */
      _validatePath(fullPath, projectRoot) {
        const resolvedPath = path.resolve(fullPath);
        const resolvedProjectRoot = path.resolve(projectRoot);
        if (!resolvedPath.startsWith(resolvedProjectRoot)) {
          throw new Error(`\u5B89\u5168\u9519\u8BEF\uFF1A\u8DEF\u5F84\u8D85\u51FA\u9879\u76EE\u76EE\u5F55\u8303\u56F4: ${resolvedPath}`);
        }
        return resolvedPath;
      }
      /**
       * è·å–æ”¯æŒçš„ç›®å½•ç±»å‹
       * @returns {Array<string>} æ”¯æŒçš„ç›®å½•ç±»å‹åˆ—è¡¨
       */
      getSupportedDirectories() {
        return Object.keys(this.projectDirs);
      }
      /**
       * æ£€æŸ¥ç›®å½•ç±»å‹æ˜¯å¦æ”¯æŒ
       * @param {string} dirType - ç›®å½•ç±»å‹
       * @returns {boolean} æ˜¯å¦æ”¯æŒ
       */
      isSupportedDirectory(dirType) {
        return this.projectDirs.hasOwnProperty(dirType);
      }
    };
    var globalProjectPathResolver = null;
    function getGlobalProjectPathResolver() {
      if (!globalProjectPathResolver) {
        globalProjectPathResolver = new ProjectPathResolver();
      }
      return globalProjectPathResolver;
    }
    module2.exports = ProjectPathResolver;
    module2.exports.getGlobalProjectPathResolver = getGlobalProjectPathResolver;
  }
});

// src/resource/protocols/UserProtocol.js
var require_UserProtocol = __commonJS({
  "src/resource/protocols/UserProtocol.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var ResourceProtocol = require_ResourceProtocol();
    var path = require("path");
    var fs = require("fs").promises;
    var envPaths = require("env-paths");
    var os = require("os");
    var getUserDirectories = () => {
      const promptxPaths = envPaths("promptx");
      return {
        getHomeFolder: () => os.homedir(),
        getDesktopFolder: () => path.join(os.homedir(), "Desktop"),
        getDocumentsFolder: () => path.join(os.homedir(), "Documents"),
        getDownloadsFolder: () => path.join(os.homedir(), "Downloads"),
        getMusicFolder: () => path.join(os.homedir(), "Music"),
        getPicturesFolder: () => path.join(os.homedir(), "Pictures"),
        getVideosFolder: () => path.join(os.homedir(), "Videos"),
        // æ–°å¢ï¼šenv-pathsæ ‡å‡†ç›®å½•
        getDataFolder: () => promptxPaths.data,
        getConfigFolder: () => promptxPaths.config,
        getCacheFolder: () => promptxPaths.cache,
        getLogFolder: () => promptxPaths.log,
        getTempFolder: () => promptxPaths.temp
      };
    };
    var UserProtocol = class extends ResourceProtocol {
      constructor(options = {}) {
        super("user", options);
        this.userDirs = {
          home: "getHomeFolder",
          desktop: "getDesktopFolder",
          documents: "getDocumentsFolder",
          downloads: "getDownloadsFolder",
          music: "getMusicFolder",
          pictures: "getPicturesFolder",
          videos: "getVideosFolder",
          // æ–°å¢ï¼šenv-pathsæ ‡å‡†ç›®å½•
          data: "getDataFolder",
          config: "getConfigFolder",
          cache: "getCacheFolder",
          log: "getLogFolder",
          temp: "getTempFolder"
        };
        this.dirCache = /* @__PURE__ */ new Map();
      }
      /**
       * è®¾ç½®æ³¨å†Œè¡¨ï¼ˆä¿æŒä¸å…¶ä»–åè®®çš„ä¸€è‡´æ€§ï¼‰
       */
      setRegistry(registry) {
        this.registry = registry || {};
      }
      /**
       * è·å–åè®®ä¿¡æ¯
       * @returns {object} åè®®ä¿¡æ¯
       */
      getProtocolInfo() {
        return {
          name: "user",
          description: "\u7528\u6237\u76EE\u5F55\u534F\u8BAE\uFF0C\u76F4\u63A5\u6620\u5C04\u5230\u7528\u6237\u4E3B\u76EE\u5F55",
          location: "user://{path}",
          examples: [
            "user://.promptx/toolbox/text-analyzer",
            "user://.bashrc",
            "user://Documents/notes.txt",
            "user://Desktop/readme.md",
            "user://Downloads/file.zip",
            "user://.promptx/config.json"
          ],
          basePath: "\u7528\u6237\u4E3B\u76EE\u5F55 (~)",
          params: this.getSupportedParams()
        };
      }
      /**
       * æ”¯æŒçš„æŸ¥è¯¢å‚æ•°
       * @returns {object} å‚æ•°è¯´æ˜
       */
      getSupportedParams() {
        return {
          ...super.getSupportedParams(),
          exists: "boolean - \u4EC5\u8FD4\u56DE\u5B58\u5728\u7684\u6587\u4EF6/\u76EE\u5F55",
          type: "string - \u8FC7\u6EE4\u7C7B\u578B (file|dir|both)"
        };
      }
      /**
       * éªŒè¯ç”¨æˆ·åè®®è·¯å¾„
       * @param {string} resourcePath - èµ„æºè·¯å¾„
       * @returns {boolean} æ˜¯å¦æœ‰æ•ˆ
       */
      validatePath(resourcePath) {
        if (!resourcePath || typeof resourcePath !== "string") {
          return false;
        }
        if (resourcePath.startsWith(".promptx/")) {
          return true;
        }
        const parts = resourcePath.split("/");
        const dirType = parts[0];
        return this.userDirs.hasOwnProperty(dirType);
      }
      /**
       * è§£æç”¨æˆ·ç›®å½•è·¯å¾„
       * @param {string} resourcePath - åŸå§‹èµ„æºè·¯å¾„ï¼Œå¦‚ ".promptx/toolbox/test-tool"
       * @param {QueryParams} queryParams - æŸ¥è¯¢å‚æ•°
       * @returns {Promise<string>} è§£æåçš„ç»å¯¹è·¯å¾„
       */
      async resolvePath(resourcePath, queryParams) {
        const userHomeDir = getUserDirectories().getHomeFolder();
        if (!resourcePath) {
          return userHomeDir;
        }
        const fullPath = path.join(userHomeDir, resourcePath);
        const resolvedPath = path.resolve(fullPath);
        const resolvedUserDir = path.resolve(userHomeDir);
        if (!resolvedPath.startsWith(resolvedUserDir)) {
          throw new Error(`\u5B89\u5168\u9519\u8BEF\uFF1A\u8DEF\u5F84\u8D85\u51FA\u7528\u6237\u76EE\u5F55\u8303\u56F4: ${resolvedPath}`);
        }
        return resolvedPath;
      }
      /**
       * è·å–ç”¨æˆ·ç›®å½•è·¯å¾„
       * @param {string} dirType - ç›®å½•ç±»å‹
       * @returns {Promise<string>} ç›®å½•è·¯å¾„
       */
      async getUserDirectory(dirType) {
        if (this.dirCache.has(dirType)) {
          return this.dirCache.get(dirType);
        }
        const userDirectories = getUserDirectories();
        const methodName = this.userDirs[dirType];
        if (!userDirectories[methodName]) {
          throw new Error(`\u672A\u627E\u5230\u7528\u6237\u76EE\u5F55\u83B7\u53D6\u65B9\u6CD5: ${methodName}`);
        }
        try {
          let dirPath;
          if (typeof userDirectories[methodName] === "function") {
            dirPath = userDirectories[methodName]();
          } else {
            dirPath = userDirectories[methodName];
          }
          this.dirCache.set(dirType, dirPath);
          return dirPath;
        } catch (error) {
          throw new Error(`\u83B7\u53D6\u7528\u6237\u76EE\u5F55\u5931\u8D25 (${dirType}): ${error.message}`);
        }
      }
      /**
       * åŠ è½½èµ„æºå†…å®¹
       * @param {string} resolvedPath - è§£æåçš„è·¯å¾„
       * @param {QueryParams} queryParams - æŸ¥è¯¢å‚æ•°
       * @returns {Promise<string>} èµ„æºå†…å®¹
       */
      async loadContent(resolvedPath, queryParams) {
        try {
          const stats = await fs.stat(resolvedPath);
          if (stats.isDirectory()) {
            return await this.loadDirectoryContent(resolvedPath, queryParams);
          } else if (stats.isFile()) {
            return await this.loadFileContent(resolvedPath, queryParams);
          } else {
            throw new Error(`\u4E0D\u652F\u6301\u7684\u6587\u4EF6\u7C7B\u578B: ${resolvedPath}`);
          }
        } catch (error) {
          if (error.code === "ENOENT") {
            if (queryParams && queryParams.get("exists") === "false") {
              return "";
            }
            throw new Error(`\u6587\u4EF6\u6216\u76EE\u5F55\u4E0D\u5B58\u5728: ${resolvedPath}`);
          }
          throw error;
        }
      }
      /**
       * åŠ è½½æ–‡ä»¶å†…å®¹
       * @param {string} filePath - æ–‡ä»¶è·¯å¾„
       * @param {QueryParams} queryParams - æŸ¥è¯¢å‚æ•°
       * @returns {Promise<string>} æ–‡ä»¶å†…å®¹
       */
      async loadFileContent(filePath, queryParams) {
        const encoding = (queryParams == null ? void 0 : queryParams.get("encoding")) || "utf8";
        return await fs.readFile(filePath, encoding);
      }
      /**
       * åŠ è½½ç›®å½•å†…å®¹
       * @param {string} dirPath - ç›®å½•è·¯å¾„
       * @param {QueryParams} queryParams - æŸ¥è¯¢å‚æ•°
       * @returns {Promise<string>} ç›®å½•å†…å®¹åˆ—è¡¨
       */
      async loadDirectoryContent(dirPath, queryParams) {
        const entries = await fs.readdir(dirPath, { withFileTypes: true });
        const typeFilter = queryParams == null ? void 0 : queryParams.get("type");
        let filteredEntries = entries;
        if (typeFilter) {
          filteredEntries = entries.filter((entry) => {
            switch (typeFilter) {
              case "file":
                return entry.isFile();
              case "dir":
                return entry.isDirectory();
              case "both":
                return true;
              default:
                return true;
            }
          });
        }
        const format = (queryParams == null ? void 0 : queryParams.get("format")) || "list";
        switch (format) {
          case "json":
            return JSON.stringify(
              filteredEntries.map((entry) => ({
                name: entry.name,
                type: entry.isDirectory() ? "directory" : "file",
                path: path.join(dirPath, entry.name)
              })),
              null,
              2
            );
          case "paths":
            return filteredEntries.map((entry) => path.join(dirPath, entry.name)).join("\n");
          case "list":
          default:
            return filteredEntries.map((entry) => {
              const type = entry.isDirectory() ? "[DIR]" : "[FILE]";
              return `${type} ${entry.name}`;
            }).join("\n");
        }
      }
      /**
       * åˆ—å‡ºæ‰€æœ‰æ”¯æŒçš„ç”¨æˆ·ç›®å½•
       * @returns {Promise<object>} ç›®å½•ä¿¡æ¯
       */
      async listUserDirectories() {
        const result = {};
        for (const dirType of Object.keys(this.userDirs)) {
          try {
            result[dirType] = await this.getUserDirectory(dirType);
          } catch (error) {
            result[dirType] = { error: error.message };
          }
        }
        return result;
      }
      /**
       * æ¸…é™¤ç›®å½•ç¼“å­˜
       */
      clearCache() {
        super.clearCache();
        this.dirCache.clear();
      }
    };
    module2.exports = UserProtocol;
  }
});

// src/resource/protocols/ProjectProtocol.js
var require_ProjectProtocol = __commonJS({
  "src/resource/protocols/ProjectProtocol.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var ResourceProtocol = require_ResourceProtocol();
    var path = require("path");
    var fs = require("fs").promises;
    var { getGlobalProjectPathResolver } = require_ProjectPathResolver();
    var ProjectManager = require_ProjectManager();
    var UserProtocol = require_UserProtocol();
    var ProjectProtocol = class extends ResourceProtocol {
      constructor(options = {}) {
        super("project", options);
        this.pathResolver = null;
        this.userProtocol = new UserProtocol(options);
      }
      /**
       * è·å–è·¯å¾„è§£æå™¨ï¼ˆå»¶è¿Ÿåˆå§‹åŒ–ï¼‰
       * @returns {ProjectPathResolver} è·¯å¾„è§£æå™¨å®ä¾‹
       */
      getPathResolver() {
        if (!this.pathResolver) {
          this.pathResolver = getGlobalProjectPathResolver();
        }
        return this.pathResolver;
      }
      /**
       * è®¾ç½®æ³¨å†Œè¡¨ï¼ˆä¿æŒä¸å…¶ä»–åè®®çš„ä¸€è‡´æ€§ï¼‰
       */
      setRegistry(registry) {
        this.registry = registry || {};
      }
      /**
       * è·å–åè®®ä¿¡æ¯
       * @returns {object} åè®®ä¿¡æ¯
       */
      getProtocolInfo() {
        return {
          name: "project",
          description: "\u9879\u76EE\u534F\u8BAE\uFF0C\u57FA\u4E8E\u5F53\u524D\u9879\u76EE\u72B6\u6001\u7684\u9AD8\u6027\u80FD\u8DEF\u5F84\u89E3\u6790",
          location: "project://{directory}/{path}",
          examples: [
            "project://src/index.js",
            "project://lib/utils.js",
            "project://docs/README.md",
            "project://root/package.json",
            "project://test/unit/"
          ],
          supportedDirectories: this.getPathResolver().getSupportedDirectories(),
          architecture: "state-based",
          params: this.getSupportedParams()
        };
      }
      /**
       * æ”¯æŒçš„æŸ¥è¯¢å‚æ•°
       * @returns {object} å‚æ•°è¯´æ˜
       */
      getSupportedParams() {
        return {
          ...super.getSupportedParams(),
          from: "string - \u6307\u5B9A\u641C\u7D22\u8D77\u59CB\u76EE\u5F55",
          create: "boolean - \u5982\u679C\u76EE\u5F55\u4E0D\u5B58\u5728\u662F\u5426\u521B\u5EFA",
          exists: "boolean - \u4EC5\u8FD4\u56DE\u5B58\u5728\u7684\u6587\u4EF6/\u76EE\u5F55",
          type: "string - \u8FC7\u6EE4\u7C7B\u578B (file|dir|both)"
        };
      }
      /**
       * éªŒè¯é¡¹ç›®åè®®è·¯å¾„
       * @param {string} resourcePath - èµ„æºè·¯å¾„
       * @returns {boolean} æ˜¯å¦æœ‰æ•ˆ
       */
      validatePath(resourcePath) {
        if (!super.validatePath(resourcePath)) {
          return false;
        }
        if (resourcePath.startsWith(".promptx/")) {
          return true;
        }
        const parts = resourcePath.split("/");
        const dirType = parts[0];
        return this.getPathResolver().isSupportedDirectory(dirType);
      }
      /**
       * è§£æé¡¹ç›®è·¯å¾„ - æ–°æ¶æ„ï¼šé«˜æ€§èƒ½é›¶æŸ¥æ‰¾ + HTTPæ¨¡å¼æ”¯æŒ
       * @param {string} resourcePath - åŸå§‹èµ„æºè·¯å¾„ï¼Œå¦‚ "src/index.js" æˆ– ".promptx/resource/..."
       * @param {QueryParams} queryParams - æŸ¥è¯¢å‚æ•°
       * @returns {Promise<string>} è§£æåçš„ç»å¯¹è·¯å¾„
       */
      async resolvePath(resourcePath, queryParams) {
        try {
          const currentProject = ProjectManager.getCurrentProject();
          const { transport } = currentProject;
          if (transport === "http") {
            return await this.resolveHttpPath(resourcePath, queryParams, currentProject);
          } else {
            return this.resolveLocalPath(resourcePath, queryParams, currentProject);
          }
        } catch (error) {
          throw new Error(`\u89E3\u6790@project://\u8DEF\u5F84\u5931\u8D25: ${error.message}`);
        }
      }
      /**
       * æœ¬åœ°æ¨¡å¼è·¯å¾„è§£æï¼ˆåŸæœ‰é€»è¾‘ï¼‰
       * @param {string} resourcePath - èµ„æºè·¯å¾„
       * @param {QueryParams} queryParams - æŸ¥è¯¢å‚æ•°
       * @param {Object} currentProject - å½“å‰é¡¹ç›®ä¿¡æ¯
       * @returns {string} è§£æåçš„ç»å¯¹è·¯å¾„
       */
      resolveLocalPath(resourcePath, queryParams, currentProject) {
        return this.getPathResolver().resolvePath(resourcePath);
      }
      /**
       * HTTPæ¨¡å¼è·¯å¾„è§£æï¼ˆæ˜ å°„åˆ°ç”¨æˆ·ç›®å½•çš„é¡¹ç›®ç©ºé—´ï¼‰
       * @param {string} resourcePath - èµ„æºè·¯å¾„ï¼Œå¦‚".promptx/resource/xxx"
       * @param {QueryParams} queryParams - æŸ¥è¯¢å‚æ•°
       * @param {Object} currentProject - å½“å‰é¡¹ç›®ä¿¡æ¯
       * @returns {Promise<string>} è§£æåçš„ç»å¯¹è·¯å¾„
       */
      async resolveHttpPath(resourcePath, queryParams, currentProject) {
        const projectHash = this.generateProjectHash(currentProject.workingDirectory);
        let mappedResourcePath = resourcePath;
        if (resourcePath === ".promptx") {
          mappedResourcePath = "data";
        } else if (resourcePath.startsWith(".promptx/")) {
          mappedResourcePath = resourcePath.replace(/^\.promptx\//, "data/");
        } else {
          mappedResourcePath = `data/${resourcePath}`;
        }
        const mappedPath = `.promptx/project/${projectHash}/${mappedResourcePath}`;
        return await this.userProtocol.resolvePath(mappedPath, queryParams);
      }
      /**
       * ç”Ÿæˆé¡¹ç›®è·¯å¾„çš„Hashå€¼ï¼ˆä¸ProjectManagerä¿æŒä¸€è‡´ï¼‰
       * @param {string} projectPath - é¡¹ç›®è·¯å¾„
       * @returns {string} 8ä½Hashå€¼
       */
      generateProjectHash(projectPath) {
        const crypto = require("crypto");
        return crypto.createHash("md5").update(path.resolve(projectPath)).digest("hex").substr(0, 8);
      }
      /**
       * åŠ è½½èµ„æºå†…å®¹
       * @param {string} resolvedPath - è§£æåçš„è·¯å¾„
       * @param {QueryParams} queryParams - æŸ¥è¯¢å‚æ•°
       * @returns {Promise<string>} èµ„æºå†…å®¹
       */
      async loadContent(resolvedPath, queryParams) {
        try {
          const currentProject = ProjectManager.getCurrentProject();
          const { transport } = currentProject;
          if (transport === "http") {
            return await this.userProtocol.loadContent(resolvedPath, queryParams);
          } else {
            return await this.loadLocalContent(resolvedPath, queryParams);
          }
        } catch (error) {
          throw error;
        }
      }
      /**
       * æœ¬åœ°æ¨¡å¼åŠ è½½èµ„æºå†…å®¹ï¼ˆåŸæœ‰é€»è¾‘ï¼‰
       * @param {string} resolvedPath - è§£æåçš„è·¯å¾„
       * @param {QueryParams} queryParams - æŸ¥è¯¢å‚æ•°
       * @returns {Promise<string>} èµ„æºå†…å®¹
       */
      async loadLocalContent(resolvedPath, queryParams) {
        try {
          const stats = await fs.stat(resolvedPath);
          if (stats.isDirectory()) {
            return await this.loadDirectoryContent(resolvedPath, queryParams);
          } else if (stats.isFile()) {
            return await this.loadFileContent(resolvedPath, queryParams);
          } else {
            throw new Error(`\u4E0D\u652F\u6301\u7684\u6587\u4EF6\u7C7B\u578B: ${resolvedPath}`);
          }
        } catch (error) {
          if (error.code === "ENOENT") {
            if ((queryParams == null ? void 0 : queryParams.get("create")) === "true") {
              await fs.mkdir(path.dirname(resolvedPath), { recursive: true });
              return "";
            }
            if ((queryParams == null ? void 0 : queryParams.get("exists")) === "false") {
              return "";
            }
            throw new Error(`\u6587\u4EF6\u6216\u76EE\u5F55\u4E0D\u5B58\u5728: ${resolvedPath}`);
          }
          throw error;
        }
      }
      /**
       * åŠ è½½æ–‡ä»¶å†…å®¹
       * @param {string} filePath - æ–‡ä»¶è·¯å¾„
       * @param {QueryParams} queryParams - æŸ¥è¯¢å‚æ•°
       * @returns {Promise<string>} æ–‡ä»¶å†…å®¹
       */
      async loadFileContent(filePath, queryParams) {
        const encoding = (queryParams == null ? void 0 : queryParams.get("encoding")) || "utf8";
        return await fs.readFile(filePath, encoding);
      }
      /**
       * åŠ è½½ç›®å½•å†…å®¹
       * @param {string} dirPath - ç›®å½•è·¯å¾„
       * @param {QueryParams} queryParams - æŸ¥è¯¢å‚æ•°
       * @returns {Promise<string>} ç›®å½•å†…å®¹åˆ—è¡¨
       */
      async loadDirectoryContent(dirPath, queryParams) {
        const entries = await fs.readdir(dirPath, { withFileTypes: true });
        const typeFilter = queryParams == null ? void 0 : queryParams.get("type");
        let filteredEntries = entries;
        if (typeFilter) {
          filteredEntries = entries.filter((entry) => {
            switch (typeFilter) {
              case "file":
                return entry.isFile();
              case "dir":
                return entry.isDirectory();
              case "both":
                return true;
              default:
                return true;
            }
          });
        }
        const format = (queryParams == null ? void 0 : queryParams.get("format")) || "list";
        switch (format) {
          case "json":
            return JSON.stringify(
              filteredEntries.map((entry) => ({
                name: entry.name,
                type: entry.isDirectory() ? "directory" : "file",
                path: path.join(dirPath, entry.name)
              })),
              null,
              2
            );
          case "paths":
            return filteredEntries.map((entry) => path.join(dirPath, entry.name)).join("\n");
          case "list":
          default:
            return filteredEntries.map((entry) => {
              const type = entry.isDirectory() ? "[DIR]" : "[FILE]";
              return `${type} ${entry.name}`;
            }).join("\n");
        }
      }
      /**
       * åˆ—å‡ºé¡¹ç›®ç»“æ„ä¿¡æ¯ - æ–°æ¶æ„
       * @returns {Promise<object>} é¡¹ç›®ä¿¡æ¯
       */
      async getProjectInfo() {
        try {
          const projectRoot = this.getPathResolver().getProjectRoot();
          const promptxPath = this.getPathResolver().getPromptXDirectory();
          const result = {
            projectRoot,
            promptxPath,
            architecture: "state-based",
            supportedDirectories: this.getPathResolver().getSupportedDirectories(),
            directories: {}
          };
          for (const dirType of this.getPathResolver().getSupportedDirectories()) {
            try {
              const fullPath = this.getPathResolver().resolvePath(dirType);
              const stats = await fs.stat(fullPath);
              result.directories[dirType] = {
                path: fullPath,
                exists: true,
                type: stats.isDirectory() ? "directory" : "file"
              };
            } catch (error) {
              result.directories[dirType] = {
                path: "N/A",
                exists: false
              };
            }
          }
          return result;
        } catch (error) {
          return {
            error: `\u83B7\u53D6\u9879\u76EE\u4FE1\u606F\u5931\u8D25: ${error.message}`,
            architecture: "state-based"
          };
        }
      }
      /**
       * æ¸…é™¤ç¼“å­˜ - æ–°æ¶æ„ï¼šæ— éœ€æ¸…é™¤è·¯å¾„ç¼“å­˜
       */
      clearCache() {
        super.clearCache();
      }
    };
    module2.exports = ProjectProtocol;
  }
});

// src/resource/protocols/RoleProtocol.js
var require_RoleProtocol = __commonJS({
  "src/resource/protocols/RoleProtocol.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var ResourceProtocol = require_ResourceProtocol();
    var fs = require("fs-extra");
    var path = require("path");
    var RoleProtocol = class extends ResourceProtocol {
      constructor() {
        super("role");
        this.registry = {};
        this.registryManager = null;
      }
      /**
       * è®¾ç½®æ³¨å†Œè¡¨ç®¡ç†å™¨
       */
      setRegistryManager(manager) {
        this.registryManager = manager;
      }
      /**
       * è®¾ç½®æ³¨å†Œè¡¨
       */
      setRegistry(registry) {
        this.registry = registry || {};
      }
      /**
       * è·å–åè®®ä¿¡æ¯
       */
      getProtocolInfo() {
        return {
          name: "role",
          description: "AI\u89D2\u8272\u8D44\u6E90\u534F\u8BAE",
          location: "role://{role_id}",
          examples: [
            "role://video-copywriter",
            "role://product-owner",
            "role://assistant",
            "role://prompt-developer"
          ]
        };
      }
      /**
       * è§£æè§’è‰²åè®®
       * @param {string} rolePath - è§’è‰²è·¯å¾„ï¼Œå¦‚ 'java-developer'
       * @param {Object} queryParams - æŸ¥è¯¢å‚æ•°ï¼ˆæš‚æœªä½¿ç”¨ï¼‰
       * @returns {Promise<string>} è§’è‰²æ–‡ä»¶å†…å®¹
       */
      async resolve(rolePath, queryParams = {}) {
        try {
          const fullResourceId = `role:${rolePath}`;
          const shortResourceId = rolePath;
          let resourceData = this.registryManager.registryData.findResourceById(rolePath, "role");
          if (!resourceData) {
            resourceData = this.registryManager.registryData.findResourceById(fullResourceId);
          }
          if (!resourceData) {
            const availableRoles = this.registryManager.registryData.getResourcesByProtocol("role").map((r) => r.id).join(", ");
            throw new Error(`\u89D2\u8272 '${rolePath}' \u672A\u627E\u5230\u3002\u53EF\u7528\u89D2\u8272: ${availableRoles}`);
          }
          const result = await this.registryManager.loadResourceByProtocol(resourceData.reference);
          return result;
        } catch (error) {
          throw new Error(`RoleProtocol.resolve failed: ${error.message}`);
        }
      }
      /**
       * åŠ è½½èµ„æºå†…å®¹
       */
      async loadContent(resolvedPath, queryParams) {
        try {
          const content = await fs.readFile(resolvedPath, "utf-8");
          return content;
        } catch (error) {
          throw new Error(`\u65E0\u6CD5\u52A0\u8F7D\u89D2\u8272\u6587\u4EF6 ${resolvedPath}: ${error.message}`);
        }
      }
      /**
       * éªŒè¯èµ„æºè·¯å¾„
       */
      validatePath(resourcePath) {
        return /^[a-zA-Z0-9_-]+$/.test(resourcePath);
      }
    };
    module2.exports = RoleProtocol;
  }
});

// src/resource/protocols/ThoughtProtocol.js
var require_ThoughtProtocol = __commonJS({
  "src/resource/protocols/ThoughtProtocol.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var ResourceProtocol = require_ResourceProtocol();
    var fs = require("fs-extra");
    var path = require("path");
    var ThoughtProtocol = class extends ResourceProtocol {
      constructor() {
        super("thought");
        this.registry = {};
        this.registryManager = null;
      }
      /**
       * è®¾ç½®æ³¨å†Œè¡¨ç®¡ç†å™¨
       */
      setRegistryManager(manager) {
        this.registryManager = manager;
      }
      /**
       * è®¾ç½®æ³¨å†Œè¡¨
       */
      setRegistry(registry) {
        this.registry = registry || {};
      }
      /**
       * è·å–åè®®ä¿¡æ¯
       */
      getProtocolInfo() {
        return {
          name: "thought",
          description: "\u601D\u7EF4\u6A21\u5F0F\u8D44\u6E90\u534F\u8BAE",
          location: "thought://{thought_id}",
          examples: [
            "thought://prompt-developer",
            "thought://product-owner"
          ]
        };
      }
      /**
       * è§£ææ€ç»´åè®®
       * @param {string} thoughtPath - æ€ç»´è·¯å¾„ï¼Œå¦‚ 'remember'
       * @param {Object} queryParams - æŸ¥è¯¢å‚æ•°ï¼ˆæš‚æœªä½¿ç”¨ï¼‰
       * @returns {Promise<string>} æ€ç»´æ–‡ä»¶å†…å®¹
       */
      async resolve(thoughtPath, queryParams = {}) {
        try {
          const fullResourceId = `thought:${thoughtPath}`;
          let resourceData = this.registryManager.registryData.findResourceById(thoughtPath, "thought");
          if (!resourceData) {
            resourceData = this.registryManager.registryData.findResourceById(fullResourceId);
          }
          if (!resourceData) {
            const availableThoughts = this.registryManager.registryData.getResourcesByProtocol("thought").map((r) => r.id).join(", ");
            throw new Error(`\u601D\u7EF4\u6A21\u5F0F '${thoughtPath}' \u672A\u627E\u5230\u3002\u53EF\u7528\u601D\u7EF4\u6A21\u5F0F: ${availableThoughts}`);
          }
          const result = await this.registryManager.loadResourceByProtocol(resourceData.reference);
          return result;
        } catch (error) {
          throw new Error(`ThoughtProtocol.resolve failed: ${error.message}`);
        }
      }
      /**
       * åŠ è½½èµ„æºå†…å®¹
       */
      async loadContent(resolvedPath, queryParams) {
        try {
          const content = await fs.readFile(resolvedPath, "utf-8");
          return content;
        } catch (error) {
          throw new Error(`\u65E0\u6CD5\u52A0\u8F7D\u601D\u7EF4\u6A21\u5F0F\u6587\u4EF6 ${resolvedPath}: ${error.message}`);
        }
      }
      /**
       * éªŒè¯èµ„æºè·¯å¾„
       */
      validatePath(resourcePath) {
        return /^[a-zA-Z0-9_-]+$/.test(resourcePath);
      }
    };
    module2.exports = ThoughtProtocol;
  }
});

// src/resource/protocols/ExecutionProtocol.js
var require_ExecutionProtocol = __commonJS({
  "src/resource/protocols/ExecutionProtocol.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var ResourceProtocol = require_ResourceProtocol();
    var fs = require("fs-extra");
    var path = require("path");
    var ExecutionProtocol = class extends ResourceProtocol {
      constructor() {
        super("execution");
        this.registry = {};
        this.registryManager = null;
      }
      /**
       * è®¾ç½®æ³¨å†Œè¡¨ç®¡ç†å™¨
       */
      setRegistryManager(manager) {
        this.registryManager = manager;
      }
      /**
       * è®¾ç½®æ³¨å†Œè¡¨
       */
      setRegistry(registry) {
        this.registry = registry || {};
      }
      /**
       * è·å–åè®®ä¿¡æ¯
       */
      getProtocolInfo() {
        return {
          name: "execution",
          description: "\u6267\u884C\u6A21\u5F0F\u8D44\u6E90\u534F\u8BAE",
          location: "execution://{execution_id}",
          examples: [
            "execution://deal-at-reference",
            "execution://prompt-developer",
            "execution://memory-trigger"
          ]
        };
      }
      /**
       * è§£ææ‰§è¡Œåè®®
       * @param {string} executionPath - æ‰§è¡Œè·¯å¾„ï¼Œå¦‚ 'best-practice'
       * @param {Object} queryParams - æŸ¥è¯¢å‚æ•°ï¼ˆæš‚æœªä½¿ç”¨ï¼‰
       * @returns {Promise<string>} æ‰§è¡Œæ–‡ä»¶å†…å®¹
       */
      async resolve(executionPath, queryParams = {}) {
        try {
          const fullResourceId = `execution:${executionPath}`;
          let resourceData = this.registryManager.registryData.findResourceById(executionPath, "execution");
          if (!resourceData) {
            resourceData = this.registryManager.registryData.findResourceById(fullResourceId);
          }
          if (!resourceData) {
            const availableExecutions = this.registryManager.registryData.getResourcesByProtocol("execution").map((r) => r.id).join(", ");
            throw new Error(`\u6267\u884C\u6A21\u5F0F '${executionPath}' \u672A\u627E\u5230\u3002\u53EF\u7528\u6267\u884C\u6A21\u5F0F: ${availableExecutions}`);
          }
          const result = await this.registryManager.loadResourceByProtocol(resourceData.reference);
          return result;
        } catch (error) {
          throw new Error(`ExecutionProtocol.resolve failed: ${error.message}`);
        }
      }
      /**
       * åŠ è½½èµ„æºå†…å®¹
       */
      async loadContent(resolvedPath, queryParams) {
        try {
          const content = await fs.readFile(resolvedPath, "utf-8");
          return content;
        } catch (error) {
          throw new Error(`\u65E0\u6CD5\u52A0\u8F7D\u6267\u884C\u6A21\u5F0F\u6587\u4EF6 ${resolvedPath}: ${error.message}`);
        }
      }
      /**
       * éªŒè¯èµ„æºè·¯å¾„
       */
      validatePath(resourcePath) {
        return /^[a-zA-Z0-9_-]+$/.test(resourcePath);
      }
    };
    module2.exports = ExecutionProtocol;
  }
});

// src/resource/protocols/KnowledgeProtocol.js
var require_KnowledgeProtocol = __commonJS({
  "src/resource/protocols/KnowledgeProtocol.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var ResourceProtocol = require_ResourceProtocol();
    var fs = require("fs-extra");
    var path = require("path");
    var KnowledgeProtocol = class extends ResourceProtocol {
      constructor() {
        super("knowledge");
        this.registry = {};
        this.registryManager = null;
      }
      /**
       * è®¾ç½®æ³¨å†Œè¡¨ç®¡ç†å™¨
       */
      setRegistryManager(manager) {
        this.registryManager = manager;
      }
      /**
       * è®¾ç½®æ³¨å†Œè¡¨
       */
      setRegistry(registry) {
        this.registry = registry || {};
      }
      /**
       * è·å–åè®®ä¿¡æ¯
       */
      getProtocolInfo() {
        return {
          name: "knowledge",
          description: "\u77E5\u8BC6\u8D44\u6E90\u534F\u8BAE",
          location: "knowledge://{knowledge_id}",
          examples: [
            "knowledge://xiaohongshu-marketing",
            "knowledge://ai-tools-guide"
          ]
        };
      }
      /**
       * è§£æçŸ¥è¯†åè®®
       * @param {string} knowledgePath - çŸ¥è¯†è·¯å¾„ï¼Œå¦‚ 'scrum'
       * @param {Object} queryParams - æŸ¥è¯¢å‚æ•°ï¼ˆæš‚æœªä½¿ç”¨ï¼‰
       * @returns {Promise<string>} çŸ¥è¯†æ–‡ä»¶å†…å®¹
       */
      async resolve(knowledgePath, queryParams = {}) {
        try {
          const fullResourceId = `knowledge:${knowledgePath}`;
          let resourceData = this.registryManager.registryData.findResourceById(knowledgePath, "knowledge");
          if (!resourceData) {
            resourceData = this.registryManager.registryData.findResourceById(fullResourceId);
          }
          if (!resourceData) {
            const availableKnowledge = this.registryManager.registryData.getResourcesByProtocol("knowledge").map((r) => r.id).join(", ");
            throw new Error(`\u77E5\u8BC6\u6A21\u5757 '${knowledgePath}' \u672A\u627E\u5230\u3002\u53EF\u7528\u77E5\u8BC6\u6A21\u5757: ${availableKnowledge}`);
          }
          const result = await this.registryManager.loadResourceByProtocol(resourceData.reference);
          return result;
        } catch (error) {
          throw new Error(`KnowledgeProtocol.resolve failed: ${error.message}`);
        }
      }
      /**
       * åŠ è½½èµ„æºå†…å®¹
       */
      async loadContent(resolvedPath, queryParams) {
        try {
          const content = await fs.readFile(resolvedPath, "utf-8");
          return content;
        } catch (error) {
          throw new Error(`\u65E0\u6CD5\u52A0\u8F7D\u77E5\u8BC6\u8D44\u6E90\u6587\u4EF6 ${resolvedPath}: ${error.message}`);
        }
      }
      /**
       * éªŒè¯èµ„æºè·¯å¾„
       */
      validatePath(resourcePath) {
        return /^[a-zA-Z0-9_-]+$/.test(resourcePath);
      }
    };
    module2.exports = KnowledgeProtocol;
  }
});

// src/resource/protocols/ToolProtocol.js
var require_ToolProtocol = __commonJS({
  "src/resource/protocols/ToolProtocol.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var ResourceProtocol = require_ResourceProtocol();
    var ToolProtocol = class extends ResourceProtocol {
      constructor() {
        super("tool");
        this.registryManager = null;
      }
      /**
       * è®¾ç½®æ³¨å†Œè¡¨ç®¡ç†å™¨å¼•ç”¨
       * @param {Object} manager - ResourceManagerå®ä¾‹
       */
      setRegistryManager(manager) {
        this.registryManager = manager;
      }
      /**
       * è§£æå·¥å…·èµ„æºè·¯å¾„
       * @param {string} toolPath - å·¥å…·åç§°ï¼Œå¦‚ "calculator"
       * @param {Object} queryParams - æŸ¥è¯¢å‚æ•°ï¼ˆå¯é€‰ï¼‰
       * @returns {Promise<Object>} å·¥å…·ä»£ç å’Œå…ƒæ•°æ®
       */
      async resolve(toolPath, queryParams = {}) {
        if (!this.registryManager) {
          throw new Error("ToolProtocol: Registry manager not set");
        }
        const toolResource = this.registryManager.registryData.findResourceById(toolPath, "tool");
        if (!toolResource) {
          throw new Error(`Tool '${toolPath}' not found in registry`);
        }
        const toolContent = await this.registryManager.loadResourceByProtocol(toolResource.reference);
        this.validateToolContent(toolContent, toolPath);
        return {
          id: toolPath,
          content: toolContent,
          metadata: toolResource,
          source: toolResource.source || "unknown"
        };
      }
      /**
       * éªŒè¯å·¥å…·å†…å®¹æ ¼å¼
       * @param {string} content - å·¥å…·æ–‡ä»¶å†…å®¹
       * @param {string} toolPath - å·¥å…·è·¯å¾„
       */
      validateToolContent(content, toolPath) {
        if (!content || typeof content !== "string") {
          throw new Error(`Tool '${toolPath}': Invalid or empty content`);
        }
        try {
          new Function(content);
        } catch (syntaxError) {
          throw new Error(`Tool '${toolPath}': JavaScript syntax error - ${syntaxError.message}`);
        }
      }
      /**
       * è·å–åè®®ä¿¡æ¯
       * @returns {Object} åè®®æè¿°ä¿¡æ¯
       */
      getProtocolInfo() {
        return {
          name: "tool",
          description: "Tool\u8D44\u6E90\u534F\u8BAE - \u52A0\u8F7D\u53EF\u6267\u884C\u7684JavaScript\u5DE5\u5177",
          syntax: "tool://{tool_id}",
          examples: [
            "tool://calculator",
            "tool://send-email",
            "tool://data-processor",
            "tool://api-client"
          ],
          supportedFileTypes: [".tool.js"],
          usageNote: "\u5DE5\u5177\u6587\u4EF6\u5FC5\u987B\u5BFC\u51FA\u7B26\u5408PromptX Tool Interface\u7684\u5BF9\u8C61"
        };
      }
      /**
       * æ£€æŸ¥ç¼“å­˜ç­–ç•¥
       * @param {string} toolPath - å·¥å…·è·¯å¾„
       * @returns {boolean} æ˜¯å¦åº”è¯¥ç¼“å­˜
       */
      shouldCache(toolPath) {
        return true;
      }
      /**
       * è·å–ç¼“å­˜é”®
       * @param {string} toolPath - å·¥å…·è·¯å¾„
       * @returns {string} ç¼“å­˜é”®
       */
      getCacheKey(toolPath) {
        return `tool://${toolPath}`;
      }
    };
    module2.exports = ToolProtocol;
  }
});

// src/resource/protocols/ManualProtocol.js
var require_ManualProtocol = __commonJS({
  "src/resource/protocols/ManualProtocol.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var ResourceProtocol = require_ResourceProtocol();
    var ManualProtocol = class extends ResourceProtocol {
      constructor() {
        super("manual");
        this.registryManager = null;
      }
      /**
       * è®¾ç½®æ³¨å†Œè¡¨ç®¡ç†å™¨å¼•ç”¨
       * @param {Object} manager - ResourceManagerå®ä¾‹
       */
      setRegistryManager(manager) {
        this.registryManager = manager;
      }
      /**
       * è§£æå·¥å…·æ‰‹å†Œèµ„æºè·¯å¾„
       * @param {string} manualPath - æ‰‹å†Œåç§°ï¼Œå¦‚ "calculator"
       * @param {Object} queryParams - æŸ¥è¯¢å‚æ•°ï¼ˆå¯é€‰ï¼‰
       * @returns {Promise<Object>} æ‰‹å†Œå†…å®¹å’Œå…ƒæ•°æ®
       */
      async resolve(manualPath, queryParams = {}) {
        if (!this.registryManager) {
          throw new Error("ManualProtocol: Registry manager not set");
        }
        const manualResource = this.registryManager.registryData.findResourceById(manualPath, "manual");
        if (!manualResource) {
          const toolResource = this.registryManager.registryData.findResourceById(manualPath, "tool");
          if (toolResource) {
            throw new Error(`Manual '${manualPath}' not found. Found corresponding tool but no manual. Consider creating ${manualPath}.manual.md`);
          }
          throw new Error(`Manual '${manualPath}' not found in registry`);
        }
        const manualContent = await this.registryManager.loadResourceByProtocol(manualResource.reference);
        this.validateManualContent(manualContent, manualPath);
        return {
          id: manualPath,
          content: manualContent,
          metadata: manualResource,
          source: manualResource.source || "unknown"
        };
      }
      /**
       * éªŒè¯æ‰‹å†Œå†…å®¹æ ¼å¼
       * @param {string} content - æ‰‹å†Œæ–‡ä»¶å†…å®¹
       * @param {string} manualPath - æ‰‹å†Œè·¯å¾„
       */
      validateManualContent(content, manualPath) {
        if (!content || typeof content !== "string") {
          throw new Error(`Manual '${manualPath}': Invalid or empty content`);
        }
        const trimmedContent = content.trim();
        if (trimmedContent.length === 0) {
          throw new Error(`Manual '${manualPath}': Empty manual content`);
        }
        if (!trimmedContent.includes("<manual>") || !trimmedContent.includes("</manual>")) {
          throw new Error(`Manual '${manualPath}': Missing required <manual> tags`);
        }
      }
      /**
       * è·å–åè®®ä¿¡æ¯
       * @returns {Object} åè®®æè¿°ä¿¡æ¯
       */
      getProtocolInfo() {
        return {
          name: "manual",
          description: "Manual\u8D44\u6E90\u534F\u8BAE - \u52A0\u8F7D\u5DE5\u5177\u4F7F\u7528\u624B\u518C\u548C\u8BF4\u660E\u6587\u6863",
          syntax: "manual://{manual_id}",
          examples: [
            "manual://calculator",
            "manual://send-email",
            "manual://data-processor",
            "manual://api-client"
          ],
          supportedFileTypes: [".manual.md"],
          usageNote: "\u624B\u518C\u6587\u4EF6\u5FC5\u987B\u4F7F\u7528<manual>\u6807\u7B7E\u5305\u88F9\u5185\u5BB9\uFF0C\u63D0\u4F9B\u5DE5\u5177\u7684\u8BE6\u7EC6\u4F7F\u7528\u8BF4\u660E"
        };
      }
      /**
       * æ£€æŸ¥ç¼“å­˜ç­–ç•¥
       * @param {string} manualPath - æ‰‹å†Œè·¯å¾„
       * @returns {boolean} æ˜¯å¦åº”è¯¥ç¼“å­˜
       */
      shouldCache(manualPath) {
        return true;
      }
      /**
       * è·å–ç¼“å­˜é”®
       * @param {string} manualPath - æ‰‹å†Œè·¯å¾„
       * @returns {string} ç¼“å­˜é”®
       */
      getCacheKey(manualPath) {
        return `manual://${manualPath}`;
      }
    };
    module2.exports = ManualProtocol;
  }
});

// src/resource/protocols/FileProtocol.js
var require_FileProtocol = __commonJS({
  "src/resource/protocols/FileProtocol.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var ResourceProtocol = require_ResourceProtocol();
    var path = require("path");
    var fs = require("fs").promises;
    var FileProtocol = class extends ResourceProtocol {
      constructor(options = {}) {
        super("file", options);
      }
      /**
       * è®¾ç½®æ³¨å†Œè¡¨ï¼ˆä¿æŒä¸å…¶ä»–åè®®çš„ä¸€è‡´æ€§ï¼‰
       */
      setRegistry(registry) {
        this.registry = registry || {};
      }
      /**
       * è·å–åè®®ä¿¡æ¯
       * @returns {object} åè®®ä¿¡æ¯
       */
      getProtocolInfo() {
        return {
          name: "file",
          description: "\u6587\u4EF6\u7CFB\u7EDF\u534F\u8BAE\uFF0C\u63D0\u4F9B\u672C\u5730\u6587\u4EF6\u8BBF\u95EE",
          location: "file://{path}",
          examples: [
            "file://package.json",
            "file:///absolute/path/to/file.txt",
            "file://./relative/path/file.md",
            "file://../parent/file.json"
          ],
          params: this.getSupportedParams()
        };
      }
      /**
       * æ”¯æŒçš„æŸ¥è¯¢å‚æ•°
       * @returns {object} å‚æ•°è¯´æ˜
       */
      getSupportedParams() {
        return {
          ...super.getSupportedParams(),
          encoding: "string - \u6587\u4EF6\u7F16\u7801 (utf8, ascii, binary\u7B49)",
          exists: "boolean - \u4EC5\u8FD4\u56DE\u5B58\u5728\u7684\u6587\u4EF6"
        };
      }
      /**
       * éªŒè¯æ–‡ä»¶åè®®è·¯å¾„
       * @param {string} resourcePath - èµ„æºè·¯å¾„
       * @returns {boolean} æ˜¯å¦æœ‰æ•ˆ
       */
      validatePath(resourcePath) {
        if (!super.validatePath(resourcePath)) {
          return false;
        }
        return typeof resourcePath === "string" && resourcePath.length > 0;
      }
      /**
       * è§£ææ–‡ä»¶è·¯å¾„
       * @param {string} resourcePath - åŸå§‹èµ„æºè·¯å¾„
       * @param {QueryParams} queryParams - æŸ¥è¯¢å‚æ•°
       * @returns {Promise<string>} è§£æåçš„ç»å¯¹è·¯å¾„
       */
      async resolvePath(resourcePath, queryParams) {
        let resolvedPath;
        if (path.isAbsolute(resourcePath)) {
          resolvedPath = resourcePath;
        } else {
          resolvedPath = path.resolve(process.cwd(), resourcePath);
        }
        resolvedPath = path.normalize(resolvedPath);
        return resolvedPath;
      }
      /**
       * åŠ è½½èµ„æºå†…å®¹
       * @param {string} resolvedPath - è§£æåçš„è·¯å¾„
       * @param {QueryParams} queryParams - æŸ¥è¯¢å‚æ•°
       * @returns {Promise<string>} èµ„æºå†…å®¹
       */
      async loadContent(resolvedPath, queryParams) {
        try {
          const stats = await fs.stat(resolvedPath);
          if (stats.isDirectory()) {
            return await this.loadDirectoryContent(resolvedPath, queryParams);
          } else if (stats.isFile()) {
            return await this.loadFileContent(resolvedPath, queryParams);
          } else {
            throw new Error(`\u4E0D\u652F\u6301\u7684\u6587\u4EF6\u7C7B\u578B: ${resolvedPath}`);
          }
        } catch (error) {
          if (error.code === "ENOENT") {
            if (queryParams && queryParams.get("exists") === "false") {
              return "";
            }
            throw new Error(`\u6587\u4EF6\u6216\u76EE\u5F55\u4E0D\u5B58\u5728: ${resolvedPath}`);
          }
          throw error;
        }
      }
      /**
       * åŠ è½½æ–‡ä»¶å†…å®¹
       * @param {string} filePath - æ–‡ä»¶è·¯å¾„
       * @param {QueryParams} queryParams - æŸ¥è¯¢å‚æ•°
       * @returns {Promise<string>} æ–‡ä»¶å†…å®¹
       */
      async loadFileContent(filePath, queryParams) {
        const encoding = (queryParams == null ? void 0 : queryParams.get("encoding")) || "utf8";
        return await fs.readFile(filePath, encoding);
      }
      /**
       * åŠ è½½ç›®å½•å†…å®¹
       * @param {string} dirPath - ç›®å½•è·¯å¾„
       * @param {QueryParams} queryParams - æŸ¥è¯¢å‚æ•°
       * @returns {Promise<string>} ç›®å½•å†…å®¹åˆ—è¡¨
       */
      async loadDirectoryContent(dirPath, queryParams) {
        const entries = await fs.readdir(dirPath, { withFileTypes: true });
        const typeFilter = queryParams == null ? void 0 : queryParams.get("type");
        let filteredEntries = entries;
        if (typeFilter) {
          filteredEntries = entries.filter((entry) => {
            switch (typeFilter) {
              case "file":
                return entry.isFile();
              case "dir":
                return entry.isDirectory();
              case "both":
                return true;
              default:
                return true;
            }
          });
        }
        const format = (queryParams == null ? void 0 : queryParams.get("format")) || "list";
        switch (format) {
          case "json":
            return JSON.stringify(
              filteredEntries.map((entry) => ({
                name: entry.name,
                type: entry.isDirectory() ? "directory" : "file",
                path: path.join(dirPath, entry.name)
              })),
              null,
              2
            );
          case "paths":
            return filteredEntries.map((entry) => path.join(dirPath, entry.name)).join("\n");
          case "list":
          default:
            return filteredEntries.map((entry) => {
              const type = entry.isDirectory() ? "[DIR]" : "[FILE]";
              return `${type} ${entry.name}`;
            }).join("\n");
        }
      }
    };
    module2.exports = FileProtocol;
  }
});

// src/resource/resourceManager.js
var require_resourceManager = __commonJS({
  "src/resource/resourceManager.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var fs = require("fs");
    var RegistryData = require_RegistryData();
    var ResourceProtocolParser = require_resourceProtocolParser();
    var DiscoveryManager = require_DiscoveryManager();
    var logger = require("@promptx/logger");
    var PackageProtocol = require_PackageProtocol();
    var ProjectProtocol = require_ProjectProtocol();
    var RoleProtocol = require_RoleProtocol();
    var ThoughtProtocol = require_ThoughtProtocol();
    var ExecutionProtocol = require_ExecutionProtocol();
    var KnowledgeProtocol = require_KnowledgeProtocol();
    var ToolProtocol = require_ToolProtocol();
    var ManualProtocol = require_ManualProtocol();
    var UserProtocol = require_UserProtocol();
    var FileProtocol = require_FileProtocol();
    var ResourceManager = class {
      constructor() {
        this.registryData = RegistryData.createEmpty("merged", null);
        this.protocolParser = new ResourceProtocolParser();
        this.parser = new ResourceProtocolParser();
        this.discoveryManager = new DiscoveryManager();
        this.protocols = /* @__PURE__ */ new Map();
        this.initializeProtocols();
      }
      /**
       * åˆå§‹åŒ–æ‰€æœ‰åè®®å¤„ç†å™¨
       */
      initializeProtocols() {
        this.protocols.set("package", new PackageProtocol());
        this.protocols.set("project", new ProjectProtocol());
        this.protocols.set("file", new FileProtocol());
        this.protocols.set("user", new UserProtocol());
        this.protocols.set("role", new RoleProtocol());
        this.protocols.set("thought", new ThoughtProtocol());
        this.protocols.set("execution", new ExecutionProtocol());
        this.protocols.set("knowledge", new KnowledgeProtocol());
        this.protocols.set("tool", new ToolProtocol());
        this.protocols.set("manual", new ManualProtocol());
      }
      /**
       * æ–°æ¶æ„åˆå§‹åŒ–æ–¹æ³•
       */
      async initializeWithNewArchitecture() {
        try {
          logger.info("[ResourceManager] Starting initialization...");
          this.registryData.clear();
          logger.info("[ResourceManager] Cleared existing registry");
          if (this.discoveryManager && typeof this.discoveryManager.clearCache === "function") {
            this.discoveryManager.clearCache();
            logger.info("[ResourceManager] Cleared discovery cache");
          }
          logger.info("[ResourceManager] Populating registry data...");
          await this.populateRegistryData();
          this.setupLogicalProtocols();
          this.initialized = true;
          const stats = this.registryData.getStats();
          logger.info("[ResourceManager] Initialization complete:", {
            totalResources: this.registryData.size,
            bySource: stats.bySource,
            byProtocol: stats.byProtocol
          });
        } catch (error) {
          logger.warn(`ResourceManager new architecture initialization failed: ${error.message}`);
          logger.warn("ResourceManager continuing with empty registry");
          this.initialized = true;
        }
      }
      /**
       * å¡«å……æ–°çš„RegistryData
       */
      async populateRegistryData() {
        this.registryData.clear();
        logger.info("[ResourceManager] Discovery managers:", {
          count: this.discoveryManager.discoveries.length,
          sources: this.discoveryManager.discoveries.map((d) => d.source)
        });
        for (const discovery of this.discoveryManager.discoveries) {
          try {
            logger.info(`[ResourceManager] Loading from ${discovery.source} discovery...`);
            if (typeof discovery.getRegistryData === "function") {
              const registryData = await discovery.getRegistryData();
              if (registryData && registryData.resources) {
                const resourceCount = registryData.size || 0;
                logger.info(`[ResourceManager] Found ${resourceCount} resources from ${discovery.source}`);
                this.registryData.merge(registryData, true);
                if (discovery.source === "USER" && registryData.resources) {
                  logger.debug(`[ResourceManager] USER resources to merge:`, registryData.resources.map((r) => `${r.protocol}://${r.id}`));
                }
                logger.info(`[ResourceManager] After merging ${discovery.source}, total: ${this.registryData.size}`);
              } else {
                logger.info(`[ResourceManager] No resources found from ${discovery.source}`);
              }
            } else {
              logger.info(`[ResourceManager] ${discovery.source} does not support getRegistryData`);
            }
          } catch (error) {
            logger.warn(`Failed to get RegistryData from ${discovery.source}: ${error.message}`);
          }
        }
        logger.info("[ResourceManager] Registry population complete, total resources:", this.registryData.size);
      }
      /**
       * ä¸ºé€»è¾‘åè®®è®¾ç½®æ³¨å†Œè¡¨å¼•ç”¨
       */
      setupLogicalProtocols() {
        const roleProtocol = this.protocols.get("role");
        const executionProtocol = this.protocols.get("execution");
        const thoughtProtocol = this.protocols.get("thought");
        const knowledgeProtocol = this.protocols.get("knowledge");
        const toolProtocol = this.protocols.get("tool");
        const manualProtocol = this.protocols.get("manual");
        if (roleProtocol) {
          roleProtocol.setRegistryManager(this);
        }
        if (executionProtocol) {
          executionProtocol.setRegistryManager(this);
        }
        if (thoughtProtocol) {
          thoughtProtocol.setRegistryManager(this);
        }
        if (knowledgeProtocol) {
          knowledgeProtocol.setRegistryManager(this);
        }
        if (toolProtocol) {
          toolProtocol.setRegistryManager(this);
        }
        if (manualProtocol) {
          manualProtocol.setRegistryManager(this);
        }
      }
      /**
       * é€šè¿‡åè®®è§£æåŠ è½½èµ„æºå†…å®¹
       * @param {string} reference - èµ„æºå¼•ç”¨
       * @returns {Promise<string>} èµ„æºå†…å®¹
       */
      async loadResourceByProtocol(reference) {
        const parsed = this.protocolParser.parse(reference);
        const protocol = this.protocols.get(parsed.protocol);
        if (!protocol) {
          throw new Error(`\u4E0D\u652F\u6301\u7684\u534F\u8BAE: ${parsed.protocol}`);
        }
        const result = await protocol.resolve(parsed.path, parsed.queryParams);
        if (typeof result === "string") {
          return result;
        } else if (result && typeof result === "object" && result.content) {
          return result.content;
        } else {
          throw new Error(`\u534F\u8BAE${parsed.protocol}\u8FD4\u56DE\u4E86\u65E0\u6548\u7684\u5185\u5BB9\u683C\u5F0F`);
        }
      }
      async loadResource(resourceId) {
        try {
          if (!this.initialized) {
            logger.info("[ResourceManager] Initializing resource manager...");
            await this.initializeWithNewArchitecture();
          }
          if (resourceId.startsWith("@")) {
            const parsed = this.protocolParser.parse(resourceId);
            const basicProtocols = ["file", "user", "package", "project"];
            if (basicProtocols.includes(parsed.protocol)) {
              const content3 = await this.loadResourceByProtocol(resourceId);
              return {
                success: true,
                content: content3,
                resourceId,
                reference: resourceId
              };
            }
            logger.debug(`[ResourceManager] Finding resource: protocol=${parsed.protocol}, id=${parsed.path}`);
            const resourceData = this.registryData.findResourceById(parsed.path, parsed.protocol);
            if (!resourceData) {
              const availableResources = this.registryData.getResourcesByProtocol(parsed.protocol);
              logger.error(`[ResourceManager] Resource not found: ${parsed.protocol}:${parsed.path}`);
              logger.error(`[ResourceManager] Available ${parsed.protocol} resources:`, availableResources.map((r) => `${r.id} (${r.source})`));
              throw new Error(`Resource not found: ${parsed.protocol}:${parsed.path}`);
            }
            logger.debug(`[ResourceManager] Found resource: ${resourceData.id} from ${resourceData.source}`);
            const content2 = await this.loadResourceByProtocol(resourceData.reference);
            return {
              success: true,
              content: content2,
              resourceId,
              reference: resourceData.reference
            };
          }
          const urlMatch = resourceId.match(/^([a-zA-Z][a-zA-Z0-9_-]*):\/\/(.+)$/);
          if (urlMatch) {
            const [, protocol, id] = urlMatch;
            const resourceData = this.registryData.findResourceById(id, protocol);
            if (!resourceData) {
              throw new Error(`Resource not found: ${resourceId}`);
            }
            const content2 = await this.loadResourceByProtocol(resourceData.reference);
            return {
              success: true,
              content: content2,
              resourceId,
              reference: resourceData.reference
            };
          }
          let reference = null;
          if (resourceId.includes(":")) {
            const [protocol, id] = resourceId.split(":", 2);
            const resourceData = this.registryData.findResourceById(id, protocol);
            if (resourceData) {
              reference = resourceData.reference;
            }
          } else {
            const resourceData = this.registryData.findResourceById(resourceId);
            if (resourceData) {
              reference = resourceData.reference;
            }
          }
          if (!reference) {
            throw new Error(`Resource not found: ${resourceId}`);
          }
          const content = await this.loadResourceByProtocol(reference);
          return {
            success: true,
            content,
            resourceId,
            reference
          };
        } catch (error) {
          logger.debug(`ResourceManager.loadResource failed for ${resourceId}: ${error.message}`);
          return {
            success: false,
            error,
            // è¿”å›å®Œæ•´çš„Errorå¯¹è±¡ï¼Œè€Œä¸æ˜¯messageå­—ç¬¦ä¸²
            resourceId
          };
        }
      }
      /**
       * è§£æåè®®å¼•ç”¨å¹¶è¿”å›ç›¸å…³ä¿¡æ¯
       */
      async resolveProtocolReference(reference) {
        try {
          const parsed = this.protocolParser.parse(reference);
          return {
            success: true,
            protocol: parsed.protocol,
            path: parsed.path,
            queryParams: parsed.queryParams,
            reference
          };
        } catch (error) {
          return {
            success: false,
            error: error.message,
            reference
          };
        }
      }
      /**
       * è·å–æ‰€æœ‰å¯ç”¨çš„åè®®åˆ—è¡¨
       */
      getAvailableProtocols() {
        return Array.from(this.protocols.keys());
      }
      /**
       * æ£€æŸ¥æ˜¯å¦æ”¯æŒæŒ‡å®šåè®®
       */
      supportsProtocol(protocol) {
        return this.protocols.has(protocol);
      }
      /**
       * è®¾ç½®åˆå§‹åŒ–çŠ¶æ€
       */
      set initialized(value) {
        this._initialized = value;
      }
      /**
       * è·å–åˆå§‹åŒ–çŠ¶æ€
       */
      get initialized() {
        return this._initialized || false;
      }
      /**
       * è§£æèµ„æºURLï¼ˆå‘åå…¼å®¹æ¥å£ï¼‰
       * è¿”å›æ ¼å¼ï¼š{success: boolean, content?: string, error?: Error}
       */
      async resolve(resourceUrl) {
        return await this.loadResource(resourceUrl);
      }
      /**
       * è·å–æ³¨å†Œè¡¨ç»Ÿè®¡ä¿¡æ¯
       */
      getStats() {
        return {
          totalResources: this.registryData.size,
          protocols: this.getAvailableProtocols(),
          initialized: this.initialized
        };
      }
      /**
       * åˆ·æ–°èµ„æºï¼ˆé‡æ–°å‘ç°å¹¶æ³¨å†Œï¼‰
       */
      async refreshResources() {
        try {
          this.initialized = false;
          this.registryData.clear();
          if (this.discoveryManager && typeof this.discoveryManager.clearCache === "function") {
            this.discoveryManager.clearCache();
          }
          await this.initializeWithNewArchitecture();
        } catch (error) {
          logger.warn(`ResourceManager resource refresh failed: ${error.message}`);
        }
      }
    };
    module2.exports = ResourceManager;
  }
});

// src/resource/index.js
var require_resource = __commonJS({
  "src/resource/index.js"(exports2, module2) {
    init_cjs_shims();
    var ResourceManager = require_resourceManager();
    var ResourceProtocolParser = require_resourceProtocolParser();
    var {
      LoadingSemantics,
      ParsedReference,
      QueryParams,
      NestedReference,
      ResourceContent,
      LazyResource,
      ProcessedResult,
      ResourceResult,
      ProtocolInfo
    } = require_types();
    var globalResourceManager = null;
    function getGlobalResourceManager() {
      if (!globalResourceManager) {
        globalResourceManager = new ResourceManager();
      }
      return globalResourceManager;
    }
    function resetGlobalResourceManager() {
      globalResourceManager = null;
    }
    module2.exports = {
      // ä¸»ç®¡ç†å™¨ç±»
      ResourceManager,
      // å…¨å±€å•ä¾‹å®ä¾‹
      getGlobalResourceManager,
      resetGlobalResourceManager,
      // æ ¸å¿ƒç»„ä»¶
      ResourceProtocolParser,
      // æ•°æ®ç±»å‹
      LoadingSemantics,
      ParsedReference,
      QueryParams,
      NestedReference,
      ResourceContent,
      LazyResource,
      ProcessedResult,
      ResourceResult,
      ProtocolInfo,
      // ä¾¿æ·æ–¹æ³• - åˆ›å»ºé»˜è®¤å®ä¾‹ï¼ˆä¿æŒå‘åå…¼å®¹ï¼‰
      createManager: (options) => new ResourceManager(options),
      // ä¾¿æ·æ–¹æ³• - å¿«é€Ÿè§£æ
      parse: (resourceRef) => {
        const parser = new ResourceProtocolParser();
        return parser.parse(resourceRef);
      },
      // ä¾¿æ·æ–¹æ³• - å¿«é€ŸéªŒè¯
      validate: (resourceRef) => {
        try {
          const parser = new ResourceProtocolParser();
          parser.parse(resourceRef);
          return true;
        } catch (error) {
          return false;
        }
      }
    };
  }
});
module.exports = require_resource();
//# sourceMappingURL=resource.js.map