"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));

// ../../node_modules/.pnpm/tsup@8.5.0_jiti@2.5.1_postcss@8.5.6_tsx@4.20.5_typescript@5.9.2_yaml@2.8.1/node_modules/tsup/assets/cjs_shims.js
var init_cjs_shims = __esm({
  "../../node_modules/.pnpm/tsup@8.5.0_jiti@2.5.1_postcss@8.5.6_tsx@4.20.5_typescript@5.9.2_yaml@2.8.1/node_modules/tsup/assets/cjs_shims.js"() {
    "use strict";
  }
});

// src/utils/ServerEnvironment.js
var require_ServerEnvironment = __commonJS({
  "src/utils/ServerEnvironment.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var ServerEnvironment = class {
      constructor() {
        this.transport = null;
        this.host = null;
        this.port = null;
        this.processId = null;
        this.initialized = false;
      }
      /**
       * 初始化服务环境（各启动渠道调用一次）
       * @param {Object} config - 配置对象
       * @param {string} config.transport - 传输协议
       * @param {string} config.host - 主机地址（可选）
       * @param {number} config.port - 端口号（可选）
       */
      initialize(config) {
        this.transport = config.transport;
        this.host = config.host || null;
        this.port = config.port || null;
        this.processId = process.pid;
        this.initialized = true;
      }
      /**
       * 获取MCP ID（基于processId生成）
       * @returns {string} MCP进程ID
       */
      getMcpId() {
        if (!this.initialized) {
          throw new Error("ServerEnvironment not initialized");
        }
        return `mcp-${this.processId}`;
      }
      /**
       * 获取传输协议
       * @returns {string} transport类型
       */
      getTransport() {
        if (!this.initialized) {
          throw new Error("ServerEnvironment not initialized");
        }
        return this.transport;
      }
      /**
       * 获取服务器地址信息（仅HTTP/SSE模式）
       * @returns {Object|null} {host, port} 或 null
       */
      getServerAddress() {
        if (!this.initialized) {
          throw new Error("ServerEnvironment not initialized");
        }
        if (this.transport === "stdio") {
          return null;
        }
        return {
          host: this.host,
          port: this.port
        };
      }
      /**
       * 检查是否已初始化
       * @returns {boolean}
       */
      isInitialized() {
        return this.initialized;
      }
    };
    var globalServerEnvironment = null;
    function getGlobalServerEnvironment() {
      if (!globalServerEnvironment) {
        globalServerEnvironment = new ServerEnvironment();
      }
      return globalServerEnvironment;
    }
    module2.exports = ServerEnvironment;
    module2.exports.getGlobalServerEnvironment = getGlobalServerEnvironment;
  }
});

// src/utils/ProjectManager.js
var require_ProjectManager = __commonJS({
  "src/utils/ProjectManager.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var fs = require("fs-extra");
    var path = require("path");
    var os = require("os");
    var crypto = require("crypto");
    var { getGlobalServerEnvironment } = require_ServerEnvironment();
    var logger = require("@promptx/logger");
    var ProjectManager = class {
      constructor() {
        this.promptxHomeDir = path.join(os.homedir(), ".promptx");
        this.projectsDir = path.join(this.promptxHomeDir, "project");
      }
      // 🎯 新架构：当前项目状态管理
      static currentProject = {
        workingDirectory: null,
        mcpId: null,
        ideType: null,
        transport: null,
        initialized: false
      };
      /**
       * 设置当前项目（init时调用）
       * @param {string} workingDirectory - 项目工作目录绝对路径
       * @param {string} mcpId - MCP进程ID
       * @param {string} ideType - IDE类型
       * @param {string} transport - 传输协议类型
       */
      static setCurrentProject(workingDirectory, mcpId, ideType, transport) {
        this.currentProject = {
          workingDirectory: path.resolve(workingDirectory),
          mcpId,
          ideType,
          transport,
          initialized: true
        };
      }
      /**
       * 获取当前项目路径（@project协议使用）
       * @returns {string} 当前项目工作目录
       */
      static getCurrentProjectPath() {
        logger.debug(`[ProjectManager DEBUG] getCurrentProjectPath\u88AB\u8C03\u7528`);
        logger.debug(`[ProjectManager DEBUG] currentProject.initialized: ${this.currentProject.initialized}`);
        logger.debug(`[ProjectManager DEBUG] currentProject\u72B6\u6001:`, JSON.stringify(this.currentProject, null, 2));
        const stack = new Error().stack;
        const stackLines = stack.split("\n").slice(1, 8);
        logger.error(`[ProjectManager DEBUG] \u5B8C\u6574\u8C03\u7528\u6808:`);
        stackLines.forEach((line, index) => {
          logger.error(`[ProjectManager DEBUG]   ${index + 1}. ${line.trim()}`);
        });
        if (!this.currentProject.initialized) {
          logger.error(`[ProjectManager DEBUG] \u274C \u9879\u76EE\u672A\u521D\u59CB\u5316\uFF0C\u5C06\u629B\u51FA\u9519\u8BEF`);
          throw new Error("\u9879\u76EE\u672A\u521D\u59CB\u5316\uFF0C\u8BF7\u5148\u8C03\u7528 init \u547D\u4EE4");
        }
        logger.debug(`[ProjectManager DEBUG] \u2705 \u8FD4\u56DE\u9879\u76EE\u8DEF\u5F84: ${this.currentProject.workingDirectory}`);
        return this.currentProject.workingDirectory;
      }
      /**
       * 获取当前项目信息
       * @returns {Object} 当前项目完整信息
       */
      static getCurrentProject() {
        logger.debug(`[ProjectManager DEBUG] getCurrentProject\u88AB\u8C03\u7528`);
        logger.debug(`[ProjectManager DEBUG] currentProject.initialized: ${this.currentProject.initialized}`);
        logger.debug(`[ProjectManager DEBUG] currentProject\u72B6\u6001:`, JSON.stringify(this.currentProject, null, 2));
        if (!this.currentProject.initialized) {
          logger.error(`[ProjectManager DEBUG] \u274C \u9879\u76EE\u672A\u521D\u59CB\u5316\uFF0C\u5C06\u629B\u51FA\u9519\u8BEF`);
          throw new Error("\u9879\u76EE\u672A\u521D\u59CB\u5316\uFF0C\u8BF7\u5148\u8C03\u7528 init \u547D\u4EE4");
        }
        logger.debug(`[ProjectManager DEBUG] \u2705 \u8FD4\u56DE\u9879\u76EE\u4FE1\u606F`);
        return { ...this.currentProject };
      }
      /**
       * 检查项目是否已初始化
       * @returns {boolean} 是否已初始化
       */
      static isInitialized() {
        return this.currentProject.initialized;
      }
      /**
       * 注册项目到MCP实例 - 使用Hash目录结构
       * @param {string} projectPath - 项目绝对路径
       * @param {string} mcpId - MCP进程ID
       * @param {string} ideType - IDE类型（cursor/vscode等）
       * @param {string} transport - 传输协议类型（stdio/http/sse）
       * @returns {Promise<Object>} 项目配置对象
       */
      async registerProject(projectPath, mcpId, ideType, transport = "stdio") {
        if (!await this.validateProjectPath(projectPath)) {
          throw new Error(`\u65E0\u6548\u7684\u9879\u76EE\u8DEF\u5F84: ${projectPath}`);
        }
        const projectConfig = {
          mcpId,
          ideType: ideType.toLowerCase(),
          transport: transport.toLowerCase(),
          projectPath: path.resolve(projectPath),
          projectHash: this.generateProjectHash(projectPath)
        };
        const projectHash = this.generateProjectHash(projectPath);
        const projectConfigDir = path.join(this.projectsDir, projectHash);
        await fs.ensureDir(projectConfigDir);
        await fs.ensureDir(path.join(projectConfigDir, ".promptx"));
        await fs.ensureDir(path.join(projectConfigDir, ".promptx", "memory"));
        await fs.ensureDir(path.join(projectConfigDir, ".promptx", "resource"));
        const fileName = this.generateConfigFileName(mcpId, ideType, transport, projectPath);
        const configPath = path.join(projectConfigDir, fileName);
        await fs.writeJson(configPath, projectConfig, { spaces: 2 });
        return projectConfig;
      }
      /**
       * 根据MCP ID获取单个项目配置（假设只有一个项目）
       * @param {string} mcpId - MCP进程ID
       * @returns {Promise<Object|null>} 项目配置对象
       */
      async getProjectByMcpId(mcpId) {
        const projects = await this.getProjectsByMcpId(mcpId);
        return projects.length > 0 ? projects[0] : null;
      }
      /**
       * 根据MCP ID获取所有绑定的项目配置 - 支持Hash目录结构
       * @param {string} mcpId - MCP进程ID
       * @returns {Promise<Array>} 项目配置数组
       */
      async getProjectsByMcpId(mcpId) {
        if (!await fs.pathExists(this.projectsDir)) {
          return [];
        }
        const hashDirs = await fs.readdir(this.projectsDir);
        const projects = [];
        for (const hashDir of hashDirs) {
          const hashDirPath = path.join(this.projectsDir, hashDir);
          if (!(await fs.stat(hashDirPath)).isDirectory()) {
            continue;
          }
          try {
            const configFiles = await fs.readdir(hashDirPath);
            for (const file of configFiles) {
              if (file.startsWith("mcp-") && file.endsWith(".json")) {
                try {
                  const configPath = path.join(hashDirPath, file);
                  const config = await fs.readJson(configPath);
                  if (config.mcpId === mcpId) {
                    projects.push(config);
                  }
                } catch (error) {
                  logger.warn(`\u8DF3\u8FC7\u635F\u574F\u7684\u914D\u7F6E\u6587\u4EF6: ${file}`);
                }
              }
            }
          } catch (error) {
            logger.warn(`\u8DF3\u8FC7\u65E0\u6CD5\u8BFB\u53D6\u7684\u76EE\u5F55: ${hashDir}`);
          }
        }
        return projects;
      }
      /**
       * 获取特定项目的所有实例（不同IDE/MCP的绑定） - 支持Hash目录结构
       * @param {string} projectPath - 项目路径
       * @returns {Promise<Array>} 项目实例数组
       */
      async getProjectInstances(projectPath) {
        if (!await fs.pathExists(this.projectsDir)) {
          return [];
        }
        const projectHash = this.generateProjectHash(projectPath);
        const projectConfigDir = path.join(this.projectsDir, projectHash);
        if (!await fs.pathExists(projectConfigDir)) {
          return [];
        }
        const instances = [];
        try {
          const configFiles = await fs.readdir(projectConfigDir);
          for (const file of configFiles) {
            if (file.startsWith("mcp-") && file.endsWith(".json")) {
              try {
                const configPath = path.join(projectConfigDir, file);
                const config = await fs.readJson(configPath);
                if (config.projectHash === projectHash) {
                  instances.push(config);
                }
              } catch (error) {
                logger.warn(`\u8DF3\u8FC7\u635F\u574F\u7684\u914D\u7F6E\u6587\u4EF6: ${file}`);
              }
            }
          }
        } catch (error) {
          logger.warn(`\u65E0\u6CD5\u8BFB\u53D6\u9879\u76EE\u914D\u7F6E\u76EE\u5F55: ${projectConfigDir}`);
        }
        return instances;
      }
      /**
       * 删除项目绑定 - 支持Hash目录结构
       * @param {string} mcpId - MCP进程ID
       * @param {string} ideType - IDE类型
       * @param {string} transport - 传输协议类型
       * @param {string} projectPath - 项目路径
       * @returns {Promise<boolean>} 是否删除成功
       */
      async removeProject(mcpId, ideType, transport, projectPath) {
        const projectHash = this.generateProjectHash(projectPath);
        const projectConfigDir = path.join(this.projectsDir, projectHash);
        const fileName = this.generateConfigFileName(mcpId, ideType, transport, projectPath);
        const configPath = path.join(projectConfigDir, fileName);
        if (await fs.pathExists(configPath)) {
          await fs.remove(configPath);
          try {
            const remainingFiles = await fs.readdir(projectConfigDir);
            const mcpConfigFiles = remainingFiles.filter((file) => file.startsWith("mcp-") && file.endsWith(".json"));
            if (mcpConfigFiles.length === 0) {
              await fs.remove(projectConfigDir);
            }
          } catch (error) {
          }
          return true;
        }
        return false;
      }
      /**
       * 清理过期的项目配置 - 支持Hash目录结构
       * @returns {Promise<number>} 清理的配置文件数量
       */
      async cleanupExpiredProjects() {
        if (!await fs.pathExists(this.projectsDir)) {
          return 0;
        }
        const hashDirs = await fs.readdir(this.projectsDir);
        let cleanedCount = 0;
        for (const hashDir of hashDirs) {
          const hashDirPath = path.join(this.projectsDir, hashDir);
          if (!(await fs.stat(hashDirPath)).isDirectory()) {
            continue;
          }
          try {
            const configFiles = await fs.readdir(hashDirPath);
            let hasValidConfig = false;
            for (const file of configFiles) {
              if (file.startsWith("mcp-") && file.endsWith(".json")) {
                try {
                  const configPath = path.join(hashDirPath, file);
                  const config = await fs.readJson(configPath);
                  if (!await fs.pathExists(config.projectPath)) {
                    await fs.remove(configPath);
                    cleanedCount++;
                    logger.info(`\u6E05\u7406\u8FC7\u671F\u9879\u76EE\u914D\u7F6E: ${file}`);
                  } else {
                    hasValidConfig = true;
                  }
                } catch (error) {
                  await fs.remove(path.join(hashDirPath, file));
                  cleanedCount++;
                  logger.info(`\u6E05\u7406\u635F\u574F\u914D\u7F6E\u6587\u4EF6: ${file}`);
                }
              }
            }
            if (!hasValidConfig) {
              await fs.remove(hashDirPath);
              logger.info(`\u6E05\u7406\u7A7A\u7684\u9879\u76EEHash\u76EE\u5F55: ${hashDir}`);
            }
          } catch (error) {
            await fs.remove(hashDirPath);
            cleanedCount++;
            logger.info(`\u6E05\u7406\u65E0\u6CD5\u8BBF\u95EE\u7684\u76EE\u5F55: ${hashDir}`);
          }
        }
        return cleanedCount;
      }
      /**
       * 生成多项目环境下的AI提示词
       * @param {string} contextType - 上下文类型：'list'/'action'/'learn'
       * @param {string} mcpId - MCP进程ID
       * @param {string} ideType - IDE类型
       * @returns {Promise<string>} 格式化的AI提示词
       */
      async generateTopLevelProjectPrompt(contextType = "list", mcpId, ideType) {
        const projects = await this.getProjectsByMcpId(mcpId);
        if (projects.length === 0) {
          return "";
        }
        if (projects.length === 1) {
          const project = projects[0];
          const basePrompt = `\u{1F6D1} **\u9879\u76EE\u73AF\u5883\u9A8C\u8BC1** \u{1F6D1}
\u{1F4CD} \u5F53\u524D\u7ED1\u5B9A\u9879\u76EE: ${project.projectPath}
\u{1F517} MCP\u5B9E\u4F8B: ${mcpId} (${ideType})

\u26A0\uFE0F **\u6267\u884C\u524D\u786E\u8BA4**\uFF1A\u4E0A\u8FF0\u8DEF\u5F84\u662F\u5426\u4E3A\u4F60\u5F53\u524D\u5DE5\u4F5C\u7684\u9879\u76EE\uFF1F`;
          switch (contextType) {
            case "action":
              return `${basePrompt}
\u5982\u4E0D\u4E00\u81F4\uFF0C\u7ACB\u5373\u505C\u6B62\u6240\u6709\u64CD\u4F5C\u5E76\u4F7F\u7528 \`promptx_init\` \u66F4\u65B0\uFF01

\u{1F4A5} **\u4E25\u91CD\u8B66\u544A**\uFF1A\u5728\u9519\u8BEF\u9879\u76EE\u8DEF\u5F84\u4E0B\u64CD\u4F5C\u5C06\u5BFC\u81F4\u4E0D\u53EF\u9884\u77E5\u7684\u9519\u8BEF\uFF01`;
            case "learn":
              return `${basePrompt}
\u9519\u8BEF\u73AF\u5883\u5C06\u5BFC\u81F4\u77E5\u8BC6\u5173\u8054\u5931\u6548\uFF01

\u{1F4A5} **\u4E25\u91CD\u8B66\u544A**\uFF1A\u9879\u76EE\u73AF\u5883\u4E0D\u5339\u914D\u5C06\u5F71\u54CD\u5B66\u4E60\u6548\u679C\uFF01`;
            default:
              return `${basePrompt}
\u5982\u4E0D\u4E00\u81F4\uFF0C\u5FC5\u987B\u4F7F\u7528 \`promptx_init\` \u66F4\u65B0\u6B63\u786E\u8DEF\u5F84\uFF01

\u{1F4A5} **\u4E25\u91CD\u8B66\u544A**\uFF1A\u9519\u8BEF\u7684\u9879\u76EE\u73AF\u5883\u5C06\u5BFC\u81F4\u670D\u52A1\u5F02\u5E38\uFF01`;
          }
        }
        const projectList = projects.map(
          (proj, index) => `${index + 1}. ${path.basename(proj.projectPath)} (${proj.projectPath})`
        ).join("\n");
        return `\u{1F3AF} **\u591A\u9879\u76EE\u73AF\u5883\u68C0\u6D4B** \u{1F3AF}
\u{1F4CD} \u5F53\u524DMCP\u5B9E\u4F8B(${mcpId})\u5DF2\u7ED1\u5B9A ${projects.length} \u4E2A\u9879\u76EE\uFF1A

${projectList}

\u26A0\uFE0F **\u8BF7\u660E\u786E\u6307\u5B9A**\uFF1A\u4F60\u8981\u5728\u54EA\u4E2A\u9879\u76EE\u4E2D\u6267\u884C\u64CD\u4F5C\uFF1F
\u{1F4A1} **\u5EFA\u8BAE**\uFF1A\u5728\u5BF9\u8BDD\u4E2D\u660E\u786E\u8BF4\u660E\u9879\u76EE\u540D\u79F0\u6216\u8DEF\u5F84`;
      }
      /**
       * 验证路径是否为有效的项目目录
       * @param {string} projectPath - 要验证的路径
       * @returns {Promise<boolean>} 是否为有效项目目录
       */
      async validateProjectPath(projectPath) {
        try {
          const stat = await fs.stat(projectPath);
          if (!stat.isDirectory()) {
            return false;
          }
          const resolved = path.resolve(projectPath);
          const homeDir = os.homedir();
          if (resolved === homeDir) {
            return false;
          }
          return true;
        } catch (error) {
          return false;
        }
      }
      /**
       * 生成配置文件名
       * @param {string} mcpId - MCP进程ID
       * @param {string} ideType - IDE类型
       * @param {string} transport - 传输协议类型
       * @param {string} projectPath - 项目路径
       * @returns {string} 配置文件名
       */
      generateConfigFileName(mcpId, ideType, transport, projectPath) {
        const projectHash = this.generateProjectHash(projectPath);
        const projectName = path.basename(projectPath).toLowerCase().replace(/[^a-z0-9-]/g, "-");
        const ideTypeSafe = ideType.replace(/[^a-z0-9-]/g, "").toLowerCase() || "unknown";
        const transportSafe = transport.replace(/[^a-z0-9-]/g, "").toLowerCase() || "unknown";
        return `mcp-${transportSafe}-${mcpId.replace("mcp-", "")}-${ideTypeSafe}-${projectName}-${projectHash}.json`;
      }
      /**
       * 生成项目路径的Hash值
       * @param {string} projectPath - 项目路径
       * @returns {string} 8位Hash值
       */
      generateProjectHash(projectPath) {
        return crypto.createHash("md5").update(path.resolve(projectPath)).digest("hex").substr(0, 8);
      }
      /**
       * 从配置文件中获取IDE类型
       * @param {string} mcpId - MCP进程ID
       * @returns {Promise<string>} IDE类型
       */
      async getIdeType(mcpId) {
        const project = await this.getProjectByMcpId(mcpId);
        return project ? project.ideType : "unknown";
      }
      /**
       * 生成MCP进程ID - 基于进程ID确保实例唯一
       * @param {string} ideType - IDE类型（保留参数兼容性，实际不使用）
       * @returns {string} MCP进程ID
       */
      static generateMcpId(ideType = "unknown") {
        const serverEnv = getGlobalServerEnvironment();
        if (serverEnv.isInitialized()) {
          return serverEnv.getMcpId();
        }
        return `mcp-${process.pid}`;
      }
      /**
       * 统一项目注册方法 - 新架构：设置当前项目并持久化配置
       * @param {string} workingDirectory - 项目工作目录
       * @param {string} ideType - IDE类型（可选，默认'unknown'）
       * @returns {Promise<Object>} 项目配置对象
       */
      static async registerCurrentProject(workingDirectory, ideType = "unknown") {
        logger.debug(`[ProjectManager DEBUG] ======= registerCurrentProject\u5F00\u59CB =======`);
        logger.debug(`[ProjectManager DEBUG] \u53C2\u6570 - workingDirectory: ${workingDirectory}`);
        logger.debug(`[ProjectManager DEBUG] \u53C2\u6570 - ideType: ${ideType}`);
        logger.debug(`[ProjectManager DEBUG] \u6CE8\u518C\u524D currentProject\u72B6\u6001:`, JSON.stringify(this.currentProject, null, 2));
        const serverEnv = getGlobalServerEnvironment();
        if (!serverEnv.isInitialized()) {
          logger.error(`[ProjectManager DEBUG] \u274C ServerEnvironment\u672A\u521D\u59CB\u5316`);
          throw new Error("ServerEnvironment not initialized");
        }
        const mcpId = serverEnv.getMcpId();
        const transport = serverEnv.getTransport();
        logger.debug(`[ProjectManager DEBUG] ServerEnvironment\u4FE1\u606F - mcpId: ${mcpId}, transport: ${transport}`);
        logger.debug(`[ProjectManager DEBUG] \u8C03\u7528 setCurrentProject...`);
        this.setCurrentProject(workingDirectory, mcpId, ideType, transport);
        logger.debug(`[ProjectManager DEBUG] setCurrentProject\u5B8C\u6210\u540E currentProject\u72B6\u6001:`, JSON.stringify(this.currentProject, null, 2));
        logger.debug(`[ProjectManager DEBUG] \u5F00\u59CB\u6301\u4E45\u5316\u9879\u76EE\u914D\u7F6E...`);
        const projectManager = getGlobalProjectManager();
        const result = await projectManager.registerProject(workingDirectory, mcpId, ideType, transport);
        logger.debug(`[ProjectManager DEBUG] \u9879\u76EE\u914D\u7F6E\u6301\u4E45\u5316\u5B8C\u6210:`, JSON.stringify(result, null, 2));
        logger.debug(`[ProjectManager DEBUG] ======= registerCurrentProject\u7ED3\u675F =======`);
        return result;
      }
    };
    var globalProjectManager = null;
    function getGlobalProjectManager() {
      if (!globalProjectManager) {
        globalProjectManager = new ProjectManager();
      }
      return globalProjectManager;
    }
    module2.exports = ProjectManager;
    module2.exports.ProjectManager = ProjectManager;
    module2.exports.getGlobalProjectManager = getGlobalProjectManager;
  }
});

// src/utils/DirectoryLocator.js
var require_DirectoryLocator = __commonJS({
  "src/utils/DirectoryLocator.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var fs = require("fs-extra");
    var path = require("path");
    var os = require("os");
    var ProjectManager = require_ProjectManager();
    var DirectoryLocator = class {
      constructor(options = {}) {
        this.options = options;
        this.cache = /* @__PURE__ */ new Map();
        this.platform = process.platform;
      }
      /**
       * 抽象方法：定位目录
       * @param {Object} context - 定位上下文
       * @returns {Promise<string>} 定位到的目录路径
       */
      async locate(context = {}) {
        throw new Error("\u5B50\u7C7B\u5FC5\u987B\u5B9E\u73B0 locate \u65B9\u6CD5");
      }
      /**
       * 获取缓存
       */
      getCached(key) {
        return this.cache.get(key);
      }
      /**
       * 设置缓存
       */
      setCached(key, value) {
        this.cache.set(key, value);
        return value;
      }
      /**
       * 清除缓存
       */
      clearCache() {
        this.cache.clear();
      }
      /**
       * 检查路径是否存在且是目录
       */
      async isValidDirectory(dirPath) {
        try {
          const stat = await fs.stat(dirPath);
          return stat.isDirectory();
        } catch {
          return false;
        }
      }
      /**
       * 规范化路径
       */
      normalizePath(inputPath) {
        if (!inputPath || typeof inputPath !== "string") {
          return null;
        }
        return path.resolve(inputPath);
      }
      /**
       * 展开家目录路径
       */
      expandHome(filepath) {
        if (!filepath || typeof filepath !== "string") {
          return "";
        }
        if (filepath.startsWith("~/") || filepath === "~") {
          return path.join(os.homedir(), filepath.slice(2));
        }
        return filepath;
      }
    };
    var ProjectRootLocator = class extends DirectoryLocator {
      constructor(options = {}) {
        super(options);
        this.projectManager = new ProjectManager();
        this.strategies = options.strategies || [
          "aiProvidedProjectPath",
          // 1. AI提供的项目路径（最可靠，由AI告知）
          "existingPromptxDirectory",
          // 2. 现有.promptx目录（最可靠的项目标识）
          "packageJsonDirectory",
          // 3. 向上查找项目标识文件（最准确的项目边界）
          "gitRootDirectory",
          // 4. Git根目录（通用可靠）
          "currentWorkingDirectoryIfHasMarkers",
          // 5. 当前目录项目标识（降级策略）
          "currentWorkingDirectory"
          // 6. 纯当前目录（最后回退）
        ];
        this.projectMarkers = options.projectMarkers || [
          "package.json",
          ".git",
          "pyproject.toml",
          "Cargo.toml",
          "pom.xml",
          "build.gradle",
          "composer.json"
        ];
      }
      /**
       * 定位项目根目录
       */
      async locate(context = {}) {
        const { startDir = process.cwd() } = context;
        const cacheKey = `projectRoot:${startDir}`;
        const cached = this.getCached(cacheKey);
        if (cached) {
          return cached;
        }
        const strategies = context.strategies || this.strategies;
        for (const strategy of strategies) {
          const result = await this._executeStrategy(strategy, startDir, context);
          if (result && await this._validateProjectRoot(result, context)) {
            return this.setCached(cacheKey, result);
          }
        }
        return this.setCached(cacheKey, startDir);
      }
      /**
       * 执行特定的查找策略
       */
      async _executeStrategy(strategy, startDir, context) {
        switch (strategy) {
          case "aiProvidedProjectPath":
            return await this._findByAIProvidedPath();
          case "existingPromptxDirectory":
            return await this._findByExistingPromptx(startDir);
          case "currentWorkingDirectoryIfHasMarkers":
            return await this._checkCurrentDirForMarkers(startDir);
          case "packageJsonDirectory":
            return await this._findByProjectMarkers(startDir);
          case "gitRootDirectory":
            return await this._findByGitRoot(startDir);
          case "currentWorkingDirectory":
            return startDir;
          default:
            return null;
        }
      }
      /**
       * 通过AI提供的项目路径查找（最高优先级）
       */
      async _findByAIProvidedPath() {
        try {
          const tempMcpId = process.env.PROMPTX_MCP_ID || `temp-${process.pid}`;
          const projects = await this.projectManager.getProjectsByMcpId(tempMcpId);
          const aiProvidedPath = projects.length > 0 ? projects[0].projectPath : null;
          if (aiProvidedPath && await this.isValidDirectory(aiProvidedPath)) {
            return aiProvidedPath;
          }
        } catch (error) {
        }
        return null;
      }
      /**
       * 检查当前目录是否包含项目标识文件
       */
      async _checkCurrentDirForMarkers(startDir) {
        const currentDir = path.resolve(startDir);
        for (const marker of this.projectMarkers) {
          const markerPath = path.join(currentDir, marker);
          if (await fs.pathExists(markerPath)) {
            return currentDir;
          }
        }
        return null;
      }
      /**
       * 通过现有.promptx目录查找
       */
      async _findByExistingPromptx(startDir) {
        let currentDir = path.resolve(startDir);
        const root = path.parse(currentDir).root;
        while (currentDir !== root) {
          const promptxPath = path.join(currentDir, ".promptx");
          if (await this.isValidDirectory(promptxPath)) {
            return currentDir;
          }
          const parentDir = path.dirname(currentDir);
          if (parentDir === currentDir) break;
          currentDir = parentDir;
        }
        return null;
      }
      /**
       * 通过项目标识文件查找
       */
      async _findByProjectMarkers(startDir) {
        let currentDir = path.resolve(startDir);
        const root = path.parse(currentDir).root;
        while (currentDir !== root) {
          for (const marker of this.projectMarkers) {
            const markerPath = path.join(currentDir, marker);
            if (await fs.pathExists(markerPath)) {
              return currentDir;
            }
          }
          const parentDir = path.dirname(currentDir);
          if (parentDir === currentDir) break;
          currentDir = parentDir;
        }
        return null;
      }
      /**
       * 通过Git根目录查找
       */
      async _findByGitRoot(startDir) {
        let currentDir = path.resolve(startDir);
        const root = path.parse(currentDir).root;
        while (currentDir !== root) {
          const gitPath = path.join(currentDir, ".git");
          if (await fs.pathExists(gitPath)) {
            return currentDir;
          }
          const parentDir = path.dirname(currentDir);
          if (parentDir === currentDir) break;
          currentDir = parentDir;
        }
        return null;
      }
      /**
       * 验证项目根目录
       */
      async _validateProjectRoot(projectRoot, context = {}) {
        if (this.platform === "win32" && context.avoidUserHome !== false) {
          const homeDir = os.homedir();
          if (path.resolve(projectRoot) === path.resolve(homeDir)) {
            return false;
          }
        }
        return await this.isValidDirectory(projectRoot);
      }
    };
    var PromptXWorkspaceLocator = class extends DirectoryLocator {
      constructor(options = {}) {
        super(options);
        this.projectRootLocator = options.projectRootLocator || new ProjectRootLocator(options);
        this.projectManager = new ProjectManager();
      }
      /**
       * 定位PromptX工作空间
       */
      async locate(context = {}) {
        const cacheKey = `promptxWorkspace:${JSON.stringify(context)}`;
        const cached = this.getCached(cacheKey);
        if (cached) {
          return cached;
        }
        const workspaceFromAI = await this._fromAIProvidedPath();
        if (workspaceFromAI) {
          return this.setCached(cacheKey, workspaceFromAI);
        }
        const workspaceFromIDE = await this._fromIDEEnvironment();
        if (workspaceFromIDE) {
          return this.setCached(cacheKey, workspaceFromIDE);
        }
        const workspaceFromEnv = await this._fromPromptXEnvironment();
        if (workspaceFromEnv) {
          return this.setCached(cacheKey, workspaceFromEnv);
        }
        if (context.strategies) {
          const workspaceFromProject2 = await this._fromProjectRoot(context);
          if (workspaceFromProject2) {
            return this.setCached(cacheKey, workspaceFromProject2);
          }
        }
        const workspaceFromExisting = await this._fromExistingDirectory(context.startDir);
        if (workspaceFromExisting) {
          return this.setCached(cacheKey, workspaceFromExisting);
        }
        const workspaceFromProject = await this._fromProjectRoot(context);
        if (workspaceFromProject) {
          return this.setCached(cacheKey, workspaceFromProject);
        }
        return this.setCached(cacheKey, await this._getSmartFallback(context));
      }
      /**
       * 从AI提供的项目路径获取（最高优先级）
       */
      async _fromAIProvidedPath() {
        try {
          const tempMcpId = process.env.PROMPTX_MCP_ID || `temp-${process.pid}`;
          const projects = await this.projectManager.getProjectsByMcpId(tempMcpId);
          const aiProvidedPath = projects.length > 0 ? projects[0].projectPath : null;
          if (aiProvidedPath && await this.isValidDirectory(aiProvidedPath)) {
            return aiProvidedPath;
          }
        } catch (error) {
        }
        return null;
      }
      /**
       * 从IDE环境变量获取（支持多种IDE）
       */
      async _fromIDEEnvironment() {
        const ideStrategies = [
          // Claude IDE (现有格式)
          {
            name: "Claude IDE",
            vars: ["WORKSPACE_FOLDER_PATHS"],
            parse: (value, varName) => {
              try {
                const folders = JSON.parse(value);
                return Array.isArray(folders) && folders.length > 0 ? folders[0] : null;
              } catch {
                return null;
              }
            }
          },
          // VSCode
          {
            name: "VSCode",
            vars: ["VSCODE_WORKSPACE_FOLDER", "VSCODE_CWD"],
            parse: (value, varName) => value
          },
          // IntelliJ IDEA / WebStorm / PhpStorm
          {
            name: "JetBrains IDEs",
            vars: ["PROJECT_ROOT", "IDEA_INITIAL_DIRECTORY", "WEBSTORM_PROJECT_PATH"],
            parse: (value, varName) => value
          },
          // Sublime Text
          {
            name: "Sublime Text",
            vars: ["SUBLIME_PROJECT_PATH", "SUBL_PROJECT_DIR"],
            parse: (value, varName) => value
          },
          // Atom
          {
            name: "Atom",
            vars: ["ATOM_PROJECT_PATH", "ATOM_HOME_PROJECT"],
            parse: (value, varName) => value
          },
          // Vim/Neovim
          {
            name: "Vim/Neovim",
            vars: ["VIM_PROJECT_ROOT", "NVIM_PROJECT_ROOT"],
            parse: (value, varName) => value
          },
          // 字节跳动 Trae 和其他基于PWD的IDE
          {
            name: "ByteDance Trae & PWD-based IDEs",
            vars: ["PWD", "TRAE_WORKSPACE", "BYTEDANCE_WORKSPACE"],
            parse: (value, varName) => {
              if (varName === "TRAE_WORKSPACE" || varName === "BYTEDANCE_WORKSPACE") {
                return value;
              }
              if (varName === "PWD") {
                const currentCwd = process.cwd();
                if (value && value !== currentCwd) {
                  return value;
                }
              }
              return null;
            }
          },
          // 通用工作目录
          {
            name: "Generic",
            vars: ["WORKSPACE_ROOT", "PROJECT_DIR", "WORKING_DIRECTORY"],
            parse: (value, varName) => value
          }
        ];
        for (const strategy of ideStrategies) {
          for (const varName of strategy.vars) {
            const envValue = process.env[varName];
            if (envValue && envValue.trim() !== "") {
              const parsedPath = strategy.parse(envValue.trim(), varName);
              if (parsedPath) {
                const normalizedPath = this.normalizePath(this.expandHome(parsedPath));
                if (normalizedPath && await this.isValidDirectory(normalizedPath)) {
                  this._detectedIDE = strategy.name;
                  return normalizedPath;
                }
              }
            }
          }
        }
        return null;
      }
      /**
       * 从PromptX环境变量获取
       */
      async _fromPromptXEnvironment() {
        const promptxWorkspaceEnv = process.env.PROMPTX_WORKSPACE;
        if (promptxWorkspaceEnv && promptxWorkspaceEnv.trim() !== "") {
          const workspacePath = this.normalizePath(this.expandHome(promptxWorkspaceEnv));
          if (workspacePath && await this.isValidDirectory(workspacePath)) {
            return workspacePath;
          }
        }
        return null;
      }
      /**
       * 从现有.promptx目录获取
       */
      async _fromExistingDirectory(startDir) {
        const projectRoot = await this.projectRootLocator._findByExistingPromptx(startDir || process.cwd());
        return projectRoot;
      }
      /**
       * 从项目根目录获取
       */
      async _fromProjectRoot(context) {
        const projectRoot = await this.projectRootLocator.locate(context);
        return projectRoot;
      }
      /**
       * 智能回退策略
       */
      async _getSmartFallback(context) {
        const argPath = await this._fromProcessArguments();
        if (argPath && await this.isValidDirectory(argPath)) {
          return argPath;
        }
        const processCwd = process.cwd();
        if (await this.isValidDirectory(processCwd)) {
          return processCwd;
        }
        return os.homedir();
      }
      /**
       * 从进程参数推断项目路径
       */
      async _fromProcessArguments() {
        const args = process.argv;
        for (let i = 0; i < args.length; i++) {
          const arg = args[i];
          if (arg.startsWith("--project-path=")) {
            return arg.split("=")[1];
          }
          if (arg === "--project-path" && i + 1 < args.length) {
            return args[i + 1];
          }
          if (arg.startsWith("--cwd=")) {
            return arg.split("=")[1];
          }
          if (arg === "--cwd" && i + 1 < args.length) {
            return args[i + 1];
          }
        }
        return null;
      }
      /**
       * 获取检测调试信息
       */
      getDetectionInfo() {
        return {
          detectedIDE: this._detectedIDE || "Unknown",
          availableEnvVars: this._getAvailableEnvVars(),
          platform: process.platform,
          cwd: process.cwd(),
          args: process.argv
        };
      }
      /**
       * 获取可用的环境变量
       */
      _getAvailableEnvVars() {
        const relevantVars = [
          "WORKSPACE_FOLDER_PATHS",
          "VSCODE_WORKSPACE_FOLDER",
          "VSCODE_CWD",
          "PROJECT_ROOT",
          "IDEA_INITIAL_DIRECTORY",
          "WEBSTORM_PROJECT_PATH",
          "SUBLIME_PROJECT_PATH",
          "SUBL_PROJECT_DIR",
          "ATOM_PROJECT_PATH",
          "ATOM_HOME_PROJECT",
          "VIM_PROJECT_ROOT",
          "NVIM_PROJECT_ROOT",
          "PWD",
          "TRAE_WORKSPACE",
          "BYTEDANCE_WORKSPACE",
          "WORKSPACE_ROOT",
          "PROJECT_DIR",
          "WORKING_DIRECTORY",
          "PROMPTX_WORKSPACE"
        ];
        const available = {};
        for (const varName of relevantVars) {
          if (process.env[varName]) {
            available[varName] = process.env[varName];
          }
        }
        return available;
      }
    };
    var DirectoryLocatorFactory = class {
      /**
       * 创建项目根目录定位器
       */
      static createProjectRootLocator(options = {}) {
        const platform = process.platform;
        if (platform === "win32") {
          return new WindowsProjectRootLocator(options);
        } else {
          return new ProjectRootLocator(options);
        }
      }
      /**
       * 创建PromptX工作空间定位器
       */
      static createPromptXWorkspaceLocator(options = {}) {
        const projectRootLocator = this.createProjectRootLocator(options);
        return new PromptXWorkspaceLocator({
          ...options,
          projectRootLocator
        });
      }
      /**
       * 获取平台信息
       */
      static getPlatform() {
        return process.platform;
      }
    };
    var WindowsProjectRootLocator = class extends ProjectRootLocator {
      constructor(options = {}) {
        super({
          ...options,
          // Windows默认避免用户家目录
          avoidUserHome: options.avoidUserHome !== false
        });
      }
      /**
       * Windows特有的项目根目录验证
       */
      async _validateProjectRoot(projectRoot, context = {}) {
        const baseValid = await super._validateProjectRoot(projectRoot, context);
        if (!baseValid) {
          return false;
        }
        const systemPaths = [
          "C:\\Windows",
          "C:\\Program Files",
          "C:\\Program Files (x86)",
          "C:\\System Volume Information"
        ];
        const resolvedPath = path.resolve(projectRoot).toUpperCase();
        for (const systemPath of systemPaths) {
          if (resolvedPath.startsWith(systemPath.toUpperCase())) {
            return false;
          }
        }
        return true;
      }
    };
    module2.exports = {
      DirectoryLocator,
      ProjectRootLocator,
      PromptXWorkspaceLocator,
      DirectoryLocatorFactory,
      WindowsProjectRootLocator
    };
  }
});

// src/utils/DirectoryService.js
var require_DirectoryService = __commonJS({
  "src/utils/DirectoryService.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var { DirectoryLocatorFactory } = require_DirectoryLocator();
    var logger = require("@promptx/logger");
    var DirectoryService = class {
      constructor() {
        this.workspaceLocator = null;
        this.initialized = false;
      }
      /**
       * 初始化服务
       */
      async initialize(options = {}) {
        if (this.initialized) {
          return;
        }
        try {
          this.workspaceLocator = DirectoryLocatorFactory.createPromptXWorkspaceLocator(options);
          this.initialized = true;
          logger.debug("[DirectoryService] \u521D\u59CB\u5316\u5B8C\u6210");
        } catch (error) {
          logger.error("[DirectoryService] \u521D\u59CB\u5316\u5931\u8D25:", error);
          throw error;
        }
      }
      /**
       * 获取IDE环境检测调试信息
       */
      async getDebugInfo(context = {}) {
        var _a;
        await this._ensureInitialized();
        const ideDetectionInfo = ((_a = this.workspaceLocator) == null ? void 0 : _a.getDetectionInfo()) || {};
        return {
          platform: process.platform,
          ideDetection: {
            detectedIDE: ideDetectionInfo.detectedIDE,
            availableEnvVars: ideDetectionInfo.availableEnvVars,
            cwd: process.cwd(),
            args: process.argv.slice(2)
          },
          environment: {
            // 主要IDE环境变量
            WORKSPACE_FOLDER_PATHS: process.env.WORKSPACE_FOLDER_PATHS,
            VSCODE_WORKSPACE_FOLDER: process.env.VSCODE_WORKSPACE_FOLDER,
            PROJECT_ROOT: process.env.PROJECT_ROOT,
            SUBLIME_PROJECT_PATH: process.env.SUBLIME_PROJECT_PATH,
            // PromptX专用
            PROMPTX_WORKSPACE: process.env.PROMPTX_WORKSPACE,
            // 系统环境
            PWD: process.env.PWD,
            NODE_ENV: process.env.NODE_ENV
          },
          recommendations: this._getPathRecommendations(ideDetectionInfo)
        };
      }
      /**
       * 获取路径配置建议
       */
      _getPathRecommendations(ideDetectionInfo = {}) {
        const recommendations = [];
        if (!ideDetectionInfo.detectedIDE || ideDetectionInfo.detectedIDE === "Unknown") {
          recommendations.push({
            type: "env_var",
            message: "\u672A\u68C0\u6D4B\u5230IDE\u73AF\u5883\u53D8\u91CF\uFF0C\u5EFA\u8BAE\u8BBE\u7F6E\u9879\u76EE\u8DEF\u5F84\u73AF\u5883\u53D8\u91CF",
            suggestions: [
              'export PROMPTX_WORKSPACE="/path/to/your/project"',
              'export PROJECT_ROOT="/path/to/your/project"',
              'export WORKSPACE_ROOT="/path/to/your/project"'
            ]
          });
        }
        if (!ideDetectionInfo.availableEnvVars || Object.keys(ideDetectionInfo.availableEnvVars).length === 0) {
          recommendations.push({
            type: "manual_config",
            message: "\u5EFA\u8BAE\u5728IDE\u4E2D\u914D\u7F6EMCP\u5DE5\u4F5C\u76EE\u5F55",
            suggestions: [
              "VSCode: \u5728settings.json\u4E2D\u8BBE\u7F6Eworkspace.folders",
              "IntelliJ: \u5728Run Configuration\u4E2D\u8BBE\u7F6EWorking directory",
              "Claude IDE: \u786E\u4FDDworkspace\u8DEF\u5F84\u6B63\u786E\u4F20\u9012"
            ]
          });
        }
        return recommendations;
      }
      /**
       * 清除缓存
       */
      clearCache() {
        if (this.workspaceLocator) {
          this.workspaceLocator.clearCache();
        }
        logger.debug("[DirectoryService] \u7F13\u5B58\u5DF2\u6E05\u9664");
      }
      /**
       * 确保服务已初始化
       */
      async _ensureInitialized() {
        if (!this.initialized) {
          await this.initialize();
        }
      }
      /**
       * 重新加载配置
       */
      async reload(options = {}) {
        this.initialized = false;
        this.clearCache();
        await this.initialize(options);
      }
    };
    var globalDirectoryService = new DirectoryService();
    function getDirectoryService() {
      return globalDirectoryService;
    }
    module2.exports = {
      DirectoryService,
      getDirectoryService
    };
  }
});

// src/constants.js
var require_constants = __commonJS({
  "src/constants.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var PACKAGE_NAMES = {
      CURRENT: "@promptx/cli",
      // 当前使用的包名
      LEGACY: "dpml-prompt",
      // 旧版包名（向后兼容）
      ALL: ["@promptx/cli", "dpml-prompt"]
      // 所有支持的包名
    };
    function getCommandPrefix() {
      const env = process.env.PROMPTX_ENV;
      if (env === "development") {
        return "pnpm start";
      } else {
        return `npx ${PACKAGE_NAMES.CURRENT}@snapshot`;
      }
    }
    var COMMAND_PREFIX = getCommandPrefix();
    var COMMANDS = {
      INIT: `${COMMAND_PREFIX} init`,
      WELCOME: `${COMMAND_PREFIX} welcome`,
      ACTION: `${COMMAND_PREFIX} action`,
      LEARN: `${COMMAND_PREFIX} learn`,
      RECALL: `${COMMAND_PREFIX} recall`,
      REMEMBER: `${COMMAND_PREFIX} remember`,
      HELP: `${COMMAND_PREFIX} help`
    };
    var buildCommand = {
      action: (roleId) => `${COMMAND_PREFIX} action ${roleId}`,
      learn: (resource) => `${COMMAND_PREFIX} learn ${resource}`,
      recall: (query = "") => `${COMMAND_PREFIX} recall${query ? " " + query : ""}`,
      remember: (content = "<content>") => `${COMMAND_PREFIX} remember${content !== "<content>" ? ' "' + content + '"' : " <content>"}`
    };
    function getCommands() {
      return COMMANDS;
    }
    function getBuildCommand() {
      return buildCommand;
    }
    function detectCommandPrefix() {
      return COMMAND_PREFIX;
    }
    var PATHS = {
      POUCH_DIR: ".promptx",
      MEMORY_DIR: ".promptx/memory",
      STATE_FILE: ".promptx/pouch.json",
      MEMORY_FILE: ".promptx/memory/declarative.md"
    };
    var VERSION = "0.0.1";
    var STATES = {
      INITIALIZED: "initialized",
      ROLE_DISCOVERY: "role_discovery",
      ACTION_PLAN_GENERATED: "action_plan_generated",
      LEARNED_ROLE: "learned_role",
      MEMORY_SAVED: "memory_saved",
      RECALL_WAITING: "recall-waiting"
    };
    module2.exports = {
      // 固定命令前缀
      COMMAND_PREFIX,
      // 命令常量
      COMMANDS,
      buildCommand,
      // 向后兼容的函数式API
      getCommands,
      getBuildCommand,
      detectCommandPrefix,
      // 其他静态常量
      PATHS,
      PACKAGE_NAMES,
      VERSION,
      STATES
    };
  }
});

// src/resource/ProtocolResolver.js
var require_ProtocolResolver = __commonJS({
  "src/resource/ProtocolResolver.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var path = require("path");
    var fs = require("fs");
    var { getDirectoryService } = require_DirectoryService();
    var { PACKAGE_NAMES } = require_constants();
    var ProtocolResolver = class {
      constructor() {
        this.packageRoot = null;
        this.__dirname = __dirname;
        this.directoryService = getDirectoryService();
      }
      parseReference(reference) {
        const match = reference.match(/^@([!?]?)(\w+):\/\/(.+)$/);
        if (!match) {
          throw new Error(`Invalid reference format: ${reference}`);
        }
        const loadingSemantic = match[1] || "";
        const protocol = match[2];
        const resourcePath = match[3];
        return {
          loadingSemantic,
          protocol,
          resourcePath,
          fullReference: reference
        };
      }
      async resolve(reference) {
        const { protocol, resourcePath, loadingSemantic } = this.parseReference(reference);
        switch (protocol) {
          case "package":
            return await this.resolvePackage(resourcePath);
          case "project":
            return await this.resolveProject(resourcePath);
          case "file":
            return await this.resolveFile(resourcePath);
          default:
            throw new Error(`Unsupported protocol: ${protocol}`);
        }
      }
      async resolvePackage(relativePath) {
        if (!this.packageRoot) {
          this.packageRoot = await this.findPackageRoot();
        }
        return path.resolve(this.packageRoot, relativePath);
      }
      async resolveProject(relativePath) {
        try {
          const context = {
            startDir: process.cwd(),
            platform: process.platform,
            avoidUserHome: true
          };
          const projectRoot = await this.directoryService.getProjectRoot(context);
          return path.resolve(projectRoot, relativePath);
        } catch (error) {
          return path.resolve(process.cwd(), relativePath);
        }
      }
      async resolveFile(filePath) {
        if (path.isAbsolute(filePath)) {
          return filePath;
        }
        try {
          const context = {
            startDir: process.cwd(),
            platform: process.platform,
            avoidUserHome: true
          };
          const projectRoot = await this.directoryService.getProjectRoot(context);
          return path.resolve(projectRoot, filePath);
        } catch (error) {
          return path.resolve(process.cwd(), filePath);
        }
      }
      async findPackageRoot() {
        let dir = this.__dirname;
        while (dir !== path.parse(dir).root) {
          const packageJson = path.join(dir, "package.json");
          if (fs.existsSync(packageJson)) {
            const pkg = JSON.parse(fs.readFileSync(packageJson, "utf8"));
            if (pkg.name === "promptx" || PACKAGE_NAMES.ALL.includes(pkg.name)) {
              return dir;
            }
          }
          dir = path.dirname(dir);
        }
        throw new Error("PromptX package root not found");
      }
    };
    module2.exports = ProtocolResolver;
  }
});

// src/resource/ResourceData.js
var require_ResourceData = __commonJS({
  "src/resource/ResourceData.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var ResourceData = class _ResourceData {
      /**
       * @param {Object} options - 资源配置选项
       * @param {string} options.id - 资源唯一标识
       * @param {string} options.source - 资源来源 ('package' | 'project' | 'user')
       * @param {string} options.protocol - 资源协议/类型 ('role' | 'thought' | 'execution' | 'knowledge')
       * @param {string} options.name - 资源名称
       * @param {string} options.description - 资源描述
       * @param {string} options.reference - 资源引用路径
       * @param {Object} options.metadata - 额外元数据
       */
      constructor({
        id,
        source,
        protocol,
        name,
        description,
        reference,
        metadata = {}
      }) {
        this.id = id;
        this.source = source;
        this.protocol = protocol;
        this.name = name;
        this.description = description;
        this.reference = reference;
        this.metadata = {
          createdAt: (/* @__PURE__ */ new Date()).toISOString(),
          updatedAt: (/* @__PURE__ */ new Date()).toISOString(),
          ...metadata
        };
      }
      /**
       * 从原始数据创建ResourceData实例
       * @param {Object} rawData - 原始数据
       * @returns {ResourceData} ResourceData实例
       */
      static fromRawData(rawData) {
        return new _ResourceData(rawData);
      }
      /**
       * 从文件路径和协议推断创建ResourceData
       * @param {string} filePath - 文件路径（仅用于提取ID，不保存）
       * @param {string} source - 资源来源
       * @param {string} protocol - 资源协议
       * @param {string} reference - 资源引用
       * @returns {ResourceData} ResourceData实例
       */
      static fromFilePath(filePath, source, protocol, reference) {
        const path = require("path");
        const fileName = path.basename(filePath, `.${protocol}.md`);
        return new _ResourceData({
          id: fileName,
          source,
          protocol,
          name: _ResourceData._generateDefaultName(fileName, protocol),
          description: _ResourceData._generateDefaultDescription(fileName, protocol),
          reference,
          metadata: {
            inferredFromFile: true
          }
        });
      }
      /**
       * 生成默认名称
       * @param {string} id - 资源ID
       * @param {string} protocol - 资源协议
       * @returns {string} 默认名称
       * @private
       */
      static _generateDefaultName(id, protocol) {
        const nameMap = {
          "role": "\u89D2\u8272",
          "thought": "\u601D\u7EF4\u6A21\u5F0F",
          "execution": "\u6267\u884C\u6A21\u5F0F",
          "knowledge": "\u77E5\u8BC6\u5E93"
        };
        const readableName = id.split("-").map((word) => word.charAt(0).toUpperCase() + word.slice(1)).join(" ");
        return `${readableName} ${nameMap[protocol] || protocol}`;
      }
      /**
       * 生成默认描述
       * @param {string} id - 资源ID
       * @param {string} protocol - 资源协议
       * @returns {string} 默认描述
       * @private
       */
      static _generateDefaultDescription(id, protocol) {
        const descMap = {
          "role": "\u4E13\u4E1A\u89D2\u8272\uFF0C\u63D0\u4F9B\u7279\u5B9A\u9886\u57DF\u7684\u4E13\u4E1A\u80FD\u529B",
          "thought": "\u601D\u7EF4\u6A21\u5F0F\uFF0C\u6307\u5BFCAI\u7684\u601D\u8003\u65B9\u5F0F",
          "execution": "\u6267\u884C\u6A21\u5F0F\uFF0C\u5B9A\u4E49\u5177\u4F53\u7684\u884C\u4E3A\u6A21\u5F0F",
          "knowledge": "\u77E5\u8BC6\u5E93\uFF0C\u63D0\u4F9B\u4E13\u4E1A\u77E5\u8BC6\u548C\u4FE1\u606F"
        };
        return descMap[protocol] || `${protocol}\u7C7B\u578B\u7684\u8D44\u6E90`;
      }
      /**
       * 获取完整的资源ID（包含来源前缀）
       * @returns {string} 完整资源ID
       */
      getFullId() {
        const baseId = this.protocol === "role" ? this.id : `${this.protocol}:${this.id}`;
        return `${this.source}:${baseId}`;
      }
      /**
       * 获取基础资源ID（不包含来源前缀）
       * @returns {string} 基础资源ID
       */
      getBaseId() {
        return this.protocol === "role" ? this.id : `${this.protocol}:${this.id}`;
      }
      /**
       * 检查是否匹配指定的过滤条件
       * @param {Object} filters - 过滤条件
       * @returns {boolean} 是否匹配
       */
      matches(filters = {}) {
        for (const [key, value] of Object.entries(filters)) {
          if (value !== void 0 && value !== null) {
            if (Array.isArray(value)) {
              if (!value.includes(this[key])) return false;
            } else {
              if (this[key] !== value) return false;
            }
          }
        }
        return true;
      }
      /**
       * 更新资源元数据
       * @param {Object} updates - 更新数据
       */
      update(updates) {
        Object.assign(this, updates);
        this.metadata.updatedAt = (/* @__PURE__ */ new Date()).toISOString();
      }
      /**
       * 转换为JSON对象
       * @returns {Object} JSON对象
       */
      toJSON() {
        return {
          id: this.id,
          source: this.source,
          protocol: this.protocol,
          name: this.name,
          description: this.description,
          reference: this.reference,
          metadata: this.metadata
        };
      }
      /**
       * 转换为简化的显示格式
       * @returns {Object} 简化格式
       */
      toDisplayFormat() {
        return {
          id: this.id,
          fullId: this.getFullId(),
          baseId: this.getBaseId(),
          name: this.name,
          description: this.description,
          source: this.source,
          protocol: this.protocol
        };
      }
      /**
       * 动态获取文件路径
       * 通过解析 reference 动态计算实际的文件路径
       * @returns {Promise<string>} 文件路径
       */
      async getFilePath() {
        const ProtocolResolver = require_ProtocolResolver();
        const resolver = new ProtocolResolver();
        try {
          const resolvedPath = await resolver.resolve(this.reference);
          return resolvedPath;
        } catch (error) {
          throw new Error(`\u65E0\u6CD5\u89E3\u6790\u8D44\u6E90\u8DEF\u5F84 ${this.reference}: ${error.message}`);
        }
      }
      /**
       * 克隆资源数据
       * @returns {ResourceData} 克隆的实例
       */
      clone() {
        return new _ResourceData(this.toJSON());
      }
    };
    module2.exports = ResourceData;
  }
});

// src/resource/RegistryData.js
var require_RegistryData = __commonJS({
  "src/resource/RegistryData.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var fs = require("fs-extra");
    var path = require("path");
    var ResourceData = require_ResourceData();
    var RegistryData = class _RegistryData {
      /**
       * @param {string} source - 注册表来源 ('package' | 'project' | 'user')
       * @param {string} filePath - 注册表文件路径
       * @param {Array<ResourceData>} resources - 资源数据数组
       * @param {Object} metadata - 注册表元数据
       */
      constructor(source, filePath, resources = [], metadata = {}) {
        this.source = source;
        this.filePath = filePath;
        this.resources = resources.map((r) => r instanceof ResourceData ? r : ResourceData.fromRawData(r));
        this.metadata = {
          version: "2.0.0",
          description: `${source} \u7EA7\u8D44\u6E90\u6CE8\u518C\u8868`,
          createdAt: (/* @__PURE__ */ new Date()).toISOString(),
          updatedAt: (/* @__PURE__ */ new Date()).toISOString(),
          ...metadata
        };
        this.cache = /* @__PURE__ */ new Map();
      }
      /**
       * 从文件加载注册表数据
       * @param {string} source - 注册表来源
       * @param {string} filePath - 文件路径
       * @returns {Promise<RegistryData>} 注册表数据实例
       */
      static async fromFile(source, filePath) {
        try {
          const data = await fs.readJSON(filePath);
          if (data.version === "2.0.0" && Array.isArray(data.resources)) {
            return new _RegistryData(source, filePath, data.resources, data.metadata);
          }
          if (data.resources && typeof data.resources === "object") {
            const resources = [];
            for (const [protocol, resourcesOfType] of Object.entries(data.resources)) {
              if (resourcesOfType && typeof resourcesOfType === "object") {
                for (const [id, reference] of Object.entries(resourcesOfType)) {
                  resources.push(ResourceData.fromFilePath(
                    reference.replace(/^@\w+:\/\//, ""),
                    source,
                    protocol,
                    reference
                  ));
                }
              }
            }
            return new _RegistryData(source, filePath, resources, {
              migratedFrom: "v1.0.0",
              originalTimestamp: data.timestamp
            });
          }
          throw new Error(`Unsupported registry format in ${filePath}`);
        } catch (error) {
          throw new Error(`Failed to load ${source} registry from ${filePath}: ${error.message}`);
        }
      }
      /**
       * 创建空的注册表数据
       * @param {string} source - 注册表来源
       * @param {string} filePath - 注册表文件路径
       * @returns {RegistryData} 空注册表数据实例
       */
      static createEmpty(source, filePath) {
        return new _RegistryData(source, filePath, [], {
          description: `${source} \u7EA7\u8D44\u6E90\u6CE8\u518C\u8868`,
          createdAt: (/* @__PURE__ */ new Date()).toISOString()
        });
      }
      /**
       * 添加资源
       * @param {ResourceData|Object} resource - 资源数据
       */
      addResource(resource) {
        const resourceData = resource instanceof ResourceData ? resource : ResourceData.fromRawData(resource);
        if (this.source !== "merged" && resourceData.source !== this.source) {
          resourceData.source = this.source;
        }
        const existingIndex = this.resources.findIndex((r) => r.id === resourceData.id && r.protocol === resourceData.protocol);
        if (existingIndex >= 0) {
          this.resources[existingIndex] = resourceData;
        } else {
          this.resources.push(resourceData);
        }
        this._updateMetadata();
        this.cache.clear();
      }
      /**
       * 移除资源
       * @param {string} id - 资源ID
       * @param {string} protocol - 资源协议
       * @returns {boolean} 是否成功移除
       */
      removeResource(id, protocol) {
        const initialLength = this.resources.length;
        this.resources = this.resources.filter((r) => !(r.id === id && r.protocol === protocol));
        const removed = this.resources.length < initialLength;
        if (removed) {
          this._updateMetadata();
          this.cache.clear();
        }
        return removed;
      }
      /**
       * 查找资源
       * @param {Object} filters - 过滤条件
       * @returns {Array<ResourceData>} 匹配的资源数组
       */
      findResources(filters = {}) {
        return this.resources.filter((resource) => resource.matches(filters));
      }
      /**
       * 根据ID查找资源
       * @param {string} id - 资源ID
       * @param {string} protocol - 资源协议（可选）
       * @returns {ResourceData|null} 找到的资源
       */
      findResourceById(id, protocol = null) {
        return this.resources.find((r) => {
          if (protocol) {
            return r.id === id && r.protocol === protocol;
          }
          return r.id === id;
        }) || null;
      }
      /**
       * 获取指定协议类型的所有资源
       * @param {string} protocol - 资源协议
       * @returns {Array<ResourceData>} 资源数组
       */
      getResourcesByProtocol(protocol) {
        return this.resources.filter((r) => r.protocol === protocol);
      }
      /**
       * 获取资源Map（兼容旧接口）
       * @param {boolean} includeSourcePrefix - 是否包含源前缀
       * @returns {Map<string, string>} 资源ID到引用的映射
       */
      getResourceMap(includeSourcePrefix = true) {
        const cacheKey = `resourceMap_${includeSourcePrefix}`;
        if (this.cache.has(cacheKey)) {
          return this.cache.get(cacheKey);
        }
        const registry = /* @__PURE__ */ new Map();
        for (const resource of this.resources) {
          if (includeSourcePrefix) {
            registry.set(resource.getFullId(), resource.reference);
            registry.set(resource.getBaseId(), resource.reference);
          } else {
            registry.set(resource.getBaseId(), resource.reference);
          }
        }
        this.cache.set(cacheKey, registry);
        return registry;
      }
      /**
       * 获取所有资源数据
       * @returns {Array<ResourceData>} 所有资源数组
       */
      getAllResources() {
        return [...this.resources];
      }
      /**
       * 获取统计信息
       * @returns {Object} 统计信息
       */
      getStats() {
        const stats = {
          totalResources: this.resources.length,
          byProtocol: {},
          bySource: {}
        };
        for (const resource of this.resources) {
          stats.byProtocol[resource.protocol] = (stats.byProtocol[resource.protocol] || 0) + 1;
          stats.bySource[resource.source] = (stats.bySource[resource.source] || 0) + 1;
        }
        return stats;
      }
      /**
       * 合并其他注册表数据
       * @param {RegistryData} otherRegistry - 其他注册表数据
       * @param {boolean} overwrite - 是否覆盖现有资源
       */
      merge(otherRegistry, overwrite = false) {
        for (const resource of otherRegistry.resources) {
          const existing = this.findResourceById(resource.id, resource.protocol);
          if (!existing || overwrite) {
            this.addResource(resource.clone());
          }
        }
      }
      /**
       * 保存注册表到文件
       * @returns {Promise<void>}
       */
      async save() {
        try {
          await fs.ensureDir(path.dirname(this.filePath));
          this._updateMetadata();
          const saveData = {
            version: this.metadata.version,
            source: this.source,
            metadata: this.metadata,
            resources: this.resources.map((r) => r.toJSON()),
            stats: this.getStats()
          };
          await fs.writeJSON(this.filePath, saveData, { spaces: 2 });
        } catch (error) {
          throw new Error(`Failed to save ${this.source} registry to ${this.filePath}: ${error.message}`);
        }
      }
      /**
       * 更新元数据
       * @private
       */
      _updateMetadata() {
        this.metadata.updatedAt = (/* @__PURE__ */ new Date()).toISOString();
        this.metadata.resourceCount = this.resources.length;
      }
      /**
       * 获取注册表大小
       * @returns {number} 资源数量
       */
      get size() {
        return this.resources.length;
      }
      /**
       * 检查注册表是否为空
       * @returns {boolean} 是否为空
       */
      isEmpty() {
        return this.resources.length === 0;
      }
      /**
       * 清空所有资源
       */
      clear() {
        this.resources = [];
        this._updateMetadata();
        this.cache.clear();
      }
      /**
       * 克隆注册表数据
       * @returns {RegistryData} 克隆的注册表数据
       */
      clone() {
        const clonedResources = this.resources.map((r) => r.clone());
        return new _RegistryData(this.source, this.filePath, clonedResources, { ...this.metadata });
      }
      /**
       * 转换为JSON对象
       * @returns {Object} JSON对象
       */
      toJSON() {
        return {
          version: this.metadata.version,
          source: this.source,
          metadata: this.metadata,
          resources: this.resources.map((r) => r.toJSON()),
          stats: this.getStats()
        };
      }
    };
    module2.exports = RegistryData;
  }
});

// src/resource/types.js
var require_types = __commonJS({
  "src/resource/types.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var LoadingSemantics = {
      DEFAULT: "default",
      // @ - AI自行决定加载时机
      HOT_LOAD: "hot_load",
      // @! - 立即加载
      LAZY_LOAD: "lazy_load"
      // @? - 懒加载
    };
    var ParsedReference = class {
      constructor() {
        this.loadingSemantics = LoadingSemantics.DEFAULT;
        this.protocol = "";
        this.path = "";
        this.queryParams = new QueryParams();
        this.isNested = false;
        this.nestedRef = null;
        this.originalRef = "";
      }
    };
    var QueryParams = class {
      constructor() {
        this.line = null;
        this.format = null;
        this.cache = null;
        this.params = /* @__PURE__ */ new Map();
      }
      /**
       * 设置参数
       */
      set(key, value) {
        if (["line", "format", "cache"].includes(key)) {
          this[key] = value;
        } else {
          this.params.set(key, value);
        }
      }
      /**
       * 获取参数
       */
      get(key) {
        if (["line", "format", "cache"].includes(key)) {
          return this[key];
        }
        return this.params.get(key);
      }
      /**
       * 获取所有参数
       */
      getAll() {
        const result = {};
        if (this.line !== null) {
          result.line = this.line;
        }
        if (this.format !== null) {
          result.format = this.format;
        }
        if (this.cache !== null) {
          result.cache = this.cache;
        }
        for (const [key, value] of this.params) {
          result[key] = value;
        }
        return result;
      }
      /**
       * 转换为字符串用于缓存键
       */
      toString() {
        const params = [];
        if (this.line !== null) {
          params.push(`line=${this.line}`);
        }
        if (this.format !== null) {
          params.push(`format=${this.format}`);
        }
        if (this.cache !== null) {
          params.push(`cache=${this.cache}`);
        }
        const sortedParams = Array.from(this.params.entries()).sort();
        for (const [key, value] of sortedParams) {
          params.push(`${key}=${value}`);
        }
        return params.join("&");
      }
    };
    var NestedReference = class {
      constructor() {
        this.outer = null;
        this.inner = null;
        this.depth = 0;
      }
    };
    var ResourceContent = class {
      constructor(path, content, metadata = {}) {
        this.path = path;
        this.content = content;
        this.metadata = metadata;
        this.relativePath = "";
        this.lastModified = null;
        this.size = content ? content.length : 0;
      }
    };
    var LazyResource = class {
      constructor(path, loader) {
        this.path = path;
        this.loader = loader;
        this.loaded = false;
        this._content = null;
      }
      /**
       * 加载资源
       */
      async load() {
        if (!this.loaded) {
          this._content = await this.loader(this.path);
          this.loaded = true;
        }
        return this._content;
      }
    };
    var ProcessedResult = class {
      constructor() {
        this.content = "";
        this.metadata = {};
        this.format = "text";
        this.sources = [];
        this.cached = false;
      }
    };
    var ResourceResult = class _ResourceResult {
      constructor() {
        this.content = "";
        this.metadata = {};
        this.sources = [];
        this.format = "text";
        this.cached = false;
        this.loadTime = Date.now();
        this.success = true;
        this.error = null;
      }
      /**
       * 创建成功结果
       */
      static success(content, metadata = {}) {
        const result = new _ResourceResult();
        result.content = content;
        result.metadata = metadata;
        result.success = true;
        return result;
      }
      /**
       * 创建错误结果
       */
      static error(error, metadata = {}) {
        const result = new _ResourceResult();
        result.success = false;
        result.error = error;
        result.metadata = metadata;
        return result;
      }
    };
    var ProtocolInfo = class {
      constructor() {
        this.name = "";
        this.description = "";
        this.location = "";
        this.params = {};
        this.registry = /* @__PURE__ */ new Map();
      }
    };
    module2.exports = {
      LoadingSemantics,
      ParsedReference,
      QueryParams,
      NestedReference,
      ResourceContent,
      LazyResource,
      ProcessedResult,
      ResourceResult,
      ProtocolInfo
    };
  }
});

// src/resource/resourceProtocolParser.js
var require_resourceProtocolParser = __commonJS({
  "src/resource/resourceProtocolParser.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var {
      LoadingSemantics,
      ParsedReference,
      QueryParams,
      NestedReference
    } = require_types();
    var ResourceProtocolParser = class {
      constructor() {
        this.resourceRefRegex = /^(@[!?]?|@)([a-zA-Z][a-zA-Z0-9_-]*):(.+)$/;
        this.nestedRefRegex = /^(@[!?]?|@)([a-zA-Z][a-zA-Z0-9_-]*):(@[!?]?|@)?(.+)$/;
        this.queryParamsRegex = /^([^?]+)(?:\?(.+))?$/;
      }
      /**
       * 解析资源引用
       * @param {string} resourceRef - 资源引用字符串
       * @returns {ParsedReference} 解析后的引用对象
       */
      parse(resourceRef) {
        if (!resourceRef || typeof resourceRef !== "string") {
          throw new Error("Invalid resource reference: must be a non-empty string");
        }
        const trimmedRef = resourceRef.trim();
        if (!this.validateSyntax(trimmedRef)) {
          throw new Error(`Invalid resource reference syntax: ${trimmedRef}`);
        }
        const parsed = new ParsedReference();
        parsed.originalRef = trimmedRef;
        if (this.isNestedReference(trimmedRef)) {
          return this.parseNestedReference(trimmedRef);
        }
        return this.parseBasicReference(trimmedRef);
      }
      /**
       * 解析基础资源引用
       * @param {string} ref - 基础引用
       * @returns {ParsedReference}
       */
      parseBasicReference(ref) {
        const parsed = new ParsedReference();
        parsed.originalRef = ref;
        parsed.loadingSemantics = this.parseLoadingSemantics(ref);
        const withoutSemantics = this.removeLoadingSemantics(ref);
        const match = withoutSemantics.match(/^([a-zA-Z][a-zA-Z0-9_-]*):(.+)$/);
        if (!match) {
          throw new Error(`Invalid protocol format: ${ref}`);
        }
        parsed.protocol = match[1];
        let pathAndParams = match[2];
        if (pathAndParams.startsWith("//")) {
          pathAndParams = pathAndParams.substring(2);
        }
        const pathMatch = pathAndParams.match(this.queryParamsRegex);
        if (pathMatch) {
          parsed.path = pathMatch[1];
          if (pathMatch[2]) {
            parsed.queryParams = this.parseQueryParams(pathMatch[2]);
          }
        } else {
          parsed.path = pathAndParams;
        }
        return parsed;
      }
      /**
       * 解析嵌套引用
       * @param {string} ref - 嵌套引用
       * @returns {ParsedReference}
       */
      parseNestedReference(ref) {
        const parsed = new ParsedReference();
        parsed.originalRef = ref;
        parsed.isNested = true;
        parsed.loadingSemantics = this.parseLoadingSemantics(ref);
        const withoutOuterSemantics = this.removeLoadingSemantics(ref);
        const match = withoutOuterSemantics.match(/^([a-zA-Z][a-zA-Z0-9_-]*):(.+)$/);
        if (!match) {
          throw new Error(`Invalid nested reference format: ${ref}`);
        }
        parsed.protocol = match[1];
        let innerRef = match[2];
        if (innerRef.startsWith("//")) {
          innerRef = innerRef.substring(2);
        }
        if (!innerRef.startsWith("@")) {
          innerRef = "@" + innerRef;
        }
        try {
          const innerParsed = this.parse(innerRef);
          const nested = new NestedReference();
          nested.outer = parsed;
          nested.inner = innerParsed;
          nested.depth = this.calculateNestingDepth(innerParsed);
          parsed.nestedRef = nested;
        } catch (error) {
          throw new Error(`Invalid nested inner reference: ${error.message}`);
        }
        return parsed;
      }
      /**
       * 解析加载语义
       * @param {string} ref - 资源引用
       * @returns {string} 加载语义
       */
      parseLoadingSemantics(ref) {
        if (ref.startsWith("@!")) {
          return LoadingSemantics.HOT_LOAD;
        } else if (ref.startsWith("@?")) {
          return LoadingSemantics.LAZY_LOAD;
        } else if (ref.startsWith("@")) {
          return LoadingSemantics.DEFAULT;
        }
        throw new Error(`Invalid loading semantics: ${ref}`);
      }
      /**
       * 移除加载语义前缀
       * @param {string} ref - 资源引用
       * @returns {string} 移除前缀后的引用
       */
      removeLoadingSemantics(ref) {
        if (ref.startsWith("@!") || ref.startsWith("@?")) {
          return ref.substring(2);
        } else if (ref.startsWith("@")) {
          return ref.substring(1);
        }
        return ref;
      }
      /**
       * 解析查询参数
       * @param {string} queryString - 查询字符串
       * @returns {QueryParams} 查询参数对象
       */
      parseQueryParams(queryString) {
        const params = new QueryParams();
        if (!queryString) {
          return params;
        }
        const pairs = queryString.split("&");
        for (const pair of pairs) {
          const [key, value] = pair.split("=").map(decodeURIComponent);
          if (key) {
            if (key === "cache") {
              params.set(key, value === "true" || value === "1");
            } else {
              params.set(key, value || "");
            }
          }
        }
        return params;
      }
      /**
       * 验证语法
       * @param {string} ref - 资源引用
       * @returns {boolean} 是否有效
       */
      validateSyntax(ref) {
        if (!ref) return false;
        if (!ref.startsWith("@")) return false;
        const withoutSemantics = this.removeLoadingSemantics(ref);
        return /^[a-zA-Z][a-zA-Z0-9_-]*:.+$/.test(withoutSemantics);
      }
      /**
       * 检查是否为嵌套引用
       * @param {string} ref - 资源引用
       * @returns {boolean} 是否为嵌套引用
       */
      isNestedReference(ref) {
        const withoutSemantics = this.removeLoadingSemantics(ref);
        const colonIndex = withoutSemantics.indexOf(":");
        if (colonIndex === -1) return false;
        const afterColon = withoutSemantics.substring(colonIndex + 1);
        return afterColon.includes("@") || afterColon.includes("://");
      }
      /**
       * 计算嵌套深度
       * @param {ParsedReference} ref - 解析后的引用
       * @returns {number} 嵌套深度
       */
      calculateNestingDepth(ref) {
        if (!ref.isNested) return 1;
        return 1 + this.calculateNestingDepth(ref.nestedRef.inner);
      }
      /**
       * 提取协议名
       * @param {string} ref - 资源引用
       * @returns {string} 协议名
       */
      extractProtocol(ref) {
        const withoutSemantics = this.removeLoadingSemantics(ref);
        const colonIndex = withoutSemantics.indexOf(":");
        return colonIndex > 0 ? withoutSemantics.substring(0, colonIndex) : "";
      }
      /**
       * 提取路径
       * @param {string} ref - 资源引用
       * @returns {string} 路径
       */
      extractPath(ref) {
        const withoutSemantics = this.removeLoadingSemantics(ref);
        const colonIndex = withoutSemantics.indexOf(":");
        if (colonIndex === -1) return "";
        let pathAndParams = withoutSemantics.substring(colonIndex + 1);
        if (pathAndParams.startsWith("//")) {
          pathAndParams = pathAndParams.substring(2);
        }
        const queryIndex = pathAndParams.indexOf("?");
        return queryIndex > 0 ? pathAndParams.substring(0, queryIndex) : pathAndParams;
      }
      /**
       * 提取查询参数字符串
       * @param {string} ref - 资源引用
       * @returns {string} 查询参数字符串
       */
      extractParams(ref) {
        const queryIndex = ref.indexOf("?");
        return queryIndex > 0 ? ref.substring(queryIndex + 1) : "";
      }
    };
    module2.exports = ResourceProtocolParser;
  }
});

// src/resource/discovery/BaseDiscovery.js
var require_BaseDiscovery = __commonJS({
  "src/resource/discovery/BaseDiscovery.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var BaseDiscovery = class {
      /**
       * 构造函数
       * @param {string} source - 发现源类型 (PACKAGE, PROJECT, USER, INTERNET)
       * @param {number} priority - 优先级，数字越小优先级越高
       */
      constructor(source, priority = 0) {
        if (!source) {
          throw new Error("Discovery source is required");
        }
        this.source = source;
        this.priority = priority;
        this.cache = /* @__PURE__ */ new Map();
      }
      /**
       * 抽象方法：发现资源
       * 子类必须实现此方法
       * @returns {Promise<Array>} 发现的资源列表
       */
      async discover() {
        throw new Error("discover method must be implemented by subclass");
      }
      /**
       * 获取发现器信息
       * @returns {Object} 发现器元数据
       */
      getDiscoveryInfo() {
        return {
          source: this.source,
          priority: this.priority,
          description: `${this.source} resource discovery`
        };
      }
      /**
       * 验证资源结构
       * @param {Object} resource - 待验证的资源对象
       * @throws {Error} 如果资源结构无效
       */
      validateResource(resource) {
        if (!resource || typeof resource !== "object") {
          throw new Error("Resource must be an object");
        }
        if (!resource.id || !resource.reference) {
          throw new Error("Resource must have id and reference");
        }
        if (typeof resource.id !== "string" || !resource.id.includes(":")) {
          throw new Error('Resource id must be in format "protocol:resourcePath"');
        }
        if (typeof resource.reference !== "string" || !resource.reference.startsWith("@")) {
          throw new Error('Resource reference must be in DPML format "@protocol://path"');
        }
      }
      /**
       * 规范化资源对象，添加元数据
       * @param {Object} resource - 原始资源对象
       * @returns {Object} 规范化后的资源对象
       */
      normalizeResource(resource) {
        this.validateResource(resource);
        const normalizedResource = {
          id: resource.id,
          reference: resource.reference,
          metadata: {
            source: this.source,
            priority: this.priority,
            timestamp: /* @__PURE__ */ new Date(),
            ...resource.metadata
            // 保留现有元数据
          }
        };
        return normalizedResource;
      }
      /**
       * 清理缓存
       */
      clearCache() {
        this.cache.clear();
      }
      /**
       * 获取缓存大小
       * @returns {number} 缓存条目数量
       */
      getCacheSize() {
        return this.cache.size;
      }
      /**
       * 从缓存获取资源
       * @param {string} key - 缓存键
       * @returns {*} 缓存的值或undefined
       */
      getFromCache(key) {
        return this.cache.get(key);
      }
      /**
       * 设置缓存
       * @param {string} key - 缓存键
       * @param {*} value - 缓存值
       */
      setCache(key, value) {
        this.cache.set(key, value);
      }
    };
    module2.exports = BaseDiscovery;
  }
});

// src/resource/discovery/PackageDiscovery.js
var require_PackageDiscovery = __commonJS({
  "src/resource/discovery/PackageDiscovery.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var BaseDiscovery = require_BaseDiscovery();
    var logger = require("@promptx/logger");
    var PackageDiscovery = class extends BaseDiscovery {
      constructor(resourceManager) {
        super("PACKAGE");
        this.resourceManager = resourceManager;
      }
      /**
       * 发现包级资源 - 从 @promptx/resource 包加载
       * @returns {Promise<Array>} 发现的资源列表
       */
      async discover() {
        var _a, _b, _c;
        try {
          const { registry } = require("@promptx/resource");
          if (!registry) {
            logger.warn("[PackageDiscovery] @promptx/resource \u6CE8\u518C\u8868\u672A\u6B63\u786E\u52A0\u8F7D");
            return [];
          }
          const resources = [];
          if (Array.isArray(registry.resources)) {
            for (const resource of registry.resources) {
              resources.push({
                id: resource.id,
                type: resource.protocol,
                // 使用 protocol 字段
                path: ((_a = resource.metadata) == null ? void 0 : _a.path) || resource.reference,
                name: resource.name || resource.id,
                metadata: {
                  description: resource.description,
                  modified: (_b = resource.metadata) == null ? void 0 : _b.modified,
                  size: (_c = resource.metadata) == null ? void 0 : _c.size,
                  source: "package",
                  // 小写以保持一致
                  packageName: "@promptx/resource"
                }
              });
            }
          }
          logger.info(`[PackageDiscovery] \u2705 \u4ECE @promptx/resource \u52A0\u8F7D\u4E86 ${resources.length} \u4E2A\u7CFB\u7EDF\u8D44\u6E90`);
          return resources;
        } catch (error) {
          logger.warn(`[PackageDiscovery] \u26A0\uFE0F \u52A0\u8F7D @promptx/resource \u5931\u8D25: ${error.message}`);
          return [];
        }
      }
      /**
       * 发现包级资源注册表
       * @returns {Promise<Map>} 资源注册表 Map<resourceId, reference>
       */
      async discoverRegistry() {
        var _a;
        try {
          const { registry } = require("@promptx/resource");
          if (!registry) {
            logger.warn("[PackageDiscovery] @promptx/resource \u6CE8\u518C\u8868\u672A\u6B63\u786E\u52A0\u8F7D");
            return /* @__PURE__ */ new Map();
          }
          const registryMap = /* @__PURE__ */ new Map();
          if (Array.isArray(registry.resources)) {
            for (const resource of registry.resources) {
              const reference = resource.reference || `@package://resources/${(_a = resource.metadata) == null ? void 0 : _a.path}`;
              registryMap.set(resource.id, reference);
              registryMap.set(`package:${resource.id}`, reference);
            }
          }
          if (registryMap.size > 0) {
            logger.info(`[PackageDiscovery] \u2705 \u4ECE @promptx/resource \u52A0\u8F7D\u4E86 ${registryMap.size / 2} \u4E2A\u7CFB\u7EDF\u8D44\u6E90\u5230\u6CE8\u518C\u8868`);
          }
          return registryMap;
        } catch (error) {
          logger.warn(`[PackageDiscovery] \u26A0\uFE0F \u7CFB\u7EDF\u8D44\u6E90\u6CE8\u518C\u8868\u52A0\u8F7D\u5931\u8D25: ${error.message}`);
          return /* @__PURE__ */ new Map();
        }
      }
      /**
       * 获取包资源的基础目录（用于文件访问）
       * @returns {Promise<string>} 包资源目录路径
       */
      async getPackageRoot() {
        try {
          const resourcePackagePath = require.resolve("@promptx/resource");
          const path = require("path");
          let currentDir = path.dirname(resourcePackagePath);
          while (currentDir !== path.dirname(currentDir)) {
            const packageJsonPath = path.join(currentDir, "package.json");
            try {
              const packageJson = require(packageJsonPath);
              if (packageJson.name === "@promptx/resource") {
                return currentDir;
              }
            } catch {
            }
            currentDir = path.dirname(currentDir);
          }
          throw new Error("\u65E0\u6CD5\u627E\u5230 @promptx/resource \u5305\u7684\u6839\u76EE\u5F55");
        } catch (error) {
          logger.error(`[PackageDiscovery] \u274C \u83B7\u53D6\u5305\u6839\u76EE\u5F55\u5931\u8D25: ${error.message}`);
          throw error;
        }
      }
      /**
       * 获取注册表数据（ResourceManager 需要的方法）
       * @returns {Promise<RegistryData>} 注册表数据实例
       */
      async getRegistryData() {
        var _a;
        try {
          logger.info("[PackageDiscovery] Starting getRegistryData...");
          const { registry } = require("@promptx/resource");
          logger.info("[PackageDiscovery] @promptx/resource loaded successfully");
          const RegistryData = require_RegistryData();
          const ResourceData = require_ResourceData();
          if (!registry) {
            logger.warn("[PackageDiscovery] Registry is empty");
            return new RegistryData("package", "", []);
          }
          logger.info(`[PackageDiscovery] Registry loaded with ${((_a = registry.resources) == null ? void 0 : _a.length) || 0} resources`);
          const resources = [];
          if (Array.isArray(registry.resources)) {
            for (const resource of registry.resources) {
              resources.push(new ResourceData({
                id: resource.id,
                source: "package",
                // 使用小写保持一致
                protocol: resource.protocol,
                // 直接使用资源的 protocol 字段
                name: resource.name || resource.id,
                description: resource.description || "",
                reference: resource.reference,
                metadata: resource.metadata || {}
              }));
            }
          }
          logger.info(`[PackageDiscovery] Successfully created ${resources.length} ResourceData objects`);
          return new RegistryData("package", "@promptx/resource", resources);
        } catch (error) {
          logger.error(`[PackageDiscovery] Error in getRegistryData: ${error.message}`);
          logger.error(`[PackageDiscovery] Stack trace: ${error.stack}`);
          logger.warn(`[PackageDiscovery] \u83B7\u53D6\u6CE8\u518C\u8868\u6570\u636E\u5931\u8D25: ${error.message}`);
          const RegistryData = require_RegistryData();
          return new RegistryData("package", "", []);
        }
      }
      /**
       * 获取环境信息（用于调试）
       */
      getEnvironmentInfo() {
        return {
          type: "PackageDiscovery",
          source: "@promptx/resource",
          loaded: this._tryRequirePackage() !== null
        };
      }
      /**
       * 尝试加载包（内部辅助方法）
       */
      _tryRequirePackage() {
        try {
          const { registry } = require("@promptx/resource");
          return registry ? { registry } : null;
        } catch {
          return null;
        }
      }
    };
    module2.exports = PackageDiscovery;
  }
});

// src/resource/discovery/ProjectDiscovery.js
var require_ProjectDiscovery = __commonJS({
  "src/resource/discovery/ProjectDiscovery.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var logger = require("@promptx/logger");
    var RegistryData = require_RegistryData();
    var ResourceData = require_ResourceData();
    var fs = require("fs-extra");
    var path = require("path");
    var ProjectDiscovery = class {
      constructor() {
        this.source = "PROJECT";
        this.priority = 2;
        this.projectProtocol = null;
      }
      /**
       * 获取ProjectProtocol实例
       */
      getProjectProtocol() {
        if (!this.projectProtocol) {
          const { getGlobalResourceManager } = require_resource();
          const resourceManager = getGlobalResourceManager();
          this.projectProtocol = resourceManager.protocols.get("project");
        }
        return this.projectProtocol;
      }
      /**
       * 发现项目级资源注册表
       * @returns {Promise<Map>} 资源注册表 Map<resourceId, reference>
       */
      async discoverRegistry() {
        try {
          const registryMap = await this.loadFromRegistry();
          if (registryMap.size > 0) {
            logger.debug(`ProjectDiscovery \u4ECE\u6CE8\u518C\u8868\u52A0\u8F7D ${registryMap.size} \u4E2A\u8D44\u6E90`);
            return registryMap;
          }
          logger.debug("ProjectDiscovery \u6CE8\u518C\u8868\u4E0D\u5B58\u5728\uFF0C\u4F7F\u7528\u52A8\u6001\u626B\u63CF");
          const resources = await this.scanProjectResources();
          return this.buildRegistryFromResources(resources);
        } catch (error) {
          logger.warn(`[ProjectDiscovery] Registry discovery failed: ${error.message}`);
          return /* @__PURE__ */ new Map();
        }
      }
      /**
       * 从注册表文件加载资源
       * @returns {Promise<Map>} 资源注册表
       */
      async loadFromRegistry() {
        try {
          const protocol = this.getProjectProtocol();
          const registryPath = await protocol.resolvePath(".promptx/resource/project.registry.json");
          if (!await fs.pathExists(registryPath)) {
            return /* @__PURE__ */ new Map();
          }
          const registryData = await RegistryData.fromFile("project", registryPath);
          return registryData.getResourceMap(true);
        } catch (error) {
          logger.warn(`[ProjectDiscovery] Failed to load registry: ${error.message}`);
          return /* @__PURE__ */ new Map();
        }
      }
      /**
       * 动态扫描项目资源 - 恢复重构前的专业扫描逻辑
       * @returns {Promise<Array>} 资源列表
       */
      async scanProjectResources() {
        try {
          const protocol = this.getProjectProtocol();
          const resourceDir = await protocol.resolvePath(".promptx/resource");
          if (!await fs.pathExists(resourceDir)) {
            logger.debug("ProjectDiscovery \u9879\u76EE\u8D44\u6E90\u76EE\u5F55\u4E0D\u5B58\u5728");
            return [];
          }
          const tempRegistry = RegistryData.createEmpty("project", null);
          await this._scanDirectory(resourceDir, tempRegistry);
          const resources = [];
          for (const resource of tempRegistry.resources) {
            resources.push({
              id: resource.id,
              protocol: resource.protocol,
              reference: resource.reference,
              source: resource.source
            });
          }
          logger.info(`[ProjectDiscovery] \u2705 \u9879\u76EE\u626B\u63CF\u5B8C\u6210\uFF0C\u53D1\u73B0 ${resources.length} \u4E2A\u8D44\u6E90`);
          return resources;
        } catch (error) {
          logger.warn(`[ProjectDiscovery] \u626B\u63CF\u9879\u76EE\u8D44\u6E90\u5931\u8D25: ${error.message}`);
          return [];
        }
      }
      /**
       * 扫描目录并添加资源到注册表（通用递归扫描）
       * @param {string} resourcesDir - 资源目录
       * @param {RegistryData} registryData - 注册表数据
       * @private
       */
      async _scanDirectory(resourcesDir, registryData) {
        try {
          await this._recursiveScan(resourcesDir, "", registryData);
        } catch (error) {
          logger.warn(`[ProjectDiscovery] \u626B\u63CF\u8D44\u6E90\u76EE\u5F55\u5931\u8D25: ${error.message}`);
        }
      }
      /**
       * 递归扫描目录
       * @param {string} currentPath - 当前扫描路径
       * @param {string} relativePath - 相对于resource目录的路径
       * @param {RegistryData} registryData - 注册表数据
       * @private
       */
      async _recursiveScan(currentPath, relativePath, registryData) {
        try {
          const items = await fs.readdir(currentPath);
          for (const item of items) {
            const itemPath = path.join(currentPath, item);
            const stat = await fs.stat(itemPath);
            const newRelativePath = relativePath ? `${relativePath}/${item}` : item;
            if (stat.isDirectory()) {
              await this._recursiveScan(itemPath, newRelativePath, registryData);
            } else {
              await this._processFile(itemPath, newRelativePath, registryData);
            }
          }
        } catch (error) {
          logger.warn(`[ProjectDiscovery] \u626B\u63CF${currentPath}\u5931\u8D25: ${error.message}`);
        }
      }
      /**
       * 处理单个文件
       * @param {string} filePath - 文件完整路径
       * @param {string} relativePath - 相对路径
       * @param {RegistryData} registryData - 注册表数据
       * @private
       */
      async _processFile(filePath, relativePath, registryData) {
        const fileName = path.basename(filePath);
        let protocol = null;
        let resourceId = null;
        if (fileName.endsWith(".role.md")) {
          protocol = "role";
          resourceId = path.basename(fileName, ".role.md");
        } else if (fileName.endsWith(".thought.md")) {
          protocol = "thought";
          resourceId = path.basename(fileName, ".thought.md");
        } else if (fileName.endsWith(".execution.md")) {
          protocol = "execution";
          resourceId = path.basename(fileName, ".execution.md");
        } else if (fileName.endsWith(".knowledge.md")) {
          protocol = "knowledge";
          resourceId = path.basename(fileName, ".knowledge.md");
        } else if (fileName.endsWith(".tool.js")) {
          protocol = "tool";
          resourceId = path.basename(fileName, ".tool.js");
        } else if (fileName.endsWith(".manual.md")) {
          protocol = "manual";
          resourceId = path.basename(fileName, ".manual.md");
        }
        if (protocol && resourceId) {
          if (await this._validateResourceFile(filePath, protocol)) {
            const reference = `@project://.promptx/resource/${relativePath}`;
            const resourceData = new ResourceData({
              id: resourceId,
              source: "project",
              protocol,
              name: ResourceData._generateDefaultName(resourceId, protocol),
              description: ResourceData._generateDefaultDescription(resourceId, protocol),
              reference,
              metadata: {
                scannedAt: (/* @__PURE__ */ new Date()).toISOString(),
                path: relativePath
              }
            });
            registryData.addResource(resourceData);
            logger.debug(`[ProjectDiscovery] \u53D1\u73B0${protocol}\u8D44\u6E90: ${resourceId} at ${relativePath}`);
          }
        }
      }
      /**
       * 验证资源文件格式（恢复重构前逻辑）
       * @param {string} filePath - 文件路径
       * @param {string} protocol - 协议类型
       * @returns {Promise<boolean>} 是否是有效的资源文件
       */
      async _validateResourceFile(filePath, protocol) {
        try {
          const content = await fs.readFile(filePath, "utf8");
          if (!content || typeof content !== "string") {
            return false;
          }
          const trimmedContent = content.trim();
          if (trimmedContent.length === 0) {
            return false;
          }
          switch (protocol) {
            case "role":
              return trimmedContent.includes("<role>") && trimmedContent.includes("</role>");
            case "execution":
              return trimmedContent.includes("<execution>") && trimmedContent.includes("</execution>");
            case "thought":
              return trimmedContent.includes("<thought>") && trimmedContent.includes("</thought>");
            case "knowledge":
              return true;
            case "manual":
              return trimmedContent.includes("<manual>") && trimmedContent.includes("</manual>");
            case "tool":
              try {
                new Function(trimmedContent);
                return true;
              } catch (e) {
                logger.warn(`[ProjectDiscovery] Invalid JavaScript in tool file ${filePath}: ${e.message}`);
                return false;
              }
            default:
              return false;
          }
        } catch (error) {
          logger.warn(`[ProjectDiscovery] Failed to validate ${filePath}: ${error.message}`);
          return false;
        }
      }
      /**
       * 从资源列表构建注册表Map
       * @param {Array} resources - 资源列表
       * @returns {Map} 资源注册表
       */
      buildRegistryFromResources(resources) {
        const registryMap = /* @__PURE__ */ new Map();
        resources.forEach((resource) => {
          const key = `project:${resource.id}`;
          registryMap.set(key, resource.reference);
        });
        return registryMap;
      }
      /**
       * 生成并保存项目注册表文件
       * @returns {Promise<RegistryData>} 生成的注册表数据
       */
      async generateRegistry() {
        try {
          const protocol = this.getProjectProtocol();
          const registryPath = await protocol.resolvePath(".promptx/resource/project.registry.json");
          const registryData = RegistryData.createEmpty("project", registryPath);
          const resourceDir = await protocol.resolvePath(".promptx/resource");
          if (await fs.pathExists(resourceDir)) {
            await this._scanDirectory(resourceDir, registryData);
          }
          await fs.ensureDir(path.dirname(registryPath));
          await registryData.save();
          logger.info(`[ProjectDiscovery] \u2705 \u9879\u76EE\u6CE8\u518C\u8868\u751F\u6210\u5B8C\u6210\uFF0C\u53D1\u73B0 ${registryData.size} \u4E2A\u8D44\u6E90`);
          return registryData;
        } catch (error) {
          logger.error(`[ProjectDiscovery] \u751F\u6210\u6CE8\u518C\u8868\u5931\u8D25: ${error.message}`);
          return RegistryData.createEmpty("project");
        }
      }
      /**
       * 获取注册表数据（兼容旧接口）
       * @returns {Promise<RegistryData>} 注册表数据
       */
      async getRegistryData() {
        try {
          const protocol = this.getProjectProtocol();
          const registryPath = await protocol.resolvePath(".promptx/resource/project.registry.json");
          if (await fs.pathExists(registryPath)) {
            const registryData = await RegistryData.fromFile("project", registryPath);
            if (registryData.size > 0) {
              logger.info(`[ProjectDiscovery] \u{1F4CB} \u4ECE\u6CE8\u518C\u8868\u52A0\u8F7D ${registryData.size} \u4E2A\u8D44\u6E90`);
              return registryData;
            }
          }
          logger.info(`[ProjectDiscovery] \u{1F4CB} \u9879\u76EE\u6CE8\u518C\u8868\u65E0\u6548\uFF0C\u91CD\u65B0\u751F\u6210`);
          return await this.generateRegistry();
        } catch (error) {
          logger.error(`[ProjectDiscovery] \u83B7\u53D6\u6CE8\u518C\u8868\u6570\u636E\u5931\u8D25: ${error.message}`);
          return RegistryData.createEmpty("project");
        }
      }
    };
    module2.exports = ProjectDiscovery;
  }
});

// src/resource/discovery/UserDiscovery.js
var require_UserDiscovery = __commonJS({
  "src/resource/discovery/UserDiscovery.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var BaseDiscovery = require_BaseDiscovery();
    var logger = require("@promptx/logger");
    var RegistryData = require_RegistryData();
    var ResourceData = require_ResourceData();
    var fs = require("fs-extra");
    var path = require("path");
    var UserDiscovery = class extends BaseDiscovery {
      constructor() {
        super("USER", 3);
        this.userProtocol = null;
      }
      /**
       * 获取 UserProtocol 实例
       */
      getUserProtocol() {
        if (!this.userProtocol) {
          const { getGlobalResourceManager } = require_resource();
          const resourceManager = getGlobalResourceManager();
          this.userProtocol = resourceManager.protocols.get("user");
        }
        return this.userProtocol;
      }
      /**
       * 发现 User 级资源注册表
       * @returns {Promise<Map>} 资源注册表 Map<resourceId, reference>
       */
      async discoverRegistry() {
        try {
          const registryMap = await this.loadFromRegistry();
          if (registryMap.size > 0) {
            logger.debug(`UserDiscovery \u4ECE\u6CE8\u518C\u8868\u52A0\u8F7D ${registryMap.size} \u4E2A\u8D44\u6E90`);
            return registryMap;
          }
          logger.debug("UserDiscovery \u6CE8\u518C\u8868\u4E0D\u5B58\u5728\uFF0C\u4F7F\u7528\u52A8\u6001\u626B\u63CF");
          const resources = await this.scanUserResources();
          return this.buildRegistryFromResources(resources);
        } catch (error) {
          logger.warn(`[UserDiscovery] Registry discovery failed: ${error.message}`);
          return /* @__PURE__ */ new Map();
        }
      }
      /**
       * 从注册表文件加载资源
       * @returns {Promise<Map>} 资源注册表
       */
      async loadFromRegistry() {
        try {
          const protocol = this.getUserProtocol();
          const registryPath = await protocol.resolvePath(".promptx/resource/user.registry.json");
          if (!await fs.pathExists(registryPath)) {
            return /* @__PURE__ */ new Map();
          }
          const registryData = await RegistryData.fromFile("user", registryPath);
          return registryData.getResourceMap(true);
        } catch (error) {
          logger.warn(`[UserDiscovery] Failed to load registry: ${error.message}`);
          return /* @__PURE__ */ new Map();
        }
      }
      /**
       * 动态扫描 User 资源
       * @returns {Promise<Array>} 资源列表
       */
      async scanUserResources() {
        try {
          const protocol = this.getUserProtocol();
          const resourceDir = await protocol.resolvePath(".promptx/resource");
          if (!await fs.pathExists(resourceDir)) {
            logger.debug("UserDiscovery User \u8D44\u6E90\u76EE\u5F55\u4E0D\u5B58\u5728");
            return [];
          }
          const tempRegistry = RegistryData.createEmpty("user", null);
          await this._scanDirectory(resourceDir, tempRegistry);
          const resources = [];
          for (const resource of tempRegistry.resources) {
            resources.push({
              id: resource.id,
              protocol: resource.protocol,
              reference: resource.reference,
              source: resource.source
            });
          }
          logger.info(`[UserDiscovery] \u2705 User \u626B\u63CF\u5B8C\u6210\uFF0C\u53D1\u73B0 ${resources.length} \u4E2A\u8D44\u6E90`);
          return resources;
        } catch (error) {
          logger.warn(`[UserDiscovery] \u626B\u63CF User \u8D44\u6E90\u5931\u8D25: ${error.message}`);
          return [];
        }
      }
      /**
       * 扫描目录并添加资源到注册表
       * @param {string} resourcesDir - 资源目录
       * @param {RegistryData} registryData - 注册表数据
       * @private
       */
      async _scanDirectory(resourcesDir, registryData) {
        try {
          await this._recursiveScan(resourcesDir, "", registryData);
        } catch (error) {
          logger.warn(`[UserDiscovery] \u626B\u63CF\u8D44\u6E90\u76EE\u5F55\u5931\u8D25: ${error.message}`);
        }
      }
      /**
       * 递归扫描目录
       * @param {string} currentPath - 当前扫描路径
       * @param {string} relativePath - 相对于 resource 目录的路径
       * @param {RegistryData} registryData - 注册表数据
       * @private
       */
      async _recursiveScan(currentPath, relativePath, registryData) {
        try {
          const items = await fs.readdir(currentPath);
          for (const item of items) {
            const itemPath = path.join(currentPath, item);
            const stat = await fs.stat(itemPath);
            const newRelativePath = relativePath ? `${relativePath}/${item}` : item;
            if (stat.isDirectory()) {
              await this._recursiveScan(itemPath, newRelativePath, registryData);
            } else {
              await this._processFile(itemPath, newRelativePath, registryData);
            }
          }
        } catch (error) {
          logger.warn(`[UserDiscovery] \u626B\u63CF${currentPath}\u5931\u8D25: ${error.message}`);
        }
      }
      /**
       * 处理单个文件
       * @param {string} filePath - 文件完整路径
       * @param {string} relativePath - 相对路径
       * @param {RegistryData} registryData - 注册表数据
       * @private
       */
      async _processFile(filePath, relativePath, registryData) {
        const fileName = path.basename(filePath);
        let protocol = null;
        let resourceId = null;
        logger.debug(`[UserDiscovery._processFile] Processing: ${relativePath} (file: ${fileName})`);
        if (fileName.endsWith(".role.md")) {
          protocol = "role";
          resourceId = path.basename(fileName, ".role.md");
        } else if (fileName.endsWith(".thought.md")) {
          protocol = "thought";
          resourceId = path.basename(fileName, ".thought.md");
        } else if (fileName.endsWith(".execution.md")) {
          protocol = "execution";
          resourceId = path.basename(fileName, ".execution.md");
        } else if (fileName.endsWith(".knowledge.md")) {
          protocol = "knowledge";
          resourceId = path.basename(fileName, ".knowledge.md");
        } else if (fileName.endsWith(".tool.js")) {
          protocol = "tool";
          resourceId = path.basename(fileName, ".tool.js");
        } else if (fileName.endsWith(".manual.md")) {
          protocol = "manual";
          resourceId = path.basename(fileName, ".manual.md");
        }
        if (protocol && resourceId) {
          logger.info(`[UserDiscovery._processFile] Found ${protocol} resource: ${resourceId}`);
          if (await this._validateResourceFile(filePath, protocol)) {
            const reference = `@user://.promptx/resource/${relativePath}`;
            const resourceData = new ResourceData({
              id: resourceId,
              source: "user",
              protocol,
              name: ResourceData._generateDefaultName(resourceId, protocol),
              description: ResourceData._generateDefaultDescription(resourceId, protocol),
              reference,
              metadata: {
                scannedAt: (/* @__PURE__ */ new Date()).toISOString(),
                path: relativePath
              }
            });
            registryData.addResource(resourceData);
            logger.info(`[UserDiscovery] \u2705 \u6210\u529F\u6DFB\u52A0${protocol}\u8D44\u6E90: ${resourceId} at ${relativePath}`);
          }
        }
      }
      /**
       * 验证资源文件格式
       * @param {string} filePath - 文件路径
       * @param {string} protocol - 协议类型
       * @returns {Promise<boolean>} 是否是有效的资源文件
       */
      async _validateResourceFile(filePath, protocol) {
        try {
          const content = await fs.readFile(filePath, "utf8");
          if (!content || typeof content !== "string") {
            return false;
          }
          const trimmedContent = content.trim();
          if (trimmedContent.length === 0) {
            return false;
          }
          switch (protocol) {
            case "role":
              return trimmedContent.includes("<role>") && trimmedContent.includes("</role>");
            case "execution":
              return trimmedContent.includes("<execution>") && trimmedContent.includes("</execution>");
            case "thought":
              return trimmedContent.includes("<thought>") && trimmedContent.includes("</thought>");
            case "knowledge":
              return true;
            case "manual":
              return trimmedContent.includes("<manual>") && trimmedContent.includes("</manual>");
            case "tool":
              try {
                new Function(trimmedContent);
                return true;
              } catch (e) {
                logger.warn(`[UserDiscovery] Invalid JavaScript in tool file ${filePath}: ${e.message}`);
                return false;
              }
            default:
              return false;
          }
        } catch (error) {
          logger.warn(`[UserDiscovery] Failed to validate ${filePath}: ${error.message}`);
          return false;
        }
      }
      /**
       * 从资源列表构建注册表 Map
       * @param {Array} resources - 资源列表
       * @returns {Map} 资源注册表
       */
      buildRegistryFromResources(resources) {
        const registryMap = /* @__PURE__ */ new Map();
        resources.forEach((resource) => {
          const key = `user:${resource.id}`;
          registryMap.set(key, resource.reference);
        });
        return registryMap;
      }
      /**
       * 生成并保存 User 注册表文件
       * @returns {Promise<RegistryData>} 生成的注册表数据
       */
      async generateRegistry() {
        try {
          const protocol = this.getUserProtocol();
          const registryPath = await protocol.resolvePath(".promptx/resource/user.registry.json");
          const registryData = RegistryData.createEmpty("user", registryPath);
          const resourceDir = await protocol.resolvePath(".promptx/resource");
          if (await fs.pathExists(resourceDir)) {
            await this._scanDirectory(resourceDir, registryData);
          }
          await fs.ensureDir(path.dirname(registryPath));
          await registryData.save();
          logger.info(`[UserDiscovery] \u2705 User \u6CE8\u518C\u8868\u751F\u6210\u5B8C\u6210\uFF0C\u53D1\u73B0 ${registryData.size} \u4E2A\u8D44\u6E90`);
          return registryData;
        } catch (error) {
          logger.error(`[UserDiscovery] \u751F\u6210\u6CE8\u518C\u8868\u5931\u8D25: ${error.message}`);
          return RegistryData.createEmpty("user");
        }
      }
      /**
       * 获取注册表数据（兼容接口）
       * @returns {Promise<RegistryData>} 注册表数据
       */
      async getRegistryData() {
        try {
          const protocol = this.getUserProtocol();
          const registryPath = await protocol.resolvePath(".promptx/resource/user.registry.json");
          if (await fs.pathExists(registryPath)) {
            const registryData = await RegistryData.fromFile("user", registryPath);
            if (registryData.size > 0) {
              logger.info(`[UserDiscovery] \u{1F4CB} \u4ECE\u6CE8\u518C\u8868\u52A0\u8F7D ${registryData.size} \u4E2A\u8D44\u6E90`);
              return registryData;
            }
          }
          logger.info(`[UserDiscovery] \u{1F4CB} User \u6CE8\u518C\u8868\u65E0\u6548\uFF0C\u91CD\u65B0\u751F\u6210`);
          return await this.generateRegistry();
        } catch (error) {
          logger.error(`[UserDiscovery] \u83B7\u53D6\u6CE8\u518C\u8868\u6570\u636E\u5931\u8D25: ${error.message}`);
          return RegistryData.createEmpty("user");
        }
      }
      /**
       * 发现资源（BaseDiscovery 要求的抽象方法）
       * @returns {Promise<Array>} 发现的资源列表
       */
      async discover() {
        const registryMap = await this.discoverRegistry();
        const resources = [];
        for (const [key, reference] of registryMap) {
          const [source, id] = key.split(":");
          if (source === "user" && id) {
            resources.push({
              id,
              reference,
              source: "user"
            });
          }
        }
        return resources;
      }
    };
    module2.exports = UserDiscovery;
  }
});

// src/resource/discovery/DiscoveryManager.js
var require_DiscoveryManager = __commonJS({
  "src/resource/discovery/DiscoveryManager.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var PackageDiscovery = require_PackageDiscovery();
    var ProjectDiscovery = require_ProjectDiscovery();
    var UserDiscovery = require_UserDiscovery();
    var logger = require("@promptx/logger");
    var DiscoveryManager = class {
      /**
       * 构造函数
       * @param {Array} discoveries - 自定义发现器列表，如果不提供则使用默认配置
       */
      constructor(discoveries = null) {
        if (discoveries) {
          this.discoveries = [...discoveries];
        } else {
          this.discoveries = [
            new PackageDiscovery(),
            // 优先级: 1
            new ProjectDiscovery(),
            // 优先级: 2
            new UserDiscovery()
            // 优先级: 3 (最高)
          ];
        }
        this._sortDiscoveriesByPriority();
      }
      /**
       * 添加发现器
       * @param {Object} discovery - 实现了发现器接口的对象
       */
      addDiscovery(discovery) {
        if (!discovery || typeof discovery.discover !== "function") {
          throw new Error("Discovery must implement discover method");
        }
        this.discoveries.push(discovery);
        this._sortDiscoveriesByPriority();
      }
      /**
       * 移除发现器
       * @param {string} source - 发现器源类型
       */
      removeDiscovery(source) {
        this.discoveries = this.discoveries.filter((discovery) => discovery.source !== source);
      }
      /**
       * 发现所有资源（并行模式）
       * @returns {Promise<Array>} 所有发现的资源列表
       */
      async discoverAll() {
        const discoveryPromises = this.discoveries.map(async (discovery) => {
          try {
            const resources = await discovery.discover();
            return Array.isArray(resources) ? resources : [];
          } catch (error) {
            logger.warn(`[DiscoveryManager] ${discovery.source} discovery failed: ${error.message}`);
            return [];
          }
        });
        const discoveryResults = await Promise.allSettled(discoveryPromises);
        const allResources = [];
        discoveryResults.forEach((result, index) => {
          if (result.status === "fulfilled") {
            allResources.push(...result.value);
          } else {
            logger.warn(`[DiscoveryManager] ${this.discoveries[index].source} discovery rejected: ${result.reason}`);
          }
        });
        return allResources;
      }
      /**
       * 发现并合并所有注册表（RegistryData架构）
       * @returns {Promise<Map>} 合并后的资源注册表 Map<resourceId, reference>
       */
      async discoverRegistries() {
        const registryPromises = this.discoveries.map(async (discovery) => {
          try {
            if (typeof discovery.discoverRegistry === "function") {
              const registry = await discovery.discoverRegistry();
              return registry instanceof Map ? registry : /* @__PURE__ */ new Map();
            } else {
              const resources = await discovery.discover();
              const registry = /* @__PURE__ */ new Map();
              if (Array.isArray(resources)) {
                resources.forEach((resource) => {
                  if (resource.id && resource.reference) {
                    registry.set(resource.id, resource.reference);
                  }
                });
              }
              return registry;
            }
          } catch (error) {
            logger.warn(`[DiscoveryManager] ${discovery.source} registry discovery failed: ${error.message}`);
            return /* @__PURE__ */ new Map();
          }
        });
        const registryResults = await Promise.allSettled(registryPromises);
        const registries = [];
        registryResults.forEach((result, index) => {
          if (result.status === "fulfilled") {
            registries.push(result.value);
          } else {
            logger.warn(`[DiscoveryManager] ${this.discoveries[index].source} registry discovery rejected: ${result.reason}`);
            registries.push(/* @__PURE__ */ new Map());
          }
        });
        return this._mergeRegistries(registries);
      }
      /**
       * 按源类型发现注册表
       * @param {string} source - 发现器源类型
       * @returns {Promise<Map>} 指定源的资源注册表
       */
      async discoverRegistryBySource(source) {
        const discovery = this._findDiscoveryBySource(source);
        if (!discovery) {
          throw new Error(`Discovery source ${source} not found`);
        }
        if (typeof discovery.discoverRegistry === "function") {
          return await discovery.discoverRegistry();
        } else {
          const resources = await discovery.discover();
          const registry = /* @__PURE__ */ new Map();
          if (Array.isArray(resources)) {
            resources.forEach((resource) => {
              if (resource.id && resource.reference) {
                registry.set(resource.id, resource.reference);
              }
            });
          }
          return registry;
        }
      }
      /**
       * 按源类型发现资源
       * @param {string} source - 发现器源类型
       * @returns {Promise<Array>} 指定源的资源列表
       */
      async discoverBySource(source) {
        const discovery = this._findDiscoveryBySource(source);
        if (!discovery) {
          throw new Error(`Discovery source ${source} not found`);
        }
        return await discovery.discover();
      }
      /**
       * 获取所有发现器信息
       * @returns {Array} 发现器信息列表
       */
      getDiscoveryInfo() {
        return this.discoveries.map((discovery) => {
          if (typeof discovery.getDiscoveryInfo === "function") {
            return discovery.getDiscoveryInfo();
          } else {
            return {
              source: discovery.source || "UNKNOWN",
              priority: discovery.priority || 0,
              description: "No description available"
            };
          }
        });
      }
      /**
       * 清理所有发现器缓存
       */
      clearCache() {
        this.discoveries.forEach((discovery) => {
          if (typeof discovery.clearCache === "function") {
            discovery.clearCache();
          }
        });
      }
      /**
       * 获取发现器数量
       * @returns {number} 注册的发现器数量
       */
      getDiscoveryCount() {
        return this.discoveries.length;
      }
      /**
       * 合并多个注册表（支持分层级资源管理）
       * @param {Array<Map>} registries - 注册表数组，按优先级排序（数字越小优先级越高）
       * @returns {Map} 合并后的注册表
       * @private
       */
      _mergeRegistries(registries) {
        const mergedRegistry = /* @__PURE__ */ new Map();
        for (let i = registries.length - 1; i >= 0; i--) {
          const registry = registries[i];
          if (registry instanceof Map) {
            for (const [key, value] of registry) {
              mergedRegistry.set(key, value);
            }
          }
        }
        const priorityLevels = ["package", "project", "user"];
        const baseResourceMap = /* @__PURE__ */ new Map();
        for (const [fullId, reference] of mergedRegistry) {
          const colonIndex = fullId.indexOf(":");
          let source = "unknown";
          let baseId = fullId;
          if (colonIndex !== -1) {
            const possibleSource = fullId.substring(0, colonIndex);
            if (priorityLevels.includes(possibleSource)) {
              source = possibleSource;
              baseId = fullId.substring(colonIndex + 1);
            }
          }
          const currentPriority = priorityLevels.indexOf(source);
          const existing = baseResourceMap.get(baseId);
          if (!existing || currentPriority > existing.priority) {
            baseResourceMap.set(baseId, {
              source,
              reference,
              priority: currentPriority,
              fullId
            });
          }
        }
        const finalRegistry = /* @__PURE__ */ new Map();
        for (const [key, value] of mergedRegistry) {
          if (key.includes(":") && priorityLevels.includes(key.split(":")[0])) {
            finalRegistry.set(key, value);
          }
        }
        for (const [baseId, info] of baseResourceMap) {
          finalRegistry.set(baseId, info.reference);
        }
        return finalRegistry;
      }
      /**
       * 按优先级排序发现器
       * @private
       */
      _sortDiscoveriesByPriority() {
        this.discoveries.sort((a, b) => {
          const priorityA = a.priority || 0;
          const priorityB = b.priority || 0;
          return priorityA - priorityB;
        });
      }
      /**
       * 根据源类型查找发现器
       * @param {string} source - 发现器源类型
       * @returns {Object|undefined} 找到的发现器或undefined
       * @private
       */
      _findDiscoveryBySource(source) {
        return this.discoveries.find((discovery) => discovery.source === source);
      }
    };
    module2.exports = DiscoveryManager;
  }
});

// src/resource/protocols/ResourceProtocol.js
var require_ResourceProtocol = __commonJS({
  "src/resource/protocols/ResourceProtocol.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var ResourceProtocol = class _ResourceProtocol {
      /**
       * 构造函数
       * @param {string} name - 协议名称
       * @param {object} options - 配置选项
       */
      constructor(name, options = {}) {
        if (new.target === _ResourceProtocol) {
          throw new Error("ResourceProtocol\u662F\u62BD\u8C61\u7C7B\uFF0C\u4E0D\u80FD\u76F4\u63A5\u5B9E\u4F8B\u5316");
        }
        this.name = name;
        this.options = options;
        this.cache = /* @__PURE__ */ new Map();
        this.enableCache = options.enableCache === true;
      }
      /**
       * 协议信息 - 需要子类实现
       * @returns {object} 协议信息
       */
      getProtocolInfo() {
        throw new Error("\u5B50\u7C7B\u5FC5\u987B\u5B9E\u73B0 getProtocolInfo() \u65B9\u6CD5");
      }
      /**
       * 解析资源路径 - 需要子类实现
       * @param {string} resourcePath - 原始资源路径
       * @param {QueryParams} queryParams - 查询参数
       * @returns {Promise<string>} 解析后的路径
       */
      async resolvePath(resourcePath, queryParams) {
        throw new Error("\u5B50\u7C7B\u5FC5\u987B\u5B9E\u73B0 resolvePath() \u65B9\u6CD5");
      }
      /**
       * 加载资源内容 - 需要子类实现
       * @param {string} resolvedPath - 解析后的路径
       * @param {QueryParams} queryParams - 查询参数
       * @returns {Promise<string>} 资源内容
       */
      async loadContent(resolvedPath, queryParams) {
        throw new Error("\u5B50\u7C7B\u5FC5\u987B\u5B9E\u73B0 loadContent() \u65B9\u6CD5");
      }
      /**
       * 验证资源路径格式 - 可选实现
       * @param {string} resourcePath - 资源路径
       * @returns {boolean} 是否有效
       */
      validatePath(resourcePath) {
        return typeof resourcePath === "string" && resourcePath.length > 0;
      }
      /**
       * 支持的查询参数列表 - 可选实现
       * @returns {object} 参数说明
       */
      getSupportedParams() {
        return {
          line: 'string - \u884C\u8303\u56F4\uFF0C\u5982 "1-10"',
          format: "string - \u8F93\u51FA\u683C\u5F0F",
          cache: "boolean - \u662F\u5426\u7F13\u5B58"
        };
      }
      /**
       * 统一的资源解析入口点
       * @param {string} resourcePath - 资源路径
       * @param {QueryParams} queryParams - 查询参数
       * @returns {Promise<string>} 资源内容
       */
      async resolve(resourcePath, queryParams) {
        if (!this.validatePath(resourcePath)) {
          const error = new Error(`\u65E0\u6548\u7684\u8D44\u6E90\u8DEF\u5F84: ${resourcePath}`);
          const logger = require("@promptx/logger");
          logger.error(`[ResourceProtocol] \u8DEF\u5F84\u9A8C\u8BC1\u5931\u8D25: ${resourcePath}`);
          logger.error(`[ResourceProtocol] \u8C03\u7528\u5806\u6808:`, error.stack);
          throw error;
        }
        const cacheKey = this.generateCacheKey(resourcePath, queryParams);
        if (this.enableCache && this.cache.has(cacheKey)) {
          return this.cache.get(cacheKey);
        }
        const resolvedPath = await this.resolvePath(resourcePath, queryParams);
        const content = await this.loadContent(resolvedPath, queryParams);
        const filteredContent = this.applyCommonParams(content, queryParams);
        if (this.enableCache) {
          this.cache.set(cacheKey, filteredContent);
        }
        return filteredContent;
      }
      /**
       * 生成缓存键
       * @param {string} resourcePath - 资源路径
       * @param {QueryParams} queryParams - 查询参数
       * @returns {string} 缓存键
       */
      generateCacheKey(resourcePath, queryParams) {
        const params = queryParams ? queryParams.getAll() : {};
        return `${this.name}:${resourcePath}:${JSON.stringify(params)}`;
      }
      /**
       * 应用通用查询参数
       * @param {string} content - 原始内容
       * @param {QueryParams} queryParams - 查询参数
       * @returns {string} 过滤后的内容
       */
      applyCommonParams(content, queryParams) {
        if (!queryParams) {
          return content;
        }
        let result = content;
        if (queryParams.line) {
          result = this.applyLineFilter(result, queryParams.line);
        }
        if (queryParams.format && queryParams.format !== "text") {
          result = this.applyFormat(result, queryParams.format);
        }
        return result;
      }
      /**
       * 应用行过滤
       * @param {string} content - 内容
       * @param {string} lineRange - 行范围，如 "5-10" 或 "5"
       * @returns {string} 过滤后的内容
       */
      applyLineFilter(content, lineRange) {
        const lines = content.split("\n");
        if (lineRange.includes("-")) {
          const [start, end] = lineRange.split("-").map((n) => parseInt(n.trim(), 10));
          const startIndex = Math.max(0, start - 1);
          const endIndex = Math.min(lines.length, end);
          return lines.slice(startIndex, endIndex).join("\n");
        } else {
          const lineNum = parseInt(lineRange, 10);
          const lineIndex = lineNum - 1;
          return lines[lineIndex] || "";
        }
      }
      /**
       * 应用格式化
       * @param {string} content - 内容
       * @param {string} format - 格式
       * @returns {string} 格式化后的内容
       */
      applyFormat(content, format) {
        switch (format) {
          case "json":
            try {
              return JSON.stringify(JSON.parse(content), null, 2);
            } catch {
              return content;
            }
          case "trim":
            return content.trim();
          default:
            return content;
        }
      }
      /**
       * 清除缓存
       */
      clearCache() {
        this.cache.clear();
      }
      /**
       * 获取缓存统计
       * @returns {object} 缓存统计信息
       */
      getCacheStats() {
        return {
          protocol: this.name,
          size: this.cache.size,
          enabled: this.enableCache
        };
      }
    };
    module2.exports = ResourceProtocol;
  }
});

// src/resource/protocols/PackageProtocol.js
var require_PackageProtocol = __commonJS({
  "src/resource/protocols/PackageProtocol.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var path = require("path");
    var fs = require("fs");
    var fsPromises = require("fs").promises;
    var ResourceProtocol = require_ResourceProtocol();
    var { QueryParams } = require_types();
    var logger = require("@promptx/logger");
    var { getDirectoryService } = require_DirectoryService();
    var PackageProtocol = class extends ResourceProtocol {
      constructor(options = {}) {
        super("package", options);
        this.directoryService = getDirectoryService();
      }
      /**
       * 设置注册表（保持与其他协议的一致性）
       */
      setRegistry(registry) {
        this.registry = registry || {};
      }
      /**
       * 获取协议信息
       */
      getProtocolInfo() {
        return {
          name: this.name,
          description: "\u5305\u534F\u8BAE - \u667A\u80FD\u8BBF\u95EENPM\u5305\u8D44\u6E90\uFF0C\u652F\u6301\u591A\u79CD\u5B89\u88C5\u6A21\u5F0F",
          examples: [
            "@package://package.json",
            "@package://src/index.js",
            "@package://docs/README.md",
            "@package://resource/core/thought.md",
            "@package://templates/basic/template.md"
          ],
          installModes: [
            "development",
            // 开发模式
            "local",
            // 本地npm install
            "global",
            // 全局npm install -g
            "npx",
            // npx执行
            "monorepo",
            // monorepo workspace
            "link"
            // npm link
          ]
        };
      }
      /**
       * 获取包根目录 - 始终使用 dist 目录
       */
      async getPackageRoot() {
        try {
          const resourcePath = require.resolve("@promptx/resource");
          logger.info(`[PackageProtocol] require.resolve('@promptx/resource') returned: ${resourcePath}`);
          const distDir = path.dirname(resourcePath);
          logger.info(`[PackageProtocol] Using dist directory as package root: ${distDir}`);
          const resourcesDir = path.join(distDir, "resources");
          logger.info(`[PackageProtocol] Resources directory path: ${resourcesDir}`);
          logger.info(`[PackageProtocol] Resources directory exists: ${fs.existsSync(resourcesDir)}`);
          return distDir;
        } catch (error) {
          logger.error(`[PackageProtocol] Cannot locate @promptx/resource package: ${error.message}`);
          logger.error(`[PackageProtocol] Error stack:`, error.stack);
          logger.error(`[PackageProtocol] This is a critical system error, @promptx/resource must exist and be accessible via require`);
          throw error;
        }
      }
      /**
       * 解析路径到具体的文件系统路径 - 使用 PackageResource
       * @param {string} relativePath - 相对于包根目录的路径
       * @param {QueryParams} params - 查询参数
       * @returns {Promise<string>} 解析后的绝对路径
       */
      async resolvePath(relativePath, params = null) {
        logger.info(`[PackageProtocol] Resolving path: ${relativePath}`);
        try {
          const resourceModule = require("@promptx/resource");
          logger.info(`[PackageProtocol] Resource module loaded:`, Object.keys(resourceModule));
          const { packageResource } = resourceModule;
          logger.info(`[PackageProtocol] PackageResource type:`, typeof packageResource);
          logger.debug(`[PackageProtocol] Successfully loaded PackageResource`);
          const cleanPath = relativePath.replace(/^\/+/, "");
          logger.debug(`[PackageProtocol] Cleaned path: ${cleanPath}`);
          const fullPath = packageResource.resolvePath(cleanPath);
          logger.info(`[PackageProtocol] PackageResource resolved path: ${fullPath}`);
          const exists = packageResource.exists(cleanPath);
          logger.info(`[PackageProtocol] File exists: ${exists} (path: ${fullPath})`);
          if (!exists) {
            logger.error(`[PackageProtocol] Resource file not found: ${fullPath}`);
            return null;
          }
          return fullPath;
        } catch (error) {
          logger.error(`[PackageProtocol] Failed to resolve resource path: ${error.message}`);
          logger.error(`[PackageProtocol] Error stack:`, error.stack);
          throw error;
        }
      }
      /**
       * 验证文件访问权限（基于package.json的files字段）
       * @param {string} packageRoot - 包根目录
       * @param {string} relativePath - 相对路径
       */
      validateFileAccess(packageRoot, relativePath) {
        logger.debug(`[PackageProtocol] Validating file access for: ${relativePath}`);
      }
      /**
       * 检查资源是否存在
       */
      async exists(resourcePath, queryParams) {
        try {
          const resolvedPath = await this.resolvePath(resourcePath, queryParams);
          await fsPromises.access(resolvedPath);
          return true;
        } catch (error) {
          return false;
        }
      }
      /**
       * 加载资源内容
       * @param {string} resolvedPath - 已解析的路径
       * @param {QueryParams} [queryParams] - 查询参数
       * @returns {Object} 包含内容和元数据的对象
       */
      async loadContent(resolvedPath, queryParams) {
        try {
          await fsPromises.access(resolvedPath);
          const content = await fsPromises.readFile(resolvedPath, "utf8");
          const stats = await fsPromises.stat(resolvedPath);
          const packageRoot = await this.getPackageRoot();
          return {
            content,
            path: resolvedPath,
            protocol: "package",
            metadata: {
              size: content.length,
              lastModified: stats.mtime,
              absolutePath: resolvedPath,
              relativePath: path.relative(packageRoot, resolvedPath)
            }
          };
        } catch (error) {
          if (error.code === "ENOENT") {
            throw new Error(`Package resource not found: ${resolvedPath}`);
          }
          throw new Error(`Failed to load package resource: ${error.message}`);
        }
      }
      /**
       * 获取调试信息
       */
      getDebugInfo() {
        return {
          protocol: this.name,
          packageRoot: this.getPackageRoot(),
          currentWorkingDirectory: process.cwd(),
          moduleDirectory: __dirname,
          cacheSize: this.cache.size
        };
      }
      /**
       * 清理缓存
       */
      clearCache() {
        super.clearCache();
      }
    };
    module2.exports = PackageProtocol;
  }
});

// src/utils/ProjectPathResolver.js
var require_ProjectPathResolver = __commonJS({
  "src/utils/ProjectPathResolver.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var path = require("path");
    var ProjectManager = require_ProjectManager();
    var ProjectPathResolver = class {
      constructor() {
        this.projectDirs = {
          root: "",
          // 项目根目录
          src: "src",
          // 源代码目录
          lib: "lib",
          // 库目录
          build: "build",
          // 构建输出目录
          dist: "dist",
          // 分发目录
          docs: "docs",
          // 文档目录
          test: "test",
          // 测试目录
          tests: "tests",
          // 测试目录（复数）
          spec: "spec",
          // 规范测试目录
          config: "config",
          // 配置目录
          scripts: "scripts",
          // 脚本目录
          assets: "assets",
          // 资源目录
          public: "public",
          // 公共资源目录
          static: "static",
          // 静态资源目录
          templates: "templates",
          // 模板目录
          examples: "examples",
          // 示例目录
          tools: "tools",
          // 工具目录
          ".promptx": ".promptx"
          // PromptX配置目录
        };
      }
      /**
       * 解析@project://协议路径
       * @param {string} resourcePath - 资源路径，如 "src/index.js" 或 ".promptx/resource/..."
       * @returns {string} 解析后的绝对路径
       */
      resolvePath(resourcePath) {
        const projectRoot = ProjectManager.getCurrentProjectPath();
        if (resourcePath.startsWith(".promptx/")) {
          const fullPath2 = path.join(projectRoot, resourcePath);
          return this._validatePath(fullPath2, projectRoot);
        }
        const parts = resourcePath.split("/");
        const dirType = parts[0];
        const relativePath = parts.slice(1).join("/");
        if (!this.projectDirs.hasOwnProperty(dirType)) {
          throw new Error(`\u4E0D\u652F\u6301\u7684\u9879\u76EE\u76EE\u5F55\u7C7B\u578B: ${dirType}\u3002\u652F\u6301\u7684\u7C7B\u578B: ${Object.keys(this.projectDirs).join(", ")}`);
        }
        const projectDirPath = this.projectDirs[dirType];
        const targetDir = projectDirPath ? path.join(projectRoot, projectDirPath) : projectRoot;
        if (!relativePath) {
          return targetDir;
        }
        const fullPath = path.join(targetDir, relativePath);
        return this._validatePath(fullPath, projectRoot);
      }
      /**
       * 获取项目根目录
       * @returns {string} 当前项目根目录
       */
      getProjectRoot() {
        return ProjectManager.getCurrentProjectPath();
      }
      /**
       * 获取PromptX配置目录路径
       * @returns {string} .promptx目录路径
       */
      getPromptXDirectory() {
        const projectRoot = ProjectManager.getCurrentProjectPath();
        return path.join(projectRoot, ".promptx");
      }
      /**
       * 获取项目资源目录路径
       * @returns {string} 项目资源目录路径
       */
      getResourceDirectory() {
        const promptxDir = this.getPromptXDirectory();
        return path.join(promptxDir, "resource");
      }
      /**
       * 获取项目注册表文件路径
       * @returns {string} 注册表文件路径
       */
      getRegistryPath() {
        const resourceDir = this.getResourceDirectory();
        return path.join(resourceDir, "project.registry.json");
      }
      /**
       * 获取记忆目录路径
       * @returns {string} 记忆目录路径
       */
      getMemoryDirectory() {
        const promptxDir = this.getPromptXDirectory();
        return path.join(promptxDir, "memory");
      }
      /**
       * 验证路径安全性
       * @param {string} fullPath - 完整路径
       * @param {string} projectRoot - 项目根目录
       * @returns {string} 验证后的路径
       * @private
       */
      _validatePath(fullPath, projectRoot) {
        const resolvedPath = path.resolve(fullPath);
        const resolvedProjectRoot = path.resolve(projectRoot);
        if (!resolvedPath.startsWith(resolvedProjectRoot)) {
          throw new Error(`\u5B89\u5168\u9519\u8BEF\uFF1A\u8DEF\u5F84\u8D85\u51FA\u9879\u76EE\u76EE\u5F55\u8303\u56F4: ${resolvedPath}`);
        }
        return resolvedPath;
      }
      /**
       * 获取支持的目录类型
       * @returns {Array<string>} 支持的目录类型列表
       */
      getSupportedDirectories() {
        return Object.keys(this.projectDirs);
      }
      /**
       * 检查目录类型是否支持
       * @param {string} dirType - 目录类型
       * @returns {boolean} 是否支持
       */
      isSupportedDirectory(dirType) {
        return this.projectDirs.hasOwnProperty(dirType);
      }
    };
    var globalProjectPathResolver = null;
    function getGlobalProjectPathResolver() {
      if (!globalProjectPathResolver) {
        globalProjectPathResolver = new ProjectPathResolver();
      }
      return globalProjectPathResolver;
    }
    module2.exports = ProjectPathResolver;
    module2.exports.getGlobalProjectPathResolver = getGlobalProjectPathResolver;
  }
});

// src/resource/protocols/UserProtocol.js
var require_UserProtocol = __commonJS({
  "src/resource/protocols/UserProtocol.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var ResourceProtocol = require_ResourceProtocol();
    var path = require("path");
    var fs = require("fs").promises;
    var envPaths = require("env-paths");
    var os = require("os");
    var getUserDirectories = () => {
      const promptxPaths = envPaths("promptx");
      return {
        getHomeFolder: () => os.homedir(),
        getDesktopFolder: () => path.join(os.homedir(), "Desktop"),
        getDocumentsFolder: () => path.join(os.homedir(), "Documents"),
        getDownloadsFolder: () => path.join(os.homedir(), "Downloads"),
        getMusicFolder: () => path.join(os.homedir(), "Music"),
        getPicturesFolder: () => path.join(os.homedir(), "Pictures"),
        getVideosFolder: () => path.join(os.homedir(), "Videos"),
        // 新增：env-paths标准目录
        getDataFolder: () => promptxPaths.data,
        getConfigFolder: () => promptxPaths.config,
        getCacheFolder: () => promptxPaths.cache,
        getLogFolder: () => promptxPaths.log,
        getTempFolder: () => promptxPaths.temp
      };
    };
    var UserProtocol = class extends ResourceProtocol {
      constructor(options = {}) {
        super("user", options);
        this.userDirs = {
          home: "getHomeFolder",
          desktop: "getDesktopFolder",
          documents: "getDocumentsFolder",
          downloads: "getDownloadsFolder",
          music: "getMusicFolder",
          pictures: "getPicturesFolder",
          videos: "getVideosFolder",
          // 新增：env-paths标准目录
          data: "getDataFolder",
          config: "getConfigFolder",
          cache: "getCacheFolder",
          log: "getLogFolder",
          temp: "getTempFolder"
        };
        this.dirCache = /* @__PURE__ */ new Map();
      }
      /**
       * 设置注册表（保持与其他协议的一致性）
       */
      setRegistry(registry) {
        this.registry = registry || {};
      }
      /**
       * 获取协议信息
       * @returns {object} 协议信息
       */
      getProtocolInfo() {
        return {
          name: "user",
          description: "\u7528\u6237\u76EE\u5F55\u534F\u8BAE\uFF0C\u76F4\u63A5\u6620\u5C04\u5230\u7528\u6237\u4E3B\u76EE\u5F55",
          location: "user://{path}",
          examples: [
            "user://.promptx/toolbox/text-analyzer",
            "user://.bashrc",
            "user://Documents/notes.txt",
            "user://Desktop/readme.md",
            "user://Downloads/file.zip",
            "user://.promptx/config.json"
          ],
          basePath: "\u7528\u6237\u4E3B\u76EE\u5F55 (~)",
          params: this.getSupportedParams()
        };
      }
      /**
       * 支持的查询参数
       * @returns {object} 参数说明
       */
      getSupportedParams() {
        return {
          ...super.getSupportedParams(),
          exists: "boolean - \u4EC5\u8FD4\u56DE\u5B58\u5728\u7684\u6587\u4EF6/\u76EE\u5F55",
          type: "string - \u8FC7\u6EE4\u7C7B\u578B (file|dir|both)"
        };
      }
      /**
       * 验证用户协议路径
       * @param {string} resourcePath - 资源路径
       * @returns {boolean} 是否有效
       */
      validatePath(resourcePath) {
        if (!resourcePath || typeof resourcePath !== "string") {
          return false;
        }
        if (resourcePath.startsWith(".promptx/")) {
          return true;
        }
        const parts = resourcePath.split("/");
        const dirType = parts[0];
        return this.userDirs.hasOwnProperty(dirType);
      }
      /**
       * 解析用户目录路径
       * @param {string} resourcePath - 原始资源路径，如 ".promptx/toolbox/test-tool"
       * @param {QueryParams} queryParams - 查询参数
       * @returns {Promise<string>} 解析后的绝对路径
       */
      async resolvePath(resourcePath, queryParams) {
        const userHomeDir = getUserDirectories().getHomeFolder();
        if (!resourcePath) {
          return userHomeDir;
        }
        const fullPath = path.join(userHomeDir, resourcePath);
        const resolvedPath = path.resolve(fullPath);
        const resolvedUserDir = path.resolve(userHomeDir);
        if (!resolvedPath.startsWith(resolvedUserDir)) {
          throw new Error(`\u5B89\u5168\u9519\u8BEF\uFF1A\u8DEF\u5F84\u8D85\u51FA\u7528\u6237\u76EE\u5F55\u8303\u56F4: ${resolvedPath}`);
        }
        return resolvedPath;
      }
      /**
       * 获取用户目录路径
       * @param {string} dirType - 目录类型
       * @returns {Promise<string>} 目录路径
       */
      async getUserDirectory(dirType) {
        if (this.dirCache.has(dirType)) {
          return this.dirCache.get(dirType);
        }
        const userDirectories = getUserDirectories();
        const methodName = this.userDirs[dirType];
        if (!userDirectories[methodName]) {
          throw new Error(`\u672A\u627E\u5230\u7528\u6237\u76EE\u5F55\u83B7\u53D6\u65B9\u6CD5: ${methodName}`);
        }
        try {
          let dirPath;
          if (typeof userDirectories[methodName] === "function") {
            dirPath = userDirectories[methodName]();
          } else {
            dirPath = userDirectories[methodName];
          }
          this.dirCache.set(dirType, dirPath);
          return dirPath;
        } catch (error) {
          throw new Error(`\u83B7\u53D6\u7528\u6237\u76EE\u5F55\u5931\u8D25 (${dirType}): ${error.message}`);
        }
      }
      /**
       * 加载资源内容
       * @param {string} resolvedPath - 解析后的路径
       * @param {QueryParams} queryParams - 查询参数
       * @returns {Promise<string>} 资源内容
       */
      async loadContent(resolvedPath, queryParams) {
        try {
          const stats = await fs.stat(resolvedPath);
          if (stats.isDirectory()) {
            return await this.loadDirectoryContent(resolvedPath, queryParams);
          } else if (stats.isFile()) {
            return await this.loadFileContent(resolvedPath, queryParams);
          } else {
            throw new Error(`\u4E0D\u652F\u6301\u7684\u6587\u4EF6\u7C7B\u578B: ${resolvedPath}`);
          }
        } catch (error) {
          if (error.code === "ENOENT") {
            if (queryParams && queryParams.get("exists") === "false") {
              return "";
            }
            throw new Error(`\u6587\u4EF6\u6216\u76EE\u5F55\u4E0D\u5B58\u5728: ${resolvedPath}`);
          }
          throw error;
        }
      }
      /**
       * 加载文件内容
       * @param {string} filePath - 文件路径
       * @param {QueryParams} queryParams - 查询参数
       * @returns {Promise<string>} 文件内容
       */
      async loadFileContent(filePath, queryParams) {
        const encoding = (queryParams == null ? void 0 : queryParams.get("encoding")) || "utf8";
        return await fs.readFile(filePath, encoding);
      }
      /**
       * 加载目录内容
       * @param {string} dirPath - 目录路径
       * @param {QueryParams} queryParams - 查询参数
       * @returns {Promise<string>} 目录内容列表
       */
      async loadDirectoryContent(dirPath, queryParams) {
        const entries = await fs.readdir(dirPath, { withFileTypes: true });
        const typeFilter = queryParams == null ? void 0 : queryParams.get("type");
        let filteredEntries = entries;
        if (typeFilter) {
          filteredEntries = entries.filter((entry) => {
            switch (typeFilter) {
              case "file":
                return entry.isFile();
              case "dir":
                return entry.isDirectory();
              case "both":
                return true;
              default:
                return true;
            }
          });
        }
        const format = (queryParams == null ? void 0 : queryParams.get("format")) || "list";
        switch (format) {
          case "json":
            return JSON.stringify(
              filteredEntries.map((entry) => ({
                name: entry.name,
                type: entry.isDirectory() ? "directory" : "file",
                path: path.join(dirPath, entry.name)
              })),
              null,
              2
            );
          case "paths":
            return filteredEntries.map((entry) => path.join(dirPath, entry.name)).join("\n");
          case "list":
          default:
            return filteredEntries.map((entry) => {
              const type = entry.isDirectory() ? "[DIR]" : "[FILE]";
              return `${type} ${entry.name}`;
            }).join("\n");
        }
      }
      /**
       * 列出所有支持的用户目录
       * @returns {Promise<object>} 目录信息
       */
      async listUserDirectories() {
        const result = {};
        for (const dirType of Object.keys(this.userDirs)) {
          try {
            result[dirType] = await this.getUserDirectory(dirType);
          } catch (error) {
            result[dirType] = { error: error.message };
          }
        }
        return result;
      }
      /**
       * 清除目录缓存
       */
      clearCache() {
        super.clearCache();
        this.dirCache.clear();
      }
    };
    module2.exports = UserProtocol;
  }
});

// src/resource/protocols/ProjectProtocol.js
var require_ProjectProtocol = __commonJS({
  "src/resource/protocols/ProjectProtocol.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var ResourceProtocol = require_ResourceProtocol();
    var path = require("path");
    var fs = require("fs").promises;
    var { getGlobalProjectPathResolver } = require_ProjectPathResolver();
    var ProjectManager = require_ProjectManager();
    var UserProtocol = require_UserProtocol();
    var ProjectProtocol = class extends ResourceProtocol {
      constructor(options = {}) {
        super("project", options);
        this.pathResolver = null;
        this.userProtocol = new UserProtocol(options);
      }
      /**
       * 获取路径解析器（延迟初始化）
       * @returns {ProjectPathResolver} 路径解析器实例
       */
      getPathResolver() {
        if (!this.pathResolver) {
          this.pathResolver = getGlobalProjectPathResolver();
        }
        return this.pathResolver;
      }
      /**
       * 设置注册表（保持与其他协议的一致性）
       */
      setRegistry(registry) {
        this.registry = registry || {};
      }
      /**
       * 获取协议信息
       * @returns {object} 协议信息
       */
      getProtocolInfo() {
        return {
          name: "project",
          description: "\u9879\u76EE\u534F\u8BAE\uFF0C\u57FA\u4E8E\u5F53\u524D\u9879\u76EE\u72B6\u6001\u7684\u9AD8\u6027\u80FD\u8DEF\u5F84\u89E3\u6790",
          location: "project://{directory}/{path}",
          examples: [
            "project://src/index.js",
            "project://lib/utils.js",
            "project://docs/README.md",
            "project://root/package.json",
            "project://test/unit/"
          ],
          supportedDirectories: this.getPathResolver().getSupportedDirectories(),
          architecture: "state-based",
          params: this.getSupportedParams()
        };
      }
      /**
       * 支持的查询参数
       * @returns {object} 参数说明
       */
      getSupportedParams() {
        return {
          ...super.getSupportedParams(),
          from: "string - \u6307\u5B9A\u641C\u7D22\u8D77\u59CB\u76EE\u5F55",
          create: "boolean - \u5982\u679C\u76EE\u5F55\u4E0D\u5B58\u5728\u662F\u5426\u521B\u5EFA",
          exists: "boolean - \u4EC5\u8FD4\u56DE\u5B58\u5728\u7684\u6587\u4EF6/\u76EE\u5F55",
          type: "string - \u8FC7\u6EE4\u7C7B\u578B (file|dir|both)"
        };
      }
      /**
       * 验证项目协议路径
       * @param {string} resourcePath - 资源路径
       * @returns {boolean} 是否有效
       */
      validatePath(resourcePath) {
        if (!super.validatePath(resourcePath)) {
          return false;
        }
        if (resourcePath.startsWith(".promptx/")) {
          return true;
        }
        const parts = resourcePath.split("/");
        const dirType = parts[0];
        return this.getPathResolver().isSupportedDirectory(dirType);
      }
      /**
       * 解析项目路径 - 新架构：高性能零查找 + HTTP模式支持
       * @param {string} resourcePath - 原始资源路径，如 "src/index.js" 或 ".promptx/resource/..."
       * @param {QueryParams} queryParams - 查询参数
       * @returns {Promise<string>} 解析后的绝对路径
       */
      async resolvePath(resourcePath, queryParams) {
        try {
          const currentProject = ProjectManager.getCurrentProject();
          const { transport } = currentProject;
          if (transport === "http") {
            return await this.resolveHttpPath(resourcePath, queryParams, currentProject);
          } else {
            return this.resolveLocalPath(resourcePath, queryParams, currentProject);
          }
        } catch (error) {
          throw new Error(`\u89E3\u6790@project://\u8DEF\u5F84\u5931\u8D25: ${error.message}`);
        }
      }
      /**
       * 本地模式路径解析（原有逻辑）
       * @param {string} resourcePath - 资源路径
       * @param {QueryParams} queryParams - 查询参数
       * @param {Object} currentProject - 当前项目信息
       * @returns {string} 解析后的绝对路径
       */
      resolveLocalPath(resourcePath, queryParams, currentProject) {
        return this.getPathResolver().resolvePath(resourcePath);
      }
      /**
       * HTTP模式路径解析（映射到用户目录的项目空间）
       * @param {string} resourcePath - 资源路径，如".promptx/resource/xxx"
       * @param {QueryParams} queryParams - 查询参数
       * @param {Object} currentProject - 当前项目信息
       * @returns {Promise<string>} 解析后的绝对路径
       */
      async resolveHttpPath(resourcePath, queryParams, currentProject) {
        const projectHash = this.generateProjectHash(currentProject.workingDirectory);
        let mappedResourcePath = resourcePath;
        if (resourcePath === ".promptx") {
          mappedResourcePath = "data";
        } else if (resourcePath.startsWith(".promptx/")) {
          mappedResourcePath = resourcePath.replace(/^\.promptx\//, "data/");
        } else {
          mappedResourcePath = `data/${resourcePath}`;
        }
        const mappedPath = `.promptx/project/${projectHash}/${mappedResourcePath}`;
        return await this.userProtocol.resolvePath(mappedPath, queryParams);
      }
      /**
       * 生成项目路径的Hash值（与ProjectManager保持一致）
       * @param {string} projectPath - 项目路径
       * @returns {string} 8位Hash值
       */
      generateProjectHash(projectPath) {
        const crypto = require("crypto");
        return crypto.createHash("md5").update(path.resolve(projectPath)).digest("hex").substr(0, 8);
      }
      /**
       * 加载资源内容
       * @param {string} resolvedPath - 解析后的路径
       * @param {QueryParams} queryParams - 查询参数
       * @returns {Promise<string>} 资源内容
       */
      async loadContent(resolvedPath, queryParams) {
        try {
          const currentProject = ProjectManager.getCurrentProject();
          const { transport } = currentProject;
          if (transport === "http") {
            return await this.userProtocol.loadContent(resolvedPath, queryParams);
          } else {
            return await this.loadLocalContent(resolvedPath, queryParams);
          }
        } catch (error) {
          throw error;
        }
      }
      /**
       * 本地模式加载资源内容（原有逻辑）
       * @param {string} resolvedPath - 解析后的路径
       * @param {QueryParams} queryParams - 查询参数
       * @returns {Promise<string>} 资源内容
       */
      async loadLocalContent(resolvedPath, queryParams) {
        try {
          const stats = await fs.stat(resolvedPath);
          if (stats.isDirectory()) {
            return await this.loadDirectoryContent(resolvedPath, queryParams);
          } else if (stats.isFile()) {
            return await this.loadFileContent(resolvedPath, queryParams);
          } else {
            throw new Error(`\u4E0D\u652F\u6301\u7684\u6587\u4EF6\u7C7B\u578B: ${resolvedPath}`);
          }
        } catch (error) {
          if (error.code === "ENOENT") {
            if ((queryParams == null ? void 0 : queryParams.get("create")) === "true") {
              await fs.mkdir(path.dirname(resolvedPath), { recursive: true });
              return "";
            }
            if ((queryParams == null ? void 0 : queryParams.get("exists")) === "false") {
              return "";
            }
            throw new Error(`\u6587\u4EF6\u6216\u76EE\u5F55\u4E0D\u5B58\u5728: ${resolvedPath}`);
          }
          throw error;
        }
      }
      /**
       * 加载文件内容
       * @param {string} filePath - 文件路径
       * @param {QueryParams} queryParams - 查询参数
       * @returns {Promise<string>} 文件内容
       */
      async loadFileContent(filePath, queryParams) {
        const encoding = (queryParams == null ? void 0 : queryParams.get("encoding")) || "utf8";
        return await fs.readFile(filePath, encoding);
      }
      /**
       * 加载目录内容
       * @param {string} dirPath - 目录路径
       * @param {QueryParams} queryParams - 查询参数
       * @returns {Promise<string>} 目录内容列表
       */
      async loadDirectoryContent(dirPath, queryParams) {
        const entries = await fs.readdir(dirPath, { withFileTypes: true });
        const typeFilter = queryParams == null ? void 0 : queryParams.get("type");
        let filteredEntries = entries;
        if (typeFilter) {
          filteredEntries = entries.filter((entry) => {
            switch (typeFilter) {
              case "file":
                return entry.isFile();
              case "dir":
                return entry.isDirectory();
              case "both":
                return true;
              default:
                return true;
            }
          });
        }
        const format = (queryParams == null ? void 0 : queryParams.get("format")) || "list";
        switch (format) {
          case "json":
            return JSON.stringify(
              filteredEntries.map((entry) => ({
                name: entry.name,
                type: entry.isDirectory() ? "directory" : "file",
                path: path.join(dirPath, entry.name)
              })),
              null,
              2
            );
          case "paths":
            return filteredEntries.map((entry) => path.join(dirPath, entry.name)).join("\n");
          case "list":
          default:
            return filteredEntries.map((entry) => {
              const type = entry.isDirectory() ? "[DIR]" : "[FILE]";
              return `${type} ${entry.name}`;
            }).join("\n");
        }
      }
      /**
       * 列出项目结构信息 - 新架构
       * @returns {Promise<object>} 项目信息
       */
      async getProjectInfo() {
        try {
          const projectRoot = this.getPathResolver().getProjectRoot();
          const promptxPath = this.getPathResolver().getPromptXDirectory();
          const result = {
            projectRoot,
            promptxPath,
            architecture: "state-based",
            supportedDirectories: this.getPathResolver().getSupportedDirectories(),
            directories: {}
          };
          for (const dirType of this.getPathResolver().getSupportedDirectories()) {
            try {
              const fullPath = this.getPathResolver().resolvePath(dirType);
              const stats = await fs.stat(fullPath);
              result.directories[dirType] = {
                path: fullPath,
                exists: true,
                type: stats.isDirectory() ? "directory" : "file"
              };
            } catch (error) {
              result.directories[dirType] = {
                path: "N/A",
                exists: false
              };
            }
          }
          return result;
        } catch (error) {
          return {
            error: `\u83B7\u53D6\u9879\u76EE\u4FE1\u606F\u5931\u8D25: ${error.message}`,
            architecture: "state-based"
          };
        }
      }
      /**
       * 清除缓存 - 新架构：无需清除路径缓存
       */
      clearCache() {
        super.clearCache();
      }
    };
    module2.exports = ProjectProtocol;
  }
});

// src/resource/protocols/RoleProtocol.js
var require_RoleProtocol = __commonJS({
  "src/resource/protocols/RoleProtocol.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var ResourceProtocol = require_ResourceProtocol();
    var fs = require("fs-extra");
    var path = require("path");
    var RoleProtocol = class extends ResourceProtocol {
      constructor() {
        super("role");
        this.registry = {};
        this.registryManager = null;
      }
      /**
       * 设置注册表管理器
       */
      setRegistryManager(manager) {
        this.registryManager = manager;
      }
      /**
       * 设置注册表
       */
      setRegistry(registry) {
        this.registry = registry || {};
      }
      /**
       * 获取协议信息
       */
      getProtocolInfo() {
        return {
          name: "role",
          description: "AI\u89D2\u8272\u8D44\u6E90\u534F\u8BAE",
          location: "role://{role_id}",
          examples: [
            "role://video-copywriter",
            "role://product-owner",
            "role://assistant",
            "role://prompt-developer"
          ]
        };
      }
      /**
       * 解析角色协议
       * @param {string} rolePath - 角色路径，如 'java-developer'
       * @param {Object} queryParams - 查询参数（暂未使用）
       * @returns {Promise<string>} 角色文件内容
       */
      async resolve(rolePath, queryParams = {}) {
        try {
          const fullResourceId = `role:${rolePath}`;
          const shortResourceId = rolePath;
          let resourceData = this.registryManager.registryData.findResourceById(rolePath, "role");
          if (!resourceData) {
            resourceData = this.registryManager.registryData.findResourceById(fullResourceId);
          }
          if (!resourceData) {
            const availableRoles = this.registryManager.registryData.getResourcesByProtocol("role").map((r) => r.id).join(", ");
            throw new Error(`\u89D2\u8272 '${rolePath}' \u672A\u627E\u5230\u3002\u53EF\u7528\u89D2\u8272: ${availableRoles}`);
          }
          const result = await this.registryManager.loadResourceByProtocol(resourceData.reference);
          return result;
        } catch (error) {
          throw new Error(`RoleProtocol.resolve failed: ${error.message}`);
        }
      }
      /**
       * 加载资源内容
       */
      async loadContent(resolvedPath, queryParams) {
        try {
          const content = await fs.readFile(resolvedPath, "utf-8");
          return content;
        } catch (error) {
          throw new Error(`\u65E0\u6CD5\u52A0\u8F7D\u89D2\u8272\u6587\u4EF6 ${resolvedPath}: ${error.message}`);
        }
      }
      /**
       * 验证资源路径
       */
      validatePath(resourcePath) {
        return /^[a-zA-Z0-9_-]+$/.test(resourcePath);
      }
    };
    module2.exports = RoleProtocol;
  }
});

// src/resource/protocols/ThoughtProtocol.js
var require_ThoughtProtocol = __commonJS({
  "src/resource/protocols/ThoughtProtocol.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var ResourceProtocol = require_ResourceProtocol();
    var fs = require("fs-extra");
    var path = require("path");
    var ThoughtProtocol = class extends ResourceProtocol {
      constructor() {
        super("thought");
        this.registry = {};
        this.registryManager = null;
      }
      /**
       * 设置注册表管理器
       */
      setRegistryManager(manager) {
        this.registryManager = manager;
      }
      /**
       * 设置注册表
       */
      setRegistry(registry) {
        this.registry = registry || {};
      }
      /**
       * 获取协议信息
       */
      getProtocolInfo() {
        return {
          name: "thought",
          description: "\u601D\u7EF4\u6A21\u5F0F\u8D44\u6E90\u534F\u8BAE",
          location: "thought://{thought_id}",
          examples: [
            "thought://prompt-developer",
            "thought://product-owner"
          ]
        };
      }
      /**
       * 解析思维协议
       * @param {string} thoughtPath - 思维路径，如 'remember'
       * @param {Object} queryParams - 查询参数（暂未使用）
       * @returns {Promise<string>} 思维文件内容
       */
      async resolve(thoughtPath, queryParams = {}) {
        try {
          const fullResourceId = `thought:${thoughtPath}`;
          let resourceData = this.registryManager.registryData.findResourceById(thoughtPath, "thought");
          if (!resourceData) {
            resourceData = this.registryManager.registryData.findResourceById(fullResourceId);
          }
          if (!resourceData) {
            const availableThoughts = this.registryManager.registryData.getResourcesByProtocol("thought").map((r) => r.id).join(", ");
            throw new Error(`\u601D\u7EF4\u6A21\u5F0F '${thoughtPath}' \u672A\u627E\u5230\u3002\u53EF\u7528\u601D\u7EF4\u6A21\u5F0F: ${availableThoughts}`);
          }
          const result = await this.registryManager.loadResourceByProtocol(resourceData.reference);
          return result;
        } catch (error) {
          throw new Error(`ThoughtProtocol.resolve failed: ${error.message}`);
        }
      }
      /**
       * 加载资源内容
       */
      async loadContent(resolvedPath, queryParams) {
        try {
          const content = await fs.readFile(resolvedPath, "utf-8");
          return content;
        } catch (error) {
          throw new Error(`\u65E0\u6CD5\u52A0\u8F7D\u601D\u7EF4\u6A21\u5F0F\u6587\u4EF6 ${resolvedPath}: ${error.message}`);
        }
      }
      /**
       * 验证资源路径
       */
      validatePath(resourcePath) {
        return /^[a-zA-Z0-9_-]+$/.test(resourcePath);
      }
    };
    module2.exports = ThoughtProtocol;
  }
});

// src/resource/protocols/ExecutionProtocol.js
var require_ExecutionProtocol = __commonJS({
  "src/resource/protocols/ExecutionProtocol.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var ResourceProtocol = require_ResourceProtocol();
    var fs = require("fs-extra");
    var path = require("path");
    var ExecutionProtocol = class extends ResourceProtocol {
      constructor() {
        super("execution");
        this.registry = {};
        this.registryManager = null;
      }
      /**
       * 设置注册表管理器
       */
      setRegistryManager(manager) {
        this.registryManager = manager;
      }
      /**
       * 设置注册表
       */
      setRegistry(registry) {
        this.registry = registry || {};
      }
      /**
       * 获取协议信息
       */
      getProtocolInfo() {
        return {
          name: "execution",
          description: "\u6267\u884C\u6A21\u5F0F\u8D44\u6E90\u534F\u8BAE",
          location: "execution://{execution_id}",
          examples: [
            "execution://deal-at-reference",
            "execution://prompt-developer",
            "execution://memory-trigger"
          ]
        };
      }
      /**
       * 解析执行协议
       * @param {string} executionPath - 执行路径，如 'best-practice'
       * @param {Object} queryParams - 查询参数（暂未使用）
       * @returns {Promise<string>} 执行文件内容
       */
      async resolve(executionPath, queryParams = {}) {
        try {
          const fullResourceId = `execution:${executionPath}`;
          let resourceData = this.registryManager.registryData.findResourceById(executionPath, "execution");
          if (!resourceData) {
            resourceData = this.registryManager.registryData.findResourceById(fullResourceId);
          }
          if (!resourceData) {
            const availableExecutions = this.registryManager.registryData.getResourcesByProtocol("execution").map((r) => r.id).join(", ");
            throw new Error(`\u6267\u884C\u6A21\u5F0F '${executionPath}' \u672A\u627E\u5230\u3002\u53EF\u7528\u6267\u884C\u6A21\u5F0F: ${availableExecutions}`);
          }
          const result = await this.registryManager.loadResourceByProtocol(resourceData.reference);
          return result;
        } catch (error) {
          throw new Error(`ExecutionProtocol.resolve failed: ${error.message}`);
        }
      }
      /**
       * 加载资源内容
       */
      async loadContent(resolvedPath, queryParams) {
        try {
          const content = await fs.readFile(resolvedPath, "utf-8");
          return content;
        } catch (error) {
          throw new Error(`\u65E0\u6CD5\u52A0\u8F7D\u6267\u884C\u6A21\u5F0F\u6587\u4EF6 ${resolvedPath}: ${error.message}`);
        }
      }
      /**
       * 验证资源路径
       */
      validatePath(resourcePath) {
        return /^[a-zA-Z0-9_-]+$/.test(resourcePath);
      }
    };
    module2.exports = ExecutionProtocol;
  }
});

// src/resource/protocols/KnowledgeProtocol.js
var require_KnowledgeProtocol = __commonJS({
  "src/resource/protocols/KnowledgeProtocol.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var ResourceProtocol = require_ResourceProtocol();
    var fs = require("fs-extra");
    var path = require("path");
    var KnowledgeProtocol = class extends ResourceProtocol {
      constructor() {
        super("knowledge");
        this.registry = {};
        this.registryManager = null;
      }
      /**
       * 设置注册表管理器
       */
      setRegistryManager(manager) {
        this.registryManager = manager;
      }
      /**
       * 设置注册表
       */
      setRegistry(registry) {
        this.registry = registry || {};
      }
      /**
       * 获取协议信息
       */
      getProtocolInfo() {
        return {
          name: "knowledge",
          description: "\u77E5\u8BC6\u8D44\u6E90\u534F\u8BAE",
          location: "knowledge://{knowledge_id}",
          examples: [
            "knowledge://xiaohongshu-marketing",
            "knowledge://ai-tools-guide"
          ]
        };
      }
      /**
       * 解析知识协议
       * @param {string} knowledgePath - 知识路径，如 'scrum'
       * @param {Object} queryParams - 查询参数（暂未使用）
       * @returns {Promise<string>} 知识文件内容
       */
      async resolve(knowledgePath, queryParams = {}) {
        try {
          const fullResourceId = `knowledge:${knowledgePath}`;
          let resourceData = this.registryManager.registryData.findResourceById(knowledgePath, "knowledge");
          if (!resourceData) {
            resourceData = this.registryManager.registryData.findResourceById(fullResourceId);
          }
          if (!resourceData) {
            const availableKnowledge = this.registryManager.registryData.getResourcesByProtocol("knowledge").map((r) => r.id).join(", ");
            throw new Error(`\u77E5\u8BC6\u6A21\u5757 '${knowledgePath}' \u672A\u627E\u5230\u3002\u53EF\u7528\u77E5\u8BC6\u6A21\u5757: ${availableKnowledge}`);
          }
          const result = await this.registryManager.loadResourceByProtocol(resourceData.reference);
          return result;
        } catch (error) {
          throw new Error(`KnowledgeProtocol.resolve failed: ${error.message}`);
        }
      }
      /**
       * 加载资源内容
       */
      async loadContent(resolvedPath, queryParams) {
        try {
          const content = await fs.readFile(resolvedPath, "utf-8");
          return content;
        } catch (error) {
          throw new Error(`\u65E0\u6CD5\u52A0\u8F7D\u77E5\u8BC6\u8D44\u6E90\u6587\u4EF6 ${resolvedPath}: ${error.message}`);
        }
      }
      /**
       * 验证资源路径
       */
      validatePath(resourcePath) {
        return /^[a-zA-Z0-9_-]+$/.test(resourcePath);
      }
    };
    module2.exports = KnowledgeProtocol;
  }
});

// src/resource/protocols/ToolProtocol.js
var require_ToolProtocol = __commonJS({
  "src/resource/protocols/ToolProtocol.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var ResourceProtocol = require_ResourceProtocol();
    var ToolProtocol = class extends ResourceProtocol {
      constructor() {
        super("tool");
        this.registryManager = null;
      }
      /**
       * 设置注册表管理器引用
       * @param {Object} manager - ResourceManager实例
       */
      setRegistryManager(manager) {
        this.registryManager = manager;
      }
      /**
       * 解析工具资源路径
       * @param {string} toolPath - 工具名称，如 "calculator"
       * @param {Object} queryParams - 查询参数（可选）
       * @returns {Promise<Object>} 工具代码和元数据
       */
      async resolve(toolPath, queryParams = {}) {
        if (!this.registryManager) {
          throw new Error("ToolProtocol: Registry manager not set");
        }
        const toolResource = this.registryManager.registryData.findResourceById(toolPath, "tool");
        if (!toolResource) {
          throw new Error(`Tool '${toolPath}' not found in registry`);
        }
        const toolContent = await this.registryManager.loadResourceByProtocol(toolResource.reference);
        this.validateToolContent(toolContent, toolPath);
        return {
          id: toolPath,
          content: toolContent,
          metadata: toolResource,
          source: toolResource.source || "unknown"
        };
      }
      /**
       * 验证工具内容格式
       * @param {string} content - 工具文件内容
       * @param {string} toolPath - 工具路径
       */
      validateToolContent(content, toolPath) {
        if (!content || typeof content !== "string") {
          throw new Error(`Tool '${toolPath}': Invalid or empty content`);
        }
        try {
          new Function(content);
        } catch (syntaxError) {
          throw new Error(`Tool '${toolPath}': JavaScript syntax error - ${syntaxError.message}`);
        }
      }
      /**
       * 获取协议信息
       * @returns {Object} 协议描述信息
       */
      getProtocolInfo() {
        return {
          name: "tool",
          description: "Tool\u8D44\u6E90\u534F\u8BAE - \u52A0\u8F7D\u53EF\u6267\u884C\u7684JavaScript\u5DE5\u5177",
          syntax: "tool://{tool_id}",
          examples: [
            "tool://calculator",
            "tool://send-email",
            "tool://data-processor",
            "tool://api-client"
          ],
          supportedFileTypes: [".tool.js"],
          usageNote: "\u5DE5\u5177\u6587\u4EF6\u5FC5\u987B\u5BFC\u51FA\u7B26\u5408PromptX Tool Interface\u7684\u5BF9\u8C61"
        };
      }
      /**
       * 检查缓存策略
       * @param {string} toolPath - 工具路径
       * @returns {boolean} 是否应该缓存
       */
      shouldCache(toolPath) {
        return true;
      }
      /**
       * 获取缓存键
       * @param {string} toolPath - 工具路径
       * @returns {string} 缓存键
       */
      getCacheKey(toolPath) {
        return `tool://${toolPath}`;
      }
    };
    module2.exports = ToolProtocol;
  }
});

// src/resource/protocols/ManualProtocol.js
var require_ManualProtocol = __commonJS({
  "src/resource/protocols/ManualProtocol.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var ResourceProtocol = require_ResourceProtocol();
    var ManualProtocol = class extends ResourceProtocol {
      constructor() {
        super("manual");
        this.registryManager = null;
      }
      /**
       * 设置注册表管理器引用
       * @param {Object} manager - ResourceManager实例
       */
      setRegistryManager(manager) {
        this.registryManager = manager;
      }
      /**
       * 解析工具手册资源路径
       * @param {string} manualPath - 手册名称，如 "calculator"
       * @param {Object} queryParams - 查询参数（可选）
       * @returns {Promise<Object>} 手册内容和元数据
       */
      async resolve(manualPath, queryParams = {}) {
        if (!this.registryManager) {
          throw new Error("ManualProtocol: Registry manager not set");
        }
        const manualResource = this.registryManager.registryData.findResourceById(manualPath, "manual");
        if (!manualResource) {
          const toolResource = this.registryManager.registryData.findResourceById(manualPath, "tool");
          if (toolResource) {
            throw new Error(`Manual '${manualPath}' not found. Found corresponding tool but no manual. Consider creating ${manualPath}.manual.md`);
          }
          throw new Error(`Manual '${manualPath}' not found in registry`);
        }
        const manualContent = await this.registryManager.loadResourceByProtocol(manualResource.reference);
        this.validateManualContent(manualContent, manualPath);
        return {
          id: manualPath,
          content: manualContent,
          metadata: manualResource,
          source: manualResource.source || "unknown"
        };
      }
      /**
       * 验证手册内容格式
       * @param {string} content - 手册文件内容
       * @param {string} manualPath - 手册路径
       */
      validateManualContent(content, manualPath) {
        if (!content || typeof content !== "string") {
          throw new Error(`Manual '${manualPath}': Invalid or empty content`);
        }
        const trimmedContent = content.trim();
        if (trimmedContent.length === 0) {
          throw new Error(`Manual '${manualPath}': Empty manual content`);
        }
        if (!trimmedContent.includes("<manual>") || !trimmedContent.includes("</manual>")) {
          throw new Error(`Manual '${manualPath}': Missing required <manual> tags`);
        }
      }
      /**
       * 获取协议信息
       * @returns {Object} 协议描述信息
       */
      getProtocolInfo() {
        return {
          name: "manual",
          description: "Manual\u8D44\u6E90\u534F\u8BAE - \u52A0\u8F7D\u5DE5\u5177\u4F7F\u7528\u624B\u518C\u548C\u8BF4\u660E\u6587\u6863",
          syntax: "manual://{manual_id}",
          examples: [
            "manual://calculator",
            "manual://send-email",
            "manual://data-processor",
            "manual://api-client"
          ],
          supportedFileTypes: [".manual.md"],
          usageNote: "\u624B\u518C\u6587\u4EF6\u5FC5\u987B\u4F7F\u7528<manual>\u6807\u7B7E\u5305\u88F9\u5185\u5BB9\uFF0C\u63D0\u4F9B\u5DE5\u5177\u7684\u8BE6\u7EC6\u4F7F\u7528\u8BF4\u660E"
        };
      }
      /**
       * 检查缓存策略
       * @param {string} manualPath - 手册路径
       * @returns {boolean} 是否应该缓存
       */
      shouldCache(manualPath) {
        return true;
      }
      /**
       * 获取缓存键
       * @param {string} manualPath - 手册路径
       * @returns {string} 缓存键
       */
      getCacheKey(manualPath) {
        return `manual://${manualPath}`;
      }
    };
    module2.exports = ManualProtocol;
  }
});

// src/resource/protocols/FileProtocol.js
var require_FileProtocol = __commonJS({
  "src/resource/protocols/FileProtocol.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var ResourceProtocol = require_ResourceProtocol();
    var path = require("path");
    var fs = require("fs").promises;
    var FileProtocol = class extends ResourceProtocol {
      constructor(options = {}) {
        super("file", options);
      }
      /**
       * 设置注册表（保持与其他协议的一致性）
       */
      setRegistry(registry) {
        this.registry = registry || {};
      }
      /**
       * 获取协议信息
       * @returns {object} 协议信息
       */
      getProtocolInfo() {
        return {
          name: "file",
          description: "\u6587\u4EF6\u7CFB\u7EDF\u534F\u8BAE\uFF0C\u63D0\u4F9B\u672C\u5730\u6587\u4EF6\u8BBF\u95EE",
          location: "file://{path}",
          examples: [
            "file://package.json",
            "file:///absolute/path/to/file.txt",
            "file://./relative/path/file.md",
            "file://../parent/file.json"
          ],
          params: this.getSupportedParams()
        };
      }
      /**
       * 支持的查询参数
       * @returns {object} 参数说明
       */
      getSupportedParams() {
        return {
          ...super.getSupportedParams(),
          encoding: "string - \u6587\u4EF6\u7F16\u7801 (utf8, ascii, binary\u7B49)",
          exists: "boolean - \u4EC5\u8FD4\u56DE\u5B58\u5728\u7684\u6587\u4EF6"
        };
      }
      /**
       * 验证文件协议路径
       * @param {string} resourcePath - 资源路径
       * @returns {boolean} 是否有效
       */
      validatePath(resourcePath) {
        if (!super.validatePath(resourcePath)) {
          return false;
        }
        return typeof resourcePath === "string" && resourcePath.length > 0;
      }
      /**
       * 解析文件路径
       * @param {string} resourcePath - 原始资源路径
       * @param {QueryParams} queryParams - 查询参数
       * @returns {Promise<string>} 解析后的绝对路径
       */
      async resolvePath(resourcePath, queryParams) {
        let resolvedPath;
        if (path.isAbsolute(resourcePath)) {
          resolvedPath = resourcePath;
        } else {
          resolvedPath = path.resolve(process.cwd(), resourcePath);
        }
        resolvedPath = path.normalize(resolvedPath);
        return resolvedPath;
      }
      /**
       * 加载资源内容
       * @param {string} resolvedPath - 解析后的路径
       * @param {QueryParams} queryParams - 查询参数
       * @returns {Promise<string>} 资源内容
       */
      async loadContent(resolvedPath, queryParams) {
        try {
          const stats = await fs.stat(resolvedPath);
          if (stats.isDirectory()) {
            return await this.loadDirectoryContent(resolvedPath, queryParams);
          } else if (stats.isFile()) {
            return await this.loadFileContent(resolvedPath, queryParams);
          } else {
            throw new Error(`\u4E0D\u652F\u6301\u7684\u6587\u4EF6\u7C7B\u578B: ${resolvedPath}`);
          }
        } catch (error) {
          if (error.code === "ENOENT") {
            if (queryParams && queryParams.get("exists") === "false") {
              return "";
            }
            throw new Error(`\u6587\u4EF6\u6216\u76EE\u5F55\u4E0D\u5B58\u5728: ${resolvedPath}`);
          }
          throw error;
        }
      }
      /**
       * 加载文件内容
       * @param {string} filePath - 文件路径
       * @param {QueryParams} queryParams - 查询参数
       * @returns {Promise<string>} 文件内容
       */
      async loadFileContent(filePath, queryParams) {
        const encoding = (queryParams == null ? void 0 : queryParams.get("encoding")) || "utf8";
        return await fs.readFile(filePath, encoding);
      }
      /**
       * 加载目录内容
       * @param {string} dirPath - 目录路径
       * @param {QueryParams} queryParams - 查询参数
       * @returns {Promise<string>} 目录内容列表
       */
      async loadDirectoryContent(dirPath, queryParams) {
        const entries = await fs.readdir(dirPath, { withFileTypes: true });
        const typeFilter = queryParams == null ? void 0 : queryParams.get("type");
        let filteredEntries = entries;
        if (typeFilter) {
          filteredEntries = entries.filter((entry) => {
            switch (typeFilter) {
              case "file":
                return entry.isFile();
              case "dir":
                return entry.isDirectory();
              case "both":
                return true;
              default:
                return true;
            }
          });
        }
        const format = (queryParams == null ? void 0 : queryParams.get("format")) || "list";
        switch (format) {
          case "json":
            return JSON.stringify(
              filteredEntries.map((entry) => ({
                name: entry.name,
                type: entry.isDirectory() ? "directory" : "file",
                path: path.join(dirPath, entry.name)
              })),
              null,
              2
            );
          case "paths":
            return filteredEntries.map((entry) => path.join(dirPath, entry.name)).join("\n");
          case "list":
          default:
            return filteredEntries.map((entry) => {
              const type = entry.isDirectory() ? "[DIR]" : "[FILE]";
              return `${type} ${entry.name}`;
            }).join("\n");
        }
      }
    };
    module2.exports = FileProtocol;
  }
});

// src/resource/resourceManager.js
var require_resourceManager = __commonJS({
  "src/resource/resourceManager.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var fs = require("fs");
    var RegistryData = require_RegistryData();
    var ResourceProtocolParser = require_resourceProtocolParser();
    var DiscoveryManager = require_DiscoveryManager();
    var logger = require("@promptx/logger");
    var PackageProtocol = require_PackageProtocol();
    var ProjectProtocol = require_ProjectProtocol();
    var RoleProtocol = require_RoleProtocol();
    var ThoughtProtocol = require_ThoughtProtocol();
    var ExecutionProtocol = require_ExecutionProtocol();
    var KnowledgeProtocol = require_KnowledgeProtocol();
    var ToolProtocol = require_ToolProtocol();
    var ManualProtocol = require_ManualProtocol();
    var UserProtocol = require_UserProtocol();
    var FileProtocol = require_FileProtocol();
    var ResourceManager = class {
      constructor() {
        this.registryData = RegistryData.createEmpty("merged", null);
        this.protocolParser = new ResourceProtocolParser();
        this.parser = new ResourceProtocolParser();
        this.discoveryManager = new DiscoveryManager();
        this.protocols = /* @__PURE__ */ new Map();
        this.initializeProtocols();
      }
      /**
       * 初始化所有协议处理器
       */
      initializeProtocols() {
        this.protocols.set("package", new PackageProtocol());
        this.protocols.set("project", new ProjectProtocol());
        this.protocols.set("file", new FileProtocol());
        this.protocols.set("user", new UserProtocol());
        this.protocols.set("role", new RoleProtocol());
        this.protocols.set("thought", new ThoughtProtocol());
        this.protocols.set("execution", new ExecutionProtocol());
        this.protocols.set("knowledge", new KnowledgeProtocol());
        this.protocols.set("tool", new ToolProtocol());
        this.protocols.set("manual", new ManualProtocol());
      }
      /**
       * 新架构初始化方法
       */
      async initializeWithNewArchitecture() {
        try {
          logger.info("[ResourceManager] Starting initialization...");
          this.registryData.clear();
          logger.info("[ResourceManager] Cleared existing registry");
          if (this.discoveryManager && typeof this.discoveryManager.clearCache === "function") {
            this.discoveryManager.clearCache();
            logger.info("[ResourceManager] Cleared discovery cache");
          }
          logger.info("[ResourceManager] Populating registry data...");
          await this.populateRegistryData();
          this.setupLogicalProtocols();
          this.initialized = true;
          const stats = this.registryData.getStats();
          logger.info("[ResourceManager] Initialization complete:", {
            totalResources: this.registryData.size,
            bySource: stats.bySource,
            byProtocol: stats.byProtocol
          });
        } catch (error) {
          logger.warn(`ResourceManager new architecture initialization failed: ${error.message}`);
          logger.warn("ResourceManager continuing with empty registry");
          this.initialized = true;
        }
      }
      /**
       * 填充新的RegistryData
       */
      async populateRegistryData() {
        this.registryData.clear();
        logger.info("[ResourceManager] Discovery managers:", {
          count: this.discoveryManager.discoveries.length,
          sources: this.discoveryManager.discoveries.map((d) => d.source)
        });
        for (const discovery of this.discoveryManager.discoveries) {
          try {
            logger.info(`[ResourceManager] Loading from ${discovery.source} discovery...`);
            if (typeof discovery.getRegistryData === "function") {
              const registryData = await discovery.getRegistryData();
              if (registryData && registryData.resources) {
                const resourceCount = registryData.size || 0;
                logger.info(`[ResourceManager] Found ${resourceCount} resources from ${discovery.source}`);
                this.registryData.merge(registryData, true);
                if (discovery.source === "USER" && registryData.resources) {
                  logger.debug(`[ResourceManager] USER resources to merge:`, registryData.resources.map((r) => `${r.protocol}://${r.id}`));
                }
                logger.info(`[ResourceManager] After merging ${discovery.source}, total: ${this.registryData.size}`);
              } else {
                logger.info(`[ResourceManager] No resources found from ${discovery.source}`);
              }
            } else {
              logger.info(`[ResourceManager] ${discovery.source} does not support getRegistryData`);
            }
          } catch (error) {
            logger.warn(`Failed to get RegistryData from ${discovery.source}: ${error.message}`);
          }
        }
        logger.info("[ResourceManager] Registry population complete, total resources:", this.registryData.size);
      }
      /**
       * 为逻辑协议设置注册表引用
       */
      setupLogicalProtocols() {
        const roleProtocol = this.protocols.get("role");
        const executionProtocol = this.protocols.get("execution");
        const thoughtProtocol = this.protocols.get("thought");
        const knowledgeProtocol = this.protocols.get("knowledge");
        const toolProtocol = this.protocols.get("tool");
        const manualProtocol = this.protocols.get("manual");
        if (roleProtocol) {
          roleProtocol.setRegistryManager(this);
        }
        if (executionProtocol) {
          executionProtocol.setRegistryManager(this);
        }
        if (thoughtProtocol) {
          thoughtProtocol.setRegistryManager(this);
        }
        if (knowledgeProtocol) {
          knowledgeProtocol.setRegistryManager(this);
        }
        if (toolProtocol) {
          toolProtocol.setRegistryManager(this);
        }
        if (manualProtocol) {
          manualProtocol.setRegistryManager(this);
        }
      }
      /**
       * 通过协议解析加载资源内容
       * @param {string} reference - 资源引用
       * @returns {Promise<string>} 资源内容
       */
      async loadResourceByProtocol(reference) {
        const parsed = this.protocolParser.parse(reference);
        const protocol = this.protocols.get(parsed.protocol);
        if (!protocol) {
          throw new Error(`\u4E0D\u652F\u6301\u7684\u534F\u8BAE: ${parsed.protocol}`);
        }
        const result = await protocol.resolve(parsed.path, parsed.queryParams);
        if (typeof result === "string") {
          return result;
        } else if (result && typeof result === "object" && result.content) {
          return result.content;
        } else {
          throw new Error(`\u534F\u8BAE${parsed.protocol}\u8FD4\u56DE\u4E86\u65E0\u6548\u7684\u5185\u5BB9\u683C\u5F0F`);
        }
      }
      async loadResource(resourceId) {
        try {
          if (!this.initialized) {
            logger.info("[ResourceManager] Initializing resource manager...");
            await this.initializeWithNewArchitecture();
          }
          if (resourceId.startsWith("@")) {
            const parsed = this.protocolParser.parse(resourceId);
            const basicProtocols = ["file", "user", "package", "project"];
            if (basicProtocols.includes(parsed.protocol)) {
              const content3 = await this.loadResourceByProtocol(resourceId);
              return {
                success: true,
                content: content3,
                resourceId,
                reference: resourceId
              };
            }
            logger.debug(`[ResourceManager] Finding resource: protocol=${parsed.protocol}, id=${parsed.path}`);
            const resourceData = this.registryData.findResourceById(parsed.path, parsed.protocol);
            if (!resourceData) {
              const availableResources = this.registryData.getResourcesByProtocol(parsed.protocol);
              logger.error(`[ResourceManager] Resource not found: ${parsed.protocol}:${parsed.path}`);
              logger.error(`[ResourceManager] Available ${parsed.protocol} resources:`, availableResources.map((r) => `${r.id} (${r.source})`));
              throw new Error(`Resource not found: ${parsed.protocol}:${parsed.path}`);
            }
            logger.debug(`[ResourceManager] Found resource: ${resourceData.id} from ${resourceData.source}`);
            const content2 = await this.loadResourceByProtocol(resourceData.reference);
            return {
              success: true,
              content: content2,
              resourceId,
              reference: resourceData.reference
            };
          }
          const urlMatch = resourceId.match(/^([a-zA-Z][a-zA-Z0-9_-]*):\/\/(.+)$/);
          if (urlMatch) {
            const [, protocol, id] = urlMatch;
            const resourceData = this.registryData.findResourceById(id, protocol);
            if (!resourceData) {
              throw new Error(`Resource not found: ${resourceId}`);
            }
            const content2 = await this.loadResourceByProtocol(resourceData.reference);
            return {
              success: true,
              content: content2,
              resourceId,
              reference: resourceData.reference
            };
          }
          let reference = null;
          if (resourceId.includes(":")) {
            const [protocol, id] = resourceId.split(":", 2);
            const resourceData = this.registryData.findResourceById(id, protocol);
            if (resourceData) {
              reference = resourceData.reference;
            }
          } else {
            const resourceData = this.registryData.findResourceById(resourceId);
            if (resourceData) {
              reference = resourceData.reference;
            }
          }
          if (!reference) {
            throw new Error(`Resource not found: ${resourceId}`);
          }
          const content = await this.loadResourceByProtocol(reference);
          return {
            success: true,
            content,
            resourceId,
            reference
          };
        } catch (error) {
          logger.debug(`ResourceManager.loadResource failed for ${resourceId}: ${error.message}`);
          return {
            success: false,
            error,
            // 返回完整的Error对象，而不是message字符串
            resourceId
          };
        }
      }
      /**
       * 解析协议引用并返回相关信息
       */
      async resolveProtocolReference(reference) {
        try {
          const parsed = this.protocolParser.parse(reference);
          return {
            success: true,
            protocol: parsed.protocol,
            path: parsed.path,
            queryParams: parsed.queryParams,
            reference
          };
        } catch (error) {
          return {
            success: false,
            error: error.message,
            reference
          };
        }
      }
      /**
       * 获取所有可用的协议列表
       */
      getAvailableProtocols() {
        return Array.from(this.protocols.keys());
      }
      /**
       * 检查是否支持指定协议
       */
      supportsProtocol(protocol) {
        return this.protocols.has(protocol);
      }
      /**
       * 设置初始化状态
       */
      set initialized(value) {
        this._initialized = value;
      }
      /**
       * 获取初始化状态
       */
      get initialized() {
        return this._initialized || false;
      }
      /**
       * 解析资源URL（向后兼容接口）
       * 返回格式：{success: boolean, content?: string, error?: Error}
       */
      async resolve(resourceUrl) {
        return await this.loadResource(resourceUrl);
      }
      /**
       * 获取注册表统计信息
       */
      getStats() {
        return {
          totalResources: this.registryData.size,
          protocols: this.getAvailableProtocols(),
          initialized: this.initialized
        };
      }
      /**
       * 刷新资源（重新发现并注册）
       */
      async refreshResources() {
        try {
          this.initialized = false;
          this.registryData.clear();
          if (this.discoveryManager && typeof this.discoveryManager.clearCache === "function") {
            this.discoveryManager.clearCache();
          }
          await this.initializeWithNewArchitecture();
        } catch (error) {
          logger.warn(`ResourceManager resource refresh failed: ${error.message}`);
        }
      }
    };
    module2.exports = ResourceManager;
  }
});

// src/resource/index.js
var require_resource = __commonJS({
  "src/resource/index.js"(exports2, module2) {
    init_cjs_shims();
    var ResourceManager = require_resourceManager();
    var ResourceProtocolParser = require_resourceProtocolParser();
    var {
      LoadingSemantics,
      ParsedReference,
      QueryParams,
      NestedReference,
      ResourceContent,
      LazyResource,
      ProcessedResult,
      ResourceResult,
      ProtocolInfo
    } = require_types();
    var globalResourceManager = null;
    function getGlobalResourceManager() {
      if (!globalResourceManager) {
        globalResourceManager = new ResourceManager();
      }
      return globalResourceManager;
    }
    function resetGlobalResourceManager() {
      globalResourceManager = null;
    }
    module2.exports = {
      // 主管理器类
      ResourceManager,
      // 全局单例实例
      getGlobalResourceManager,
      resetGlobalResourceManager,
      // 核心组件
      ResourceProtocolParser,
      // 数据类型
      LoadingSemantics,
      ParsedReference,
      QueryParams,
      NestedReference,
      ResourceContent,
      LazyResource,
      ProcessedResult,
      ResourceResult,
      ProtocolInfo,
      // 便捷方法 - 创建默认实例（保持向后兼容）
      createManager: (options) => new ResourceManager(options),
      // 便捷方法 - 快速解析
      parse: (resourceRef) => {
        const parser = new ResourceProtocolParser();
        return parser.parse(resourceRef);
      },
      // 便捷方法 - 快速验证
      validate: (resourceRef) => {
        try {
          const parser = new ResourceProtocolParser();
          parser.parse(resourceRef);
          return true;
        } catch (error) {
          return false;
        }
      }
    };
  }
});
module.exports = require_resource();
//# sourceMappingURL=resource.js.map