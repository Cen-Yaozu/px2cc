{"version":3,"sources":["../../../node_modules/.pnpm/tsup@8.5.0_jiti@2.5.1_postcss@8.5.6_tsx@4.20.5_typescript@5.9.2_yaml@2.8.1/node_modules/tsup/assets/cjs_shims.js","../src/cognition/Cue.js","../src/cognition/FrequencyCue.js","../src/cognition/Network.js","../src/cognition/Mind.js","../src/cognition/Engram.js","../src/cognition/WeightContext.js","../src/cognition/Remember.js","../src/cognition/ActivationStrategy.js","../src/cognition/ActivationContext.js","../src/cognition/Recall.js","../src/cognition/Prime.js","../src/cognition/Memory.js","../src/cognition/WeightStrategy.js","../src/cognition/CognitionSystem.js","../src/cognition/index.js","../src/utils/ServerEnvironment.js","../src/utils/ProjectManager.js","../src/utils/DirectoryLocator.js","../src/utils/DirectoryService.js","../src/constants.js","../src/resource/ProtocolResolver.js","../src/resource/ResourceData.js","../src/resource/RegistryData.js","../src/resource/types.js","../src/resource/resourceProtocolParser.js","../src/resource/discovery/BaseDiscovery.js","../src/resource/discovery/PackageDiscovery.js","../src/resource/discovery/ProjectDiscovery.js","../src/resource/discovery/UserDiscovery.js","../src/resource/discovery/DiscoveryManager.js","../src/resource/protocols/ResourceProtocol.js","../src/resource/protocols/PackageProtocol.js","../src/utils/ProjectPathResolver.js","../src/resource/protocols/UserProtocol.js","../src/resource/protocols/ProjectProtocol.js","../src/resource/protocols/RoleProtocol.js","../src/resource/protocols/ThoughtProtocol.js","../src/resource/protocols/ExecutionProtocol.js","../src/resource/protocols/KnowledgeProtocol.js","../src/resource/protocols/ToolProtocol.js","../src/resource/protocols/ManualProtocol.js","../src/resource/protocols/FileProtocol.js","../src/resource/resourceManager.js","../src/resource/index.js","../src/toolx/SandboxIsolationManager.js","../src/toolx/SandboxErrorManager.js","../src/toolx/ToolDirectoryManager.js","../src/toolx/ESModuleRequireSupport.js","../src/toolx/ToolSandbox.js","../src/toolx/ToolInterface.js","../src/toolx/ToolValidator.js","../src/toolx/ToolUtils.js","../src/toolx/index.js","../src/pouch/state/PouchStateMachine.js","../src/pouch/PouchRegistry.js","../src/pouch/areas/BaseArea.js","../src/pouch/areas/common/LegacyArea.js","../src/pouch/layers/BaseLayer.js","../src/pouch/BasePouchCommand.js","../src/pouch/areas/init/InitArea.js","../src/pouch/areas/common/StateArea.js","../src/pouch/commands/InitCommand.js","../src/pouch/areas/welcome/WelcomeHeaderArea.js","../src/pouch/areas/welcome/RoleListArea.js","../src/pouch/areas/welcome/ToolListArea.js","../src/pouch/commands/WelcomeCommand.js","../src/pouch/areas/CognitionArea.js","../src/pouch/areas/action/RoleArea.js","../src/pouch/layers/CognitionLayer.js","../src/pouch/layers/RoleLayer.js","../src/dpml/DPMLContentParser.js","../src/dpml/SemanticRenderer.js","../src/cognition/Anchor.js","../src/cognition/CognitionManager.js","../src/pouch/commands/ActionCommand.js","../src/pouch/commands/LearnCommand.js","../src/pouch/commands/RecallCommand.js","../src/pouch/commands/RememberCommand.js","../src/pouch/commands/ThinkCommand.js","../src/pouch/commands/ToolCommand.js","../src/pouch/commands/index.js","../src/pouch/PouchCLI.js","../src/pouch/index.js","../src/utils/version.js","../src/utils/ProjectConfig.js","../src/index.js"],"sourcesContent":["// Shim globals in cjs bundle\n// There's a weird bug that esbuild will always inject importMetaUrl\n// if we export it as `const importMetaUrl = ... __filename ...`\n// But using a function will not cause this issue\n\nconst getImportMetaUrl = () =>\n  typeof document === 'undefined'\n    ? new URL(`file:${__filename}`).href\n    : (document.currentScript && document.currentScript.src) ||\n      new URL('main.js', document.baseURI).href\n\nexport const importMetaUrl = /* @__PURE__ */ getImportMetaUrl()\n","/**\n * Cue - 认知线索（记忆网络节点）\n * \n * ## 设计理念\n * \n * Cue是整个认知系统的原子单位，代表一个最小的认知概念。\n * 基于认知心理学的\"线索依赖记忆\"（Cue-dependent memory）理论：\n * - 记忆不是孤立存储的，而是通过线索（cue）相互连接\n * - 一个线索被激活时，会激活与其相连的其他线索\n * - 连接的强度（权重）决定了激活传播的概率和强度\n * \n * ## 为什么这样设计\n * \n * 1. **去中心化的连接管理**\n *    - 每个Cue管理自己的出边（connections），像神经元管理自己的突触\n *    - 避免了中央连接表的复杂性，符合生物神经网络的结构\n *    - 便于并行处理和局部更新\n * \n * 2. **极简的数据结构**\n *    - 只存储word（概念）和connections（连接）\n *    - 不存储原始内容，因为：\n *      a) 大模型本身就能理解word的语义\n *      b) 记忆本身就是模糊的、重构性的\n *      c) 节省存储空间，提高检索效率\n * \n * 3. **单向连接设计**\n *    - connections只记录出边，不记录入边\n *    - 原因：认知过程是有方向的（从A想到B，不一定从B想到A）\n *    - 简化了数据结构，避免了双向同步的复杂性\n * \n * ## 数据结构说明\n * \n * ```javascript\n * {\n *   word: \"认知\",                    // 概念本身\n *   connections: Map {               // 出边集合\n *     \"模型\" => 1234567890.5,       // 目标词 => 权重（时间戳*衰减因子）\n *     \"理解\" => 1234567880.3\n *   }\n * }\n * ```\n * \n * ## 权重的含义\n * \n * 权重不是简单的强度值，而是编码了多个维度的信息：\n * - 时间信息：通过时间戳基数体现新旧\n * - 位置信息：通过位置衰减体现序列中的重要性\n * - 网络信息：通过出度调整体现节点的hub特性\n * \n * @class Cue\n */\nclass Cue {\n  /**\n   * 创建一个新的Cue节点\n   * \n   * @param {string} word - 概念词，作为节点的唯一标识\n   * \n   * @example\n   * const cue = new Cue(\"认知\");\n   * cue.connections.set(\"模型\", 1234567890);\n   */\n  constructor(word) {\n    /**\n     * 概念词 - Cue的核心标识\n     * \n     * 设计考虑：\n     * - 使用词而不是ID，便于理解和调试\n     * - 词本身就携带语义信息，大模型可以直接理解\n     * - 支持任何语言的词汇（中文、英文、混合）\n     * \n     * @type {string}\n     */\n    this.word = word;\n    \n    /**\n     * 连接映射表 - 管理所有出边\n     * \n     * 数据结构：Map<targetWord, weight>\n     * - key: 目标Cue的word\n     * - value: 连接权重（number）\n     * \n     * 为什么用Map而不是Object：\n     * - Map的键可以是任何类型（虽然这里是string）\n     * - Map保持插入顺序（便于按时间顺序遍历）\n     * - Map有更好的性能（频繁增删改查）\n     * - Map有size属性（便于计算出度）\n     * \n     * @type {Map<string, number>}\n     */\n    this.connections = new Map();\n  }\n  \n  /**\n   * 获取节点的出度（连接到多少个其他节点）\n   * \n   * 出度的意义：\n   * - 高出度 = 枢纽节点（hub），概念发散性强\n   * - 低出度 = 专门节点，概念专一性强\n   * \n   * @returns {number} 出边数量\n   */\n  getOutDegree() {\n    return this.connections.size;\n  }\n  \n  /**\n   * 获取最强连接（权重最高的出边）\n   * \n   * 用途：\n   * - Prime时选择默认激活路径\n   * - Recall时决定主要扩散方向\n   * \n   * @returns {{word: string, weight: number}|null} 最强连接信息\n   */\n  getStrongestConnection() {\n    if (this.connections.size === 0) return null;\n    \n    let maxWeight = -Infinity;\n    let strongestWord = null;\n    \n    for (const [word, weight] of this.connections) {\n      if (weight > maxWeight) {\n        maxWeight = weight;\n        strongestWord = word;\n      }\n    }\n    \n    return { word: strongestWord, weight: maxWeight };\n  }\n  \n  /**\n   * 获取按权重排序的连接列表\n   * \n   * @param {number} limit - 返回前N个连接\n   * @returns {Array<{word: string, weight: number}>} 排序后的连接列表\n   */\n  getSortedConnections(limit = Infinity) {\n    return Array.from(this.connections.entries())\n      .map(([word, weight]) => ({ word, weight }))\n      .sort((a, b) => b.weight - a.weight)\n      .slice(0, limit);\n  }\n  \n  /**\n   * 序列化为JSON对象（用于持久化）\n   * \n   * @returns {Object} 可序列化的对象\n   */\n  toJSON() {\n    return {\n      word: this.word,\n      connections: Array.from(this.connections.entries()).map(([target, weight]) => ({\n        target,\n        weight\n      }))\n    };\n  }\n  \n  /**\n   * 从JSON对象恢复（用于加载）\n   * \n   * @param {Object} json - 序列化的对象\n   * @returns {Cue} 恢复的Cue实例\n   */\n  static fromJSON(json) {\n    const cue = new Cue(json.word);\n    if (json.connections) {\n      for (const conn of json.connections) {\n        cue.connections.set(conn.target, conn.weight);\n      }\n    }\n    return cue;\n  }\n}\n\nmodule.exports = Cue;","const Cue = require('./Cue');\nconst logger = require('@promptx/logger');\n\n/**\n * FrequencyCue - 带频率统计的认知线索\n * \n * ## 设计理念\n * \n * FrequencyCue继承自Cue，在保持Cue纯数据结构的基础上，\n * 添加了频率统计功能。这种设计遵循了开闭原则（OCP）：\n * - 对扩展开放：通过继承添加新功能\n * - 对修改关闭：不改变Cue的原有设计\n * \n * ## 为什么需要FrequencyCue\n * \n * 1. **使用强化原理**\n *    - 神经科学：\"neurons that fire together wire together\"\n *    - 频繁被激活的神经通路会得到强化\n *    - 模拟人类记忆的\"越用越强\"特性\n * \n * 2. **分离关注点**\n *    - Cue：纯粹的数据结构，表示概念和连接\n *    - FrequencyCue：添加统计信息，用于Network管理\n *    - 清晰的职责边界\n * \n * 3. **向后兼容**\n *    - FrequencyCue IS-A Cue，可以无缝替换\n *    - 所有使用Cue的地方都可以使用FrequencyCue\n *    - 不影响现有代码\n * \n * ## 频率的作用\n * \n * 在Softmax归一化时，频率作为偏置项：\n * ```\n * adjustedLogWeight = log(weight) + log(1 + frequency * α)\n * ```\n * \n * - 高频率的节点获得额外的激活概率\n * - 形成\"优先激活常用路径\"的模式\n * - 模拟工作记忆的激活模式\n * \n * @class FrequencyCue\n * @extends Cue\n */\nclass FrequencyCue extends Cue {\n  /**\n   * 创建一个带频率统计的Cue\n   * \n   * @param {string} word - 概念词\n   */\n  constructor(word) {\n    super(word);\n    \n    /**\n     * Recall频率 - 记录该节点被激活的次数\n     * \n     * 含义：\n     * - 每次被Recall激活时递增\n     * - 反映了概念在思考中的活跃度\n     * - 用于Softmax归一化时的频率偏置\n     * \n     * @type {number}\n     */\n    this.recallFrequency = 0;\n  }\n  \n  /**\n   * 增加recall频率\n   * \n   * 设计：\n   * - 简单递增，不设上限\n   * - 未来可以考虑添加衰减机制\n   * - 可以扩展为更复杂的统计（如时间窗口内的频率）\n   */\n  incrementFrequency() {\n    this.recallFrequency++;\n    logger.debug('[FrequencyCue] Frequency incremented', {\n      word: this.word,\n      newFrequency: this.recallFrequency\n    });\n  }\n  \n  /**\n   * 获取频率值\n   * \n   * @returns {number} 当前频率\n   */\n  getFrequency() {\n    return this.recallFrequency;\n  }\n  \n  /**\n   * 重置频率（用于测试或清理）\n   */\n  resetFrequency() {\n    this.recallFrequency = 0;\n    logger.debug('[FrequencyCue] Frequency reset', { word: this.word });\n  }\n  \n  /**\n   * 序列化为JSON（包含频率信息）\n   * \n   * @returns {Object} 包含频率的序列化对象\n   */\n  toJSON() {\n    return {\n      ...super.toJSON(),\n      recallFrequency: this.recallFrequency\n    };\n  }\n  \n  /**\n   * 从JSON恢复（包含频率信息）\n   * \n   * @param {Object} json - 序列化的对象\n   * @returns {FrequencyCue} 恢复的FrequencyCue实例\n   */\n  static fromJSON(json) {\n    const freqCue = new FrequencyCue(json.word);\n    \n    // 恢复连接\n    if (json.connections) {\n      for (const conn of json.connections) {\n        freqCue.connections.set(conn.target, conn.weight);\n      }\n    }\n    \n    // 恢复频率\n    freqCue.recallFrequency = json.recallFrequency || 0;\n    \n    return freqCue;\n  }\n  \n  /**\n   * 获取调试信息\n   * \n   * @returns {Object} 调试信息\n   */\n  getDebugInfo() {\n    return {\n      word: this.word,\n      outDegree: this.getOutDegree(),\n      recallFrequency: this.recallFrequency,\n      strongestConnection: this.getStrongestConnection()\n    };\n  }\n}\n\nmodule.exports = FrequencyCue;","const logger = require('@promptx/logger');\nconst fs = require('fs');\nconst path = require('path');\n\n/**\n * Network - 全局认知网络（所有 Cue 的容器）\n * \n * ## 设计理念\n * \n * Network是整个认知系统的基础设施，相当于生物大脑中的海马体（Hippocampus）。\n * 它不负责思考或推理，只负责存储和管理所有的记忆节点（Cue）。\n * \n * ## 为什么这样设计\n * \n * 1. **纯容器设计**\n *    - Network只是Cue的容器，不包含任何业务逻辑\n *    - 职责单一：存储、检索、持久化\n *    - 便于测试和维护\n * \n * 2. **去中心化架构**\n *    - 连接信息存储在Cue内部，Network不维护全局连接表\n *    - 优点：\n *      a) 避免了数据同步问题\n *      b) 支持局部更新，不需要全局锁\n *      c) 符合神经网络的生物学原理\n * \n * 3. **Map数据结构**\n *    - 使用Map而不是Object存储Cue\n *    - 原因：\n *      a) O(1)的查找性能\n *      b) 支持任何类型的键（虽然这里用string）\n *      c) 保持插入顺序（便于调试）\n *      d) 有明确的size属性\n * \n * ## 持久化设计\n * \n * 采用JSON格式持久化，结构如下：\n * ```json\n * {\n *   \"version\": \"1.0\",           // 版本号，便于未来升级\n *   \"timestamp\": 1234567890,     // 保存时间\n *   \"cues\": {                    // 所有Cue的集合\n *     \"认知\": {\n *       \"word\": \"认知\",\n *       \"connections\": [\n *         {\"target\": \"模型\", \"weight\": 1234567890}\n *       ]\n *     }\n *   }\n * }\n * ```\n * \n * ## 性能考虑\n * \n * - 单个Network预计存储10000+个Cue\n * - 每个Cue平均10-50个连接\n * - JSON文件大小：约1-10MB\n * - 加载时间：<100ms\n * \n * @class Network\n */\nclass Network {\n  constructor() {\n    /**\n     * Cue存储映射表\n     * \n     * 数据结构：Map<word, Cue>\n     * - key: 概念词（string）\n     * - value: Cue实例\n     * \n     * @type {Map<string, Cue>}\n     */\n    this.cues = new Map();\n    \n    logger.debug('[Network] Initialized empty network');\n  }\n  \n  /**\n   * 添加或获取Cue\n   * \n   * 如果Cue不存在则创建，存在则返回现有的。\n   * 这是一个幂等操作，多次调用结果相同。\n   * \n   * @param {string} word - 概念词\n   * @returns {FrequencyCue} FrequencyCue实例\n   */\n  getOrCreateCue(word) {\n    if (!this.cues.has(word)) {\n      const FrequencyCue = require('./FrequencyCue');\n      const cue = new FrequencyCue(word);\n      this.cues.set(word, cue);\n      logger.debug('[Network] Created new FrequencyCue', { word });\n    }\n    return this.cues.get(word);\n  }\n  \n  /**\n   * 获取Cue（不创建）\n   * \n   * @param {string} word - 概念词\n   * @returns {Cue|undefined} Cue实例或undefined\n   */\n  getCue(word) {\n    return this.cues.get(word);\n  }\n  \n  /**\n   * 检查Cue是否存在\n   * \n   * @param {string} word - 概念词\n   * @returns {boolean} 是否存在\n   */\n  hasCue(word) {\n    return this.cues.has(word);\n  }\n  \n  /**\n   * 获取网络规模\n   * \n   * @returns {number} Cue总数\n   */\n  size() {\n    return this.cues.size;\n  }\n  \n  /**\n   * 计算网络的入度信息\n   * \n   * 入度 = 有多少其他Cue指向这个Cue\n   * 这需要遍历整个网络，因为我们只存储出边。\n   * \n   * @returns {Map<string, number>} word => 入度\n   */\n  calculateInDegrees() {\n    const inDegrees = new Map();\n    \n    // 初始化所有Cue的入度为0\n    for (const word of this.cues.keys()) {\n      inDegrees.set(word, 0);\n    }\n    \n    // 遍历所有连接，累计入度\n    for (const [sourceWord, sourceCue] of this.cues) {\n      for (const targetWord of sourceCue.connections.keys()) {\n        const currentDegree = inDegrees.get(targetWord) || 0;\n        inDegrees.set(targetWord, currentDegree + 1);\n      }\n    }\n    \n    return inDegrees;\n  }\n  \n  /**\n   * 计算网络的入度权重（每个节点被指向的总权重）\n   * \n   * 用于Prime选择最重要的节点。\n   * \n   * @returns {Map<string, number>} word => 总入度权重\n   */\n  calculateInWeights() {\n    const inWeights = new Map();\n    \n    // 遍历所有连接，累计权重\n    for (const [sourceWord, sourceCue] of this.cues) {\n      for (const [targetWord, weight] of sourceCue.connections) {\n        const currentWeight = inWeights.get(targetWord) || 0;\n        inWeights.set(targetWord, currentWeight + weight);\n      }\n    }\n    \n    return inWeights;\n  }\n  \n  /**\n   * 获取网络统计信息\n   * \n   * @returns {Object} 统计信息\n   */\n  getStatistics() {\n    let totalConnections = 0;\n    let maxOutDegree = 0;\n    let hubNode = null;\n    let isolatedNodes = 0;\n    \n    for (const [word, cue] of this.cues) {\n      const outDegree = cue.connections.size;\n      totalConnections += outDegree;\n      \n      if (outDegree === 0) {\n        isolatedNodes++;\n      }\n      \n      if (outDegree > maxOutDegree) {\n        maxOutDegree = outDegree;\n        hubNode = word;\n      }\n    }\n    \n    const inDegrees = this.calculateInDegrees();\n    let maxInDegree = 0;\n    let sinkNode = null;\n    \n    for (const [word, inDegree] of inDegrees) {\n      if (inDegree > maxInDegree) {\n        maxInDegree = inDegree;\n        sinkNode = word;\n      }\n    }\n    \n    return {\n      totalCues: this.cues.size,\n      totalConnections,\n      averageOutDegree: this.cues.size > 0 ? totalConnections / this.cues.size : 0,\n      maxOutDegree,\n      hubNode,       // 出度最高的节点（发散中心）\n      maxInDegree,\n      sinkNode,      // 入度最高的节点（汇聚中心）\n      isolatedNodes  // 孤立节点数量\n    };\n  }\n  \n  /**\n   * 序列化Network到JSON文件\n   * \n   * 设计考虑：\n   * - 使用同步版本避免异步复杂性\n   * - 包含版本号便于未来升级\n   * - 包含时间戳便于调试\n   * \n   * @param {string} filePath - 保存路径\n   * @returns {Promise<void>}\n   */\n  async persist(filePath) {\n    try {\n      const fs = require('fs').promises;\n      const path = require('path');\n      \n      // 转换Map为可序列化的对象\n      const data = {\n        version: '1.0',\n        timestamp: Date.now(),\n        cues: {}\n      };\n      \n      // 序列化每个Cue\n      for (const [word, cue] of this.cues) {\n        data.cues[word] = cue.toJSON();\n      }\n      \n      // 确保目录存在\n      const dir = path.dirname(filePath);\n      await fs.mkdir(dir, { recursive: true });\n      \n      // 写入文件\n      await fs.writeFile(filePath, JSON.stringify(data, null, 2), 'utf8');\n      \n      logger.info('[Network] Persisted to file', { \n        path: filePath, \n        cues: this.cues.size,\n        size: JSON.stringify(data).length \n      });\n    } catch (error) {\n      logger.error('[Network] Failed to persist', { \n        path: filePath, \n        error: error.message \n      });\n      throw error;\n    }\n  }\n  \n  /**\n   * 从JSON文件加载Network\n   * \n   * @param {string} filePath - 文件路径\n   * @returns {Promise<void>}\n   */\n  async load(filePath) {\n    try {\n      const fs = require('fs').promises;\n      const FrequencyCue = require('./FrequencyCue');\n      \n      // 读取文件\n      const content = await fs.readFile(filePath, 'utf8');\n      const data = JSON.parse(content);\n      \n      // 版本检查\n      if (data.version !== '1.0') {\n        logger.warn('[Network] Version mismatch', { \n          expected: '1.0', \n          actual: data.version \n        });\n      }\n      \n      // 清空当前网络\n      this.cues.clear();\n      \n      // 重建所有Cue\n      for (const [word, cueData] of Object.entries(data.cues)) {\n        const cue = FrequencyCue.fromJSON(cueData);\n        this.cues.set(word, cue);\n      }\n      \n      logger.info('[Network] Loaded from file', { \n        path: filePath, \n        cues: this.cues.size,\n        timestamp: new Date(data.timestamp).toISOString()\n      });\n    } catch (error) {\n      logger.error('[Network] Failed to load', { \n        path: filePath, \n        error: error.message \n      });\n      throw error;\n    }\n  }\n  \n  /**\n   * 同步版本的persist\n   * \n   * Remember需要同步保存，避免异步复杂性。\n   * \n   * @param {string} filePath - 保存路径\n   */\n  persistSync(filePath) {\n    try {\n      // 转换Map为可序列化的对象\n      const data = {\n        version: '1.0',\n        timestamp: Date.now(),\n        cues: {}\n      };\n      \n      // 序列化每个Cue\n      for (const [word, cue] of this.cues) {\n        data.cues[word] = cue.toJSON();\n      }\n      \n      // 确保目录存在\n      const dir = path.dirname(filePath);\n      fs.mkdirSync(dir, { recursive: true });\n      \n      // 写入文件\n      fs.writeFileSync(filePath, JSON.stringify(data, null, 2), 'utf8');\n      \n      logger.debug('[Network] Persisted (sync) to file', { \n        path: filePath, \n        cues: this.cues.size \n      });\n    } catch (error) {\n      logger.error('[Network] Failed to persist (sync)', { \n        path: filePath, \n        error: error.message \n      });\n      throw error;\n    }\n  }\n  \n  /**\n   * 同步版本的load\n   * \n   * Prime需要同步加载，避免异步复杂性。\n   * \n   * @param {string} filePath - 文件路径\n   */\n  loadSync(filePath) {\n    try {\n      const FrequencyCue = require('./FrequencyCue');\n      \n      // 读取文件\n      const content = fs.readFileSync(filePath, 'utf8');\n      const data = JSON.parse(content);\n      \n      // 版本检查\n      if (data.version !== '1.0') {\n        logger.warn('[Network] Version mismatch', { \n          expected: '1.0', \n          actual: data.version \n        });\n      }\n      \n      // 清空当前网络\n      this.cues.clear();\n      \n      // 重建所有Cue\n      for (const [word, cueData] of Object.entries(data.cues)) {\n        const cue = FrequencyCue.fromJSON(cueData);\n        this.cues.set(word, cue);\n      }\n      \n      logger.debug('[Network] Loaded (sync) from file', { \n        path: filePath, \n        cues: this.cues.size \n      });\n    } catch (error) {\n      logger.error('[Network] Failed to load (sync)', { \n        path: filePath, \n        error: error.message \n      });\n      throw error;\n    }\n  }\n  \n  /**\n   * 更新Recall频率\n   * \n   * 当Recall操作完成后，更新所有被激活节点的频率。\n   * 这是Network作为容器管理统计信息的体现。\n   * \n   * @param {Set<string>} activatedCues - 被激活的节点集合\n   */\n  updateRecallFrequency(activatedCues) {\n    if (!activatedCues || activatedCues.size === 0) {\n      return;\n    }\n    \n    let updatedCount = 0;\n    for (const word of activatedCues) {\n      const cue = this.cues.get(word);\n      if (cue && typeof cue.incrementFrequency === 'function') {\n        cue.incrementFrequency();\n        updatedCount++;\n      }\n    }\n    \n    logger.debug('[Network] Updated recall frequencies', {\n      requested: activatedCues.size,\n      updated: updatedCount\n    });\n  }\n  \n  /**\n   * 获取频率统计信息\n   * \n   * @returns {Object} 频率统计\n   */\n  getFrequencyStatistics() {\n    let totalFrequency = 0;\n    let maxFrequency = 0;\n    let mostFrequentNode = null;\n    const frequencyDistribution = new Map();\n    \n    for (const [word, cue] of this.cues) {\n      const frequency = cue.recallFrequency || 0;\n      totalFrequency += frequency;\n      \n      if (frequency > maxFrequency) {\n        maxFrequency = frequency;\n        mostFrequentNode = word;\n      }\n      \n      // 统计频率分布\n      const bucket = Math.floor(frequency / 10) * 10; // 10为一档\n      frequencyDistribution.set(bucket, (frequencyDistribution.get(bucket) || 0) + 1);\n    }\n    \n    return {\n      totalRecalls: totalFrequency,\n      averageFrequency: this.cues.size > 0 ? totalFrequency / this.cues.size : 0,\n      maxFrequency,\n      mostFrequentNode,\n      distribution: Array.from(frequencyDistribution.entries())\n        .sort((a, b) => a[0] - b[0])\n        .map(([bucket, count]) => ({ range: `${bucket}-${bucket+9}`, count }))\n    };\n  }\n  \n  /**\n   * 清空网络\n   * \n   * 用于测试或重置。\n   */\n  clear() {\n    const previousSize = this.cues.size;\n    this.cues.clear();\n    logger.info('[Network] Cleared', { previousSize });\n  }\n}\n\nmodule.exports = Network;","/**\n * Mind - 认知网络（以 Cue 为中心的激活子图）\n * \n * ## 设计理念\n * \n * Mind代表一个当前激活的认知状态，相当于\"工作记忆\"（Working Memory）。\n * 它不是所有记忆的容器（那是Network的职责），而是当前正在思考的内容。\n * \n * 类比：\n * - Network = 长期记忆（所有你知道的）\n * - Mind = 工作记忆（你现在正在想的）\n * \n * ## 为什么这样设计\n * \n * 1. **动态激活模型**\n *    - Mind是动态生成的，不是静态存储的\n *    - 每次Recall/Prime都会生成新的Mind\n *    - 反映了人类认知的动态性：同一个概念在不同时刻激活的相关内容可能不同\n * \n * 2. **有向无环图（DAG）结构**\n *    - 从中心Cue向外扩散形成的子图\n *    - 避免环路，防止无限激活\n *    - 保持思维的方向性和层次性\n * \n * 3. **轻量级设计**\n *    - 只存储激活的Cue集合和连接关系\n *    - 不复制Cue的内容，只引用\n *    - 便于序列化和传输（给大模型）\n * \n * ## 数据结构说明\n * \n * ```javascript\n * {\n *   center: Cue实例,              // 激活中心（起点）\n *   activatedCues: Set(['认知', '模型', ...]),  // 所有激活的节点\n *   connections: [                // 激活的连接\n *     {from: '认知', to: '模型', weight: 1234567890},\n *     {from: '模型', to: '训练', weight: 1234567880}\n *   ]\n * }\n * ```\n * \n * ## Mind的用途\n * \n * 1. **作为上下文提供给大模型**\n *    - 大模型可以根据Mind理解当前的思维脉络\n *    - 提供相关概念的关联性\n * \n * 2. **可视化思维过程**\n *    - 可以渲染成mindmap\n *    - 展示概念之间的关系强度\n * \n * 3. **思维链的基础**\n *    - 多个Mind可以组合成思维链\n *    - 支持复杂的推理过程\n * \n * @class Mind\n */\nclass Mind {\n  /**\n   * 创建一个新的Mind\n   * \n   * @param {Cue} center - 中心Cue（激活的起点）\n   */\n  constructor(center) {\n    /**\n     * 激活中心 - 思维的起点\n     * \n     * 设计考虑：\n     * - 可能为null（如Prime失败或多中心激活）\n     * - 保存Cue引用而不是word，便于访问连接信息\n     * \n     * @type {Cue|null}\n     */\n    this.center = center;\n    \n    /**\n     * 激活的Cue集合 - 所有被激活的概念\n     * \n     * 使用Set的原因：\n     * - O(1)的查找性能（避免重复激活）\n     * - 自动去重\n     * - 便于统计激活数量\n     * \n     * 存储word而不是Cue引用的原因：\n     * - 减少内存占用\n     * - 便于序列化\n     * - 避免循环引用\n     * \n     * @type {Set<string>}\n     */\n    this.activatedCues = new Set();\n    \n    /**\n     * 连接关系 - 激活的边\n     * \n     * 数组结构：便于保持激活顺序\n     * 每个连接包含：\n     * - from: 源节点word\n     * - to: 目标节点word  \n     * - weight: 连接权重\n     * \n     * @type {Array<{from: string, to: string, weight: number}>}\n     */\n    this.connections = [];\n    \n    /**\n     * 多中心支持（实验性）\n     * \n     * 用于Prime.executeMultiple等场景\n     * 允许多个起点同时激活\n     * \n     * @type {Array<Cue>}\n     */\n    this.centers = [];\n    \n    /**\n     * 激活深度记录\n     * \n     * 记录每个节点距离中心的深度\n     * 用于可视化和分析\n     * \n     * @type {Map<string, number>}\n     */\n    this.depths = new Map();\n    \n    // 如果有中心，将其加入激活集合\n    if (center) {\n      this.activatedCues.add(center.word);\n      this.depths.set(center.word, 0);\n    }\n  }\n  \n  /**\n   * 添加一个激活的Cue\n   * \n   * @param {string} word - 概念词\n   * @param {number} depth - 距离中心的深度\n   */\n  addActivatedCue(word, depth = 0) {\n    this.activatedCues.add(word);\n    if (!this.depths.has(word) || this.depths.get(word) > depth) {\n      this.depths.set(word, depth);\n    }\n  }\n  \n  /**\n   * 添加一个连接\n   * \n   * @param {string} from - 源节点\n   * @param {string} to - 目标节点\n   * @param {number} weight - 连接权重\n   */\n  addConnection(from, to, weight) {\n    this.connections.push({ from, to, weight });\n    // 确保两端都在激活集合中\n    this.activatedCues.add(from);\n    this.activatedCues.add(to);\n  }\n  \n  /**\n   * 获取激活的节点数量\n   * \n   * @returns {number} 节点数\n   */\n  size() {\n    return this.activatedCues.size;\n  }\n  \n  /**\n   * 获取连接数量\n   * \n   * @returns {number} 边数\n   */\n  connectionCount() {\n    return this.connections.length;\n  }\n  \n  /**\n   * 检查是否为空Mind\n   * \n   * @returns {boolean} 是否为空\n   */\n  isEmpty() {\n    return this.activatedCues.size === 0;\n  }\n  \n  /**\n   * 获取按权重排序的连接\n   * \n   * @returns {Array} 排序后的连接\n   */\n  getSortedConnections() {\n    return [...this.connections].sort((a, b) => b.weight - a.weight);\n  }\n  \n  /**\n   * 获取特定节点的所有出边\n   * \n   * @param {string} word - 节点词\n   * @returns {Array} 出边列表\n   */\n  getOutgoingConnections(word) {\n    return this.connections.filter(conn => conn.from === word);\n  }\n  \n  /**\n   * 获取特定节点的所有入边\n   * \n   * @param {string} word - 节点词\n   * @returns {Array} 入边列表\n   */\n  getIncomingConnections(word) {\n    return this.connections.filter(conn => conn.to === word);\n  }\n  \n  /**\n   * 转换为可序列化的JSON对象\n   * \n   * 用于：\n   * - 发送给大模型\n   * - 保存思维快照\n   * - 可视化展示\n   * \n   * @returns {Object} JSON对象\n   */\n  toJSON() {\n    return {\n      center: this.center ? this.center.word : null,\n      centers: this.centers.map(c => c.word),\n      activatedCues: Array.from(this.activatedCues),\n      connections: this.connections,\n      depths: Array.from(this.depths.entries()).map(([word, depth]) => ({ word, depth })),\n      statistics: {\n        nodeCount: this.activatedCues.size,\n        edgeCount: this.connections.length,\n        maxDepth: Math.max(...this.depths.values(), 0)\n      }\n    };\n  }\n  \n  /**\n   * 生成Mermaid mindmap代码\n   * \n   * 可以直接用于可视化展示\n   * \n   * @returns {string} Mermaid mindmap代码\n   */\n  toMermaid() {\n    if (!this.center || this.activatedCues.size === 0) {\n      return 'mindmap\\n  root((空))';\n    }\n    \n    // 构建树形结构（从连接关系构建）\n    const tree = this.buildTree();\n    \n    // 生成mindmap格式\n    let mermaid = 'mindmap\\n';\n    mermaid += `  root((${this.center.word}))\\n`;\n    \n    // 递归添加子节点\n    const addChildren = (parent, indent) => {\n      const children = tree.get(parent) || [];\n      for (const child of children) {\n        mermaid += ' '.repeat(indent) + child + '\\n';\n        addChildren(child, indent + 2);\n      }\n    };\n    \n    addChildren(this.center.word, 4);\n    \n    return mermaid;\n  }\n  \n  /**\n   * 构建树形结构\n   * 用于生成mindmap\n   * \n   * @returns {Map<string, Array<string>>} 父节点 -> 子节点列表\n   */\n  buildTree() {\n    const tree = new Map();\n    const visited = new Set();\n    \n    // 从连接构建父子关系\n    for (const conn of this.connections) {\n      if (!tree.has(conn.from)) {\n        tree.set(conn.from, []);\n      }\n      // 避免重复添加\n      if (!visited.has(`${conn.from}->${conn.to}`)) {\n        tree.get(conn.from).push(conn.to);\n        visited.add(`${conn.from}->${conn.to}`);\n      }\n    }\n    \n    // 按权重排序子节点（可选）\n    for (const [parent, children] of tree) {\n      // 获取每个子节点的权重\n      const childrenWithWeight = children.map(child => {\n        const conn = this.connections.find(c => c.from === parent && c.to === child);\n        return { child, weight: conn ? conn.weight : 0 };\n      });\n      // 按权重降序排序\n      childrenWithWeight.sort((a, b) => b.weight - a.weight);\n      // 更新排序后的子节点\n      tree.set(parent, childrenWithWeight.map(item => item.child));\n    }\n    \n    return tree;\n  }\n  \n  /**\n   * 合并另一个Mind\n   * \n   * 用于多线索思考的场景\n   * \n   * @param {Mind} otherMind - 要合并的Mind\n   */\n  merge(otherMind) {\n    // 合并激活集合\n    for (const cue of otherMind.activatedCues) {\n      this.activatedCues.add(cue);\n    }\n    \n    // 合并连接（避免重复）\n    const existingConns = new Set(\n      this.connections.map(c => `${c.from}->${c.to}`)\n    );\n    \n    for (const conn of otherMind.connections) {\n      const key = `${conn.from}->${conn.to}`;\n      if (!existingConns.has(key)) {\n        this.connections.push(conn);\n      }\n    }\n    \n    // 合并深度信息\n    for (const [word, depth] of otherMind.depths) {\n      if (!this.depths.has(word) || this.depths.get(word) > depth) {\n        this.depths.set(word, depth);\n      }\n    }\n    \n    // 添加到多中心列表\n    if (otherMind.center) {\n      this.centers.push(otherMind.center);\n    }\n  }\n}\n\nmodule.exports = Mind;","const logger = require('@promptx/logger');\n\n/**\n * Engram - 记忆痕迹载体\n * \n * ## 设计理念\n * \n * Engram（记忆痕迹）是认知系统中的基本记忆单元，包含了一次认知体验的完整信息。\n * 它贯穿整个认知循环，从AI的感知理解到海马体的存储检索。\n * \n * 在神经科学中，Engram指大脑中存储特定记忆的物理或生化变化。\n * 在我们的系统中，它是连接AI大脑皮层和认知海马体的标准数据结构。\n * \n * ## 康德认识论映射\n * \n * - content = 感性直观（现象界的原始经验）\n * - schema = 知性范畴（概念化的结果）\n * - strength = 实践理性（角色的主观价值判断）\n * - timestamp = 时间形式（内感官的先验形式）\n * \n * ## 为什么需要Engram\n * \n * 1. **数据完整性**\n *    - 保留完整的认知过程信息\n *    - content用于追溯和调试\n *    - schema用于存储和检索\n * \n * 2. **职责分离**\n *    - Engram负责数据承载\n *    - Remember负责处理逻辑\n *    - 清晰的数据与算法分离\n * \n * 3. **时间一致性**\n *    - timestamp在创建时确定\n *    - 避免处理过程中的时间漂移\n *    - 保证批次内的时间统一\n * \n * @class Engram\n */\nclass Engram {\n  /**\n   * 创建记忆痕迹\n   * \n   * @param {Object} params - 参数对象\n   * @param {string} params.content - 原始经验内容\n   * @param {string|Array} params.schema - 概念序列（字符串或数组）\n   * @param {number} params.strength - 记忆强度 (0-1)，表示角色的主观重要性评分\n   * @param {number} [params.timestamp] - 时间戳（可选，默认为当前时间）\n   */\n  constructor({ content, schema, strength, timestamp }) {\n    // 验证必需参数\n    if (!content) {\n      throw new Error('Engram requires content');\n    }\n    if (!schema) {\n      throw new Error('Engram requires schema');\n    }\n    if (strength === undefined || strength === null) {\n      throw new Error('Engram requires strength');\n    }\n    \n    /**\n     * 原始经验内容\n     * 保留AI的原始理解，用于追溯和调试\n     * @type {string}\n     */\n    this.content = content;\n    \n    /**\n     * 概念序列\n     * 经过图式化处理的概念数组\n     * @type {Array<string>}\n     */\n    this.schema = this._normalizeSchema(schema);\n    \n    /**\n     * 记忆强度\n     * 角色视角的主观重要性评分 (0-1)\n     * @type {number}\n     */\n    this.strength = this._validateStrength(strength);\n    \n    /**\n     * 时间戳\n     * 记忆创建的精确时间\n     * @type {number}\n     */\n    this.timestamp = timestamp || Date.now();\n    \n    /**\n     * Engram唯一标识符\n     * 格式: timestamp_randomId\n     * @type {string}\n     */\n    this.id = `${this.timestamp}_${Math.random().toString(36).substr(2, 9)}`;\n    \n    logger.debug('[Engram] Created new engram', {\n      schemaLength: this.schema.length,\n      strength: this.strength,\n      timestamp: new Date(this.timestamp).toISOString()\n    });\n  }\n  \n  /**\n   * 标准化schema格式\n   * 支持字符串（换行分隔）或数组格式\n   * \n   * @private\n   * @param {string|Array} schema - 原始schema\n   * @returns {Array<string>} 标准化的概念数组\n   */\n  _normalizeSchema(schema) {\n    if (Array.isArray(schema)) {\n      return schema.filter(item => item && typeof item === 'string');\n    }\n    \n    if (typeof schema === 'string') {\n      // 支持换行分隔的字符串格式\n      return schema\n        .split('\\n')\n        .map(s => s.trim())\n        .filter(Boolean);\n    }\n    \n    throw new Error('Schema must be a string or array');\n  }\n  \n  /**\n   * 验证strength值的有效性\n   * \n   * @private\n   * @param {number} strength - 强度值\n   * @returns {number} 验证后的强度值\n   */\n  _validateStrength(strength) {\n    const num = Number(strength);\n    if (isNaN(num)) {\n      throw new Error('Strength must be a number');\n    }\n    if (num < 0 || num > 1) {\n      throw new Error('Strength must be between 0 and 1');\n    }\n    return num;\n  }\n  \n  /**\n   * 获取schema长度\n   * 用于快速判断是否可以创建连接\n   * \n   * @returns {number} schema数组的长度\n   */\n  get length() {\n    return this.schema.length;\n  }\n  \n  /**\n   * 判断是否有效\n   * schema至少需要2个元素才能创建连接\n   * \n   * @returns {boolean} 是否为有效的engram\n   */\n  isValid() {\n    return this.schema.length >= 2;\n  }\n  \n  /**\n   * 获取预览字符串\n   * 用于日志和调试\n   * \n   * @param {number} [maxLength=5] - 最大显示元素数\n   * @returns {string} 预览字符串\n   */\n  getPreview(maxLength = 5) {\n    const preview = this.schema.slice(0, maxLength).join(' -> ');\n    return this.schema.length > maxLength ? `${preview}...` : preview;\n  }\n  \n  /**\n   * 转换为JSON对象\n   * 用于序列化和传输\n   * \n   * @returns {Object} JSON对象\n   */\n  toJSON() {\n    return {\n      id: this.id,\n      content: this.content,\n      schema: this.schema,\n      strength: this.strength,\n      timestamp: this.timestamp\n    };\n  }\n  \n  /**\n   * 从JSON对象创建Engram\n   * 用于反序列化\n   * \n   * @static\n   * @param {Object} json - JSON对象\n   * @returns {Engram} 新的Engram实例\n   */\n  static fromJSON(json) {\n    return new Engram(json);\n  }\n}\n\nmodule.exports = Engram;","/**\n * WeightContext - 权重计算上下文\n * \n * ## 设计理念\n * \n * WeightContext封装了计算连接权重所需的所有信息。\n * 这是策略模式（Strategy Pattern）的关键部分，让权重计算与数据收集解耦。\n * \n * ## 为什么这样设计\n * \n * 1. **职责分离**\n *    - WeightContext负责收集数据\n *    - Strategy负责计算逻辑\n *    - 便于测试和扩展\n * \n * 2. **最小化原则**\n *    - 只包含实际使用的参数\n *    - 避免过度设计\n *    - 保持简洁清晰\n * \n * 3. **透明性**\n *    - 所有影响权重的因素都明确定义\n *    - 便于调试和优化\n *    - 易于理解权重的来源\n * \n * ## 权重因子说明\n * \n * 当前包含的因子：\n * 1. **时间因子（timestamp）**\n *    - 作为权重的基数\n *    - 新的记忆自然比旧的权重大\n *    - 体现记忆的时效性\n * \n * 2. **位置因子（position）**\n *    - 在Schema序列中的位置\n *    - 越靠后的连接权重越低（衰减）\n *    - 体现首因效应和近因效应\n * \n * 3. **网络因子（sourceOutDegree）**\n *    - 源节点的出度\n *    - 出度越高，每条边的权重越分散\n *    - 防止hub节点过度激活\n * \n * ## 设计决策\n * \n * Q: 为什么不包含targetCue？\n * A: 目标节点可能还不存在（Remember创建时），而且当前算法不需要目标节点信息。\n * \n * Q: 为什么sourceOutDegree要缓存？\n * A: 避免重复计算，虽然简单但频繁调用。\n * \n * Q: 为什么timestamp可以外部传入？\n * A: 同一批Schema应该使用相同的时间戳，保持批次内的一致性。\n * \n * @class WeightContext\n */\nclass WeightContext {\n  /**\n   * 创建权重计算上下文\n   * \n   * @param {Object} data - 上下文数据\n   * @param {Cue} data.sourceCue - 源节点\n   * @param {string} data.targetWord - 目标词\n   * @param {number} data.position - 在Schema中的位置\n   * @param {number} [data.timestamp] - 时间戳（可选，默认当前时间）\n   * @param {Engram} [data.engram] - 完整的记忆痕迹对象（可选）\n   */\n  constructor(data) {\n    /**\n     * 源Cue节点\n     * \n     * 包含了源节点的所有信息：\n     * - word: 概念词\n     * - connections: 所有出边\n     * \n     * @type {Cue}\n     */\n    this.sourceCue = data.sourceCue;\n    \n    /**\n     * 目标词\n     * \n     * 注意：是词而不是Cue，因为目标节点可能还不存在。\n     * Remember在创建连接时，目标Cue可能刚刚创建。\n     * \n     * @type {string}\n     */\n    this.targetWord = data.targetWord;\n    \n    /**\n     * 在Schema中的位置（0-based）\n     * \n     * 用于计算位置衰减：\n     * - position=0: 第一条边，权重最高\n     * - position=1: 第二条边，权重衰减\n     * - position=n: 权重 = base * decay^n\n     * \n     * @type {number}\n     */\n    this.position = data.position;\n    \n    /**\n     * 当前时间戳\n     * \n     * 作为权重的基数，保证：\n     * - 新的记忆权重 > 旧的记忆权重\n     * - 同批次使用相同时间戳\n     * \n     * 使用毫秒时间戳（13位数字），足够精确且不会溢出。\n     * \n     * @type {number}\n     */\n    this.timestamp = data.timestamp || Date.now();\n    \n    /**\n     * 源节点的出度（缓存）\n     * \n     * 出度 = 源节点连接到多少其他节点\n     * 用于调整权重，防止hub节点过度激活。\n     * \n     * 缓存原因：避免重复访问Map.size\n     * \n     * @type {number}\n     */\n    this.sourceOutDegree = this.sourceCue ? this.sourceCue.connections.size : 0;\n    \n    /**\n     * 完整的记忆痕迹对象\n     * \n     * 包含了记忆的完整信息：\n     * - content: 原始经验\n     * - schema: 概念序列\n     * - strength: 角色评分（0-1）\n     * - timestamp: 时间戳\n     * \n     * 让策略可以使用strength进行权重调整\n     * \n     * @type {Engram|null}\n     */\n    this.engram = data.engram || null;\n    \n    /**\n     * 记忆强度（从engram提取）\n     * \n     * 便捷访问，避免总是写this.engram.strength\n     * 默认值0.8用于向后兼容\n     * \n     * @type {number}\n     */\n    this.strength = this.engram ? this.engram.strength : 0.8;\n  }\n  \n  /**\n   * 获取源词\n   * \n   * 便捷方法，避免总是写this.sourceCue.word\n   * \n   * @returns {string|null} 源词\n   */\n  getSourceWord() {\n    return this.sourceCue ? this.sourceCue.word : null;\n  }\n  \n  /**\n   * 转换为调试字符串\n   * \n   * 用于日志输出，包含关键信息。\n   * \n   * @returns {string} 调试信息\n   */\n  toString() {\n    const sourceWord = this.getSourceWord();\n    return `WeightContext{${sourceWord}->${this.targetWord}, pos:${this.position}, degree:${this.sourceOutDegree}}`;\n  }\n  \n  /**\n   * 转换为JSON对象\n   * \n   * 用于序列化和日志记录。\n   * \n   * @returns {Object} JSON对象\n   */\n  toJSON() {\n    return {\n      sourceWord: this.getSourceWord(),\n      targetWord: this.targetWord,\n      position: this.position,\n      timestamp: this.timestamp,\n      sourceOutDegree: this.sourceOutDegree,\n      strength: this.strength\n    };\n  }\n}\n\nmodule.exports = WeightContext;","const logger = require('@promptx/logger');\n\n/**\n * Remember - 记忆写入执行器\n * \n * ## 设计理念\n * \n * Remember是记忆系统的写入端，负责将Schema（概念序列）写入Network。\n * 采用纯执行器模式，不包含任何计算逻辑，所有计算委托给Strategy。\n * \n * 类比生物记忆：\n * - Schema = 体验的序列（如\"看到-理解-记住\"）\n * - Remember = 海马体的编码过程\n * - 连接权重 = 突触强度\n * \n * ## 为什么这样设计\n * \n * 1. **职责单一**\n *    - Remember只负责执行流程，不负责算法\n *    - 便于测试和维护\n *    - 可以轻松切换不同的权重策略\n * \n * 2. **批处理优化**\n *    - 同一批Schema使用相同时间戳\n *    - 保证批次内的一致性\n *    - 避免时间戳漂移\n * \n * 3. **覆盖而非累加**\n *    - 新的记忆覆盖旧的（用户决定）\n *    - 简化模型，避免权重爆炸\n *    - 符合\"遗忘即学习\"的认知规律\n * \n * ## 执行流程\n * \n * ```\n * Schema: [\"认知\", \"模型\", \"训练\", \"效果\"]\n * \n * Phase 1: 确保Cue存在\n *   - 创建/获取 \"认知\" Cue\n *   - 创建/获取 \"模型\" Cue\n *   - 创建/获取 \"训练\" Cue\n *   - 创建/获取 \"效果\" Cue\n * \n * Phase 2: 建立连接\n *   - \"认知\" -> \"模型\" (position=0)\n *   - \"模型\" -> \"训练\" (position=1)\n *   - \"训练\" -> \"效果\" (position=2)\n * ```\n * \n * ## 设计决策\n * \n * Q: 为什么不在Remember中计算权重？\n * A: 策略模式，算法可独立演化，Remember保持稳定。\n * \n * Q: 为什么要两个Phase？\n * A: \n * - Phase 1确保所有节点存在，避免边创建时找不到节点\n * - Phase 2专注于边的创建，逻辑清晰\n * \n * Q: 为什么返回connections数组？\n * A: 便于调试、日志记录和可视化展示。\n * \n * @class Remember\n */\nclass Remember {\n  /**\n   * 创建Remember实例\n   * \n   * @param {Network} network - 全局认知网络\n   * @param {WeightStrategy} strategy - 权重计算策略\n   */\n  constructor(network, options = {}) {\n    /**\n     * 认知网络引用\n     * @type {Network}\n     */\n    this.network = network;\n    \n    /**\n     * 权重策略\n     * @type {WeightStrategy}\n     */\n    this.strategy = options.strategy || null;\n    \n    if (this.strategy) {\n      logger.debug('[Remember] Initialized with strategy', { \n        strategy: this.strategy.constructor.name \n      });\n    } else {\n      logger.warn('[Remember] No strategy provided');\n    }\n  }\n\n  /**\n   * 执行记忆写入\n   * \n   * 将Engram中的Schema序列写入Network，建立Cue之间的连接，\n   * 同时建立Cue到Engram.id的反向索引。\n   * \n   * @param {Engram} engram - 记忆痕迹对象\n   * @param {string} [engramId] - 可选的Engram ID，默认使用engram.id\n   * @returns {Object} 执行结果\n   * @returns {number} returns.processed - 处理的节点数\n   * @returns {Array} returns.connections - 创建的连接列表\n   * @returns {string} returns.engramId - 使用的Engram ID\n   */\n  execute(engram, engramId = null) {\n    // 参数验证\n    const Engram = require('./Engram');\n    if (!engram || !(engram instanceof Engram)) {\n      logger.warn('[Remember] Invalid engram provided', { engram });\n      return {\n        processed: 0,\n        connections: []\n      };\n    }\n    \n    if (!engram.isValid()) {\n      logger.debug('[Remember] Engram schema too short, no connections to create', { \n        length: engram.length \n      });\n      return {\n        processed: engram.length,\n        connections: []\n      };\n    }\n    \n    const { schema, strength, timestamp } = engram;\n    \n    logger.debug('[Remember] Processing engram', { \n      length: schema.length,\n      strength: strength,\n      preview: engram.getPreview()\n    });\n    \n    // Phase 1: 确保所有Cue存在\n    logger.debug('[Remember] Phase 1: Ensuring all Cues exist');\n    const createdCues = [];\n    for (const word of schema) {\n      // 使用Network的getOrCreateCue方法，它会创建FrequencyCue\n      if (!this.network.cues.has(word)) {\n        createdCues.push(word);\n      }\n      this.network.getOrCreateCue(word);\n    }\n    \n    if (createdCues.length > 0) {\n      logger.debug('[Remember] Created new Cues', { \n        count: createdCues.length,\n        cues: createdCues.slice(0, 10)  // 只显示前10个\n      });\n    }\n    \n    // Phase 2: 建立连接结构（先用临时权重）\n    logger.debug('[Remember] Phase 2: Building connection structure');\n    const WeightContext = require('./WeightContext');\n    const connections = [];\n    // 使用engram的timestamp，保证时间一致性\n    \n    // 2.1 先建立所有连接（用临时权重0）\n    for (let i = 0; i < schema.length - 1; i++) {\n      const sourceWord = schema[i];\n      const targetWord = schema[i + 1];\n      const sourceCue = this.network.cues.get(sourceWord);\n      \n      // 检查是否已有连接\n      const existingWeight = sourceCue.connections.get(targetWord);\n      if (!existingWeight) {\n        // 新连接，先用0占位\n        sourceCue.connections.set(targetWord, 0);\n      }\n    }\n    \n    // 2.2 现在计算并更新权重（此时出度已正确）\n    logger.debug('[Remember] Phase 2.2: Calculating and updating weights');\n    for (let i = 0; i < schema.length - 1; i++) {\n      const sourceWord = schema[i];\n      const targetWord = schema[i + 1];\n      const sourceCue = this.network.cues.get(sourceWord);\n      \n      // 构建上下文（现在sourceOutDegree是正确的）\n      const context = new WeightContext({\n        sourceCue: sourceCue,\n        targetWord: targetWord,\n        position: i,\n        timestamp: timestamp,\n        engram: engram  // 传递完整的engram对象\n      });\n      \n      // 委托策略计算权重\n      const weight = this.strategy.calculate(context);\n      \n      logger.debug('[Remember] Weight calculation', {\n        from: sourceWord,\n        to: targetWord,\n        position: i,\n        outDegree: context.sourceOutDegree,\n        weight: weight\n      });\n      \n      // 更新权重（覆盖）\n      sourceCue.connections.set(targetWord, weight);\n      \n      // 记录本次更新\n      connections.push({\n        source: sourceWord,\n        target: targetWord,\n        weight: weight,\n        position: i\n      });\n    }\n    \n    logger.info('[Remember] Schema processed successfully', {\n      nodes: schema.length,\n      connections: connections.length,\n      timestamp: new Date(timestamp).toISOString()\n    });\n    \n    // 建立Cue到Engram的反向索引\n    const actualEngramId = engramId || engram.id;\n    if (actualEngramId) {\n      for (const word of schema) {\n        const cue = this.network.cues.get(word);\n        if (cue) {\n          if (!cue.memories) {\n            cue.memories = new Set();\n          }\n          cue.memories.add(actualEngramId);\n          \n          logger.debug('[Remember] Added engram reference', {\n            cue: word,\n            engramId: actualEngramId,\n            totalReferences: cue.memories.size\n          });\n        }\n      }\n    }\n    \n    return {\n      processed: schema.length,\n      connections: connections,\n      timestamp: timestamp,\n      engramId: actualEngramId\n    };\n  }\n}\n\nmodule.exports = Remember;","const logger = require('@promptx/logger');\n\n/**\n * ActivationStrategy - 激活策略基类\n * \n * ## 设计理念\n * \n * 定义激活扩散的策略接口，让不同的激活算法可以灵活切换。\n * 这是策略模式在激活扩散中的应用。\n * \n * ## 为什么这样设计\n * \n * 1. **算法独立**\n *    - 激活算法独立于Recall的流程控制\n *    - 便于实现和测试不同的算法\n *    - 可以根据场景选择不同策略\n * \n * 2. **职责清晰**\n *    - Strategy负责决策（是否激活、如何激活）\n *    - Recall负责执行（管理流程、构建Mind）\n *    - Context负责状态（数据和状态管理）\n * \n * 3. **易于扩展**\n *    - 新算法只需继承基类\n *    - 不影响现有代码\n *    - 可以组合不同的策略\n * \n * @class ActivationStrategy\n */\nclass ActivationStrategy {\n  constructor(options = {}) {\n    /**\n     * 策略名称\n     * @type {string}\n     */\n    this.name = 'base';\n    \n    /**\n     * 策略配置\n     * @type {Object}\n     */\n    this.options = options;\n  }\n  \n  /**\n   * 决定如何激活节点\n   * \n   * 子类必须实现此方法\n   * \n   * @param {ActivationContext} context - 激活上下文\n   * @returns {Object} 激活决策\n   * @returns {boolean} returns.shouldActivate - 是否应该激活\n   * @returns {Array} returns.edges - 要激活的边列表\n   */\n  activate(context) {\n    throw new Error('ActivationStrategy.activate() must be implemented');\n  }\n  \n  /**\n   * 判断是否继续激活\n   * \n   * @param {ActivationContext} context - 激活上下文\n   * @returns {boolean} true继续，false停止\n   */\n  shouldContinue(context) {\n    return true;\n  }\n  \n  /**\n   * 应用衰减或其他周期性操作\n   * \n   * @param {ActivationContext} context - 激活上下文\n   */\n  applyDecay(context) {\n    // 默认不做任何事\n  }\n}\n\n/**\n * HippocampalActivationStrategy - 海马体激活策略\n * \n * ## 设计理念\n * \n * 模拟海马体的激活扩散机制：\n * - 能量在网络中流动和衰减\n * - 只有能量足够的节点才会激活\n * - 侧抑制防止过度激活\n * - 频率增强经常使用的连接\n * \n * ## 算法特点\n * \n * 1. **能量模型**\n *    - 初始节点满能量（1.0）\n *    - 能量通过连接传递，有损耗\n *    - 能量低于阈值的节点不再传播\n * \n * 2. **频率增强**\n *    - 经常被recall的节点更容易激活\n *    - 模拟长时程增强（LTP）效应\n * \n * 3. **侧抑制**\n *    - 激活节点越多，每个节点获得的能量越少\n *    - 保持稀疏表征\n * \n * 4. **自然终止**\n *    - 能量耗散后自然停止\n *    - 不需要硬性深度限制\n * \n * @class HippocampalActivationStrategy\n * @extends ActivationStrategy\n */\nclass HippocampalActivationStrategy extends ActivationStrategy {\n  constructor(options = {}) {\n    super(options);\n    \n    /**\n     * 策略名称\n     * @type {string}\n     */\n    this.name = 'hippocampal';\n    \n    /**\n     * 神经元激活阈值\n     * 只有能量超过此值的节点才会激活\n     * @type {number}\n     */\n    this.firingThreshold = options.firingThreshold || 0.1;  // 降低阈值，让更多节点能激活\n    \n    /**\n     * 突触传递效率\n     * 能量传递时的损耗率\n     * @type {number}\n     */\n    this.synapticDecay = options.synapticDecay || 0.9;  // 提高传递效率，减少能量损失\n    \n    /**\n     * 侧抑制因子\n     * 控制网络激活的稀疏性\n     * @type {number}\n     */\n    this.inhibitionFactor = options.inhibitionFactor || 0.1;\n    \n    /**\n     * 最大循环次数\n     * 防止无限循环的保护机制\n     * @type {number}\n     */\n    this.maxCycles = options.maxCycles || 10;\n    \n    /**\n     * 每周期能量衰减率\n     * 模拟时间流逝的能量损耗\n     * @type {number}\n     */\n    this.cycleDecay = options.cycleDecay || 0.9;\n    \n    /**\n     * 频率增强因子\n     * 控制频率对激活的影响程度\n     * @type {number}\n     */\n    this.frequencyBoost = options.frequencyBoost || 0.1;\n    \n    /**\n     * 权重策略（用于归一化和批次感知）\n     * @type {WeightStrategy|null}\n     */\n    this.weightStrategy = options.weightStrategy || null;\n    \n    logger.debug('[HippocampalActivationStrategy] Initialized', {\n      firingThreshold: this.firingThreshold,\n      synapticDecay: this.synapticDecay,\n      maxCycles: this.maxCycles\n    });\n  }\n  \n  /**\n   * 决定如何激活节点\n   * \n   * @param {ActivationContext} context - 激活上下文\n   * @returns {Object} 激活决策\n   */\n  activate(context) {\n    // 能量不足，不激活\n    if (context.currentEnergy < this.firingThreshold) {\n      logger.debug('[HippocampalActivationStrategy] Energy below threshold', {\n        word: context.sourceCue?.word,\n        energy: context.currentEnergy,\n        threshold: this.firingThreshold\n      });\n      return { shouldActivate: false, edges: [] };\n    }\n    \n    if (!context.sourceCue || !context.sourceCue.connections) {\n      return { shouldActivate: false, edges: [] };\n    }\n    \n    // 准备边数据\n    let edges = Array.from(context.sourceCue.connections.entries())\n      .map(([targetWord, weight]) => ({\n        targetWord,\n        weight,\n        frequency: context.getTargetFrequency(targetWord)\n      }));\n    \n    // 如果有权重策略，使用它进行归一化（包含温度控制和批次感知）\n    if (this.weightStrategy && typeof this.weightStrategy.normalizeForActivation === 'function') {\n      edges = this.weightStrategy.normalizeForActivation(edges);\n      logger.debug('[HippocampalActivationStrategy] Applied weight strategy normalization', {\n        strategy: this.weightStrategy.constructor.name,\n        edgeCount: edges.length\n      });\n    }\n    \n    // 基于归一化后的概率计算能量传递\n    const processedEdges = edges.map(edge => {\n      // 使用归一化后的概率（如果有）或原始权重\n      const activationProbability = edge.probability || (edge.weight / edges.reduce((sum, e) => sum + e.weight, 0));\n      \n      // 频率加成（经常被激活的节点更容易再次激活）\n      const freqBonus = 1 + Math.log(1 + edge.frequency) * this.frequencyBoost;\n      \n      // 基于概率的能量传递\n      const transmittedEnergy = context.currentEnergy * \n                               activationProbability * \n                               this.synapticDecay * \n                               freqBonus;\n      \n      // 应用侧抑制（激活节点越多，抑制越强）\n      const inhibition = 1 - (this.inhibitionFactor * context.activatedNodes.size / 100);\n      const finalEnergy = transmittedEnergy * inhibition;\n      \n      return {\n        targetWord: edge.targetWord,\n        weight: edge.weight,\n        energy: finalEnergy,\n        frequency: edge.frequency,\n        probability: activationProbability,\n        batchMultiplier: edge.batchMultiplier || 1,\n        shouldFire: finalEnergy >= this.firingThreshold\n      };\n    });\n    \n    // 只返回能量足够且未激活的边\n    const activeEdges = processedEdges.filter(e => \n      e.shouldFire && !context.isActivated(e.targetWord)\n    );\n    \n    logger.debug('[HippocampalActivationStrategy] Activation decision', {\n      source: context.sourceCue.word,\n      sourceEnergy: context.currentEnergy,\n      totalEdges: edges.length,\n      activeEdges: activeEdges.length,\n      cycle: context.cycle,\n      hasWeightStrategy: !!this.weightStrategy\n    });\n    \n    return { shouldActivate: true, edges: activeEdges };\n  }\n  \n  /**\n   * 判断是否继续激活\n   * \n   * @param {ActivationContext} context - 激活上下文\n   * @returns {boolean} true继续，false停止\n   */\n  shouldContinue(context) {\n    // 超过最大循环次数\n    if (context.cycle >= this.maxCycles) {\n      logger.debug('[HippocampalActivationStrategy] Max cycles reached', {\n        cycle: context.cycle,\n        maxCycles: this.maxCycles\n      });\n      return false;\n    }\n    \n    // 检查是否还有高能量节点\n    let hasHighEnergyNode = false;\n    for (const [word, energy] of context.energyPool) {\n      if (energy >= this.firingThreshold) {\n        hasHighEnergyNode = true;\n        break;\n      }\n    }\n    \n    if (!hasHighEnergyNode) {\n      logger.debug('[HippocampalActivationStrategy] No high energy nodes', {\n        cycle: context.cycle,\n        poolSize: context.energyPool.size\n      });\n    }\n    \n    return hasHighEnergyNode;\n  }\n  \n  /**\n   * 应用能量衰减\n   * \n   * @param {ActivationContext} context - 激活上下文\n   */\n  applyDecay(context) {\n    // 对所有节点应用时间衰减\n    for (const [word, energy] of context.energyPool) {\n      const decayedEnergy = energy * this.cycleDecay;\n      \n      // 能量太低的节点移除\n      if (decayedEnergy < 0.01) {\n        context.energyPool.delete(word);\n      } else {\n        context.energyPool.set(word, decayedEnergy);\n      }\n    }\n    \n    logger.debug('[HippocampalActivationStrategy] Applied decay', {\n      cycle: context.cycle,\n      remainingNodes: context.energyPool.size,\n      totalEnergy: Array.from(context.energyPool.values()).reduce((sum, e) => sum + e, 0).toFixed(2)\n    });\n  }\n}\n\nmodule.exports = {\n  ActivationStrategy,\n  HippocampalActivationStrategy\n};","/**\n * ActivationContext - 激活扩散上下文\n * \n * ## 设计理念\n * \n * ActivationContext封装了激活扩散过程中的所有状态和数据。\n * 与WeightContext不同，这是一个有状态的对象，会在激活过程中不断更新。\n * \n * ## 为什么这样设计\n * \n * 1. **状态管理**\n *    - 集中管理激活过程的所有状态\n *    - 避免在Recall中维护大量状态变量\n *    - 便于不同策略共享和访问状态\n * \n * 2. **策略解耦**\n *    - 策略只需要关注算法逻辑\n *    - 状态管理由Context负责\n *    - 便于实现不同的激活算法\n * \n * 3. **可扩展性**\n *    - 新策略可能需要新的状态\n *    - 通过Context统一管理\n *    - 不影响现有代码\n * \n * ## 海马体算法需要的状态\n * \n * - **能量池（energyPool）**：每个节点的当前能量水平\n * - **激活集（activatedNodes）**：已激活的节点集合\n * - **循环计数（cycle）**：当前的激活循环次数\n * - **连接记录（connections）**：已建立的连接关系\n * \n * @class ActivationContext\n */\nclass ActivationContext {\n  /**\n   * 创建激活上下文\n   * \n   * @param {Object} params - 初始参数\n   * @param {Network} params.network - 认知网络\n   * @param {Cue} params.sourceCue - 当前源节点\n   * @param {number} params.depth - 当前深度（兼容旧代码）\n   * @param {number} params.currentEnergy - 当前节点能量\n   * @param {Set} params.activatedNodes - 已激活节点集\n   * @param {Map} params.energyPool - 节点能量池\n   * @param {number} params.cycle - 循环次数\n   * @param {Array} params.connections - 连接记录\n   */\n  constructor(params = {}) {\n    /**\n     * 认知网络引用\n     * @type {Network}\n     */\n    this.network = params.network;\n    \n    /**\n     * 当前源节点\n     * @type {Cue}\n     */\n    this.sourceCue = params.sourceCue || null;\n    \n    /**\n     * 当前深度（为了兼容性保留）\n     * @type {number}\n     */\n    this.depth = params.depth || 0;\n    \n    /**\n     * 当前节点的能量水平\n     * 海马体算法的核心概念\n     * @type {number}\n     */\n    this.currentEnergy = params.currentEnergy || 1.0;\n    \n    /**\n     * 已激活的节点集合\n     * 用于避免重复激活和计算网络规模\n     * @type {Set<string>}\n     */\n    this.activatedNodes = params.activatedNodes || new Set();\n    \n    /**\n     * 能量池 - 记录每个节点的当前能量\n     * 海马体算法的核心数据结构\n     * @type {Map<string, number>}\n     */\n    this.energyPool = params.energyPool || new Map();\n    \n    /**\n     * 当前循环次数\n     * 海马体算法用于限制激活轮数\n     * @type {number}\n     */\n    this.cycle = params.cycle || 0;\n    \n    /**\n     * 连接记录\n     * 记录激活过程中建立的所有连接\n     * @type {Array<{from: string, to: string, weight: number}>}\n     */\n    this.connections = params.connections || [];\n    \n    /**\n     * 时间戳（用于日志和调试）\n     * @type {number}\n     */\n    this.timestamp = params.timestamp || Date.now();\n  }\n  \n  /**\n   * 获取目标节点的频率\n   * \n   * @param {string} targetWord - 目标词\n   * @returns {number} 频率值\n   */\n  getTargetFrequency(targetWord) {\n    const targetCue = this.network.getCue(targetWord);\n    return targetCue?.recallFrequency || 0;\n  }\n  \n  /**\n   * 检查节点是否已激活\n   * \n   * @param {string} word - 节点词\n   * @returns {boolean} 是否已激活\n   */\n  isActivated(word) {\n    return this.activatedNodes.has(word);\n  }\n  \n  /**\n   * 获取节点的当前能量\n   * \n   * @param {string} word - 节点词\n   * @returns {number} 能量值\n   */\n  getNodeEnergy(word) {\n    return this.energyPool.get(word) || 0;\n  }\n  \n  /**\n   * 设置节点能量\n   * \n   * @param {string} word - 节点词\n   * @param {number} energy - 能量值\n   */\n  setNodeEnergy(word, energy) {\n    if (energy > 0) {\n      this.energyPool.set(word, energy);\n    } else {\n      this.energyPool.delete(word);  // 能量耗尽，移除\n    }\n  }\n  \n  /**\n   * 累加节点能量\n   * \n   * @param {string} word - 节点词\n   * @param {number} energyToAdd - 要添加的能量\n   * @returns {number} 新的能量值\n   */\n  addNodeEnergy(word, energyToAdd) {\n    const current = this.getNodeEnergy(word);\n    const newEnergy = current + energyToAdd;\n    this.setNodeEnergy(word, newEnergy);\n    return newEnergy;\n  }\n  \n  /**\n   * 标记节点为已激活\n   * \n   * @param {string} word - 节点词\n   */\n  markActivated(word) {\n    this.activatedNodes.add(word);\n  }\n  \n  /**\n   * 记录连接\n   * \n   * @param {string} from - 源节点\n   * @param {string} to - 目标节点\n   * @param {number} weight - 连接权重\n   */\n  recordConnection(from, to, weight) {\n    this.connections.push({ from, to, weight });\n  }\n  \n  /**\n   * 增加循环计数\n   */\n  incrementCycle() {\n    this.cycle++;\n  }\n  \n  /**\n   * 获取统计信息\n   * \n   * @returns {Object} 统计信息\n   */\n  getStatistics() {\n    return {\n      activatedNodes: this.activatedNodes.size,\n      totalEnergy: Array.from(this.energyPool.values()).reduce((sum, e) => sum + e, 0),\n      highEnergyNodes: Array.from(this.energyPool.entries())\n        .filter(([_, energy]) => energy > 0.5)\n        .length,\n      connections: this.connections.length,\n      cycle: this.cycle\n    };\n  }\n  \n  /**\n   * 转换为调试字符串\n   * \n   * @returns {string} 调试信息\n   */\n  toString() {\n    const stats = this.getStatistics();\n    return `ActivationContext{cycle:${this.cycle}, activated:${stats.activatedNodes}, energy:${stats.totalEnergy.toFixed(2)}}`;\n  }\n}\n\nmodule.exports = ActivationContext;","const logger = require('@promptx/logger');\n\n/**\n * Recall - 记忆检索执行器\n * \n * ## 设计理念\n * \n * Recall是记忆系统的读取端，负责从Network中检索相关记忆。\n * 现在使用可插拔的激活策略，支持不同的激活扩散算法。\n * \n * ## 为什么这样设计\n * \n * 1. **策略模式**\n *    - 激活算法通过ActivationStrategy实现\n *    - 可以灵活切换不同的算法\n *    - Recall只负责流程控制\n * \n * 2. **关注点分离**\n *    - Recall：流程控制和Mind构建\n *    - ActivationStrategy：激活决策\n *    - ActivationContext：状态管理\n * \n * 3. **可扩展性**\n *    - 轻松添加新的激活算法\n *    - 不影响现有代码\n *    - 便于A/B测试不同算法\n * \n * @class Recall\n */\nclass Recall {\n  /**\n   * @param {Network} network - 全局认知网络\n   * @param {Object} options - 可选配置\n   * @param {ActivationStrategy} options.activationStrategy - 激活策略\n   * @param {WeightStrategy} options.weightStrategy - 权重策略（用于归一化）\n   */\n  constructor(network, options = {}) {\n    /**\n     * 认知网络引用\n     * @type {Network}\n     */\n    this.network = network;\n    \n    /**\n     * 权重策略（用于Softmax归一化等）\n     * @type {WeightStrategy|null}\n     */\n    this.weightStrategy = options.weightStrategy || null;\n    \n    /**\n     * 激活策略\n     * 默认使用海马体策略\n     * @type {ActivationStrategy}\n     */\n    if (options.activationStrategy) {\n      this.activationStrategy = options.activationStrategy;\n      // 如果激活策略需要权重策略，注入它\n      if (this.weightStrategy && typeof this.activationStrategy.setWeightStrategy === 'function') {\n        this.activationStrategy.setWeightStrategy(this.weightStrategy);\n      }\n    } else {\n      // 默认使用海马体策略\n      const { HippocampalActivationStrategy } = require('./ActivationStrategy');\n      this.activationStrategy = new HippocampalActivationStrategy({\n        weightStrategy: this.weightStrategy\n      });\n    }\n    \n    logger.debug('[Recall] Initialized', {\n      strategy: this.activationStrategy.name,\n      hasWeightStrategy: !!this.weightStrategy\n    });\n  }\n\n  /**\n   * 执行记忆检索\n   * \n   * @param {string} word - 起始词\n   * @returns {Mind|null} 激活的认知网络\n   */\n  execute(word) {\n    logger.debug('[Recall] Starting recall', { word });\n    \n    // 找到起始Cue\n    const centerCue = this.network.cues.get(word);\n    if (!centerCue) {\n      logger.warn('[Recall] Cue not found', { word });\n      return null;\n    }\n    \n    logger.debug('[Recall] Found center Cue', {\n      word: centerCue.word,\n      outDegree: centerCue.connections.size,\n      frequency: centerCue.recallFrequency || 0\n    });\n    \n    const Mind = require('./Mind');\n    const mind = new Mind(centerCue);\n    \n    // 创建激活上下文\n    const ActivationContext = require('./ActivationContext');\n    const context = new ActivationContext({\n      network: this.network,\n      sourceCue: centerCue,\n      energyPool: new Map([[centerCue.word, 1.0]]),  // 初始能量\n      activatedNodes: new Set([centerCue.word]),\n      connections: []\n    });\n    \n    const startTime = Date.now();\n    \n    // 激活循环\n    while (this.activationStrategy.shouldContinue(context)) {\n      const newActivations = new Map();\n      \n      // 处理当前能量池中的所有节点\n      for (const [word, energy] of context.energyPool) {\n        const sourceCue = this.network.getCue(word);\n        if (!sourceCue) continue;\n        \n        // 更新上下文\n        context.sourceCue = sourceCue;\n        context.currentEnergy = energy;\n        \n        // 获取激活决策\n        const { shouldActivate, edges } = this.activationStrategy.activate(context);\n        \n        if (shouldActivate && edges.length > 0) {\n          logger.debug('[Recall] Activating from node', {\n            source: word,\n            energy: energy.toFixed(3),\n            edgeCount: edges.length,\n            cycle: context.cycle\n          });\n          \n          // 处理每条激活的边\n          for (const edge of edges) {\n            // 累积能量（可能从多个源获得）\n            const currentEnergy = newActivations.get(edge.targetWord) || 0;\n            const totalEnergy = currentEnergy + edge.energy;\n            newActivations.set(edge.targetWord, totalEnergy);\n            \n            // 记录连接\n            mind.addConnection(word, edge.targetWord, edge.weight);\n            context.recordConnection(word, edge.targetWord, edge.weight);\n            \n            logger.debug('[Recall] Edge activated', {\n              from: word,\n              to: edge.targetWord,\n              transmittedEnergy: edge.energy.toFixed(3),\n              totalEnergy: totalEnergy.toFixed(3)\n            });\n          }\n        }\n      }\n      \n      // 清空旧能量池，使用新的\n      context.energyPool.clear();\n      \n      // 更新能量池和激活集\n      for (const [word, energy] of newActivations) {\n        context.setNodeEnergy(word, energy);\n        \n        // 能量足够高的节点标记为激活\n        if (energy >= (this.activationStrategy.firingThreshold || 0.01)) {\n          if (!context.isActivated(word)) {\n            context.markActivated(word);\n            mind.addActivatedCue(word, context.cycle + 1);  // 记录激活深度\n          }\n        }\n      }\n      \n      // 应用衰减\n      this.activationStrategy.applyDecay(context);\n      \n      // 增加循环计数\n      context.incrementCycle();\n      \n      // 如果没有新的激活，提前结束\n      if (newActivations.size === 0) {\n        logger.debug('[Recall] No new activations, stopping', {\n          cycle: context.cycle\n        });\n        break;\n      }\n    }\n    \n    const duration = Date.now() - startTime;\n    \n    // 更新节点的recall频率\n    this.network.updateRecallFrequency(context.activatedNodes);\n    \n    logger.info('[Recall] Recall completed', {\n      center: word,\n      strategy: this.activationStrategy.name,\n      cycles: context.cycle,\n      activatedNodes: context.activatedNodes.size,\n      connections: context.connections.length,\n      duration: `${duration}ms`\n    });\n    \n    return mind;\n  }\n}\n\nmodule.exports = Recall;","const logger = require('@promptx/logger');\n\n/**\n * Prime - 认知系统启动器\n * \n * ## 设计理念\n * \n * Prime是系统启动时的特殊操作，负责建立基础认知状态。\n * 类比人类的“晨起意识”：\n * - 睡醒后需要一个“启动”过程来恢复意识\n * - 基础认知状态影响整天的思维活动\n * - 不同的启动点会带来不同的认知偏向\n * \n * ## 为什么这样设计\n * \n * 1. **自动选择启动点**\n *    - 通过入度权重找到“最重要”的概念\n *    - 高入度权重 = 被多个概念强烈关联\n *    - 类似于PageRank算法的思想\n * \n * 2. **继承Recall的逻辑**\n *    - Prime本质上是特殊的Recall\n *    - 复用扩散激活的所有逻辑\n *    - 只是增加了自动选择启动词的能力\n * \n * 3. **多中心启动**\n *    - 支持从多个点同时启动\n *    - 模拟并行思维和多线索思考\n *    - 用于复杂任务的初始化\n * \n * ## 启动词选择算法\n * \n * ```\n * 对于每个节点n:\n *   inWeight(n) = Σ(weight of edges pointing to n)\n * \n * primeWord = argmax(inWeight)\n * ```\n * \n * 这个算法找到“汇聚中心”：\n * - 被多个概念指向\n * - 且连接权重高\n * - 通常是核心概念\n * \n * ## 设计决策\n * \n * Q: 为什么用入度权重而不是出度权重？\n * A: \n * - 入度高 = 被多个概念依赖，是“基础概念”\n * - 出度高 = 发散性强，是“hub节点”\n * - 启动时需要稳定的基础，不是发散的中心\n * \n * Q: 为什么支持多中心启动？\n * A: \n * - 复杂任务需要多个视角\n * - 模拟人类的并行思维\n * - 避免单一视角的偏见\n * \n * @class Prime\n * @extends Recall\n */\nconst Recall = require('./Recall');\n\nclass Prime extends Recall {\n  /**\n   * 获取默认的启动词\n   * \n   * 策略优先级：\n   * 1. 选择根节点（入度为0的节点）- 认知网络的起点\n   * 2. 选择被指向最多的节点 - 重要概念\n   * 3. 返回第一个节点 - 兜底策略\n   * \n   * @returns {string|null} 启动词\n   */\n  getPrimeWord() {\n    if (this.network.cues.size === 0) {\n      logger.warn('[Prime] Network is empty, no word to prime');\n      return null;\n    }\n    \n    logger.debug('[Prime] Calculating prime word from network', {\n      totalCues: this.network.cues.size\n    });\n    \n    // 策略1: 寻找根节点（入度为0的节点）\n    const rootNodes = this.findRootNodes();\n    if (rootNodes.length > 0) {\n      // 如果有多个根节点，选择出度最大的那个\n      const selectedRoot = rootNodes.reduce((best, current) => {\n        const currentOutDegree = this.network.cues.get(current)?.connections?.size || 0;\n        const bestOutDegree = this.network.cues.get(best)?.connections?.size || 0;\n        return currentOutDegree > bestOutDegree ? current : best;\n      });\n      \n      logger.info('[Prime] Selected root node as prime word', {\n        word: selectedRoot,\n        allRoots: rootNodes,\n        outDegree: this.network.cues.get(selectedRoot)?.connections?.size || 0\n      });\n      return selectedRoot;\n    }\n    \n    // 策略2: 选择被指向最多的节点（原逻辑）\n    const inWeights = this.network.calculateInWeights();\n    if (inWeights.size > 0) {\n      let maxWeight = 0;\n      let primeWord = null;\n      \n      for (const [word, weight] of inWeights) {\n        if (weight > maxWeight) {\n          maxWeight = weight;\n          primeWord = word;\n        }\n      }\n      \n      if (primeWord) {\n        logger.info('[Prime] Selected high in-degree node as prime word', {\n          word: primeWord,\n          inWeight: maxWeight\n        });\n        return primeWord;\n      }\n    }\n    \n    // 策略3: 返回第一个节点\n    const firstWord = this.network.cues.keys().next().value;\n    logger.debug('[Prime] Using first cue as fallback', { \n      word: firstWord \n    });\n    return firstWord;\n  }\n  \n  /**\n   * 寻找根节点（入度为0的节点）\n   * @returns {Array<string>} 根节点列表\n   */\n  findRootNodes() {\n    const hasIncomingEdge = new Set();\n    \n    // 标记所有有入边的节点\n    for (const [sourceWord, sourceCue] of this.network.cues) {\n      for (const [targetWord] of sourceCue.connections) {\n        hasIncomingEdge.add(targetWord);\n      }\n    }\n    \n    // 找出没有入边的节点（根节点）\n    const rootNodes = [];\n    for (const word of this.network.cues.keys()) {\n      if (!hasIncomingEdge.has(word)) {\n        rootNodes.push(word);\n      }\n    }\n    \n    logger.debug('[Prime] Found root nodes', {\n      count: rootNodes.length,\n      nodes: rootNodes\n    });\n    \n    return rootNodes;\n  }\n  \n  /**\n   * 执行启动\n   * \n   * @param {string} word - 可选的启动词，如果不提供则自动选择\n   * @returns {Mind|null} 基础认知状态\n   */\n  execute(word = null) {\n    logger.info('[Prime] Starting prime operation', { \n      providedWord: word,\n      autoSelect: !word,\n      networkSize: this.network.cues.size\n    });\n    \n    // 如果没有提供启动词，自动选择\n    if (!word) {\n      word = this.getPrimeWord();\n      if (!word) {\n        logger.error('[Prime] Failed to find prime word, network empty or no suitable node');\n        return null;\n      }\n      logger.info('[Prime] Auto-selected prime word', { word });\n    } else {\n      // 验证提供的词是否存在\n      if (!this.network.hasCue(word)) {\n        logger.warn('[Prime] Provided word not found in network', { word });\n        return null;\n      }\n    }\n    \n    logger.info('[Prime] Executing recall with prime word', { \n      word,\n      cueExists: this.network.hasCue(word),\n      cueConnections: this.network.cues.get(word)?.connections?.size || 0\n    });\n    \n    // 调用父类的recall逻辑\n    const mind = super.execute(word);\n    \n    if (mind) {\n      logger.info('[Prime] Prime completed successfully', {\n        primeWord: word,\n        activatedNodes: mind.activatedCues.size,\n        connections: mind.connections.length\n      });\n    } else {\n      logger.error('[Prime] Prime failed', { word });\n    }\n    \n    return mind;\n  }\n  \n  /**\n   * 多词启动（实验性功能）\n   * \n   * 同时从多个词开始激活，模拟并行思考。\n   * 生成的Mind包含多个激活中心。\n   * \n   * @param {Array<string>} words - 启动词数组\n   * @returns {Mind} 合并的认知状态\n   */\n  executeMultiple(words) {\n    logger.info('[Prime] Starting multi-center prime', {\n      words,\n      count: words.length\n    });\n    \n    const Mind = require('./Mind');\n    \n    // 创建一个合并的Mind\n    const mergedMind = new Mind(null);  // 没有单一中心\n    mergedMind.centers = [];  // 多个中心\n    \n    const validCenters = [];\n    const missingWords = [];\n    \n    // 对每个词分别执行recall\n    for (const word of words) {\n      const cue = this.network.cues.get(word);\n      if (!cue) {\n        missingWords.push(word);\n        logger.warn('[Prime] Word not found in network', { word });\n        continue;\n      }\n      \n      validCenters.push(word);\n      mergedMind.centers.push(cue);\n      \n      logger.debug('[Prime] Spreading from center', {\n        word,\n        outDegree: cue.connections.size\n      });\n      \n      // 扩散激活（重用spread方法）\n      this.spread(cue, mergedMind, [], 0);\n    }\n    \n    logger.info('[Prime] Multi-center prime completed', {\n      requestedWords: words.length,\n      validCenters: validCenters.length,\n      missingWords,\n      activatedNodes: mergedMind.activatedCues.size,\n      connections: mergedMind.connections.length\n    });\n    \n    return mergedMind;\n  }\n}\n\nmodule.exports = Prime;","const { Level } = require('level');\nconst logger = require('@promptx/logger');\n\n/**\n * Memory - 记忆内容存储\n * \n * ## 设计理念\n * \n * Memory是纯粹的KV存储，负责持久化Engram对象的完整内容。\n * 它不知道角色(role)概念，只提供简单的存储和检索功能。\n * \n * ## 存储格式\n * \n * - Key: `${timestamp}_${randomId}` (确保唯一性)\n * - Value: Engram.toJSON() 的完整对象\n * \n * ## 设计决策\n * \n * Q: 为什么用LevelDB而不是文件?\n * A: LevelDB提供事务、压缩、并发访问，更适合频繁读写\n * \n * Q: 为什么不在Memory中管理role?\n * A: 职责分离，Memory只管存储，role由上层管理\n * \n * @class Memory\n */\nclass Memory {\n  /**\n   * 创建Memory实例\n   * \n   * @param {string} dbPath - LevelDB数据库路径\n   */\n  constructor(dbPath) {\n    /**\n     * LevelDB数据库实例\n     * @type {Level}\n     */\n    this.db = new Level(dbPath, { \n      valueEncoding: 'json'  // 自动JSON序列化/反序列化\n    });\n    \n    logger.debug('[Memory] Initialized', { dbPath });\n  }\n  \n  /**\n   * 存储Engram对象\n   * \n   * @param {Engram} engram - 要存储的Engram对象\n   * @returns {Promise<string>} Engram的id（作为存储key）\n   */\n  async store(engram) {\n    // 使用engram的id作为key\n    const key = engram.id;\n    \n    try {\n      await this.db.put(key, engram.toJSON());\n      \n      logger.debug('[Memory] Stored engram', { \n        key,\n        preview: engram.getPreview(),\n        strength: engram.strength\n      });\n      \n      return key;\n    } catch (error) {\n      logger.error('[Memory] Failed to store engram', { \n        key, \n        error: error.message \n      });\n      throw error;\n    }\n  }\n  \n  /**\n   * 获取Engram对象\n   * \n   * @param {string} key - 存储key\n   * @returns {Promise<Object|null>} Engram数据对象，不存在时返回null\n   */\n  async get(key) {\n    try {\n      const data = await this.db.get(key);\n      \n      logger.debug('[Memory] Retrieved engram', { \n        key,\n        hasContent: !!data.content\n      });\n      \n      return data;\n    } catch (error) {\n      if (error.notFound) {\n        logger.debug('[Memory] Engram not found', { key });\n        return null;\n      }\n      \n      logger.error('[Memory] Failed to retrieve engram', { \n        key, \n        error: error.message \n      });\n      throw error;\n    }\n  }\n  \n  /**\n   * 关闭数据库连接\n   * \n   * @returns {Promise<void>}\n   */\n  async close() {\n    try {\n      await this.db.close();\n      logger.debug('[Memory] Database closed');\n    } catch (error) {\n      logger.error('[Memory] Failed to close database', { \n        error: error.message \n      });\n      throw error;\n    }\n  }\n  \n  /**\n   * 获取存储统计信息\n   * \n   * @returns {Promise<Object>} 统计信息\n   */\n  async getStatistics() {\n    try {\n      let count = 0;\n      for await (const [key] of this.db.iterator()) {\n        count++;\n      }\n      \n      return {\n        totalEngrams: count,\n        dbPath: this.db.location\n      };\n    } catch (error) {\n      logger.error('[Memory] Failed to get statistics', { \n        error: error.message \n      });\n      return {\n        totalEngrams: 0,\n        dbPath: this.db.location,\n        error: error.message\n      };\n    }\n  }\n}\n\nmodule.exports = Memory;","/**\n * WeightStrategy - 权重计算策略接口\n * \n * ## 设计理念\n * \n * 采用策略模式（Strategy Pattern）来封装权重计算算法，让算法可以独立变化。\n * 这样设计的好处是：\n * - 算法与使用者（Remember）解耦\n * - 便于测试不同的权重算法\n * - 支持运行时切换策略\n * \n * ## 为什么这样设计\n * \n * 1. **可扩展性**\n *    - 未来可能需要不同的权重算法（如基于频率、基于重要性等）\n *    - 不同场景可能需要不同的策略（学习模式 vs 复习模式）\n *    - 避免在Remember类中写死算法\n * \n * 2. **测试友好**\n *    - 可以独立测试每个策略\n *    - 可以使用mock策略进行单元测试\n *    - 便于对比不同策略的效果\n * \n * 3. **关注点分离**\n *    - Remember只负责构建网络结构\n *    - Strategy只负责计算权重\n *    - WeightContext负责传递数据\n * \n * ## 策略接口约定\n * \n * 所有策略必须实现calculate方法：\n * - 输入：WeightContext对象（包含所有计算所需信息）\n * - 输出：number类型的权重值\n * - 约束：权重应该是正数，且有合理的数值范围\n * \n * @class WeightStrategy\n */\nclass WeightStrategy {\n  /**\n   * 计算权重\n   * \n   * 子类必须实现此方法。\n   * \n   * @param {WeightContext} context - 计算上下文\n   * @param {Cue} context.sourceCue - 源节点\n   * @param {string} context.targetWord - 目标词\n   * @param {number} context.position - 在Schema中的位置\n   * @param {number} context.timestamp - 时间戳\n   * @param {number} context.sourceOutDegree - 源节点出度\n   * @returns {number} 计算得出的权重（应为正数）\n   */\n  calculate(context) {\n    throw new Error('WeightStrategy.calculate() must be implemented');\n  }\n  \n  /**\n   * 激活时归一化（用于Recall）\n   * \n   * 将一组边的权重转换为激活概率\n   * 默认实现：简单归一化\n   * \n   * @param {Array} edges - 边数组 [{targetWord, weight}, ...]\n   * @returns {Array} 归一化后的边数组，添加了probability字段\n   */\n  normalizeForActivation(edges) {\n    if (edges.length === 0) return edges;\n    \n    // 默认：简单归一化\n    const totalWeight = edges.reduce((sum, e) => sum + e.weight, 0);\n    return edges.map(edge => ({\n      ...edge,\n      probability: edge.weight / totalWeight\n    }));\n  }\n}\n\n/**\n * SimpleWeightStrategy - 简单权重策略\n * \n * ## 设计理念\n * \n * 最简单的权重策略，只考虑位置因素。\n * 适用于测试或者不需要复杂权重计算的场景。\n * \n * ## 算法说明\n * \n * weight = baseWeight * decay^position\n * \n * - baseWeight: 基础权重（默认1.0）\n * - decay: 衰减率（默认0.9）\n * - position: 在Schema中的位置（0-based）\n * \n * 例子：\n * - position=0: weight = 1.0 * 0.9^0 = 1.0\n * - position=1: weight = 1.0 * 0.9^1 = 0.9\n * - position=2: weight = 1.0 * 0.9^2 = 0.81\n * \n * @class SimpleWeightStrategy\n * @extends WeightStrategy\n */\nclass SimpleWeightStrategy extends WeightStrategy {\n  constructor(options = {}) {\n    super();\n    \n    /**\n     * 基础权重\n     * @type {number}\n     */\n    this.baseWeight = options.baseWeight || 1.0;\n    \n    /**\n     * 位置衰减率\n     * @type {number}\n     */\n    this.decay = options.decay || 0.9;\n  }\n  \n  /**\n   * 计算权重\n   * \n   * @param {WeightContext} context - 计算上下文\n   * @returns {number} 权重值\n   */\n  calculate(context) {\n    // 简单的位置衰减\n    const weight = this.baseWeight * Math.pow(this.decay, context.position);\n    return weight;\n  }\n}\n\n/**\n * TimeBasedWeightStrategy - 基于时间戳的权重策略（核心策略）\n * \n * ## 设计理念\n * \n * 这是我们的核心权重策略，基于认知心理学和神经网络原理设计。\n * \n * ### 存储阶段（Remember）\n * 权重编码了两个维度的信息：\n * 1. **时间维度**：新的记忆自然比旧的权重大\n * 2. **序列维度**：序列中越靠后的连接权重越低\n * \n * ### 激活阶段（Recall）\n * 使用Softmax归一化模拟神经网络激活：\n * - 将权重转换为概率分布\n * - 高权重连接有更高的激活概率\n * - 自然实现了选择性激活\n * \n * ## 算法公式\n * \n * ### 存储权重\n * ```\n * weight = timestamp × decay^position\n * ```\n * \n * ### 激活概率（Softmax）\n * ```\n * probability_i = exp(log(weight_i)) / Σexp(log(weight))\n * ```\n * \n * 参数说明：\n * - **timestamp**: 时间戳基数（毫秒），保证新记忆 > 旧记忆\n * - **decay**: 位置衰减率（默认0.9），体现序列中的重要性递减\n * - **position**: 在Schema中的位置（0-based）\n * \n * ## 设计决策\n * \n * Q: 为什么不在存储时考虑出度？\n * A: \n * - 存储时保持完整权重，激活时通过Softmax自然调节\n * - Softmax自动实现了\"能量守恒\"：概率总和为1\n * - 更像真实神经网络的激活模式\n * \n * Q: 为什么用Softmax而不是简单归一化？\n * A:\n * - Softmax放大差异，强者更强\n * - 符合神经网络的winner-take-all机制\n * - 自然形成选择性激活\n * \n * ## 计算示例\n * \n * 假设：\n * - timestamp = 1700000000000\n * - position = 2\n * - decay = 0.9\n * \n * 存储权重：\n * - weight = 1700000000000 * 0.9^2 = 1377000000000\n * \n * 激活时（假设有3条边）：\n * - 边1: 1700000000000 → 概率 35%\n * - 边2: 1530000000000 → 概率 33%\n * - 边3: 1377000000000 → 概率 32%\n * \n * @class TimeBasedWeightStrategy\n * @extends WeightStrategy\n */\nclass TimeBasedWeightStrategy extends WeightStrategy {\n  constructor(options = {}) {\n    super();\n    \n    /**\n     * 位置衰减率\n     * 控制序列中权重的递减速度\n     * @type {number}\n     */\n    this.decay = options.decay || 0.9;\n    \n    /**\n     * 激活阈值\n     * 低于此概率的边不激活\n     * @type {number}\n     */\n    this.activationThreshold = options.activationThreshold || 0.05;  // 5%\n    \n    /**\n     * 频率因子\n     * 控制频率对激活概率的影响程度\n     * @type {number}\n     */\n    this.frequencyFactor = options.frequencyFactor || 0.1;\n    \n    /**\n     * Network引用（用于获取频率）\n     * 由CognitionSystem注入\n     * @type {Network|null}\n     */\n    this.network = null;\n  }\n  \n  /**\n   * 计算存储权重\n   * \n   * @param {WeightContext} context - 计算上下文\n   * @returns {number} 权重值\n   */\n  calculate(context) {\n    // 时间戳作为基数\n    const timestamp = context.timestamp;\n    \n    // 位置衰减因子\n    const positionFactor = Math.pow(this.decay, context.position);\n    \n    // 角色强度因子（从engram获取）\n    const strengthFactor = context.strength || 0.8;\n    \n    // 最终权重：时间 * 位置衰减 * 角色强度\n    const weight = timestamp * positionFactor * strengthFactor;\n    \n    return weight;\n  }\n  \n  /**\n   * Softmax归一化（用于激活）\n   * \n   * 加入频率偏置，实现\"越用越强\"的效果\n   * \n   * @param {Array} edges - 边数组\n   * @returns {Array} 归一化后的边数组\n   */\n  normalizeForActivation(edges) {\n    if (edges.length === 0) return edges;\n    \n    // 计算带频率偏置的对数权重\n    const enhancedEdges = edges.map(edge => {\n      // 获取目标节点的频率\n      let frequency = 0;\n      if (this.network) {\n        const targetCue = this.network.cues.get(edge.targetWord);\n        frequency = targetCue ? (targetCue.recallFrequency || 0) : 0;\n      }\n      \n      // 在对数空间添加频率偏置\n      const logWeight = Math.log(edge.weight);\n      const frequencyBias = Math.log(1 + frequency * this.frequencyFactor);\n      \n      return {\n        ...edge,\n        adjustedLogWeight: logWeight + frequencyBias,\n        frequency\n      };\n    });\n    \n    // 找出最大值（避免数值溢出）\n    const maxLogWeight = Math.max(...enhancedEdges.map(e => e.adjustedLogWeight));\n    \n    // 计算exp(adjustedLogWeight - max)\n    const expWeights = enhancedEdges.map(e => \n      Math.exp(e.adjustedLogWeight - maxLogWeight)\n    );\n    const sumExp = expWeights.reduce((a, b) => a + b, 0);\n    \n    // 计算概率并排序\n    const normalizedEdges = edges.map((edge, i) => ({\n      ...edge,\n      probability: expWeights[i] / sumExp,\n      frequency: enhancedEdges[i].frequency\n    })).sort((a, b) => b.probability - a.probability);\n    \n    // 过滤掉概率太低的边\n    return normalizedEdges.filter(edge => edge.probability >= this.activationThreshold);\n  }\n}\n\n/**\n * TemperatureWeightStrategy - 温度控制的权重策略\n * \n * ## 设计理念\n * \n * 基于深度学习中的temperature-controlled softmax，解决hub节点语义污染问题。\n * 通过温度参数控制概率分布的\"锐度\"，实现批次隔离和创造性平衡。\n * \n * ### 核心创新\n * 1. **批次感知**：利用timestamp作为天然的批次指纹\n * 2. **温度控制**：动态调节激活的集中度\n * 3. **对比度调节**：保留归一化的同时维持批次差异\n * \n * ## 温度参数效果\n * \n * - **低温（0.1-0.5）**：锐化差异，强化同批次连接\n * - **常温（0.8-1.2）**：平衡模式，适度扩散\n * - **高温（1.5-2.0）**：平滑差异，鼓励跨批次探索\n * \n * ## 算法公式\n * \n * ### 带温度的Softmax\n * ```\n * probability_i = exp((weight_i + batch_bonus_i) / T) / Σexp((weight_j + batch_bonus_j) / T)\n * ```\n * \n * 其中：\n * - T: 温度参数\n * - batch_bonus: 批次奖励（同批次获得额外权重）\n * \n * @class TemperatureWeightStrategy\n * @extends TimeBasedWeightStrategy\n */\nclass TemperatureWeightStrategy extends TimeBasedWeightStrategy {\n  constructor(options = {}) {\n    super(options);\n    \n    /**\n     * 温度参数\n     * 控制概率分布的锐度\n     * @type {number}\n     */\n    this.temperature = options.temperature || 0.5;\n    \n    /**\n     * 对比度模式\n     * 'auto' | 'low' | 'medium' | 'high'\n     * @type {string}\n     */\n    this.contrastMode = options.contrastMode || 'auto';\n  }\n  \n  /**\n   * 设置对比度级别\n   * \n   * @param {'low'|'medium'|'high'} level - 对比度级别\n   */\n  setContrastLevel(level) {\n    const contrastMap = {\n      'low': 2.0,    // 高温，低对比度（~20%差异）\n      'medium': 1.0,  // 常温，中等对比度（~50%差异）\n      'high': 0.3     // 低温，高对比度（~80%差异）\n    };\n    \n    this.temperature = contrastMap[level] || 1.0;\n    this.contrastMode = level;\n  }\n  \n  /**\n   * 设置对比度百分比\n   * \n   * @param {number} percentage - 对比度百分比（0-100）\n   */\n  setContrastPercentage(percentage) {\n    // 0% = 完全平均（高温），100% = 极度锐化（低温）\n    const clampedPercentage = Math.max(0, Math.min(100, percentage));\n    this.temperature = 2.0 - (clampedPercentage / 100) * 1.8;\n    this.contrastMode = 'custom';\n  }\n  \n  \n  /**\n   * 自动调节温度（基于网络状态）\n   * \n   * @param {Array} edges - 边数组\n   * @returns {number} 调节后的温度\n   */\n  autoAdjustTemperature(edges) {\n    if (this.contrastMode !== 'auto') {\n      return this.temperature;\n    }\n    \n    // 计算hub密度（高连接数节点的比例）\n    const avgConnections = edges.length;\n    const hubThreshold = 5;\n    \n    if (avgConnections > hubThreshold * 2) {\n      // 超级hub节点：降低温度，增强选择性\n      return 0.3;\n    } else if (avgConnections > hubThreshold) {\n      // 普通hub节点：中低温度\n      return 0.5;\n    } else {\n      // 普通节点：常温\n      return 1.0;\n    }\n  }\n  \n  /**\n   * 带温度控制的Softmax归一化\n   * \n   * 核心思想：\n   * - 权重本身已包含timestamp信息（weight = timestamp * decay^position）\n   * - 同批次的权重数量级相近，不同批次差异巨大\n   * - 温度控制这种差异的影响程度\n   * \n   * @param {Array} edges - 边数组\n   * @returns {Array} 归一化后的边数组\n   */\n  normalizeForActivation(edges) {\n    if (edges.length === 0) return edges;\n    \n    // 自动调节温度\n    const effectiveTemperature = this.autoAdjustTemperature(edges);\n    \n    // 计算带频率偏置的对数权重\n    const enhancedEdges = edges.map(edge => {\n      // 获取频率（继承自父类）\n      let frequency = 0;\n      if (this.network) {\n        const targetCue = this.network.cues.get(edge.targetWord);\n        frequency = targetCue ? (targetCue.recallFrequency || 0) : 0;\n      }\n      \n      // 在对数空间处理（权重已包含timestamp信息）\n      const logWeight = Math.log(edge.weight);\n      const frequencyBias = Math.log(1 + frequency * this.frequencyFactor);\n      \n      return {\n        ...edge,\n        adjustedLogWeight: logWeight + frequencyBias,\n        frequency\n      };\n    });\n    \n    // 找出最大值（数值稳定性）\n    const maxLogWeight = Math.max(...enhancedEdges.map(e => e.adjustedLogWeight));\n    \n    // 带温度的softmax计算\n    // 低温：放大权重差异（同批次权重相近，会一起被选中）\n    // 高温：平滑权重差异（允许跨批次激活）\n    const expWeights = enhancedEdges.map(e => \n      Math.exp((e.adjustedLogWeight - maxLogWeight) / effectiveTemperature)\n    );\n    const sumExp = expWeights.reduce((a, b) => a + b, 0);\n    \n    // 计算概率并排序\n    const normalizedEdges = enhancedEdges.map((edge, i) => ({\n      ...edges[i],\n      probability: expWeights[i] / sumExp,\n      frequency: edge.frequency,\n      temperature: effectiveTemperature\n    })).sort((a, b) => b.probability - a.probability);\n    \n    // 过滤掉概率太低的边\n    return normalizedEdges.filter(edge => edge.probability >= this.activationThreshold);\n  }\n  \n}\n\nmodule.exports = {\n  WeightStrategy,\n  SimpleWeightStrategy,\n  TimeBasedWeightStrategy,\n  TemperatureWeightStrategy\n};","const logger = require('@promptx/logger');\nconst Network = require('./Network');\nconst Remember = require('./Remember');\nconst Recall = require('./Recall');\nconst Prime = require('./Prime');\nconst Memory = require('./Memory');\nconst { TemperatureWeightStrategy } = require('./WeightStrategy');\n\n/**\n * CognitionSystem - 认知系统主控制器\n * \n * ## 设计理念\n * \n * CognitionSystem是整个认知模块的门面（Facade），统一管理所有认知操作。\n * 它协调Network、Remember、Recall、Prime等组件，提供简单的API。\n * \n * ## 为什么这样设计\n * \n * 1. **统一入口**\n *    - 外部只需要与CognitionSystem交互\n *    - 隐藏内部复杂性\n *    - 便于版本升级和重构\n * \n * 2. **生命周期管理**\n *    - 管理Network的创建和销毁\n *    - 协调各操作的执行顺序\n *    - 处理频率更新等统计任务\n * \n * 3. **策略注入**\n *    - 统一的权重策略配置\n *    - 确保Remember和Recall使用相同策略\n *    - 便于切换不同的策略实现\n * \n * ## 架构位置\n * \n * ```\n * 用户代码\n *    ↓\n * CognitionSystem (协调器)\n *    ├── Network (容器)\n *    ├── Remember (写)\n *    ├── Recall (读)\n *    └── Prime (启动)\n * ```\n * \n * @class CognitionSystem\n */\nclass CognitionSystem {\n  /**\n   * 创建认知系统\n   * \n   * @param {Object} options - 配置选项\n   * @param {string} options.dataPath - 数据文件路径\n   * @param {Object} options.strategyOptions - 策略配置\n   * @param {Object} options.rememberOptions - Remember配置\n   * @param {Object} options.recallOptions - Recall配置\n   */\n  constructor(options = {}) {\n    /**\n     * 数据持久化路径\n     * @type {string}\n     */\n    this.dataPath = options.dataPath || './cognition.json';\n    \n    /**\n     * 全局认知网络\n     * @type {Network}\n     */\n    this.network = new Network();\n    \n    /**\n     * 权重计算策略\n     * @type {WeightStrategy}\n     */\n    this.strategy = new TemperatureWeightStrategy({\n      decay: 0.9,\n      activationThreshold: 0.01,  // 降低过滤阈值\n      frequencyFactor: 0.1,  // 频率因子\n      temperature: 0.8,      // 提高温度，允许适度扩散\n      contrastMode: 'auto',  // 自动调节对比度\n      ...options.strategyOptions\n    });\n    \n    // 让策略能访问network（用于获取频率）\n    this.strategy.network = this.network;\n    \n    /**\n     * Remember引擎配置\n     * @type {Object}\n     */\n    this.rememberOptions = {\n      ...options.rememberOptions,\n      strategy: this.strategy\n    };\n    \n    /**\n     * Recall引擎配置\n     * @type {Object}\n     */\n    this.recallOptions = {\n      ...options.recallOptions,\n      weightStrategy: this.strategy  // 传递权重策略\n    };\n    \n    /**\n     * Remember引擎实例（延迟创建）\n     * @type {Remember|null}\n     */\n    this.rememberEngine = null;\n    \n    /**\n     * Recall引擎实例（延迟创建）\n     * @type {Recall|null}\n     */\n    this.recallEngine = null;\n    \n    /**\n     * Memory存储实例（延迟创建）\n     * @type {Memory|null}\n     */\n    this.memory = null;\n    \n    logger.info('[CognitionSystem] Initialized', {\n      dataPath: this.dataPath,\n      strategyType: this.strategy.constructor.name\n    });\n  }\n  \n  /**\n   * 获取Remember引擎（懒加载）\n   * \n   * @returns {Remember}\n   */\n  getRememberEngine() {\n    if (!this.rememberEngine) {\n      this.rememberEngine = new Remember(this.network, this.rememberOptions);\n    }\n    return this.rememberEngine;\n  }\n  \n  /**\n   * 获取Recall引擎（懒加载）\n   * \n   * @returns {Recall}\n   */\n  getRecallEngine() {\n    if (!this.recallEngine) {\n      this.recallEngine = new Recall(this.network, this.recallOptions);\n    }\n    return this.recallEngine;\n  }\n  \n  /**\n   * 获取Memory存储（懒加载）\n   * \n   * @returns {Memory|null} Memory实例，如果没有directory则返回null\n   */\n  getMemory() {\n    if (!this.memory && this.network.directory) {\n      const path = require('path');\n      const memoryPath = path.join(this.network.directory, 'engrams.db');\n      this.memory = new Memory(memoryPath);\n    }\n    return this.memory;\n  }\n  \n  /**\n   * 记忆操作\n   * \n   * 执行流程：\n   * 1. 存储Engram到Memory（使用engram.id）\n   * 2. 调用Remember引擎处理Schema连接\n   * 3. 建立Cue到Engram.id的反向索引\n   * \n   * @param {Engram} engram - 记忆痕迹对象\n   * @returns {Promise<Object>} 记忆结果\n   */\n  async remember(engram) {\n    logger.debug('[CognitionSystem] Remember operation', {\n      id: engram.id,\n      schemaLength: engram.length,\n      strength: engram.strength,\n      preview: engram.getPreview()\n    });\n    \n    // 存储到Memory（使用engram.id作为key）\n    if (this.getMemory()) {\n      try {\n        await this.getMemory().store(engram);\n        logger.debug('[CognitionSystem] Stored engram to memory', { id: engram.id });\n      } catch (error) {\n        logger.error('[CognitionSystem] Failed to store engram to memory', { \n          id: engram.id,\n          error: error.message \n        });\n        throw error;\n      }\n    }\n    \n    const remember = this.getRememberEngine();\n    const result = remember.execute(engram, engram.id);\n    \n    // 注意：持久化由CognitionManager.saveSystem()负责\n    // 这里不再自动保存，避免路径冲突\n    \n    return result;\n  }\n  \n  /**\n   * 回忆操作\n   * \n   * 执行流程：\n   * 1. 调用Recall引擎激活网络\n   * 2. 加载与原始查询相关的Engrams\n   * 3. 更新被激活节点的频率\n   * 4. 返回激活的Mind（包含engrams）\n   * \n   * @param {string} word - 起始概念\n   * @returns {Promise<Mind|null>} 激活的认知网络\n   */\n  async recall(word) {\n    logger.debug('[CognitionSystem] Recall operation', { word });\n    \n    const recall = this.getRecallEngine();\n    const mind = recall.execute(word);\n    \n    if (!mind) {\n      return null;\n    }\n    \n    // 加载与原始查询直接相关的engrams\n    if (this.getMemory()) {\n      try {\n        await this.loadEngrams(mind, word);\n      } catch (error) {\n        logger.error('[CognitionSystem] Failed to load engrams', { error: error.message });\n        // 不影响recall的核心功能，继续执行\n      }\n    }\n    \n    // 更新频率\n    if (mind.activatedCues.size > 0) {\n      this.network.updateRecallFrequency(mind.activatedCues);\n      logger.debug('[CognitionSystem] Updated frequencies after recall', {\n        activatedCount: mind.activatedCues.size\n      });\n    }\n    \n    return mind;\n  }\n  \n  /**\n   * 加载与查询词直接相关的Engrams\n   * \n   * @param {Mind} mind - Mind对象\n   * @param {string} originalQuery - 原始查询词\n   * @returns {Promise<void>}\n   */\n  async loadEngrams(mind, originalQuery) {\n    mind.engrams = [];\n    \n    // Debug logging for loadEngrams process\n    logger.info('[CognitionSystem] DEBUG - loadEngrams process:', {\n      originalQuery,\n      networkCuesSize: this.network.cues.size,\n      hasMemorySystem: !!this.getMemory(),\n      networkCuesKeys: Array.from(this.network.cues.keys())\n    });\n    \n    // 只加载与原始查询词直接相关的engrams\n    const queryCue = this.network.cues.get(originalQuery);\n    \n    logger.info('[CognitionSystem] DEBUG - queryCue lookup:', {\n      originalQuery,\n      hasQueryCue: !!queryCue,\n      queryCueMemories: queryCue?.memories,\n      memoriesLength: queryCue?.memories?.length\n    });\n    \n    if (queryCue && queryCue.memories) {\n      for (const engramId of queryCue.memories) {\n        const engramData = await this.getMemory().get(engramId);\n        \n        logger.debug('[CognitionSystem] DEBUG - loading engram:', {\n          engramId,\n          hasEngramData: !!engramData,\n          engramContent: engramData?.content?.substring(0, 50)\n        });\n        \n        if (engramData) {\n          mind.engrams.push({\n            id: engramData.id,\n            content: engramData.content,\n            schema: engramData.schema,\n            strength: engramData.strength,\n            timestamp: engramData.timestamp,\n            activatedBy: originalQuery\n          });\n        }\n      }\n    } else {\n      logger.info('[CognitionSystem] DEBUG - No engrams loaded - reason:', {\n        hasQueryCue: !!queryCue,\n        hasMemories: !!queryCue?.memories,\n        query: originalQuery\n      });\n    }\n    \n    logger.debug('[CognitionSystem] Loaded engrams', { \n      query: originalQuery,\n      engramCount: mind.engrams.length \n    });\n  }\n  \n  /**\n   * 启动操作\n   * \n   * 执行流程：\n   * 1. 从磁盘加载Network\n   * 2. 使用Prime选择起始点\n   * 3. 执行预热Recall\n   * \n   * @returns {Mind|null} 预热的认知网络\n   */\n  async prime() {\n    logger.debug('[CognitionSystem] Prime operation');\n    \n    // 注意：数据加载已由CognitionManager.getSystem()完成\n    // 这里直接使用已加载的network，不再重复加载\n    logger.info('[CognitionSystem] Using existing network', {\n      cues: this.network.size()\n    });\n    \n    // 使用Prime执行启动，Prime.execute()已经包含了选择启动词和执行recall的逻辑\n    const prime = new Prime(this.network);\n    const mind = prime.execute();\n    \n    if (!mind) {\n      logger.warn('[CognitionSystem] Prime found no suitable starting point or recall failed');\n      return null;\n    }\n    \n    logger.info('[CognitionSystem] Prime completed', {\n      activatedNodes: mind.activatedCues?.size || 0,\n      connections: mind.connections?.length || 0,\n      centerWord: mind.centerWord\n    });\n    \n    // 加载与prime中心词相关的engrams\n    if (this.getMemory() && mind.centerWord) {\n      try {\n        await this.loadEngrams(mind, mind.centerWord);\n        logger.info('[CognitionSystem] Loaded engrams for prime center word', {\n          centerWord: mind.centerWord,\n          engramCount: mind.engrams?.length || 0\n        });\n      } catch (error) {\n        logger.error('[CognitionSystem] Failed to load engrams for prime', { \n          centerWord: mind.centerWord,\n          error: error.message \n        });\n        // 不影响prime的核心功能，继续执行\n      }\n    }\n    \n    // Prime时不更新频率，因为这是系统自动触发的\n    \n    return mind;\n  }\n  \n  /**\n   * 获取系统统计信息\n   * \n   * @returns {Object} 统计信息\n   */\n  getStatistics() {\n    const networkStats = this.network.getStatistics();\n    const frequencyStats = this.network.getFrequencyStatistics();\n    \n    return {\n      network: networkStats,\n      frequency: frequencyStats,\n      dataPath: this.dataPath,\n      strategy: {\n        type: this.strategy.constructor.name,\n        decay: this.strategy.decay,\n        frequencyFactor: this.strategy.frequencyFactor || 0\n      }\n    };\n  }\n  \n  /**\n   * 清空系统\n   * \n   * 用于测试或重置。\n   */\n  clear() {\n    this.network.clear();\n    this.rememberEngine = null;\n    this.recallEngine = null;\n    logger.info('[CognitionSystem] System cleared');\n  }\n  \n  /**\n   * 手动保存\n   * \n   * 虽然remember会自动保存，但提供手动保存接口。\n   */\n  save() {\n    this.network.persistSync(this.dataPath);\n    logger.info('[CognitionSystem] Manual save completed');\n  }\n  \n  /**\n   * 手动加载\n   * \n   * 虽然prime会自动加载，但提供手动加载接口。\n   */\n  load() {\n    this.network.loadSync(this.dataPath);\n    // 重置引擎，因为network变了\n    this.rememberEngine = null;\n    this.recallEngine = null;\n    logger.info('[CognitionSystem] Manual load completed');\n  }\n}\n\nmodule.exports = CognitionSystem;","/**\n * 认知系统核心结构（极简版）\n * \n * 三个基础结构：\n * - Cue: 认知网络的节点，自管理连接\n * - Network: 所有 Cue 的容器\n * - Mind: 以某个 Cue 为中心的激活子图\n * \n * 设计原则：\n * - 只定义数据结构，不定义算法\n * - Cue 管理自己的连接（去中心化）\n * - 不存储原始内容（让大模型理解）\n */\n\nconst Cue = require('./Cue');\nconst Network = require('./Network');\nconst Mind = require('./Mind');\nconst Remember = require('./Remember');\nconst Recall = require('./Recall');\nconst Prime = require('./Prime');\nconst WeightContext = require('./WeightContext');\nconst ActivationContext = require('./ActivationContext');\nconst CognitionSystem = require('./CognitionSystem');\nconst { WeightStrategy, SimpleWeightStrategy, TimeBasedWeightStrategy } = require('./WeightStrategy');\nconst { ActivationStrategy, HippocampalActivationStrategy } = require('./ActivationStrategy');\n\nmodule.exports = {\n  // 核心数据结构\n  Cue,\n  Network,\n  Mind,\n  WeightContext,\n  ActivationContext,\n  \n  // 操作类\n  Remember,\n  Recall,\n  Prime,\n  \n  // 权重策略\n  WeightStrategy,\n  SimpleWeightStrategy,\n  TimeBasedWeightStrategy,\n  \n  // 激活策略\n  ActivationStrategy,\n  HippocampalActivationStrategy,\n  \n  // 系统\n  CognitionSystem\n};","/**\n * 服务器环境全局管理器\n * 管理MCP服务器的核心运行时属性：transport、host、port、processId\n * 启动时装配，运行时直接获取，避免参数传递错误\n */\nclass ServerEnvironment {\n  constructor() {\n    this.transport = null   // 'stdio' | 'http' | 'sse'\n    this.host = null       // 'localhost' | '0.0.0.0' 等\n    this.port = null       // 端口号（stdio模式为null）\n    this.processId = null  // 进程ID，用于生成mcpId\n    this.initialized = false\n  }\n\n  /**\n   * 初始化服务环境（各启动渠道调用一次）\n   * @param {Object} config - 配置对象\n   * @param {string} config.transport - 传输协议\n   * @param {string} config.host - 主机地址（可选）\n   * @param {number} config.port - 端口号（可选）\n   */\n  initialize(config) {\n    this.transport = config.transport\n    this.host = config.host || null\n    this.port = config.port || null\n    this.processId = process.pid\n    this.initialized = true\n  }\n\n  /**\n   * 获取MCP ID（基于processId生成）\n   * @returns {string} MCP进程ID\n   */\n  getMcpId() {\n    if (!this.initialized) {\n      throw new Error('ServerEnvironment not initialized')\n    }\n    return `mcp-${this.processId}`\n  }\n\n  /**\n   * 获取传输协议\n   * @returns {string} transport类型\n   */\n  getTransport() {\n    if (!this.initialized) {\n      throw new Error('ServerEnvironment not initialized')\n    }\n    return this.transport\n  }\n\n  /**\n   * 获取服务器地址信息（仅HTTP/SSE模式）\n   * @returns {Object|null} {host, port} 或 null\n   */\n  getServerAddress() {\n    if (!this.initialized) {\n      throw new Error('ServerEnvironment not initialized')\n    }\n    if (this.transport === 'stdio') {\n      return null\n    }\n    return {\n      host: this.host,\n      port: this.port\n    }\n  }\n\n  /**\n   * 检查是否已初始化\n   * @returns {boolean}\n   */\n  isInitialized() {\n    return this.initialized\n  }\n}\n\n// 创建全局单例实例\nlet globalServerEnvironment = null\n\n/**\n * 获取全局ServerEnvironment单例\n * @returns {ServerEnvironment} 全局ServerEnvironment实例\n */\nfunction getGlobalServerEnvironment() {\n  if (!globalServerEnvironment) {\n    globalServerEnvironment = new ServerEnvironment()\n  }\n  return globalServerEnvironment\n}\n\nmodule.exports = ServerEnvironment\nmodule.exports.getGlobalServerEnvironment = getGlobalServerEnvironment","const fs = require('fs-extra')\nconst path = require('path')\nconst os = require('os')\nconst crypto = require('crypto')\nconst { getGlobalServerEnvironment } = require('./ServerEnvironment')\nconst logger = require('@promptx/logger')\n\n/**\n * 统一项目管理器 - 新架构\n * 核心原则：一次设置，全程使用\n * 负责当前项目状态管理和多项目配置持久化\n */\nclass ProjectManager {\n  constructor() {\n    this.promptxHomeDir = path.join(os.homedir(), '.promptx')\n    this.projectsDir = path.join(this.promptxHomeDir, 'project')\n  }\n\n  // 🎯 新架构：当前项目状态管理\n  static currentProject = {\n    workingDirectory: null,\n    mcpId: null,\n    ideType: null,\n    transport: null,\n    initialized: false\n  }\n\n  /**\n   * 设置当前项目（init时调用）\n   * @param {string} workingDirectory - 项目工作目录绝对路径\n   * @param {string} mcpId - MCP进程ID\n   * @param {string} ideType - IDE类型\n   * @param {string} transport - 传输协议类型\n   */\n  static setCurrentProject(workingDirectory, mcpId, ideType, transport) {\n    this.currentProject = {\n      workingDirectory: path.resolve(workingDirectory),\n      mcpId,\n      ideType,\n      transport,\n      initialized: true\n    }\n  }\n\n  /**\n   * 获取当前项目路径（@project协议使用）\n   * @returns {string} 当前项目工作目录\n   */\n  static getCurrentProjectPath() {\n    logger.debug(`[ProjectManager DEBUG] getCurrentProjectPath被调用`)\n    logger.debug(`[ProjectManager DEBUG] currentProject.initialized: ${this.currentProject.initialized}`)\n    logger.debug(`[ProjectManager DEBUG] currentProject状态:`, JSON.stringify(this.currentProject, null, 2))\n    \n    // 输出完整的调用栈，包含文件名和行号\n    const stack = new Error().stack\n    const stackLines = stack.split('\\n').slice(1, 8) // 取前7层调用栈\n    logger.error(`[ProjectManager DEBUG] 完整调用栈:`)\n    stackLines.forEach((line, index) => {\n      logger.error(`[ProjectManager DEBUG]   ${index + 1}. ${line.trim()}`)\n    })\n    \n    if (!this.currentProject.initialized) {\n      logger.error(`[ProjectManager DEBUG] ❌ 项目未初始化，将抛出错误`)\n      throw new Error('项目未初始化，请先调用 init 命令')\n    }\n    \n    logger.debug(`[ProjectManager DEBUG] ✅ 返回项目路径: ${this.currentProject.workingDirectory}`)\n    return this.currentProject.workingDirectory\n  }\n\n  /**\n   * 获取当前项目信息\n   * @returns {Object} 当前项目完整信息\n   */\n  static getCurrentProject() {\n    logger.debug(`[ProjectManager DEBUG] getCurrentProject被调用`)\n    logger.debug(`[ProjectManager DEBUG] currentProject.initialized: ${this.currentProject.initialized}`)\n    logger.debug(`[ProjectManager DEBUG] currentProject状态:`, JSON.stringify(this.currentProject, null, 2))\n    \n    if (!this.currentProject.initialized) {\n      logger.error(`[ProjectManager DEBUG] ❌ 项目未初始化，将抛出错误`)\n      throw new Error('项目未初始化，请先调用 init 命令')\n    }\n    \n    logger.debug(`[ProjectManager DEBUG] ✅ 返回项目信息`)\n    return { ...this.currentProject }\n  }\n\n  /**\n   * 检查项目是否已初始化\n   * @returns {boolean} 是否已初始化\n   */\n  static isInitialized() {\n    return this.currentProject.initialized\n  }\n\n  /**\n   * 注册项目到MCP实例 - 使用Hash目录结构\n   * @param {string} projectPath - 项目绝对路径\n   * @param {string} mcpId - MCP进程ID\n   * @param {string} ideType - IDE类型（cursor/vscode等）\n   * @param {string} transport - 传输协议类型（stdio/http/sse）\n   * @returns {Promise<Object>} 项目配置对象\n   */\n  async registerProject(projectPath, mcpId, ideType, transport = 'stdio') {\n    // 验证项目路径\n    if (!await this.validateProjectPath(projectPath)) {\n      throw new Error(`无效的项目路径: ${projectPath}`)\n    }\n\n    // 生成项目配置\n    const projectConfig = {\n      mcpId: mcpId,\n      ideType: ideType.toLowerCase(),\n      transport: transport.toLowerCase(),\n      projectPath: path.resolve(projectPath),\n      projectHash: this.generateProjectHash(projectPath)\n    }\n\n    // 生成项目Hash目录\n    const projectHash = this.generateProjectHash(projectPath)\n    const projectConfigDir = path.join(this.projectsDir, projectHash)\n\n    // 🎯 确保Hash目录和.promptx子目录存在\n    await fs.ensureDir(projectConfigDir)\n    await fs.ensureDir(path.join(projectConfigDir, '.promptx'))\n    await fs.ensureDir(path.join(projectConfigDir, '.promptx', 'memory'))\n    await fs.ensureDir(path.join(projectConfigDir, '.promptx', 'resource'))\n\n    // 生成配置文件名并保存到Hash目录下\n    const fileName = this.generateConfigFileName(mcpId, ideType, transport, projectPath)\n    const configPath = path.join(projectConfigDir, fileName)\n    \n    await fs.writeJson(configPath, projectConfig, { spaces: 2 })\n    \n    return projectConfig\n  }\n\n  /**\n   * 根据MCP ID获取单个项目配置（假设只有一个项目）\n   * @param {string} mcpId - MCP进程ID\n   * @returns {Promise<Object|null>} 项目配置对象\n   */\n  async getProjectByMcpId(mcpId) {\n    const projects = await this.getProjectsByMcpId(mcpId)\n    return projects.length > 0 ? projects[0] : null\n  }\n\n  /**\n   * 根据MCP ID获取所有绑定的项目配置 - 支持Hash目录结构\n   * @param {string} mcpId - MCP进程ID\n   * @returns {Promise<Array>} 项目配置数组\n   */\n  async getProjectsByMcpId(mcpId) {\n    if (!await fs.pathExists(this.projectsDir)) {\n      return []\n    }\n\n    const hashDirs = await fs.readdir(this.projectsDir)\n    const projects = []\n\n    for (const hashDir of hashDirs) {\n      const hashDirPath = path.join(this.projectsDir, hashDir)\n      \n      // 🎯 只处理Hash目录（忽略旧的平铺文件）\n      if (!(await fs.stat(hashDirPath)).isDirectory()) {\n        continue\n      }\n      \n      try {\n        const configFiles = await fs.readdir(hashDirPath)\n        for (const file of configFiles) {\n          // 查找MCP配置文件\n          if (file.startsWith('mcp-') && file.endsWith('.json')) {\n            try {\n              const configPath = path.join(hashDirPath, file)\n              const config = await fs.readJson(configPath)\n              if (config.mcpId === mcpId) {\n                projects.push(config)\n              }\n            } catch (error) {\n              // 忽略损坏的配置文件\n              logger.warn(`跳过损坏的配置文件: ${file}`)\n            }\n          }\n        }\n      } catch (error) {\n        // 忽略无法读取的目录\n        logger.warn(`跳过无法读取的目录: ${hashDir}`)\n      }\n    }\n\n    return projects\n  }\n\n  /**\n   * 获取特定项目的所有实例（不同IDE/MCP的绑定） - 支持Hash目录结构\n   * @param {string} projectPath - 项目路径\n   * @returns {Promise<Array>} 项目实例数组\n   */\n  async getProjectInstances(projectPath) {\n    if (!await fs.pathExists(this.projectsDir)) {\n      return []\n    }\n\n    const projectHash = this.generateProjectHash(projectPath)\n    const projectConfigDir = path.join(this.projectsDir, projectHash)\n    \n    // 检查Hash目录是否存在\n    if (!await fs.pathExists(projectConfigDir)) {\n      return []\n    }\n\n    const instances = []\n    \n    try {\n      const configFiles = await fs.readdir(projectConfigDir)\n      \n      for (const file of configFiles) {\n        // 查找MCP配置文件\n        if (file.startsWith('mcp-') && file.endsWith('.json')) {\n          try {\n            const configPath = path.join(projectConfigDir, file)\n            const config = await fs.readJson(configPath)\n            if (config.projectHash === projectHash) {\n              instances.push(config)\n            }\n          } catch (error) {\n            logger.warn(`跳过损坏的配置文件: ${file}`)\n          }\n        }\n      }\n    } catch (error) {\n      logger.warn(`无法读取项目配置目录: ${projectConfigDir}`)\n    }\n\n    return instances\n  }\n\n  /**\n   * 删除项目绑定 - 支持Hash目录结构\n   * @param {string} mcpId - MCP进程ID\n   * @param {string} ideType - IDE类型\n   * @param {string} transport - 传输协议类型\n   * @param {string} projectPath - 项目路径\n   * @returns {Promise<boolean>} 是否删除成功\n   */\n  async removeProject(mcpId, ideType, transport, projectPath) {\n    const projectHash = this.generateProjectHash(projectPath)\n    const projectConfigDir = path.join(this.projectsDir, projectHash)\n    const fileName = this.generateConfigFileName(mcpId, ideType, transport, projectPath)\n    const configPath = path.join(projectConfigDir, fileName)\n    \n    if (await fs.pathExists(configPath)) {\n      await fs.remove(configPath)\n      \n      // 🎯 检查Hash目录是否为空，如果为空则删除整个目录\n      try {\n        const remainingFiles = await fs.readdir(projectConfigDir)\n        const mcpConfigFiles = remainingFiles.filter(file => file.startsWith('mcp-') && file.endsWith('.json'))\n        \n        if (mcpConfigFiles.length === 0) {\n          // 没有其他MCP配置文件，删除整个Hash目录\n          await fs.remove(projectConfigDir)\n        }\n      } catch (error) {\n        // 目录可能已经被删除，忽略错误\n      }\n      \n      return true\n    }\n    \n    return false\n  }\n\n  /**\n   * 清理过期的项目配置 - 支持Hash目录结构\n   * @returns {Promise<number>} 清理的配置文件数量\n   */\n  async cleanupExpiredProjects() {\n    if (!await fs.pathExists(this.projectsDir)) {\n      return 0\n    }\n\n    const hashDirs = await fs.readdir(this.projectsDir)\n    let cleanedCount = 0\n\n    for (const hashDir of hashDirs) {\n      const hashDirPath = path.join(this.projectsDir, hashDir)\n      \n      // 只处理Hash目录\n      if (!(await fs.stat(hashDirPath)).isDirectory()) {\n        continue\n      }\n      \n      try {\n        const configFiles = await fs.readdir(hashDirPath)\n        let hasValidConfig = false\n        \n        for (const file of configFiles) {\n          if (file.startsWith('mcp-') && file.endsWith('.json')) {\n            try {\n              const configPath = path.join(hashDirPath, file)\n              const config = await fs.readJson(configPath)\n              \n              // 检查项目路径是否仍然存在\n              if (!await fs.pathExists(config.projectPath)) {\n                await fs.remove(configPath)\n                cleanedCount++\n                logger.info(`清理过期项目配置: ${file}`)\n              } else {\n                hasValidConfig = true\n              }\n            } catch (error) {\n              // 清理损坏的配置文件\n              await fs.remove(path.join(hashDirPath, file))\n              cleanedCount++\n              logger.info(`清理损坏配置文件: ${file}`)\n            }\n          }\n        }\n        \n        // 如果Hash目录中没有有效的配置文件，删除整个目录\n        if (!hasValidConfig) {\n          await fs.remove(hashDirPath)\n          logger.info(`清理空的项目Hash目录: ${hashDir}`)\n        }\n      } catch (error) {\n        // 清理无法访问的目录\n        await fs.remove(hashDirPath)\n        cleanedCount++\n        logger.info(`清理无法访问的目录: ${hashDir}`)\n      }\n    }\n\n    return cleanedCount\n  }\n\n  /**\n   * 生成多项目环境下的AI提示词\n   * @param {string} contextType - 上下文类型：'list'/'action'/'learn'\n   * @param {string} mcpId - MCP进程ID\n   * @param {string} ideType - IDE类型\n   * @returns {Promise<string>} 格式化的AI提示词\n   */\n  async generateTopLevelProjectPrompt(contextType = 'list', mcpId, ideType) {\n    const projects = await this.getProjectsByMcpId(mcpId)\n    \n    if (projects.length === 0) {\n      // 未绑定项目，但这是正常的，不需要特别提示\n      return ''\n    }\n    \n    if (projects.length === 1) {\n      // 单项目环境（保持现有体验）\n      const project = projects[0]\n      const basePrompt = `🛑 **项目环境验证** 🛑\n📍 当前绑定项目: ${project.projectPath}\n🔗 MCP实例: ${mcpId} (${ideType})\n\n⚠️ **执行前确认**：上述路径是否为你当前工作的项目？`\n\n      switch (contextType) {\n        case 'action':\n          return `${basePrompt}\n如不一致，立即停止所有操作并使用 \\`promptx_init\\` 更新！\n\n💥 **严重警告**：在错误项目路径下操作将导致不可预知的错误！`\n        \n        case 'learn':\n          return `${basePrompt}\n错误环境将导致知识关联失效！\n\n💥 **严重警告**：项目环境不匹配将影响学习效果！`\n        \n        default:\n          return `${basePrompt}\n如不一致，必须使用 \\`promptx_init\\` 更新正确路径！\n\n💥 **严重警告**：错误的项目环境将导致服务异常！`\n      }\n    }\n    \n    // 多项目环境\n    const projectList = projects.map((proj, index) => \n      `${index + 1}. ${path.basename(proj.projectPath)} (${proj.projectPath})`\n    ).join('\\n')\n    \n    return `🎯 **多项目环境检测** 🎯\n📍 当前MCP实例(${mcpId})已绑定 ${projects.length} 个项目：\n\n${projectList}\n\n⚠️ **请明确指定**：你要在哪个项目中执行操作？\n💡 **建议**：在对话中明确说明项目名称或路径`\n  }\n\n  /**\n   * 验证路径是否为有效的项目目录\n   * @param {string} projectPath - 要验证的路径\n   * @returns {Promise<boolean>} 是否为有效项目目录\n   */\n  async validateProjectPath(projectPath) {\n    try {\n      // 基础检查：路径存在且为目录\n      const stat = await fs.stat(projectPath)\n      if (!stat.isDirectory()) {\n        return false\n      }\n\n      // 简单检查：避免明显错误的路径\n      const resolved = path.resolve(projectPath)\n      const homeDir = os.homedir()\n      \n      // 不允许是用户主目录\n      if (resolved === homeDir) {\n        return false\n      }\n\n      return true\n    } catch (error) {\n      return false\n    }\n  }\n\n  /**\n   * 生成配置文件名\n   * @param {string} mcpId - MCP进程ID\n   * @param {string} ideType - IDE类型\n   * @param {string} transport - 传输协议类型\n   * @param {string} projectPath - 项目路径\n   * @returns {string} 配置文件名\n   */\n  generateConfigFileName(mcpId, ideType, transport, projectPath) {\n    const projectHash = this.generateProjectHash(projectPath)\n    const projectName = path.basename(projectPath).toLowerCase().replace(/[^a-z0-9-]/g, '-')\n    const ideTypeSafe = ideType.replace(/[^a-z0-9-]/g, '').toLowerCase() || 'unknown'\n    const transportSafe = transport.replace(/[^a-z0-9-]/g, '').toLowerCase() || 'unknown'\n    // 格式：mcp-transport-id-idetype-projectname-hash.json\n    return `mcp-${transportSafe}-${mcpId.replace('mcp-', '')}-${ideTypeSafe}-${projectName}-${projectHash}.json`\n  }\n\n  /**\n   * 生成项目路径的Hash值\n   * @param {string} projectPath - 项目路径\n   * @returns {string} 8位Hash值\n   */\n  generateProjectHash(projectPath) {\n    return crypto.createHash('md5').update(path.resolve(projectPath)).digest('hex').substr(0, 8)\n  }\n\n  /**\n   * 从配置文件中获取IDE类型\n   * @param {string} mcpId - MCP进程ID\n   * @returns {Promise<string>} IDE类型\n   */\n  async getIdeType(mcpId) {\n    const project = await this.getProjectByMcpId(mcpId)\n    return project ? project.ideType : 'unknown'\n  }\n\n  /**\n   * 生成MCP进程ID - 基于进程ID确保实例唯一\n   * @param {string} ideType - IDE类型（保留参数兼容性，实际不使用）\n   * @returns {string} MCP进程ID\n   */\n  static generateMcpId(ideType = 'unknown') {\n    const serverEnv = getGlobalServerEnvironment()\n    if (serverEnv.isInitialized()) {\n      return serverEnv.getMcpId()\n    }\n    // fallback到原逻辑\n    return `mcp-${process.pid}`\n  }\n\n  /**\n   * 统一项目注册方法 - 新架构：设置当前项目并持久化配置\n   * @param {string} workingDirectory - 项目工作目录\n   * @param {string} ideType - IDE类型（可选，默认'unknown'）\n   * @returns {Promise<Object>} 项目配置对象\n   */\n  static async registerCurrentProject(workingDirectory, ideType = 'unknown') {\n    logger.debug(`[ProjectManager DEBUG] ======= registerCurrentProject开始 =======`)\n    logger.debug(`[ProjectManager DEBUG] 参数 - workingDirectory: ${workingDirectory}`)\n    logger.debug(`[ProjectManager DEBUG] 参数 - ideType: ${ideType}`)\n    logger.debug(`[ProjectManager DEBUG] 注册前 currentProject状态:`, JSON.stringify(this.currentProject, null, 2))\n    \n    const serverEnv = getGlobalServerEnvironment()\n    if (!serverEnv.isInitialized()) {\n      logger.error(`[ProjectManager DEBUG] ❌ ServerEnvironment未初始化`)\n      throw new Error('ServerEnvironment not initialized')\n    }\n    \n    const mcpId = serverEnv.getMcpId()\n    const transport = serverEnv.getTransport()\n    logger.debug(`[ProjectManager DEBUG] ServerEnvironment信息 - mcpId: ${mcpId}, transport: ${transport}`)\n    \n    // 🎯 新架构：设置当前项目状态\n    logger.debug(`[ProjectManager DEBUG] 调用 setCurrentProject...`)\n    this.setCurrentProject(workingDirectory, mcpId, ideType, transport)\n    logger.debug(`[ProjectManager DEBUG] setCurrentProject完成后 currentProject状态:`, JSON.stringify(this.currentProject, null, 2))\n    \n    // 持久化项目配置（保持多项目管理功能）\n    logger.debug(`[ProjectManager DEBUG] 开始持久化项目配置...`)\n    const projectManager = getGlobalProjectManager()\n    const result = await projectManager.registerProject(workingDirectory, mcpId, ideType, transport)\n    logger.debug(`[ProjectManager DEBUG] 项目配置持久化完成:`, JSON.stringify(result, null, 2))\n    logger.debug(`[ProjectManager DEBUG] ======= registerCurrentProject结束 =======`)\n    \n    return result\n  }\n}\n\n// 创建全局单例实例\nlet globalProjectManager = null\n\n/**\n * 获取全局ProjectManager单例\n * @returns {ProjectManager} 全局ProjectManager实例\n */\nfunction getGlobalProjectManager() {\n  if (!globalProjectManager) {\n    globalProjectManager = new ProjectManager()\n  }\n  return globalProjectManager\n}\n\nmodule.exports = ProjectManager\nmodule.exports.ProjectManager = ProjectManager\nmodule.exports.getGlobalProjectManager = getGlobalProjectManager","const fs = require('fs-extra')\nconst path = require('path')\nconst os = require('os')\nconst ProjectManager = require('./ProjectManager')\n\n/**\n * 目录定位器基础抽象类\n * 统一管理所有路径解析逻辑，支持跨平台差异化实现\n */\nclass DirectoryLocator {\n  constructor(options = {}) {\n    this.options = options\n    this.cache = new Map()\n    this.platform = process.platform\n  }\n\n  /**\n   * 抽象方法：定位目录\n   * @param {Object} context - 定位上下文\n   * @returns {Promise<string>} 定位到的目录路径\n   */\n  async locate(context = {}) {\n    throw new Error('子类必须实现 locate 方法')\n  }\n\n  /**\n   * 获取缓存\n   */\n  getCached(key) {\n    return this.cache.get(key)\n  }\n\n  /**\n   * 设置缓存\n   */\n  setCached(key, value) {\n    this.cache.set(key, value)\n    return value\n  }\n\n  /**\n   * 清除缓存\n   */\n  clearCache() {\n    this.cache.clear()\n  }\n\n  /**\n   * 检查路径是否存在且是目录\n   */\n  async isValidDirectory(dirPath) {\n    try {\n      const stat = await fs.stat(dirPath)\n      return stat.isDirectory()\n    } catch {\n      return false\n    }\n  }\n\n  /**\n   * 规范化路径\n   */\n  normalizePath(inputPath) {\n    if (!inputPath || typeof inputPath !== 'string') {\n      return null\n    }\n    return path.resolve(inputPath)\n  }\n\n  /**\n   * 展开家目录路径\n   */\n  expandHome(filepath) {\n    if (!filepath || typeof filepath !== 'string') {\n      return ''\n    }\n    \n    if (filepath.startsWith('~/') || filepath === '~') {\n      return path.join(os.homedir(), filepath.slice(2))\n    }\n    \n    return filepath\n  }\n}\n\n/**\n * 项目根目录定位器\n * 负责查找项目的根目录\n */\nclass ProjectRootLocator extends DirectoryLocator {\n  constructor(options = {}) {\n    super(options)\n    \n    // 初始化AI驱动的项目管理器\n    this.projectManager = new ProjectManager()\n    \n    // 可配置的查找策略优先级（按可靠性和准确性排序）\n    this.strategies = options.strategies || [\n      'aiProvidedProjectPath',              // 1. AI提供的项目路径（最可靠，由AI告知）\n      'existingPromptxDirectory',           // 2. 现有.promptx目录（最可靠的项目标识）\n      'packageJsonDirectory',               // 3. 向上查找项目标识文件（最准确的项目边界）\n      'gitRootDirectory',                   // 4. Git根目录（通用可靠）\n      'currentWorkingDirectoryIfHasMarkers', // 5. 当前目录项目标识（降级策略）\n      'currentWorkingDirectory'             // 6. 纯当前目录（最后回退）\n    ]\n    \n    // 项目标识文件\n    this.projectMarkers = options.projectMarkers || [\n      'package.json',\n      '.git',\n      'pyproject.toml',\n      'Cargo.toml',\n      'pom.xml',\n      'build.gradle',\n      'composer.json'\n    ]\n  }\n\n  /**\n   * 定位项目根目录\n   */\n  async locate(context = {}) {\n    const { startDir = process.cwd() } = context\n    const cacheKey = `projectRoot:${startDir}`\n    \n    // 检查缓存\n    const cached = this.getCached(cacheKey)\n    if (cached) {\n      return cached\n    }\n\n    // 使用上下文中的策略或默认策略\n    const strategies = context.strategies || this.strategies\n\n    // 按策略优先级查找\n    for (const strategy of strategies) {\n      const result = await this._executeStrategy(strategy, startDir, context)\n      if (result && await this._validateProjectRoot(result, context)) {\n        return this.setCached(cacheKey, result)\n      }\n    }\n\n    // 如果所有策略都失败，返回起始目录\n    return this.setCached(cacheKey, startDir)\n  }\n\n  /**\n   * 执行特定的查找策略\n   */\n  async _executeStrategy(strategy, startDir, context) {\n    switch (strategy) {\n      case 'aiProvidedProjectPath':\n        return await this._findByAIProvidedPath()\n      \n      case 'existingPromptxDirectory':\n        return await this._findByExistingPromptx(startDir)\n      \n      case 'currentWorkingDirectoryIfHasMarkers':\n        return await this._checkCurrentDirForMarkers(startDir)\n      \n      case 'packageJsonDirectory':\n        return await this._findByProjectMarkers(startDir)\n      \n      case 'gitRootDirectory':\n        return await this._findByGitRoot(startDir)\n      \n      case 'currentWorkingDirectory':\n        return startDir\n      \n      default:\n        return null\n    }\n  }\n\n  /**\n   * 通过AI提供的项目路径查找（最高优先级）\n   */\n  async _findByAIProvidedPath() {\n    try {\n      // 注意：多项目环境下需要传入mcpId，这里使用临时ID\n      const tempMcpId = process.env.PROMPTX_MCP_ID || `temp-${process.pid}`\n      const projects = await this.projectManager.getProjectsByMcpId(tempMcpId)\n      const aiProvidedPath = projects.length > 0 ? projects[0].projectPath : null\n      if (aiProvidedPath && await this.isValidDirectory(aiProvidedPath)) {\n        return aiProvidedPath\n      }\n    } catch (error) {\n      // AI提供的路径获取失败，继续使用其他策略\n    }\n    return null\n  }\n\n  /**\n   * 检查当前目录是否包含项目标识文件\n   */\n  async _checkCurrentDirForMarkers(startDir) {\n    const currentDir = path.resolve(startDir)\n    \n    // 检查当前目录是否包含项目标识文件\n    for (const marker of this.projectMarkers) {\n      const markerPath = path.join(currentDir, marker)\n      if (await fs.pathExists(markerPath)) {\n        return currentDir\n      }\n    }\n    \n    return null\n  }\n\n  /**\n   * 通过现有.promptx目录查找\n   */\n  async _findByExistingPromptx(startDir) {\n    let currentDir = path.resolve(startDir)\n    const root = path.parse(currentDir).root\n\n    while (currentDir !== root) {\n      const promptxPath = path.join(currentDir, '.promptx')\n      if (await this.isValidDirectory(promptxPath)) {\n        return currentDir\n      }\n      \n      const parentDir = path.dirname(currentDir)\n      if (parentDir === currentDir) break\n      currentDir = parentDir\n    }\n\n    return null\n  }\n\n  /**\n   * 通过项目标识文件查找\n   */\n  async _findByProjectMarkers(startDir) {\n    let currentDir = path.resolve(startDir)\n    const root = path.parse(currentDir).root\n\n    while (currentDir !== root) {\n      for (const marker of this.projectMarkers) {\n        const markerPath = path.join(currentDir, marker)\n        if (await fs.pathExists(markerPath)) {\n          return currentDir\n        }\n      }\n      \n      const parentDir = path.dirname(currentDir)\n      if (parentDir === currentDir) break\n      currentDir = parentDir\n    }\n\n    return null\n  }\n\n  /**\n   * 通过Git根目录查找\n   */\n  async _findByGitRoot(startDir) {\n    let currentDir = path.resolve(startDir)\n    const root = path.parse(currentDir).root\n\n    while (currentDir !== root) {\n      const gitPath = path.join(currentDir, '.git')\n      if (await fs.pathExists(gitPath)) {\n        return currentDir\n      }\n      \n      const parentDir = path.dirname(currentDir)\n      if (parentDir === currentDir) break\n      currentDir = parentDir\n    }\n\n    return null\n  }\n\n  /**\n   * 验证项目根目录\n   */\n  async _validateProjectRoot(projectRoot, context = {}) {\n    // Windows平台：避免用户家目录\n    if (this.platform === 'win32' && context.avoidUserHome !== false) {\n      const homeDir = os.homedir()\n      if (path.resolve(projectRoot) === path.resolve(homeDir)) {\n        return false\n      }\n    }\n\n    return await this.isValidDirectory(projectRoot)\n  }\n}\n\n/**\n * PromptX工作空间定位器\n * 负责确定.promptx目录的位置\n */\nclass PromptXWorkspaceLocator extends DirectoryLocator {\n  constructor(options = {}) {\n    super(options)\n    this.projectRootLocator = options.projectRootLocator || new ProjectRootLocator(options)\n    this.projectManager = new ProjectManager()\n  }\n\n  /**\n   * 定位PromptX工作空间\n   */\n  async locate(context = {}) {\n    const cacheKey = `promptxWorkspace:${JSON.stringify(context)}`\n\n    // 检查缓存\n    const cached = this.getCached(cacheKey)\n    if (cached) {\n      return cached\n    }\n\n    // 策略1：AI提供的项目路径（最高优先级 - AI驱动的路径管理）\n    const workspaceFromAI = await this._fromAIProvidedPath()\n    if (workspaceFromAI) {\n      return this.setCached(cacheKey, workspaceFromAI)\n    }\n\n    // 策略2：IDE环境变量（用户/IDE明确指定）\n    const workspaceFromIDE = await this._fromIDEEnvironment()\n    if (workspaceFromIDE) {\n      return this.setCached(cacheKey, workspaceFromIDE)\n    }\n\n    // 策略3：PromptX专用环境变量（用户手动配置）\n    const workspaceFromEnv = await this._fromPromptXEnvironment()\n    if (workspaceFromEnv) {\n      return this.setCached(cacheKey, workspaceFromEnv)\n    }\n\n    // 策略4：特定上下文策略（如init命令的强制指定）\n    if (context.strategies) {\n      const workspaceFromProject = await this._fromProjectRoot(context)\n      if (workspaceFromProject) {\n        return this.setCached(cacheKey, workspaceFromProject)\n      }\n    }\n\n    // 策略5：现有.promptx目录（已初始化的项目）\n    const workspaceFromExisting = await this._fromExistingDirectory(context.startDir)\n    if (workspaceFromExisting) {\n      return this.setCached(cacheKey, workspaceFromExisting)\n    }\n\n    // 策略6：项目根目录（基于项目结构推断）\n    const workspaceFromProject = await this._fromProjectRoot(context)\n    if (workspaceFromProject) {\n      return this.setCached(cacheKey, workspaceFromProject)\n    }\n\n    // 策略7：智能回退策略（兜底方案）\n    return this.setCached(cacheKey, await this._getSmartFallback(context))\n  }\n\n  /**\n   * 从AI提供的项目路径获取（最高优先级）\n   */\n  async _fromAIProvidedPath() {\n    try {\n      // 注意：多项目环境下需要传入mcpId，这里使用临时ID\n      const tempMcpId = process.env.PROMPTX_MCP_ID || `temp-${process.pid}`\n      const projects = await this.projectManager.getProjectsByMcpId(tempMcpId)\n      const aiProvidedPath = projects.length > 0 ? projects[0].projectPath : null\n      if (aiProvidedPath && await this.isValidDirectory(aiProvidedPath)) {\n        return aiProvidedPath\n      }\n    } catch (error) {\n      // AI提供的路径获取失败，继续使用其他策略\n    }\n    return null\n  }\n\n  /**\n   * 从IDE环境变量获取（支持多种IDE）\n   */\n  async _fromIDEEnvironment() {\n    // IDE环境变量检测策略（按优先级排序）\n    const ideStrategies = [\n      // Claude IDE (现有格式)\n      {\n        name: 'Claude IDE',\n        vars: ['WORKSPACE_FOLDER_PATHS'],\n        parse: (value, varName) => {\n          try {\n            const folders = JSON.parse(value)\n            return Array.isArray(folders) && folders.length > 0 ? folders[0] : null\n          } catch {\n            return null\n          }\n        }\n      },\n      \n      // VSCode\n      {\n        name: 'VSCode',\n        vars: ['VSCODE_WORKSPACE_FOLDER', 'VSCODE_CWD'],\n        parse: (value, varName) => value\n      },\n      \n      // IntelliJ IDEA / WebStorm / PhpStorm\n      {\n        name: 'JetBrains IDEs',\n        vars: ['PROJECT_ROOT', 'IDEA_INITIAL_DIRECTORY', 'WEBSTORM_PROJECT_PATH'],\n        parse: (value, varName) => value\n      },\n      \n      // Sublime Text\n      {\n        name: 'Sublime Text',\n        vars: ['SUBLIME_PROJECT_PATH', 'SUBL_PROJECT_DIR'],\n        parse: (value, varName) => value\n      },\n      \n      // Atom\n      {\n        name: 'Atom',\n        vars: ['ATOM_PROJECT_PATH', 'ATOM_HOME_PROJECT'],\n        parse: (value, varName) => value\n      },\n      \n      // Vim/Neovim\n      {\n        name: 'Vim/Neovim',\n        vars: ['VIM_PROJECT_ROOT', 'NVIM_PROJECT_ROOT'],\n        parse: (value, varName) => value\n      },\n      \n      // 字节跳动 Trae 和其他基于PWD的IDE\n      {\n        name: 'ByteDance Trae & PWD-based IDEs',\n        vars: ['PWD', 'TRAE_WORKSPACE', 'BYTEDANCE_WORKSPACE'],\n        parse: (value, varName) => {\n          // 对于专用环境变量，直接使用\n          if (varName === 'TRAE_WORKSPACE' || varName === 'BYTEDANCE_WORKSPACE') {\n            return value\n          }\n          \n          // 对于PWD，只有当它与process.cwd()不同时，才认为是IDE设置的项目路径\n          if (varName === 'PWD') {\n            const currentCwd = process.cwd()\n            if (value && value !== currentCwd) {\n              return value\n            }\n          }\n          \n          return null\n        }\n      },\n      \n      // 通用工作目录\n      {\n        name: 'Generic',\n        vars: ['WORKSPACE_ROOT', 'PROJECT_DIR', 'WORKING_DIRECTORY'],\n        parse: (value, varName) => value\n      }\n    ]\n\n    // 按策略逐一检测\n    for (const strategy of ideStrategies) {\n      for (const varName of strategy.vars) {\n        const envValue = process.env[varName]\n        if (envValue && envValue.trim() !== '') {\n          // 传递varName给parse函数，支持变量名相关的解析逻辑\n          const parsedPath = strategy.parse(envValue.trim(), varName)\n          if (parsedPath) {\n            const normalizedPath = this.normalizePath(this.expandHome(parsedPath))\n            if (normalizedPath && await this.isValidDirectory(normalizedPath)) {\n              // 记录检测到的IDE类型（用于调试）\n              this._detectedIDE = strategy.name\n              return normalizedPath\n            }\n          }\n        }\n      }\n    }\n    \n    return null\n  }\n\n  /**\n   * 从PromptX环境变量获取\n   */\n  async _fromPromptXEnvironment() {\n    const promptxWorkspaceEnv = process.env.PROMPTX_WORKSPACE\n    if (promptxWorkspaceEnv && promptxWorkspaceEnv.trim() !== '') {\n      const workspacePath = this.normalizePath(this.expandHome(promptxWorkspaceEnv))\n      if (workspacePath && await this.isValidDirectory(workspacePath)) {\n        return workspacePath\n      }\n    }\n    return null\n  }\n\n  /**\n   * 从现有.promptx目录获取\n   */\n  async _fromExistingDirectory(startDir) {\n    const projectRoot = await this.projectRootLocator._findByExistingPromptx(startDir || process.cwd())\n    return projectRoot\n  }\n\n  /**\n   * 从项目根目录获取\n   */\n  async _fromProjectRoot(context) {\n    const projectRoot = await this.projectRootLocator.locate(context)\n    return projectRoot\n  }\n\n  /**\n   * 智能回退策略\n   */\n  async _getSmartFallback(context) {\n    // 1. 尝试从命令行参数推断\n    const argPath = await this._fromProcessArguments()\n    if (argPath && await this.isValidDirectory(argPath)) {\n      return argPath\n    }\n\n    // 2. 尝试从进程的工作目录\n    const processCwd = process.cwd()\n    if (await this.isValidDirectory(processCwd)) {\n      return processCwd\n    }\n\n    // 3. 最后回退到用户主目录\n    return os.homedir()\n  }\n\n  /**\n   * 从进程参数推断项目路径\n   */\n  async _fromProcessArguments() {\n    const args = process.argv\n    \n    // 查找可能的路径参数\n    for (let i = 0; i < args.length; i++) {\n      const arg = args[i]\n      \n      // 查找 --project-path 或类似参数\n      if (arg.startsWith('--project-path=')) {\n        return arg.split('=')[1]\n      }\n      \n      if (arg === '--project-path' && i + 1 < args.length) {\n        return args[i + 1]\n      }\n      \n      // 查找 --cwd 参数\n      if (arg.startsWith('--cwd=')) {\n        return arg.split('=')[1]\n      }\n      \n      if (arg === '--cwd' && i + 1 < args.length) {\n        return args[i + 1]\n      }\n    }\n    \n    return null\n  }\n\n  /**\n   * 获取检测调试信息\n   */\n  getDetectionInfo() {\n    return {\n      detectedIDE: this._detectedIDE || 'Unknown',\n      availableEnvVars: this._getAvailableEnvVars(),\n      platform: process.platform,\n      cwd: process.cwd(),\n      args: process.argv\n    }\n  }\n\n  /**\n   * 获取可用的环境变量\n   */\n  _getAvailableEnvVars() {\n    const relevantVars = [\n      'WORKSPACE_FOLDER_PATHS', 'VSCODE_WORKSPACE_FOLDER', 'VSCODE_CWD',\n      'PROJECT_ROOT', 'IDEA_INITIAL_DIRECTORY', 'WEBSTORM_PROJECT_PATH',\n      'SUBLIME_PROJECT_PATH', 'SUBL_PROJECT_DIR',\n      'ATOM_PROJECT_PATH', 'ATOM_HOME_PROJECT',\n      'VIM_PROJECT_ROOT', 'NVIM_PROJECT_ROOT',\n      'PWD', 'TRAE_WORKSPACE', 'BYTEDANCE_WORKSPACE',\n      'WORKSPACE_ROOT', 'PROJECT_DIR', 'WORKING_DIRECTORY',\n      'PROMPTX_WORKSPACE'\n    ]\n    \n    const available = {}\n    for (const varName of relevantVars) {\n      if (process.env[varName]) {\n        available[varName] = process.env[varName]\n      }\n    }\n    \n    return available\n  }\n}\n\n/**\n * 目录定位器工厂\n */\nclass DirectoryLocatorFactory {\n  /**\n   * 创建项目根目录定位器\n   */\n  static createProjectRootLocator(options = {}) {\n    const platform = process.platform\n    \n    // 根据平台创建特定实现\n    if (platform === 'win32') {\n      return new WindowsProjectRootLocator(options)\n    } else {\n      return new ProjectRootLocator(options)\n    }\n  }\n\n  /**\n   * 创建PromptX工作空间定位器\n   */\n  static createPromptXWorkspaceLocator(options = {}) {\n    const projectRootLocator = this.createProjectRootLocator(options)\n    return new PromptXWorkspaceLocator({\n      ...options,\n      projectRootLocator\n    })\n  }\n\n  /**\n   * 获取平台信息\n   */\n  static getPlatform() {\n    return process.platform\n  }\n}\n\n/**\n * Windows平台的项目根目录定位器\n * 特殊处理Windows环境下的路径问题\n */\nclass WindowsProjectRootLocator extends ProjectRootLocator {\n  constructor(options = {}) {\n    super({\n      ...options,\n      // Windows默认避免用户家目录\n      avoidUserHome: options.avoidUserHome !== false\n    })\n  }\n\n  /**\n   * Windows特有的项目根目录验证\n   */\n  async _validateProjectRoot(projectRoot, context = {}) {\n    // 调用基类验证\n    const baseValid = await super._validateProjectRoot(projectRoot, context)\n    if (!baseValid) {\n      return false\n    }\n\n    // Windows特有：避免系统关键目录\n    const systemPaths = [\n      'C:\\\\Windows',\n      'C:\\\\Program Files',\n      'C:\\\\Program Files (x86)',\n      'C:\\\\System Volume Information'\n    ]\n\n    const resolvedPath = path.resolve(projectRoot).toUpperCase()\n    for (const systemPath of systemPaths) {\n      if (resolvedPath.startsWith(systemPath.toUpperCase())) {\n        return false\n      }\n    }\n\n    return true\n  }\n}\n\nmodule.exports = {\n  DirectoryLocator,\n  ProjectRootLocator,\n  PromptXWorkspaceLocator,\n  DirectoryLocatorFactory,\n  WindowsProjectRootLocator\n} ","const { DirectoryLocatorFactory } = require('./DirectoryLocator')\nconst logger = require('@promptx/logger')\n\n/**\n * IDE环境检测服务 - 新架构\n * 专注于IDE环境变量检测和配置建议\n * 项目路径管理已移交ProjectManager和ProjectPathResolver\n */\nclass DirectoryService {\n  constructor() {\n    this.workspaceLocator = null\n    this.initialized = false\n  }\n\n  /**\n   * 初始化服务\n   */\n  async initialize(options = {}) {\n    if (this.initialized) {\n      return\n    }\n\n    try {\n      this.workspaceLocator = DirectoryLocatorFactory.createPromptXWorkspaceLocator(options)\n      this.initialized = true\n      \n      logger.debug('[DirectoryService] 初始化完成')\n    } catch (error) {\n      logger.error('[DirectoryService] 初始化失败:', error)\n      throw error\n    }\n  }\n\n  /**\n   * 获取IDE环境检测调试信息\n   */\n  async getDebugInfo(context = {}) {\n    await this._ensureInitialized()\n    \n    // 获取IDE检测信息\n    const ideDetectionInfo = this.workspaceLocator?.getDetectionInfo() || {}\n    \n    return {\n      platform: process.platform,\n      ideDetection: {\n        detectedIDE: ideDetectionInfo.detectedIDE,\n        availableEnvVars: ideDetectionInfo.availableEnvVars,\n        cwd: process.cwd(),\n        args: process.argv.slice(2)\n      },\n      environment: {\n        // 主要IDE环境变量\n        WORKSPACE_FOLDER_PATHS: process.env.WORKSPACE_FOLDER_PATHS,\n        VSCODE_WORKSPACE_FOLDER: process.env.VSCODE_WORKSPACE_FOLDER,\n        PROJECT_ROOT: process.env.PROJECT_ROOT,\n        SUBLIME_PROJECT_PATH: process.env.SUBLIME_PROJECT_PATH,\n        // PromptX专用\n        PROMPTX_WORKSPACE: process.env.PROMPTX_WORKSPACE,\n        // 系统环境\n        PWD: process.env.PWD,\n        NODE_ENV: process.env.NODE_ENV\n      },\n      recommendations: this._getPathRecommendations(ideDetectionInfo)\n    }\n  }\n\n  /**\n   * 获取路径配置建议\n   */\n  _getPathRecommendations(ideDetectionInfo = {}) {\n    const recommendations = []\n    \n    if (!ideDetectionInfo.detectedIDE || ideDetectionInfo.detectedIDE === 'Unknown') {\n      recommendations.push({\n        type: 'env_var',\n        message: '未检测到IDE环境变量，建议设置项目路径环境变量',\n        suggestions: [\n          'export PROMPTX_WORKSPACE=\"/path/to/your/project\"',\n          'export PROJECT_ROOT=\"/path/to/your/project\"',\n          'export WORKSPACE_ROOT=\"/path/to/your/project\"'\n        ]\n      })\n    }\n    \n    if (!ideDetectionInfo.availableEnvVars || Object.keys(ideDetectionInfo.availableEnvVars).length === 0) {\n      recommendations.push({\n        type: 'manual_config',\n        message: '建议在IDE中配置MCP工作目录',\n        suggestions: [\n          'VSCode: 在settings.json中设置workspace.folders',\n          'IntelliJ: 在Run Configuration中设置Working directory',\n          'Claude IDE: 确保workspace路径正确传递'\n        ]\n      })\n    }\n    \n    return recommendations\n  }\n\n  /**\n   * 清除缓存\n   */\n  clearCache() {\n    if (this.workspaceLocator) {\n      this.workspaceLocator.clearCache()\n    }\n    logger.debug('[DirectoryService] 缓存已清除')\n  }\n\n  /**\n   * 确保服务已初始化\n   */\n  async _ensureInitialized() {\n    if (!this.initialized) {\n      await this.initialize()\n    }\n  }\n\n  /**\n   * 重新加载配置\n   */\n  async reload(options = {}) {\n    this.initialized = false\n    this.clearCache()\n    await this.initialize(options)\n  }\n}\n\n// 创建全局单例\nconst globalDirectoryService = new DirectoryService()\n\n/**\n * 获取全局目录服务实例\n */\nfunction getDirectoryService() {\n  return globalDirectoryService\n}\n\nmodule.exports = {\n  DirectoryService,\n  getDirectoryService\n}","/**\n * PromptX 系统常量配置\n * 统一管理命令格式、路径等配置信息\n */\n\n// 包名配置（支持新旧两个包名）\nconst PACKAGE_NAMES = {\n  CURRENT: '@promptx/cli',    // 当前使用的包名\n  LEGACY: 'dpml-prompt',       // 旧版包名（向后兼容）\n  ALL: ['@promptx/cli', 'dpml-prompt']  // 所有支持的包名\n}\n\n// 根据环境变量决定命令前缀\nfunction getCommandPrefix() {\n  const env = process.env.PROMPTX_ENV\n  \n  if (env === 'development') {\n    return 'pnpm start'\n  } else {\n    return `npx ${PACKAGE_NAMES.CURRENT}@snapshot`\n  }\n}\n\nconst COMMAND_PREFIX = getCommandPrefix()\n\n// 静态命令常量\nconst COMMANDS = {\n  INIT: `${COMMAND_PREFIX} init`,\n  WELCOME: `${COMMAND_PREFIX} welcome`,\n  ACTION: `${COMMAND_PREFIX} action`,\n  LEARN: `${COMMAND_PREFIX} learn`,\n  RECALL: `${COMMAND_PREFIX} recall`,\n  REMEMBER: `${COMMAND_PREFIX} remember`,\n  HELP: `${COMMAND_PREFIX} help`\n}\n\n// 带参数的命令构建函数\nconst buildCommand = {\n  action: (roleId) => `${COMMAND_PREFIX} action ${roleId}`,\n  learn: (resource) => `${COMMAND_PREFIX} learn ${resource}`,\n  recall: (query = '') => `${COMMAND_PREFIX} recall${query ? ' ' + query : ''}`,\n  remember: (content = '<content>') => `${COMMAND_PREFIX} remember${content !== '<content>' ? ' \"' + content + '\"' : ' <content>'}`\n}\n\n// 为了向后兼容，保留函数式API\nfunction getCommands() {\n  return COMMANDS\n}\n\nfunction getBuildCommand() {\n  return buildCommand\n}\n\nfunction detectCommandPrefix() {\n  return COMMAND_PREFIX\n}\n\n\n\n// 系统路径配置（静态）\nconst PATHS = {\n  POUCH_DIR: '.promptx',\n  MEMORY_DIR: '.promptx/memory',\n  STATE_FILE: '.promptx/pouch.json',\n  MEMORY_FILE: '.promptx/memory/declarative.md'\n}\n\n// 版本信息\nconst VERSION = '0.0.1'\n\n// 系统状态\nconst STATES = {\n  INITIALIZED: 'initialized',\n  ROLE_DISCOVERY: 'role_discovery',\n  ACTION_PLAN_GENERATED: 'action_plan_generated',\n  LEARNED_ROLE: 'learned_role',\n  MEMORY_SAVED: 'memory_saved',\n  RECALL_WAITING: 'recall-waiting'\n}\n\n// 导出\nmodule.exports = {\n  // 固定命令前缀\n  COMMAND_PREFIX,\n  \n  // 命令常量\n  COMMANDS,\n  buildCommand,\n  \n  // 向后兼容的函数式API\n  getCommands,\n  getBuildCommand,\n  detectCommandPrefix,\n  \n  // 其他静态常量\n  PATHS,\n  PACKAGE_NAMES,\n  VERSION,\n  STATES\n}\n","const path = require('path')\nconst fs = require('fs')\nconst { getDirectoryService } = require('~/utils/DirectoryService')\nconst { PACKAGE_NAMES } = require('~/constants')\n\nclass ProtocolResolver {\n  constructor() {\n    this.packageRoot = null\n    this.__dirname = __dirname\n    this.directoryService = getDirectoryService()\n  }\n\n  parseReference(reference) {\n    // 支持 @、@!、@? 三种加载语义前缀\n    const match = reference.match(/^@([!?]?)(\\w+):\\/\\/(.+)$/)\n    if (!match) {\n      throw new Error(`Invalid reference format: ${reference}`)\n    }\n    \n    const loadingSemantic = match[1] || '' // '', '!', 或 '?'\n    const protocol = match[2]\n    const resourcePath = match[3]\n    \n    return {\n      loadingSemantic,\n      protocol,\n      resourcePath,\n      fullReference: reference\n    }\n  }\n\n  async resolve(reference) {\n    const { protocol, resourcePath, loadingSemantic } = this.parseReference(reference)\n    \n    switch (protocol) {\n      case 'package':\n        return await this.resolvePackage(resourcePath)\n      case 'project':\n        return await this.resolveProject(resourcePath)\n      case 'file':\n        return await this.resolveFile(resourcePath)\n      default:\n        throw new Error(`Unsupported protocol: ${protocol}`)\n    }\n  }\n\n  async resolvePackage(relativePath) {\n    if (!this.packageRoot) {\n      this.packageRoot = await this.findPackageRoot()\n    }\n    return path.resolve(this.packageRoot, relativePath)\n  }\n\n  async resolveProject(relativePath) {\n    try {\n      const context = {\n        startDir: process.cwd(),\n        platform: process.platform,\n        avoidUserHome: true\n      }\n      const projectRoot = await this.directoryService.getProjectRoot(context)\n      return path.resolve(projectRoot, relativePath)\n    } catch (error) {\n      // 回退到原始逻辑\n      return path.resolve(process.cwd(), relativePath)\n    }\n  }\n\n  async resolveFile(filePath) {\n    if (path.isAbsolute(filePath)) {\n      return filePath\n    }\n    \n    try {\n      const context = {\n        startDir: process.cwd(),\n        platform: process.platform,\n        avoidUserHome: true\n      }\n      const projectRoot = await this.directoryService.getProjectRoot(context)\n      return path.resolve(projectRoot, filePath)\n    } catch (error) {\n      // 回退到原始逻辑\n      return path.resolve(process.cwd(), filePath)\n    }\n  }\n\n  async findPackageRoot() {\n    let dir = this.__dirname\n    while (dir !== path.parse(dir).root) {\n      const packageJson = path.join(dir, 'package.json')\n      if (fs.existsSync(packageJson)) {\n        const pkg = JSON.parse(fs.readFileSync(packageJson, 'utf8'))\n        // 支持配置的包名列表，同时也支持 'promptx' 作为开发版本名称\n        if (pkg.name === 'promptx' || PACKAGE_NAMES.ALL.includes(pkg.name)) {\n          return dir\n        }\n      }\n      dir = path.dirname(dir)\n    }\n    throw new Error('PromptX package root not found')\n  }\n}\n\nmodule.exports = ProtocolResolver","/**\n * 资源数据类\n * 描述单个资源的完整元信息\n */\nclass ResourceData {\n  /**\n   * @param {Object} options - 资源配置选项\n   * @param {string} options.id - 资源唯一标识\n   * @param {string} options.source - 资源来源 ('package' | 'project' | 'user')\n   * @param {string} options.protocol - 资源协议/类型 ('role' | 'thought' | 'execution' | 'knowledge')\n   * @param {string} options.name - 资源名称\n   * @param {string} options.description - 资源描述\n   * @param {string} options.reference - 资源引用路径\n   * @param {Object} options.metadata - 额外元数据\n   */\n  constructor({\n    id,\n    source,\n    protocol,\n    name,\n    description,\n    reference,\n    metadata = {}\n  }) {\n    this.id = id\n    this.source = source\n    this.protocol = protocol\n    this.name = name\n    this.description = description\n    this.reference = reference\n    this.metadata = {\n      createdAt: new Date().toISOString(),\n      updatedAt: new Date().toISOString(),\n      ...metadata\n    }\n  }\n\n  /**\n   * 从原始数据创建ResourceData实例\n   * @param {Object} rawData - 原始数据\n   * @returns {ResourceData} ResourceData实例\n   */\n  static fromRawData(rawData) {\n    return new ResourceData(rawData)\n  }\n\n  /**\n   * 从文件路径和协议推断创建ResourceData\n   * @param {string} filePath - 文件路径（仅用于提取ID，不保存）\n   * @param {string} source - 资源来源\n   * @param {string} protocol - 资源协议\n   * @param {string} reference - 资源引用\n   * @returns {ResourceData} ResourceData实例\n   */\n  static fromFilePath(filePath, source, protocol, reference) {\n    const path = require('path')\n    const fileName = path.basename(filePath, `.${protocol}.md`)\n    \n    return new ResourceData({\n      id: fileName,\n      source,\n      protocol,\n      name: ResourceData._generateDefaultName(fileName, protocol),\n      description: ResourceData._generateDefaultDescription(fileName, protocol),\n      reference,\n      metadata: {\n        inferredFromFile: true\n      }\n    })\n  }\n\n  /**\n   * 生成默认名称\n   * @param {string} id - 资源ID\n   * @param {string} protocol - 资源协议\n   * @returns {string} 默认名称\n   * @private\n   */\n  static _generateDefaultName(id, protocol) {\n    const nameMap = {\n      'role': '角色',\n      'thought': '思维模式',\n      'execution': '执行模式',\n      'knowledge': '知识库'\n    }\n    \n    // 将kebab-case转换为可读名称\n    const readableName = id\n      .split('-')\n      .map(word => word.charAt(0).toUpperCase() + word.slice(1))\n      .join(' ')\n    \n    return `${readableName} ${nameMap[protocol] || protocol}`\n  }\n\n  /**\n   * 生成默认描述\n   * @param {string} id - 资源ID\n   * @param {string} protocol - 资源协议\n   * @returns {string} 默认描述\n   * @private\n   */\n  static _generateDefaultDescription(id, protocol) {\n    const descMap = {\n      'role': '专业角色，提供特定领域的专业能力',\n      'thought': '思维模式，指导AI的思考方式',\n      'execution': '执行模式，定义具体的行为模式',\n      'knowledge': '知识库，提供专业知识和信息'\n    }\n    \n    return descMap[protocol] || `${protocol}类型的资源`\n  }\n\n  /**\n   * 获取完整的资源ID（包含来源前缀）\n   * @returns {string} 完整资源ID\n   */\n  getFullId() {\n    // role类型不需要协议前缀，其他类型需要\n    const baseId = this.protocol === 'role' ? this.id : `${this.protocol}:${this.id}`\n    return `${this.source}:${baseId}`\n  }\n\n  /**\n   * 获取基础资源ID（不包含来源前缀）\n   * @returns {string} 基础资源ID\n   */\n  getBaseId() {\n    return this.protocol === 'role' ? this.id : `${this.protocol}:${this.id}`\n  }\n\n  /**\n   * 检查是否匹配指定的过滤条件\n   * @param {Object} filters - 过滤条件\n   * @returns {boolean} 是否匹配\n   */\n  matches(filters = {}) {\n    for (const [key, value] of Object.entries(filters)) {\n      if (value !== undefined && value !== null) {\n        if (Array.isArray(value)) {\n          if (!value.includes(this[key])) return false\n        } else {\n          if (this[key] !== value) return false\n        }\n      }\n    }\n    return true\n  }\n\n  /**\n   * 更新资源元数据\n   * @param {Object} updates - 更新数据\n   */\n  update(updates) {\n    Object.assign(this, updates)\n    this.metadata.updatedAt = new Date().toISOString()\n  }\n\n  /**\n   * 转换为JSON对象\n   * @returns {Object} JSON对象\n   */\n  toJSON() {\n    return {\n      id: this.id,\n      source: this.source,\n      protocol: this.protocol,\n      name: this.name,\n      description: this.description,\n      reference: this.reference,\n      metadata: this.metadata\n    }\n  }\n\n  /**\n   * 转换为简化的显示格式\n   * @returns {Object} 简化格式\n   */\n  toDisplayFormat() {\n    return {\n      id: this.id,\n      fullId: this.getFullId(),\n      baseId: this.getBaseId(),\n      name: this.name,\n      description: this.description,\n      source: this.source,\n      protocol: this.protocol\n    }\n  }\n\n  /**\n   * 动态获取文件路径\n   * 通过解析 reference 动态计算实际的文件路径\n   * @returns {Promise<string>} 文件路径\n   */\n  async getFilePath() {\n    const ProtocolResolver = require('./ProtocolResolver')\n    const resolver = new ProtocolResolver()\n    \n    try {\n      const resolvedPath = await resolver.resolve(this.reference)\n      return resolvedPath\n    } catch (error) {\n      throw new Error(`无法解析资源路径 ${this.reference}: ${error.message}`)\n    }\n  }\n\n  /**\n   * 克隆资源数据\n   * @returns {ResourceData} 克隆的实例\n   */\n  clone() {\n    return new ResourceData(this.toJSON())\n  }\n}\n\nmodule.exports = ResourceData ","const fs = require('fs-extra')\nconst path = require('path')\nconst ResourceData = require('./ResourceData')\n\n/**\n * 注册表数据管理器 v2.0\n * 基于ResourceData数组的全新架构，严格区分资源来源(source)和资源种类(protocol)\n */\nclass RegistryData {\n  /**\n   * @param {string} source - 注册表来源 ('package' | 'project' | 'user')\n   * @param {string} filePath - 注册表文件路径\n   * @param {Array<ResourceData>} resources - 资源数据数组\n   * @param {Object} metadata - 注册表元数据\n   */\n  constructor(source, filePath, resources = [], metadata = {}) {\n    this.source = source\n    this.filePath = filePath\n    this.resources = resources.map(r => r instanceof ResourceData ? r : ResourceData.fromRawData(r))\n    this.metadata = {\n      version: \"2.0.0\",\n      description: `${source} 级资源注册表`,\n      createdAt: new Date().toISOString(),\n      updatedAt: new Date().toISOString(),\n      ...metadata\n    }\n    this.cache = new Map()\n  }\n\n  /**\n   * 从文件加载注册表数据\n   * @param {string} source - 注册表来源\n   * @param {string} filePath - 文件路径\n   * @returns {Promise<RegistryData>} 注册表数据实例\n   */\n  static async fromFile(source, filePath) {\n    try {\n      const data = await fs.readJSON(filePath)\n      \n      // 处理新格式（v2.0）\n      if (data.version === \"2.0.0\" && Array.isArray(data.resources)) {\n        return new RegistryData(source, filePath, data.resources, data.metadata)\n      }\n      \n      // 处理旧格式（v1.0）- 自动转换\n      if (data.resources && typeof data.resources === 'object') {\n        const resources = []\n        for (const [protocol, resourcesOfType] of Object.entries(data.resources)) {\n          if (resourcesOfType && typeof resourcesOfType === 'object') {\n            for (const [id, reference] of Object.entries(resourcesOfType)) {\n              resources.push(ResourceData.fromFilePath(\n                reference.replace(/^@\\w+:\\/\\//, ''), \n                source, \n                protocol, \n                reference\n              ))\n            }\n          }\n        }\n        return new RegistryData(source, filePath, resources, { \n          migratedFrom: \"v1.0.0\",\n          originalTimestamp: data.timestamp \n        })\n      }\n      \n      throw new Error(`Unsupported registry format in ${filePath}`)\n    } catch (error) {\n      throw new Error(`Failed to load ${source} registry from ${filePath}: ${error.message}`)\n    }\n  }\n\n  /**\n   * 创建空的注册表数据\n   * @param {string} source - 注册表来源\n   * @param {string} filePath - 注册表文件路径\n   * @returns {RegistryData} 空注册表数据实例\n   */\n  static createEmpty(source, filePath) {\n    return new RegistryData(source, filePath, [], {\n      description: `${source} 级资源注册表`,\n      createdAt: new Date().toISOString()\n    })\n  }\n\n  /**\n   * 添加资源\n   * @param {ResourceData|Object} resource - 资源数据\n   */\n  addResource(resource) {\n    const resourceData = resource instanceof ResourceData ? resource : ResourceData.fromRawData(resource)\n    \n    // 对于merged类型的注册表，保持原始来源信息\n    // 只有在非merged注册表中才强制统一来源\n    if (this.source !== 'merged' && resourceData.source !== this.source) {\n      resourceData.source = this.source\n    }\n    \n    // 检查是否已存在相同ID的资源\n    const existingIndex = this.resources.findIndex(r => r.id === resourceData.id && r.protocol === resourceData.protocol)\n    \n    if (existingIndex >= 0) {\n      // 更新现有资源\n      this.resources[existingIndex] = resourceData\n    } else {\n      // 添加新资源\n      this.resources.push(resourceData)\n    }\n    \n    this._updateMetadata()\n    this.cache.clear()\n  }\n\n  /**\n   * 移除资源\n   * @param {string} id - 资源ID\n   * @param {string} protocol - 资源协议\n   * @returns {boolean} 是否成功移除\n   */\n  removeResource(id, protocol) {\n    const initialLength = this.resources.length\n    this.resources = this.resources.filter(r => !(r.id === id && r.protocol === protocol))\n    \n    const removed = this.resources.length < initialLength\n    if (removed) {\n      this._updateMetadata()\n      this.cache.clear()\n    }\n    \n    return removed\n  }\n\n  /**\n   * 查找资源\n   * @param {Object} filters - 过滤条件\n   * @returns {Array<ResourceData>} 匹配的资源数组\n   */\n  findResources(filters = {}) {\n    return this.resources.filter(resource => resource.matches(filters))\n  }\n\n  /**\n   * 根据ID查找资源\n   * @param {string} id - 资源ID\n   * @param {string} protocol - 资源协议（可选）\n   * @returns {ResourceData|null} 找到的资源\n   */\n  findResourceById(id, protocol = null) {\n    return this.resources.find(r => {\n      if (protocol) {\n        return r.id === id && r.protocol === protocol\n      }\n      return r.id === id\n    }) || null\n  }\n\n  /**\n   * 获取指定协议类型的所有资源\n   * @param {string} protocol - 资源协议\n   * @returns {Array<ResourceData>} 资源数组\n   */\n  getResourcesByProtocol(protocol) {\n    return this.resources.filter(r => r.protocol === protocol)\n  }\n\n  /**\n   * 获取资源Map（兼容旧接口）\n   * @param {boolean} includeSourcePrefix - 是否包含源前缀\n   * @returns {Map<string, string>} 资源ID到引用的映射\n   */\n  getResourceMap(includeSourcePrefix = true) {\n    const cacheKey = `resourceMap_${includeSourcePrefix}`\n    if (this.cache.has(cacheKey)) {\n      return this.cache.get(cacheKey)\n    }\n\n    const registry = new Map()\n    \n    for (const resource of this.resources) {\n      if (includeSourcePrefix) {\n        // 包含源前缀的完整ID\n        registry.set(resource.getFullId(), resource.reference)\n        // 同时也注册基础ID（用于向后兼容）\n        registry.set(resource.getBaseId(), resource.reference)\n      } else {\n        // 仅使用基础ID\n        registry.set(resource.getBaseId(), resource.reference)\n      }\n    }\n\n    this.cache.set(cacheKey, registry)\n    return registry\n  }\n\n  /**\n   * 获取所有资源数据\n   * @returns {Array<ResourceData>} 所有资源数组\n   */\n  getAllResources() {\n    return [...this.resources]\n  }\n\n  /**\n   * 获取统计信息\n   * @returns {Object} 统计信息\n   */\n  getStats() {\n    const stats = {\n      totalResources: this.resources.length,\n      byProtocol: {},\n      bySource: {}\n    }\n\n    for (const resource of this.resources) {\n      // 按协议统计\n      stats.byProtocol[resource.protocol] = (stats.byProtocol[resource.protocol] || 0) + 1\n      \n      // 按来源统计\n      stats.bySource[resource.source] = (stats.bySource[resource.source] || 0) + 1\n    }\n\n    return stats\n  }\n\n  /**\n   * 合并其他注册表数据\n   * @param {RegistryData} otherRegistry - 其他注册表数据\n   * @param {boolean} overwrite - 是否覆盖现有资源\n   */\n  merge(otherRegistry, overwrite = false) {\n    for (const resource of otherRegistry.resources) {\n      const existing = this.findResourceById(resource.id, resource.protocol)\n      \n      if (!existing || overwrite) {\n        this.addResource(resource.clone())\n      }\n    }\n  }\n\n  /**\n   * 保存注册表到文件\n   * @returns {Promise<void>}\n   */\n  async save() {\n    try {\n      // 确保目录存在\n      await fs.ensureDir(path.dirname(this.filePath))\n      \n      // 更新元数据\n      this._updateMetadata()\n      \n      // 构建保存数据\n      const saveData = {\n        version: this.metadata.version,\n        source: this.source,\n        metadata: this.metadata,\n        resources: this.resources.map(r => r.toJSON()),\n        stats: this.getStats()\n      }\n      \n      // 保存文件\n      await fs.writeJSON(this.filePath, saveData, { spaces: 2 })\n    } catch (error) {\n      throw new Error(`Failed to save ${this.source} registry to ${this.filePath}: ${error.message}`)\n    }\n  }\n\n  /**\n   * 更新元数据\n   * @private\n   */\n  _updateMetadata() {\n    this.metadata.updatedAt = new Date().toISOString()\n    this.metadata.resourceCount = this.resources.length\n  }\n\n  /**\n   * 获取注册表大小\n   * @returns {number} 资源数量\n   */\n  get size() {\n    return this.resources.length\n  }\n\n  /**\n   * 检查注册表是否为空\n   * @returns {boolean} 是否为空\n   */\n  isEmpty() {\n    return this.resources.length === 0\n  }\n\n  /**\n   * 清空所有资源\n   */\n  clear() {\n    this.resources = []\n    this._updateMetadata()\n    this.cache.clear()\n  }\n\n  /**\n   * 克隆注册表数据\n   * @returns {RegistryData} 克隆的注册表数据\n   */\n  clone() {\n    const clonedResources = this.resources.map(r => r.clone())\n    return new RegistryData(this.source, this.filePath, clonedResources, { ...this.metadata })\n  }\n\n  /**\n   * 转换为JSON对象\n   * @returns {Object} JSON对象\n   */\n  toJSON() {\n    return {\n      version: this.metadata.version,\n      source: this.source,\n      metadata: this.metadata,\n      resources: this.resources.map(r => r.toJSON()),\n      stats: this.getStats()\n    }\n  }\n}\n\nmodule.exports = RegistryData ","/**\n * 资源模块基础数据类型定义\n * 基于DPML资源协议标准\n */\n\n/**\n * 加载语义枚举\n */\nconst LoadingSemantics = {\n  DEFAULT: 'default', // @ - AI自行决定加载时机\n  HOT_LOAD: 'hot_load', // @! - 立即加载\n  LAZY_LOAD: 'lazy_load' // @? - 懒加载\n}\n\n/**\n * 解析后的资源引用\n */\nclass ParsedReference {\n  constructor () {\n    this.loadingSemantics = LoadingSemantics.DEFAULT\n    this.protocol = ''\n    this.path = ''\n    this.queryParams = new QueryParams()\n    this.isNested = false\n    this.nestedRef = null\n    this.originalRef = ''\n  }\n}\n\n/**\n * 查询参数\n */\nclass QueryParams {\n  constructor () {\n    this.line = null // 行范围 \"5-10\"\n    this.format = null // 输出格式 \"json\"\n    this.cache = null // 是否缓存，默认为null表示未设置\n    this.params = new Map() // 其他参数\n  }\n\n  /**\n   * 设置参数\n   */\n  set (key, value) {\n    if (['line', 'format', 'cache'].includes(key)) {\n      this[key] = value\n    } else {\n      this.params.set(key, value)\n    }\n  }\n\n  /**\n   * 获取参数\n   */\n  get (key) {\n    if (['line', 'format', 'cache'].includes(key)) {\n      return this[key]\n    }\n    return this.params.get(key)\n  }\n\n  /**\n   * 获取所有参数\n   */\n  getAll () {\n    const result = {}\n\n    // 只添加非null的内置参数\n    if (this.line !== null) {\n      result.line = this.line\n    }\n    if (this.format !== null) {\n      result.format = this.format\n    }\n    if (this.cache !== null) {\n      result.cache = this.cache\n    }\n\n    // 添加其他参数\n    for (const [key, value] of this.params) {\n      result[key] = value\n    }\n\n    return result\n  }\n\n  /**\n   * 转换为字符串用于缓存键\n   */\n  toString () {\n    const params = []\n\n    // 添加内置参数\n    if (this.line !== null) {\n      params.push(`line=${this.line}`)\n    }\n    if (this.format !== null) {\n      params.push(`format=${this.format}`)\n    }\n    if (this.cache !== null) {\n      params.push(`cache=${this.cache}`)\n    }\n\n    // 添加其他参数（按键排序以确保一致性）\n    const sortedParams = Array.from(this.params.entries()).sort()\n    for (const [key, value] of sortedParams) {\n      params.push(`${key}=${value}`)\n    }\n\n    return params.join('&')\n  }\n}\n\n/**\n * 嵌套引用\n */\nclass NestedReference {\n  constructor () {\n    this.outer = null // 外层引用\n    this.inner = null // 内层引用\n    this.depth = 0 // 嵌套深度\n  }\n}\n\n/**\n * 资源内容\n */\nclass ResourceContent {\n  constructor (path, content, metadata = {}) {\n    this.path = path\n    this.content = content\n    this.metadata = metadata\n    this.relativePath = ''\n    this.lastModified = null\n    this.size = content ? content.length : 0\n  }\n}\n\n/**\n * 懒加载资源\n */\nclass LazyResource {\n  constructor (path, loader) {\n    this.path = path\n    this.loader = loader\n    this.loaded = false\n    this._content = null\n  }\n\n  /**\n   * 加载资源\n   */\n  async load () {\n    if (!this.loaded) {\n      this._content = await this.loader(this.path)\n      this.loaded = true\n    }\n    return this._content\n  }\n}\n\n/**\n * 处理后的结果\n */\nclass ProcessedResult {\n  constructor () {\n    this.content = ''\n    this.metadata = {}\n    this.format = 'text'\n    this.sources = []\n    this.cached = false\n  }\n}\n\n/**\n * 最终资源结果\n */\nclass ResourceResult {\n  constructor () {\n    this.content = ''\n    this.metadata = {}\n    this.sources = []\n    this.format = 'text'\n    this.cached = false\n    this.loadTime = Date.now()\n    this.success = true\n    this.error = null\n  }\n\n  /**\n   * 创建成功结果\n   */\n  static success (content, metadata = {}) {\n    const result = new ResourceResult()\n    result.content = content\n    result.metadata = metadata\n    result.success = true\n    return result\n  }\n\n  /**\n   * 创建错误结果\n   */\n  static error (error, metadata = {}) {\n    const result = new ResourceResult()\n    result.success = false\n    result.error = error\n    result.metadata = metadata\n    return result\n  }\n}\n\n/**\n * 资源协议信息\n */\nclass ProtocolInfo {\n  constructor () {\n    this.name = ''\n    this.description = ''\n    this.location = '' // EBNF路径定义\n    this.params = {} // 支持的参数\n    this.registry = new Map() // ID到路径的映射\n  }\n}\n\nmodule.exports = {\n  LoadingSemantics,\n  ParsedReference,\n  QueryParams,\n  NestedReference,\n  ResourceContent,\n  LazyResource,\n  ProcessedResult,\n  ResourceResult,\n  ProtocolInfo\n}\n","const {\n  LoadingSemantics,\n  ParsedReference,\n  QueryParams,\n  NestedReference\n} = require('./types')\n\n/**\n * 资源协议解析器\n * 解析DPML资源引用语法：@protocol://path?params\n */\nclass ResourceProtocolParser {\n  constructor () {\n    // 资源引用正则表达式\n    this.resourceRefRegex = /^(@[!?]?|@)([a-zA-Z][a-zA-Z0-9_-]*):(.+)$/\n    this.nestedRefRegex = /^(@[!?]?|@)([a-zA-Z][a-zA-Z0-9_-]*):(@[!?]?|@)?(.+)$/\n    this.queryParamsRegex = /^([^?]+)(?:\\?(.+))?$/\n  }\n\n  /**\n   * 解析资源引用\n   * @param {string} resourceRef - 资源引用字符串\n   * @returns {ParsedReference} 解析后的引用对象\n   */\n  parse (resourceRef) {\n    if (!resourceRef || typeof resourceRef !== 'string') {\n      throw new Error('Invalid resource reference: must be a non-empty string')\n    }\n\n    const trimmedRef = resourceRef.trim()\n    if (!this.validateSyntax(trimmedRef)) {\n      throw new Error(`Invalid resource reference syntax: ${trimmedRef}`)\n    }\n\n    const parsed = new ParsedReference()\n    parsed.originalRef = trimmedRef\n\n    // 检查是否为嵌套引用\n    if (this.isNestedReference(trimmedRef)) {\n      return this.parseNestedReference(trimmedRef)\n    }\n\n    // 解析基础引用\n    return this.parseBasicReference(trimmedRef)\n  }\n\n  /**\n   * 解析基础资源引用\n   * @param {string} ref - 基础引用\n   * @returns {ParsedReference}\n   */\n  parseBasicReference (ref) {\n    const parsed = new ParsedReference()\n    parsed.originalRef = ref\n\n    // 解析加载语义\n    parsed.loadingSemantics = this.parseLoadingSemantics(ref)\n\n    // 移除加载语义前缀\n    const withoutSemantics = this.removeLoadingSemantics(ref)\n\n    // 匹配协议和路径\n    const match = withoutSemantics.match(/^([a-zA-Z][a-zA-Z0-9_-]*):(.+)$/)\n    if (!match) {\n      throw new Error(`Invalid protocol format: ${ref}`)\n    }\n\n    parsed.protocol = match[1]\n    let pathAndParams = match[2]\n\n    // 移除 :// 前缀（如果存在）\n    if (pathAndParams.startsWith('//')) {\n      pathAndParams = pathAndParams.substring(2)\n    }\n\n    // 解析路径和查询参数\n    const pathMatch = pathAndParams.match(this.queryParamsRegex)\n    if (pathMatch) {\n      parsed.path = pathMatch[1]\n      if (pathMatch[2]) {\n        parsed.queryParams = this.parseQueryParams(pathMatch[2])\n      }\n    } else {\n      parsed.path = pathAndParams\n    }\n\n    return parsed\n  }\n\n  /**\n   * 解析嵌套引用\n   * @param {string} ref - 嵌套引用\n   * @returns {ParsedReference}\n   */\n  parseNestedReference (ref) {\n    const parsed = new ParsedReference()\n    parsed.originalRef = ref\n    parsed.isNested = true\n\n    // 解析外层加载语义\n    parsed.loadingSemantics = this.parseLoadingSemantics(ref)\n    const withoutOuterSemantics = this.removeLoadingSemantics(ref)\n\n    // 匹配嵌套结构: protocol:@inner_protocol://path 或 protocol:inner_protocol://path\n    const match = withoutOuterSemantics.match(/^([a-zA-Z][a-zA-Z0-9_-]*):(.+)$/)\n    if (!match) {\n      throw new Error(`Invalid nested reference format: ${ref}`)\n    }\n\n    parsed.protocol = match[1]\n    let innerRef = match[2]\n\n    // 处理内层引用：移除可能的 :// 前缀，但保留 @ 前缀\n    if (innerRef.startsWith('//')) {\n      innerRef = innerRef.substring(2)\n    }\n\n    // 确保内层引用有正确的格式\n    if (!innerRef.startsWith('@')) {\n      innerRef = '@' + innerRef\n    }\n\n    // 递归解析内层引用\n    try {\n      const innerParsed = this.parse(innerRef)\n\n      // 创建嵌套引用结构\n      const nested = new NestedReference()\n      nested.outer = parsed\n      nested.inner = innerParsed\n      nested.depth = this.calculateNestingDepth(innerParsed)\n\n      parsed.nestedRef = nested\n    } catch (error) {\n      throw new Error(`Invalid nested inner reference: ${error.message}`)\n    }\n\n    return parsed\n  }\n\n  /**\n   * 解析加载语义\n   * @param {string} ref - 资源引用\n   * @returns {string} 加载语义\n   */\n  parseLoadingSemantics (ref) {\n    if (ref.startsWith('@!')) {\n      return LoadingSemantics.HOT_LOAD\n    } else if (ref.startsWith('@?')) {\n      return LoadingSemantics.LAZY_LOAD\n    } else if (ref.startsWith('@')) {\n      return LoadingSemantics.DEFAULT\n    }\n\n    throw new Error(`Invalid loading semantics: ${ref}`)\n  }\n\n  /**\n   * 移除加载语义前缀\n   * @param {string} ref - 资源引用\n   * @returns {string} 移除前缀后的引用\n   */\n  removeLoadingSemantics (ref) {\n    if (ref.startsWith('@!') || ref.startsWith('@?')) {\n      return ref.substring(2)\n    } else if (ref.startsWith('@')) {\n      return ref.substring(1)\n    }\n    return ref\n  }\n\n  /**\n   * 解析查询参数\n   * @param {string} queryString - 查询字符串\n   * @returns {QueryParams} 查询参数对象\n   */\n  parseQueryParams (queryString) {\n    const params = new QueryParams()\n\n    if (!queryString) {\n      return params\n    }\n\n    const pairs = queryString.split('&')\n    for (const pair of pairs) {\n      const [key, value] = pair.split('=').map(decodeURIComponent)\n\n      if (key) {\n        // 处理特殊参数\n        if (key === 'cache') {\n          params.set(key, value === 'true' || value === '1')\n        } else {\n          params.set(key, value || '')\n        }\n      }\n    }\n\n    return params\n  }\n\n  /**\n   * 验证语法\n   * @param {string} ref - 资源引用\n   * @returns {boolean} 是否有效\n   */\n  validateSyntax (ref) {\n    if (!ref) return false\n\n    // 必须以@开头\n    if (!ref.startsWith('@')) return false\n\n    // 基本格式检查\n    const withoutSemantics = this.removeLoadingSemantics(ref)\n    return /^[a-zA-Z][a-zA-Z0-9_-]*:.+$/.test(withoutSemantics)\n  }\n\n  /**\n   * 检查是否为嵌套引用\n   * @param {string} ref - 资源引用\n   * @returns {boolean} 是否为嵌套引用\n   */\n  isNestedReference (ref) {\n    const withoutSemantics = this.removeLoadingSemantics(ref)\n    const colonIndex = withoutSemantics.indexOf(':')\n\n    if (colonIndex === -1) return false\n\n    const afterColon = withoutSemantics.substring(colonIndex + 1)\n\n    // 检查是否包含内层引用 (@protocol: 或 protocol:)\n    return afterColon.includes('@') || afterColon.includes('://')\n  }\n\n  /**\n   * 计算嵌套深度\n   * @param {ParsedReference} ref - 解析后的引用\n   * @returns {number} 嵌套深度\n   */\n  calculateNestingDepth (ref) {\n    if (!ref.isNested) return 1\n    return 1 + this.calculateNestingDepth(ref.nestedRef.inner)\n  }\n\n  /**\n   * 提取协议名\n   * @param {string} ref - 资源引用\n   * @returns {string} 协议名\n   */\n  extractProtocol (ref) {\n    const withoutSemantics = this.removeLoadingSemantics(ref)\n    const colonIndex = withoutSemantics.indexOf(':')\n    return colonIndex > 0 ? withoutSemantics.substring(0, colonIndex) : ''\n  }\n\n  /**\n   * 提取路径\n   * @param {string} ref - 资源引用\n   * @returns {string} 路径\n   */\n  extractPath (ref) {\n    const withoutSemantics = this.removeLoadingSemantics(ref)\n    const colonIndex = withoutSemantics.indexOf(':')\n    if (colonIndex === -1) return ''\n\n    let pathAndParams = withoutSemantics.substring(colonIndex + 1)\n\n    // 移除 :// 前缀（如果存在）\n    if (pathAndParams.startsWith('//')) {\n      pathAndParams = pathAndParams.substring(2)\n    }\n\n    const queryIndex = pathAndParams.indexOf('?')\n    return queryIndex > 0 ? pathAndParams.substring(0, queryIndex) : pathAndParams\n  }\n\n  /**\n   * 提取查询参数字符串\n   * @param {string} ref - 资源引用\n   * @returns {string} 查询参数字符串\n   */\n  extractParams (ref) {\n    const queryIndex = ref.indexOf('?')\n    return queryIndex > 0 ? ref.substring(queryIndex + 1) : ''\n  }\n}\n\nmodule.exports = ResourceProtocolParser\n","/**\n * BaseDiscovery - 资源发现基础抽象类\n * \n * 按照DPML协议架构文档设计，提供统一的资源发现接口\n * 所有具体的Discovery实现都应该继承这个基类\n */\nclass BaseDiscovery {\n  /**\n   * 构造函数\n   * @param {string} source - 发现源类型 (PACKAGE, PROJECT, USER, INTERNET)\n   * @param {number} priority - 优先级，数字越小优先级越高\n   */\n  constructor(source, priority = 0) {\n    if (!source) {\n      throw new Error('Discovery source is required')\n    }\n    \n    this.source = source\n    this.priority = priority\n    this.cache = new Map()\n  }\n\n  /**\n   * 抽象方法：发现资源\n   * 子类必须实现此方法\n   * @returns {Promise<Array>} 发现的资源列表\n   */\n  async discover() {\n    throw new Error('discover method must be implemented by subclass')\n  }\n\n  /**\n   * 获取发现器信息\n   * @returns {Object} 发现器元数据\n   */\n  getDiscoveryInfo() {\n    return {\n      source: this.source,\n      priority: this.priority,\n      description: `${this.source} resource discovery`\n    }\n  }\n\n  /**\n   * 验证资源结构\n   * @param {Object} resource - 待验证的资源对象\n   * @throws {Error} 如果资源结构无效\n   */\n  validateResource(resource) {\n    if (!resource || typeof resource !== 'object') {\n      throw new Error('Resource must be an object')\n    }\n\n    if (!resource.id || !resource.reference) {\n      throw new Error('Resource must have id and reference')\n    }\n\n    // 验证ID格式 (protocol:resourcePath)\n    if (typeof resource.id !== 'string' || !resource.id.includes(':')) {\n      throw new Error('Resource id must be in format \"protocol:resourcePath\"')\n    }\n\n    // 验证引用格式 (@protocol://path)\n    if (typeof resource.reference !== 'string' || !resource.reference.startsWith('@')) {\n      throw new Error('Resource reference must be in DPML format \"@protocol://path\"')\n    }\n  }\n\n  /**\n   * 规范化资源对象，添加元数据\n   * @param {Object} resource - 原始资源对象\n   * @returns {Object} 规范化后的资源对象\n   */\n  normalizeResource(resource) {\n    // 验证资源结构\n    this.validateResource(resource)\n\n    // 创建规范化的资源对象\n    const normalizedResource = {\n      id: resource.id,\n      reference: resource.reference,\n      metadata: {\n        source: this.source,\n        priority: this.priority,\n        timestamp: new Date(),\n        ...resource.metadata // 保留现有元数据\n      }\n    }\n\n    return normalizedResource\n  }\n\n  /**\n   * 清理缓存\n   */\n  clearCache() {\n    this.cache.clear()\n  }\n\n  /**\n   * 获取缓存大小\n   * @returns {number} 缓存条目数量\n   */\n  getCacheSize() {\n    return this.cache.size\n  }\n\n  /**\n   * 从缓存获取资源\n   * @param {string} key - 缓存键\n   * @returns {*} 缓存的值或undefined\n   */\n  getFromCache(key) {\n    return this.cache.get(key)\n  }\n\n  /**\n   * 设置缓存\n   * @param {string} key - 缓存键\n   * @param {*} value - 缓存值\n   */\n  setCache(key, value) {\n    this.cache.set(key, value)\n  }\n}\n\nmodule.exports = BaseDiscovery","/**\n * 包级资源发现器 - 从 @promptx/resource 包加载系统内置资源\n * 新版本：直接从 npm 包加载，不再依赖文件系统扫描\n */\n\nconst BaseDiscovery = require('./BaseDiscovery')\nconst logger = require('@promptx/logger')\n\n/**\n * 包级资源发现器\n * 负责从 @promptx/resource 包加载系统内置的角色、工具等资源\n */\nclass PackageDiscovery extends BaseDiscovery {\n  constructor(resourceManager) {\n    super('PACKAGE')\n    this.resourceManager = resourceManager\n  }\n\n  /**\n   * 发现包级资源 - 从 @promptx/resource 包加载\n   * @returns {Promise<Array>} 发现的资源列表\n   */\n  async discover() {\n    try {\n      // 使用新的 @promptx/resource API\n      const { registry } = require('@promptx/resource')\n      \n      if (!registry) {\n        logger.warn('[PackageDiscovery] @promptx/resource 注册表未正确加载')\n        return []\n      }\n      const resources = []\n      \n      // v2.0.0 格式：resources 是数组\n      if (Array.isArray(registry.resources)) {\n        for (const resource of registry.resources) {\n          resources.push({\n            id: resource.id,\n            type: resource.protocol,  // 使用 protocol 字段\n            path: resource.metadata?.path || resource.reference,\n            name: resource.name || resource.id,\n            metadata: {\n              description: resource.description,\n              modified: resource.metadata?.modified,\n              size: resource.metadata?.size,\n              source: 'package',  // 小写以保持一致\n              packageName: '@promptx/resource'\n            }\n          })\n        }\n      }\n      \n      logger.info(`[PackageDiscovery] ✅ 从 @promptx/resource 加载了 ${resources.length} 个系统资源`)\n      return resources\n\n    } catch (error) {\n      // 如果包不存在或加载失败，返回空数组（不阻塞其他发现器）\n      logger.warn(`[PackageDiscovery] ⚠️ 加载 @promptx/resource 失败: ${error.message}`)\n      return []\n    }\n  }\n\n  /**\n   * 发现包级资源注册表\n   * @returns {Promise<Map>} 资源注册表 Map<resourceId, reference>\n   */\n  async discoverRegistry() {\n    try {\n      // 使用新的 @promptx/resource API\n      const { registry } = require('@promptx/resource')\n      \n      if (!registry) {\n        logger.warn('[PackageDiscovery] @promptx/resource 注册表未正确加载')\n        return new Map()\n      }\n\n      const registryMap = new Map()\n      \n      // v2.0.0 格式：resources 是数组\n      if (Array.isArray(registry.resources)) {\n        for (const resource of registry.resources) {\n          // 添加多种引用格式\n          const reference = resource.reference || `@package://resources/${resource.metadata?.path}`\n          registryMap.set(resource.id, reference)\n          registryMap.set(`package:${resource.id}`, reference)\n        }\n      }\n      \n      if (registryMap.size > 0) {\n        logger.info(`[PackageDiscovery] ✅ 从 @promptx/resource 加载了 ${registryMap.size / 2} 个系统资源到注册表`)\n      }\n      \n      return registryMap\n\n    } catch (error) {\n      logger.warn(`[PackageDiscovery] ⚠️ 系统资源注册表加载失败: ${error.message}`)\n      return new Map()\n    }\n  }\n\n  /**\n   * 获取包资源的基础目录（用于文件访问）\n   * @returns {Promise<string>} 包资源目录路径\n   */\n  async getPackageRoot() {\n    try {\n      // 获取 @promptx/resource 包的实际路径\n      const resourcePackagePath = require.resolve('@promptx/resource')\n      const path = require('path')\n      \n      // 找到包的根目录（包含 package.json 的目录）\n      let currentDir = path.dirname(resourcePackagePath)\n      while (currentDir !== path.dirname(currentDir)) {\n        const packageJsonPath = path.join(currentDir, 'package.json')\n        try {\n          const packageJson = require(packageJsonPath)\n          if (packageJson.name === '@promptx/resource') {\n            return currentDir\n          }\n        } catch {\n          // 继续向上查找\n        }\n        currentDir = path.dirname(currentDir)\n      }\n      \n      throw new Error('无法找到 @promptx/resource 包的根目录')\n    } catch (error) {\n      logger.error(`[PackageDiscovery] ❌ 获取包根目录失败: ${error.message}`)\n      throw error\n    }\n  }\n\n  /**\n   * 获取注册表数据（ResourceManager 需要的方法）\n   * @returns {Promise<RegistryData>} 注册表数据实例\n   */\n  async getRegistryData() {\n    try {\n      logger.info('[PackageDiscovery] Starting getRegistryData...')\n      const { registry } = require('@promptx/resource')\n      logger.info('[PackageDiscovery] @promptx/resource loaded successfully')\n      const RegistryData = require('../RegistryData')\n      const ResourceData = require('../ResourceData')\n      \n      if (!registry) {\n        logger.warn('[PackageDiscovery] Registry is empty')\n        return new RegistryData('package', '', [])\n      }\n      \n      logger.info(`[PackageDiscovery] Registry loaded with ${registry.resources?.length || 0} resources`)\n      const resources = []\n      \n      // v2.0.0 格式：resources 是数组，直接处理\n      if (Array.isArray(registry.resources)) {\n        for (const resource of registry.resources) {\n          resources.push(new ResourceData({\n            id: resource.id,\n            source: 'package',  // 使用小写保持一致\n            protocol: resource.protocol,  // 直接使用资源的 protocol 字段\n            name: resource.name || resource.id,\n            description: resource.description || '',\n            reference: resource.reference,\n            metadata: resource.metadata || {}\n          }))\n        }\n      }\n      \n      logger.info(`[PackageDiscovery] Successfully created ${resources.length} ResourceData objects`)\n      return new RegistryData('package', '@promptx/resource', resources)\n    } catch (error) {\n      logger.error(`[PackageDiscovery] Error in getRegistryData: ${error.message}`)\n      logger.error(`[PackageDiscovery] Stack trace: ${error.stack}`)\n      logger.warn(`[PackageDiscovery] 获取注册表数据失败: ${error.message}`)\n      const RegistryData = require('../RegistryData')\n      return new RegistryData('package', '', [])\n    }\n  }\n\n  /**\n   * 获取环境信息（用于调试）\n   */\n  getEnvironmentInfo() {\n    return {\n      type: 'PackageDiscovery',\n      source: '@promptx/resource',\n      loaded: this._tryRequirePackage() !== null\n    }\n  }\n\n  /**\n   * 尝试加载包（内部辅助方法）\n   */\n  _tryRequirePackage() {\n    try {\n      const { registry } = require('@promptx/resource')\n      return registry ? { registry } : null\n    } catch {\n      return null\n    }\n  }\n}\n\nmodule.exports = PackageDiscovery","const logger = require('@promptx/logger')\nconst RegistryData = require('../RegistryData')\nconst ResourceData = require('../ResourceData')\nconst fs = require('fs-extra')\nconst path = require('path')\n\n/**\n * ProjectDiscovery - 项目级资源发现器（恢复重构前完整逻辑）\n * \n * 核心设计原则：\n * 1. 完全基于@project协议，支持HTTP/本地模式\n * 2. 优先使用注册表，fallback到动态扫描  \n * 3. 恢复重构前的专业目录结构处理能力\n * 4. 恢复完整的ResourceData构建和文件验证逻辑\n */\nclass ProjectDiscovery {\n  constructor() {\n    this.source = 'PROJECT'\n    this.priority = 2\n    this.projectProtocol = null\n  }\n\n  /**\n   * 获取ProjectProtocol实例\n   */\n  getProjectProtocol() {\n    if (!this.projectProtocol) {\n      const { getGlobalResourceManager } = require('../../resource')\n      const resourceManager = getGlobalResourceManager()\n      this.projectProtocol = resourceManager.protocols.get('project')\n    }\n    return this.projectProtocol\n  }\n\n  /**\n   * 发现项目级资源注册表\n   * @returns {Promise<Map>} 资源注册表 Map<resourceId, reference>\n   */\n  async discoverRegistry() {\n    try {\n      // 1. 优先尝试从注册表加载\n      const registryMap = await this.loadFromRegistry()\n      if (registryMap.size > 0) {\n        logger.debug(`ProjectDiscovery 从注册表加载 ${registryMap.size} 个资源`)\n        return registryMap\n      }\n\n      // 2. Fallback: 动态扫描生成注册表\n      logger.debug('ProjectDiscovery 注册表不存在，使用动态扫描')\n      const resources = await this.scanProjectResources()\n      return this.buildRegistryFromResources(resources)\n\n    } catch (error) {\n      logger.warn(`[ProjectDiscovery] Registry discovery failed: ${error.message}`)\n      return new Map()\n    }\n  }\n\n  /**\n   * 从注册表文件加载资源\n   * @returns {Promise<Map>} 资源注册表\n   */\n  async loadFromRegistry() {\n    try {\n      const protocol = this.getProjectProtocol()\n      \n      // 使用@project协议检查注册表文件\n      const registryPath = await protocol.resolvePath('.promptx/resource/project.registry.json')\n      \n      if (!await fs.pathExists(registryPath)) {\n        return new Map()\n      }\n\n      // 加载并解析注册表\n      const registryData = await RegistryData.fromFile('project', registryPath)\n      return registryData.getResourceMap(true) // 带前缀\n      \n    } catch (error) {\n      logger.warn(`[ProjectDiscovery] Failed to load registry: ${error.message}`)\n      return new Map()\n    }\n  }\n\n  /**\n   * 动态扫描项目资源 - 恢复重构前的专业扫描逻辑\n   * @returns {Promise<Array>} 资源列表\n   */\n  async scanProjectResources() {\n    try {\n      const protocol = this.getProjectProtocol()\n      \n      // 使用@project协议获取资源目录\n      const resourceDir = await protocol.resolvePath('.promptx/resource')\n      \n      if (!await fs.pathExists(resourceDir)) {\n        logger.debug('ProjectDiscovery 项目资源目录不存在')\n        return []\n      }\n\n      // 创建临时注册表来收集资源\n      const tempRegistry = RegistryData.createEmpty('project', null)\n      \n      // 扫描专业目录结构\n      await this._scanDirectory(resourceDir, tempRegistry)\n      \n      // 转换为资源列表\n      const resources = []\n      for (const resource of tempRegistry.resources) {\n        resources.push({\n          id: resource.id,\n          protocol: resource.protocol,\n          reference: resource.reference,\n          source: resource.source\n        })\n      }\n\n      logger.info(`[ProjectDiscovery] ✅ 项目扫描完成，发现 ${resources.length} 个资源`)\n      return resources\n      \n    } catch (error) {\n      logger.warn(`[ProjectDiscovery] 扫描项目资源失败: ${error.message}`)\n      return []\n    }\n  }\n\n  /**\n   * 扫描目录并添加资源到注册表（通用递归扫描）\n   * @param {string} resourcesDir - 资源目录\n   * @param {RegistryData} registryData - 注册表数据\n   * @private\n   */\n  async _scanDirectory(resourcesDir, registryData) {\n    try {\n      // 递归扫描整个resource目录\n      await this._recursiveScan(resourcesDir, '', registryData)\n    } catch (error) {\n      logger.warn(`[ProjectDiscovery] 扫描资源目录失败: ${error.message}`)\n    }\n  }\n\n  /**\n   * 递归扫描目录\n   * @param {string} currentPath - 当前扫描路径\n   * @param {string} relativePath - 相对于resource目录的路径\n   * @param {RegistryData} registryData - 注册表数据\n   * @private\n   */\n  async _recursiveScan(currentPath, relativePath, registryData) {\n    try {\n      const items = await fs.readdir(currentPath)\n      \n      for (const item of items) {\n        const itemPath = path.join(currentPath, item)\n        const stat = await fs.stat(itemPath)\n        const newRelativePath = relativePath ? `${relativePath}/${item}` : item\n        \n        if (stat.isDirectory()) {\n          // 递归扫描子目录\n          await this._recursiveScan(itemPath, newRelativePath, registryData)\n        } else {\n          // 处理文件\n          await this._processFile(itemPath, newRelativePath, registryData)\n        }\n      }\n    } catch (error) {\n      logger.warn(`[ProjectDiscovery] 扫描${currentPath}失败: ${error.message}`)\n    }\n  }\n\n  /**\n   * 处理单个文件\n   * @param {string} filePath - 文件完整路径\n   * @param {string} relativePath - 相对路径\n   * @param {RegistryData} registryData - 注册表数据\n   * @private\n   */\n  async _processFile(filePath, relativePath, registryData) {\n    const fileName = path.basename(filePath)\n    let protocol = null\n    let resourceId = null\n    \n    // 根据文件名后缀识别资源类型\n    if (fileName.endsWith('.role.md')) {\n      protocol = 'role'\n      resourceId = path.basename(fileName, '.role.md')\n    } else if (fileName.endsWith('.thought.md')) {\n      protocol = 'thought'\n      resourceId = path.basename(fileName, '.thought.md')\n    } else if (fileName.endsWith('.execution.md')) {\n      protocol = 'execution'\n      resourceId = path.basename(fileName, '.execution.md')\n    } else if (fileName.endsWith('.knowledge.md')) {\n      protocol = 'knowledge'\n      resourceId = path.basename(fileName, '.knowledge.md')\n    } else if (fileName.endsWith('.tool.js')) {\n      protocol = 'tool'\n      resourceId = path.basename(fileName, '.tool.js')\n    } else if (fileName.endsWith('.manual.md')) {\n      protocol = 'manual'\n      resourceId = path.basename(fileName, '.manual.md')\n    }\n    \n    if (protocol && resourceId) {\n      // 验证文件内容\n      if (await this._validateResourceFile(filePath, protocol)) {\n        const reference = `@project://.promptx/resource/${relativePath}`\n        \n        const resourceData = new ResourceData({\n          id: resourceId,\n          source: 'project',\n          protocol: protocol,\n          name: ResourceData._generateDefaultName(resourceId, protocol),\n          description: ResourceData._generateDefaultDescription(resourceId, protocol),\n          reference: reference,\n          metadata: {\n            scannedAt: new Date().toISOString(),\n            path: relativePath\n          }\n        })\n        \n        registryData.addResource(resourceData)\n        logger.debug(`[ProjectDiscovery] 发现${protocol}资源: ${resourceId} at ${relativePath}`)\n      }\n    }\n  }\n\n\n  /**\n   * 验证资源文件格式（恢复重构前逻辑）\n   * @param {string} filePath - 文件路径\n   * @param {string} protocol - 协议类型\n   * @returns {Promise<boolean>} 是否是有效的资源文件\n   */\n  async _validateResourceFile(filePath, protocol) {\n    try {\n      const content = await fs.readFile(filePath, 'utf8')\n\n      if (!content || typeof content !== 'string') {\n        return false\n      }\n\n      const trimmedContent = content.trim()\n      if (trimmedContent.length === 0) {\n        return false\n      }\n\n      // 根据协议类型验证DPML标签\n      switch (protocol) {\n        case 'role':\n          return trimmedContent.includes('<role>') && trimmedContent.includes('</role>')\n        case 'execution':\n          return trimmedContent.includes('<execution>') && trimmedContent.includes('</execution>')\n        case 'thought':\n          return trimmedContent.includes('<thought>') && trimmedContent.includes('</thought>')\n        case 'knowledge':\n          // knowledge类型比较灵活，只要文件有内容就认为是有效的\n          return true\n        case 'manual':\n          return trimmedContent.includes('<manual>') && trimmedContent.includes('</manual>')\n        case 'tool':\n          // tool文件是JavaScript，进行基本的语法验证\n          try {\n            new Function(trimmedContent)\n            return true\n          } catch (e) {\n            logger.warn(`[ProjectDiscovery] Invalid JavaScript in tool file ${filePath}: ${e.message}`)\n            return false\n          }\n        default:\n          return false\n      }\n    } catch (error) {\n      logger.warn(`[ProjectDiscovery] Failed to validate ${filePath}: ${error.message}`)\n      return false\n    }\n  }\n\n  /**\n   * 从资源列表构建注册表Map\n   * @param {Array} resources - 资源列表\n   * @returns {Map} 资源注册表\n   */\n  buildRegistryFromResources(resources) {\n    const registryMap = new Map()\n    \n    resources.forEach(resource => {\n      const key = `project:${resource.id}`\n      registryMap.set(key, resource.reference)\n    })\n    \n    return registryMap\n  }\n\n  /**\n   * 生成并保存项目注册表文件\n   * @returns {Promise<RegistryData>} 生成的注册表数据\n   */\n  async generateRegistry() {\n    try {\n      const protocol = this.getProjectProtocol()\n      \n      // 获取注册表文件路径\n      const registryPath = await protocol.resolvePath('.promptx/resource/project.registry.json')\n      \n      // 创建注册表数据\n      const registryData = RegistryData.createEmpty('project', registryPath)\n      \n      // 扫描资源目录\n      const resourceDir = await protocol.resolvePath('.promptx/resource')\n      \n      if (await fs.pathExists(resourceDir)) {\n        await this._scanDirectory(resourceDir, registryData)\n      }\n      \n      // 确保目录存在\n      await fs.ensureDir(path.dirname(registryPath))\n      \n      // 保存注册表\n      await registryData.save()\n      \n      logger.info(`[ProjectDiscovery] ✅ 项目注册表生成完成，发现 ${registryData.size} 个资源`)\n      return registryData\n      \n    } catch (error) {\n      logger.error(`[ProjectDiscovery] 生成注册表失败: ${error.message}`)\n      return RegistryData.createEmpty('project')\n    }\n  }\n\n  /**\n   * 获取注册表数据（兼容旧接口）\n   * @returns {Promise<RegistryData>} 注册表数据\n   */\n  async getRegistryData() {\n    try {\n      const protocol = this.getProjectProtocol()\n      const registryPath = await protocol.resolvePath('.promptx/resource/project.registry.json')\n      \n      if (await fs.pathExists(registryPath)) {\n        const registryData = await RegistryData.fromFile('project', registryPath)\n        \n        if (registryData.size > 0) {\n          logger.info(`[ProjectDiscovery] 📋 从注册表加载 ${registryData.size} 个资源`)\n          return registryData\n        }\n      }\n      \n      // 动态生成注册表\n      logger.info(`[ProjectDiscovery] 📋 项目注册表无效，重新生成`)\n      return await this.generateRegistry()\n      \n    } catch (error) {\n      logger.error(`[ProjectDiscovery] 获取注册表数据失败: ${error.message}`)\n      return RegistryData.createEmpty('project')\n    }\n  }\n}\n\nmodule.exports = ProjectDiscovery","const BaseDiscovery = require('./BaseDiscovery')\nconst logger = require('@promptx/logger')\nconst RegistryData = require('../RegistryData')\nconst ResourceData = require('../ResourceData')\nconst fs = require('fs-extra')\nconst path = require('path')\n\n/**\n * UserDiscovery - User 级资源发现器\n * \n * 核心设计原则：\n * 1. 基于 @user 协议，扫描 ~/.promptx/resource 目录\n * 2. 优先使用注册表，fallback 到动态扫描\n * 3. 与 ProjectDiscovery 保持相同的目录结构和扫描逻辑\n * 4. User 级资源具有最高优先级（priority = 3）\n */\nclass UserDiscovery extends BaseDiscovery {\n  constructor() {\n    super('USER', 3)  // source = 'USER', priority = 3 (最高优先级)\n    this.userProtocol = null\n  }\n\n  /**\n   * 获取 UserProtocol 实例\n   */\n  getUserProtocol() {\n    if (!this.userProtocol) {\n      const { getGlobalResourceManager } = require('../../resource')\n      const resourceManager = getGlobalResourceManager()\n      this.userProtocol = resourceManager.protocols.get('user')\n    }\n    return this.userProtocol\n  }\n\n  /**\n   * 发现 User 级资源注册表\n   * @returns {Promise<Map>} 资源注册表 Map<resourceId, reference>\n   */\n  async discoverRegistry() {\n    try {\n      // 1. 优先尝试从注册表加载\n      const registryMap = await this.loadFromRegistry()\n      if (registryMap.size > 0) {\n        logger.debug(`UserDiscovery 从注册表加载 ${registryMap.size} 个资源`)\n        return registryMap\n      }\n\n      // 2. Fallback: 动态扫描生成注册表\n      logger.debug('UserDiscovery 注册表不存在，使用动态扫描')\n      const resources = await this.scanUserResources()\n      return this.buildRegistryFromResources(resources)\n\n    } catch (error) {\n      logger.warn(`[UserDiscovery] Registry discovery failed: ${error.message}`)\n      return new Map()\n    }\n  }\n\n  /**\n   * 从注册表文件加载资源\n   * @returns {Promise<Map>} 资源注册表\n   */\n  async loadFromRegistry() {\n    try {\n      const protocol = this.getUserProtocol()\n      \n      // 使用 @user 协议检查注册表文件\n      const registryPath = await protocol.resolvePath('.promptx/resource/user.registry.json')\n      \n      if (!await fs.pathExists(registryPath)) {\n        return new Map()\n      }\n\n      // 加载并解析注册表\n      const registryData = await RegistryData.fromFile('user', registryPath)\n      return registryData.getResourceMap(true) // 带前缀\n      \n    } catch (error) {\n      logger.warn(`[UserDiscovery] Failed to load registry: ${error.message}`)\n      return new Map()\n    }\n  }\n\n  /**\n   * 动态扫描 User 资源\n   * @returns {Promise<Array>} 资源列表\n   */\n  async scanUserResources() {\n    try {\n      const protocol = this.getUserProtocol()\n      \n      // 使用 @user 协议获取资源目录\n      const resourceDir = await protocol.resolvePath('.promptx/resource')\n      \n      if (!await fs.pathExists(resourceDir)) {\n        logger.debug('UserDiscovery User 资源目录不存在')\n        return []\n      }\n\n      // 创建临时注册表来收集资源\n      const tempRegistry = RegistryData.createEmpty('user', null)\n      \n      // 扫描目录结构（复用 ProjectDiscovery 的扫描逻辑）\n      await this._scanDirectory(resourceDir, tempRegistry)\n      \n      // 转换为资源列表\n      const resources = []\n      for (const resource of tempRegistry.resources) {\n        resources.push({\n          id: resource.id,\n          protocol: resource.protocol,\n          reference: resource.reference,\n          source: resource.source\n        })\n      }\n\n      logger.info(`[UserDiscovery] ✅ User 扫描完成，发现 ${resources.length} 个资源`)\n      return resources\n      \n    } catch (error) {\n      logger.warn(`[UserDiscovery] 扫描 User 资源失败: ${error.message}`)\n      return []\n    }\n  }\n\n  /**\n   * 扫描目录并添加资源到注册表\n   * @param {string} resourcesDir - 资源目录\n   * @param {RegistryData} registryData - 注册表数据\n   * @private\n   */\n  async _scanDirectory(resourcesDir, registryData) {\n    try {\n      // 递归扫描整个 resource 目录\n      await this._recursiveScan(resourcesDir, '', registryData)\n    } catch (error) {\n      logger.warn(`[UserDiscovery] 扫描资源目录失败: ${error.message}`)\n    }\n  }\n\n  /**\n   * 递归扫描目录\n   * @param {string} currentPath - 当前扫描路径\n   * @param {string} relativePath - 相对于 resource 目录的路径\n   * @param {RegistryData} registryData - 注册表数据\n   * @private\n   */\n  async _recursiveScan(currentPath, relativePath, registryData) {\n    try {\n      const items = await fs.readdir(currentPath)\n      \n      for (const item of items) {\n        const itemPath = path.join(currentPath, item)\n        const stat = await fs.stat(itemPath)\n        const newRelativePath = relativePath ? `${relativePath}/${item}` : item\n        \n        if (stat.isDirectory()) {\n          // 递归扫描子目录\n          await this._recursiveScan(itemPath, newRelativePath, registryData)\n        } else {\n          // 处理文件\n          await this._processFile(itemPath, newRelativePath, registryData)\n        }\n      }\n    } catch (error) {\n      logger.warn(`[UserDiscovery] 扫描${currentPath}失败: ${error.message}`)\n    }\n  }\n\n  /**\n   * 处理单个文件\n   * @param {string} filePath - 文件完整路径\n   * @param {string} relativePath - 相对路径\n   * @param {RegistryData} registryData - 注册表数据\n   * @private\n   */\n  async _processFile(filePath, relativePath, registryData) {\n    const fileName = path.basename(filePath)\n    let protocol = null\n    let resourceId = null\n    \n    // 🔍 Knuth调试日志：追踪文件处理\n    logger.debug(`[UserDiscovery._processFile] Processing: ${relativePath} (file: ${fileName})`)\n    \n    // 根据文件名后缀识别资源类型\n    if (fileName.endsWith('.role.md')) {\n      protocol = 'role'\n      resourceId = path.basename(fileName, '.role.md')\n    } else if (fileName.endsWith('.thought.md')) {\n      protocol = 'thought'\n      resourceId = path.basename(fileName, '.thought.md')\n    } else if (fileName.endsWith('.execution.md')) {\n      protocol = 'execution'\n      resourceId = path.basename(fileName, '.execution.md')\n    } else if (fileName.endsWith('.knowledge.md')) {\n      protocol = 'knowledge'\n      resourceId = path.basename(fileName, '.knowledge.md')\n    } else if (fileName.endsWith('.tool.js')) {\n      protocol = 'tool'\n      resourceId = path.basename(fileName, '.tool.js')\n    } else if (fileName.endsWith('.manual.md')) {\n      protocol = 'manual'\n      resourceId = path.basename(fileName, '.manual.md')\n    }\n    \n    if (protocol && resourceId) {\n      // 🔍 Knuth调试：发现资源类型\n      logger.info(`[UserDiscovery._processFile] Found ${protocol} resource: ${resourceId}`)\n      \n      // 验证文件内容\n      if (await this._validateResourceFile(filePath, protocol)) {\n        const reference = `@user://.promptx/resource/${relativePath}`\n        \n        const resourceData = new ResourceData({\n          id: resourceId,\n          source: 'user',\n          protocol: protocol,\n          name: ResourceData._generateDefaultName(resourceId, protocol),\n          description: ResourceData._generateDefaultDescription(resourceId, protocol),\n          reference: reference,\n          metadata: {\n            scannedAt: new Date().toISOString(),\n            path: relativePath\n          }\n        })\n        \n        registryData.addResource(resourceData)\n        logger.info(`[UserDiscovery] ✅ 成功添加${protocol}资源: ${resourceId} at ${relativePath}`)\n      }\n    }\n  }\n\n  /**\n   * 验证资源文件格式\n   * @param {string} filePath - 文件路径\n   * @param {string} protocol - 协议类型\n   * @returns {Promise<boolean>} 是否是有效的资源文件\n   */\n  async _validateResourceFile(filePath, protocol) {\n    try {\n      const content = await fs.readFile(filePath, 'utf8')\n\n      if (!content || typeof content !== 'string') {\n        return false\n      }\n\n      const trimmedContent = content.trim()\n      if (trimmedContent.length === 0) {\n        return false\n      }\n\n      // 根据协议类型验证 DPML 标签\n      switch (protocol) {\n        case 'role':\n          return trimmedContent.includes('<role>') && trimmedContent.includes('</role>')\n        case 'execution':\n          return trimmedContent.includes('<execution>') && trimmedContent.includes('</execution>')\n        case 'thought':\n          return trimmedContent.includes('<thought>') && trimmedContent.includes('</thought>')\n        case 'knowledge':\n          // knowledge 类型比较灵活，只要文件有内容就认为是有效的\n          return true\n        case 'manual':\n          return trimmedContent.includes('<manual>') && trimmedContent.includes('</manual>')\n        case 'tool':\n          // tool 文件是 JavaScript，进行基本的语法验证\n          try {\n            new Function(trimmedContent)\n            return true\n          } catch (e) {\n            logger.warn(`[UserDiscovery] Invalid JavaScript in tool file ${filePath}: ${e.message}`)\n            return false\n          }\n        default:\n          return false\n      }\n    } catch (error) {\n      logger.warn(`[UserDiscovery] Failed to validate ${filePath}: ${error.message}`)\n      return false\n    }\n  }\n\n  /**\n   * 从资源列表构建注册表 Map\n   * @param {Array} resources - 资源列表\n   * @returns {Map} 资源注册表\n   */\n  buildRegistryFromResources(resources) {\n    const registryMap = new Map()\n    \n    resources.forEach(resource => {\n      const key = `user:${resource.id}`\n      registryMap.set(key, resource.reference)\n    })\n    \n    return registryMap\n  }\n\n  /**\n   * 生成并保存 User 注册表文件\n   * @returns {Promise<RegistryData>} 生成的注册表数据\n   */\n  async generateRegistry() {\n    try {\n      const protocol = this.getUserProtocol()\n      \n      // 获取注册表文件路径\n      const registryPath = await protocol.resolvePath('.promptx/resource/user.registry.json')\n      \n      // 创建注册表数据\n      const registryData = RegistryData.createEmpty('user', registryPath)\n      \n      // 扫描资源目录\n      const resourceDir = await protocol.resolvePath('.promptx/resource')\n      \n      if (await fs.pathExists(resourceDir)) {\n        await this._scanDirectory(resourceDir, registryData)\n      }\n      \n      // 确保目录存在\n      await fs.ensureDir(path.dirname(registryPath))\n      \n      // 保存注册表\n      await registryData.save()\n      \n      logger.info(`[UserDiscovery] ✅ User 注册表生成完成，发现 ${registryData.size} 个资源`)\n      return registryData\n      \n    } catch (error) {\n      logger.error(`[UserDiscovery] 生成注册表失败: ${error.message}`)\n      return RegistryData.createEmpty('user')\n    }\n  }\n\n  /**\n   * 获取注册表数据（兼容接口）\n   * @returns {Promise<RegistryData>} 注册表数据\n   */\n  async getRegistryData() {\n    try {\n      const protocol = this.getUserProtocol()\n      const registryPath = await protocol.resolvePath('.promptx/resource/user.registry.json')\n      \n      if (await fs.pathExists(registryPath)) {\n        const registryData = await RegistryData.fromFile('user', registryPath)\n        \n        if (registryData.size > 0) {\n          logger.info(`[UserDiscovery] 📋 从注册表加载 ${registryData.size} 个资源`)\n          return registryData\n        }\n      }\n      \n      // 动态生成注册表\n      logger.info(`[UserDiscovery] 📋 User 注册表无效，重新生成`)\n      return await this.generateRegistry()\n      \n    } catch (error) {\n      logger.error(`[UserDiscovery] 获取注册表数据失败: ${error.message}`)\n      return RegistryData.createEmpty('user')\n    }\n  }\n\n  /**\n   * 发现资源（BaseDiscovery 要求的抽象方法）\n   * @returns {Promise<Array>} 发现的资源列表\n   */\n  async discover() {\n    const registryMap = await this.discoverRegistry()\n    const resources = []\n    \n    for (const [key, reference] of registryMap) {\n      // 解析 key 格式：user:resourceId\n      const [source, id] = key.split(':')\n      if (source === 'user' && id) {\n        resources.push({\n          id,\n          reference,\n          source: 'user'\n        })\n      }\n    }\n    \n    return resources\n  }\n}\n\nmodule.exports = UserDiscovery","const PackageDiscovery = require('./PackageDiscovery')\nconst ProjectDiscovery = require('./ProjectDiscovery')\nconst UserDiscovery = require('./UserDiscovery')\nconst logger = require('@promptx/logger')\n\n/**\n * DiscoveryManager - 资源发现管理器\n * \n * 统一管理多个资源发现器，按照文档架构设计：\n * 1. 按优先级排序发现器 (数字越小优先级越高)\n * 2. 并行执行资源发现\n * 3. 收集并合并所有发现的资源\n * 4. 提供容错机制，单个发现器失败不影响整体\n */\nclass DiscoveryManager {\n  /**\n   * 构造函数\n   * @param {Array} discoveries - 自定义发现器列表，如果不提供则使用默认配置\n   */\n  constructor(discoveries = null) {\n    if (discoveries) {\n      this.discoveries = [...discoveries]\n    } else {\n      // 默认发现器配置：包含包级、项目级和用户级发现\n      this.discoveries = [\n        new PackageDiscovery(),  // 优先级: 1\n        new ProjectDiscovery(),  // 优先级: 2\n        new UserDiscovery()      // 优先级: 3 (最高)\n      ]\n    }\n\n    // 按优先级排序\n    this._sortDiscoveriesByPriority()\n  }\n\n  /**\n   * 添加发现器\n   * @param {Object} discovery - 实现了发现器接口的对象\n   */\n  addDiscovery(discovery) {\n    if (!discovery || typeof discovery.discover !== 'function') {\n      throw new Error('Discovery must implement discover method')\n    }\n\n    this.discoveries.push(discovery)\n    this._sortDiscoveriesByPriority()\n  }\n\n  /**\n   * 移除发现器\n   * @param {string} source - 发现器源类型\n   */\n  removeDiscovery(source) {\n    this.discoveries = this.discoveries.filter(discovery => discovery.source !== source)\n  }\n\n  /**\n   * 发现所有资源（并行模式）\n   * @returns {Promise<Array>} 所有发现的资源列表\n   */\n  async discoverAll() {\n    const discoveryPromises = this.discoveries.map(async (discovery) => {\n      try {\n        const resources = await discovery.discover()\n        return Array.isArray(resources) ? resources : []\n      } catch (error) {\n        logger.warn(`[DiscoveryManager] ${discovery.source} discovery failed: ${error.message}`)\n        return []\n      }\n    })\n\n    // 并行执行所有发现器\n    const discoveryResults = await Promise.allSettled(discoveryPromises)\n\n    // 收集所有成功的结果\n    const allResources = []\n    discoveryResults.forEach((result, index) => {\n      if (result.status === 'fulfilled') {\n        allResources.push(...result.value)\n      } else {\n        logger.warn(`[DiscoveryManager] ${this.discoveries[index].source} discovery rejected: ${result.reason}`)\n      }\n    })\n\n    return allResources\n  }\n\n  /**\n   * 发现并合并所有注册表（RegistryData架构）\n   * @returns {Promise<Map>} 合并后的资源注册表 Map<resourceId, reference>\n   */\n  async discoverRegistries() {\n    const registryPromises = this.discoveries.map(async (discovery) => {\n      try {\n        // 优先使用新的discoverRegistry方法\n        if (typeof discovery.discoverRegistry === 'function') {\n          const registry = await discovery.discoverRegistry()\n          return registry instanceof Map ? registry : new Map()\n        } else {\n          // 向后兼容：将discover()结果转换为注册表格式\n          const resources = await discovery.discover()\n          const registry = new Map()\n          if (Array.isArray(resources)) {\n            resources.forEach(resource => {\n              if (resource.id && resource.reference) {\n                registry.set(resource.id, resource.reference)\n              }\n            })\n          }\n          return registry\n        }\n      } catch (error) {\n        logger.warn(`[DiscoveryManager] ${discovery.source} registry discovery failed: ${error.message}`)\n        return new Map()\n      }\n    })\n\n    // 并行执行所有发现器\n    const registryResults = await Promise.allSettled(registryPromises)\n\n    // 收集所有成功的注册表\n    const registries = []\n    registryResults.forEach((result, index) => {\n      if (result.status === 'fulfilled') {\n        registries.push(result.value)\n      } else {\n        logger.warn(`[DiscoveryManager] ${this.discoveries[index].source} registry discovery rejected: ${result.reason}`)\n        registries.push(new Map())\n      }\n    })\n\n    // 按发现器优先级合并注册表\n    return this._mergeRegistries(registries)\n  }\n\n  /**\n   * 按源类型发现注册表\n   * @param {string} source - 发现器源类型\n   * @returns {Promise<Map>} 指定源的资源注册表\n   */\n  async discoverRegistryBySource(source) {\n    const discovery = this._findDiscoveryBySource(source)\n    if (!discovery) {\n      throw new Error(`Discovery source ${source} not found`)\n    }\n\n    if (typeof discovery.discoverRegistry === 'function') {\n      return await discovery.discoverRegistry()\n    } else {\n      // 向后兼容：将discover()结果转换为注册表格式\n      const resources = await discovery.discover()\n      const registry = new Map()\n      if (Array.isArray(resources)) {\n        resources.forEach(resource => {\n          if (resource.id && resource.reference) {\n            registry.set(resource.id, resource.reference)\n          }\n        })\n      }\n      return registry\n    }\n  }\n\n  /**\n   * 按源类型发现资源\n   * @param {string} source - 发现器源类型\n   * @returns {Promise<Array>} 指定源的资源列表\n   */\n  async discoverBySource(source) {\n    const discovery = this._findDiscoveryBySource(source)\n    if (!discovery) {\n      throw new Error(`Discovery source ${source} not found`)\n    }\n\n    return await discovery.discover()\n  }\n\n  /**\n   * 获取所有发现器信息\n   * @returns {Array} 发现器信息列表\n   */\n  getDiscoveryInfo() {\n    return this.discoveries.map(discovery => {\n      if (typeof discovery.getDiscoveryInfo === 'function') {\n        return discovery.getDiscoveryInfo()\n      } else {\n        return {\n          source: discovery.source || 'UNKNOWN',\n          priority: discovery.priority || 0,\n          description: 'No description available'\n        }\n      }\n    })\n  }\n\n  /**\n   * 清理所有发现器缓存\n   */\n  clearCache() {\n    this.discoveries.forEach(discovery => {\n      if (typeof discovery.clearCache === 'function') {\n        discovery.clearCache()\n      }\n    })\n  }\n\n  /**\n   * 获取发现器数量\n   * @returns {number} 注册的发现器数量\n   */\n  getDiscoveryCount() {\n    return this.discoveries.length\n  }\n\n  /**\n   * 合并多个注册表（支持分层级资源管理）\n   * @param {Array<Map>} registries - 注册表数组，按优先级排序（数字越小优先级越高）\n   * @returns {Map} 合并后的注册表\n   * @private\n   */\n  _mergeRegistries(registries) {\n    const mergedRegistry = new Map()\n\n    // 第一阶段：收集所有资源（包括带前缀的）\n    for (let i = registries.length - 1; i >= 0; i--) {\n      const registry = registries[i]\n      if (registry instanceof Map) {\n        for (const [key, value] of registry) {\n          mergedRegistry.set(key, value)\n        }\n      }\n    }\n\n    // 第二阶段：处理优先级覆盖 - 高优先级的无前缀版本覆盖低优先级的\n    const priorityLevels = ['package', 'project', 'user'] // 优先级：package < project < user\n    \n    // 为每个基础资源ID找到最高优先级的版本\n    const baseResourceMap = new Map() // baseId -> {source, reference, priority}\n    \n    for (const [fullId, reference] of mergedRegistry) {\n      // 解析资源ID：可能是 \"source:resourceId\" 或 \"resourceId\"\n      const colonIndex = fullId.indexOf(':')\n      let source = 'unknown'\n      let baseId = fullId\n      \n      if (colonIndex !== -1) {\n        const possibleSource = fullId.substring(0, colonIndex)\n        if (priorityLevels.includes(possibleSource)) {\n          source = possibleSource\n          baseId = fullId.substring(colonIndex + 1)\n        }\n      }\n      \n      const currentPriority = priorityLevels.indexOf(source)\n      const existing = baseResourceMap.get(baseId)\n      \n      if (!existing || currentPriority > existing.priority) {\n        baseResourceMap.set(baseId, {\n          source,\n          reference,\n          priority: currentPriority,\n          fullId\n        })\n      }\n    }\n    \n    // 第三阶段：构建最终注册表\n    const finalRegistry = new Map()\n    \n    // 1. 添加所有带前缀的资源（用于明确指定级别）\n    for (const [key, value] of mergedRegistry) {\n      if (key.includes(':') && priorityLevels.includes(key.split(':')[0])) {\n        finalRegistry.set(key, value)\n      }\n    }\n    \n    // 2. 添加最高优先级的无前缀版本（用于默认解析）\n    for (const [baseId, info] of baseResourceMap) {\n      finalRegistry.set(baseId, info.reference)\n    }\n\n    return finalRegistry\n  }\n\n  /**\n   * 按优先级排序发现器\n   * @private\n   */\n  _sortDiscoveriesByPriority() {\n    this.discoveries.sort((a, b) => {\n      const priorityA = a.priority || 0\n      const priorityB = b.priority || 0\n      return priorityA - priorityB // 升序排序，数字越小优先级越高\n    })\n  }\n\n  /**\n   * 根据源类型查找发现器\n   * @param {string} source - 发现器源类型\n   * @returns {Object|undefined} 找到的发现器或undefined\n   * @private\n   */\n  _findDiscoveryBySource(source) {\n    return this.discoveries.find(discovery => discovery.source === source)\n  }\n}\n\nmodule.exports = DiscoveryManager","/**\n * 资源协议接口基类\n * 定义所有DPML资源协议的统一规范\n */\nclass ResourceProtocol {\n  /**\n   * 构造函数\n   * @param {string} name - 协议名称\n   * @param {object} options - 配置选项\n   */\n  constructor (name, options = {}) {\n    if (new.target === ResourceProtocol) {\n      throw new Error('ResourceProtocol是抽象类，不能直接实例化')\n    }\n\n    this.name = name\n    this.options = options\n    this.cache = new Map()\n    // 默认禁用缓存，避免开发时的问题，需要时显式启用\n    this.enableCache = options.enableCache === true\n  }\n\n  /**\n   * 协议信息 - 需要子类实现\n   * @returns {object} 协议信息\n   */\n  getProtocolInfo () {\n    throw new Error('子类必须实现 getProtocolInfo() 方法')\n  }\n\n  /**\n   * 解析资源路径 - 需要子类实现\n   * @param {string} resourcePath - 原始资源路径\n   * @param {QueryParams} queryParams - 查询参数\n   * @returns {Promise<string>} 解析后的路径\n   */\n  async resolvePath (resourcePath, queryParams) {\n    throw new Error('子类必须实现 resolvePath() 方法')\n  }\n\n  /**\n   * 加载资源内容 - 需要子类实现\n   * @param {string} resolvedPath - 解析后的路径\n   * @param {QueryParams} queryParams - 查询参数\n   * @returns {Promise<string>} 资源内容\n   */\n  async loadContent (resolvedPath, queryParams) {\n    throw new Error('子类必须实现 loadContent() 方法')\n  }\n\n  /**\n   * 验证资源路径格式 - 可选实现\n   * @param {string} resourcePath - 资源路径\n   * @returns {boolean} 是否有效\n   */\n  validatePath (resourcePath) {\n    return typeof resourcePath === 'string' && resourcePath.length > 0\n  }\n\n  /**\n   * 支持的查询参数列表 - 可选实现\n   * @returns {object} 参数说明\n   */\n  getSupportedParams () {\n    return {\n      line: 'string - 行范围，如 \"1-10\"',\n      format: 'string - 输出格式',\n      cache: 'boolean - 是否缓存'\n    }\n  }\n\n  /**\n   * 统一的资源解析入口点\n   * @param {string} resourcePath - 资源路径\n   * @param {QueryParams} queryParams - 查询参数\n   * @returns {Promise<string>} 资源内容\n   */\n  async resolve (resourcePath, queryParams) {\n    // 1. 验证路径格式\n    if (!this.validatePath(resourcePath)) {\n      const error = new Error(`无效的资源路径: ${resourcePath}`)\n      const logger = require('@promptx/logger')\n      logger.error(`[ResourceProtocol] 路径验证失败: ${resourcePath}`)\n      logger.error(`[ResourceProtocol] 调用堆栈:`, error.stack)\n      throw error\n    }\n\n    // 2. 生成缓存键\n    const cacheKey = this.generateCacheKey(resourcePath, queryParams)\n\n    // 3. 检查缓存\n    if (this.enableCache && this.cache.has(cacheKey)) {\n      return this.cache.get(cacheKey)\n    }\n\n    // 4. 解析路径\n    const resolvedPath = await this.resolvePath(resourcePath, queryParams)\n\n    // 5. 加载内容\n    const content = await this.loadContent(resolvedPath, queryParams)\n\n    // 6. 应用通用查询参数过滤\n    const filteredContent = this.applyCommonParams(content, queryParams)\n\n    // 7. 缓存结果\n    if (this.enableCache) {\n      this.cache.set(cacheKey, filteredContent)\n    }\n\n    return filteredContent\n  }\n\n  /**\n   * 生成缓存键\n   * @param {string} resourcePath - 资源路径\n   * @param {QueryParams} queryParams - 查询参数\n   * @returns {string} 缓存键\n   */\n  generateCacheKey (resourcePath, queryParams) {\n    const params = queryParams ? queryParams.getAll() : {}\n    return `${this.name}:${resourcePath}:${JSON.stringify(params)}`\n  }\n\n  /**\n   * 应用通用查询参数\n   * @param {string} content - 原始内容\n   * @param {QueryParams} queryParams - 查询参数\n   * @returns {string} 过滤后的内容\n   */\n  applyCommonParams (content, queryParams) {\n    if (!queryParams) {\n      return content\n    }\n\n    let result = content\n\n    // 应用行过滤\n    if (queryParams.line) {\n      result = this.applyLineFilter(result, queryParams.line)\n    }\n\n    // 应用格式化（基础实现，子类可以重写）\n    if (queryParams.format && queryParams.format !== 'text') {\n      result = this.applyFormat(result, queryParams.format)\n    }\n\n    return result\n  }\n\n  /**\n   * 应用行过滤\n   * @param {string} content - 内容\n   * @param {string} lineRange - 行范围，如 \"5-10\" 或 \"5\"\n   * @returns {string} 过滤后的内容\n   */\n  applyLineFilter (content, lineRange) {\n    const lines = content.split('\\n')\n\n    if (lineRange.includes('-')) {\n      const [start, end] = lineRange.split('-').map(n => parseInt(n.trim(), 10))\n      const startIndex = Math.max(0, start - 1)\n      const endIndex = Math.min(lines.length, end)\n      return lines.slice(startIndex, endIndex).join('\\n')\n    } else {\n      const lineNum = parseInt(lineRange, 10)\n      const lineIndex = lineNum - 1\n      return lines[lineIndex] || ''\n    }\n  }\n\n  /**\n   * 应用格式化\n   * @param {string} content - 内容\n   * @param {string} format - 格式\n   * @returns {string} 格式化后的内容\n   */\n  applyFormat (content, format) {\n    // 基础实现，子类可以重写\n    switch (format) {\n      case 'json':\n        try {\n          return JSON.stringify(JSON.parse(content), null, 2)\n        } catch {\n          return content\n        }\n      case 'trim':\n        return content.trim()\n      default:\n        return content\n    }\n  }\n\n  /**\n   * 清除缓存\n   */\n  clearCache () {\n    this.cache.clear()\n  }\n\n  /**\n   * 获取缓存统计\n   * @returns {object} 缓存统计信息\n   */\n  getCacheStats () {\n    return {\n      protocol: this.name,\n      size: this.cache.size,\n      enabled: this.enableCache\n    }\n  }\n}\n\nmodule.exports = ResourceProtocol\n","const path = require('path')\nconst fs = require('fs')\nconst fsPromises = require('fs').promises\nconst ResourceProtocol = require('./ResourceProtocol')\nconst { QueryParams } = require('../types')\nconst logger = require('@promptx/logger')\nconst { getDirectoryService } = require('~/utils/DirectoryService')\n\n/**\n * 包协议实现\n * 实现@package://协议，智能检测并访问NPM包资源\n * 支持：本地开发、npm install、npm -g、npx、monorepo等场景\n */\nclass PackageProtocol extends ResourceProtocol {\n  constructor (options = {}) {\n    super('package', options)\n    this.directoryService = getDirectoryService()\n  }\n\n  /**\n   * 设置注册表（保持与其他协议的一致性）\n   */\n  setRegistry (registry) {\n    // Package协议不使用注册表，但为了一致性提供此方法\n    this.registry = registry || {}\n  }\n\n  /**\n   * 获取协议信息\n   */\n  getProtocolInfo () {\n    return {\n      name: this.name,\n      description: '包协议 - 智能访问NPM包资源，支持多种安装模式',\n      examples: [\n        '@package://package.json',\n        '@package://src/index.js',\n        '@package://docs/README.md',\n        '@package://resource/core/thought.md',\n        '@package://templates/basic/template.md'\n      ],\n      installModes: [\n        'development', // 开发模式\n        'local', // 本地npm install\n        'global', // 全局npm install -g\n        'npx', // npx执行\n        'monorepo', // monorepo workspace\n        'link' // npm link\n      ]\n    }\n  }\n\n\n\n  /**\n   * 获取包根目录 - 始终使用 dist 目录\n   */\n  async getPackageRoot () {\n    try {\n      // 直接使用 @promptx/resource 包的 dist 目录\n      const resourcePath = require.resolve('@promptx/resource')\n      logger.info(`[PackageProtocol] require.resolve('@promptx/resource') returned: ${resourcePath}`)\n      \n      // require.resolve 返回的是 dist/index.js，所以 dirname 就是 dist 目录\n      const distDir = path.dirname(resourcePath)\n      logger.info(`[PackageProtocol] Using dist directory as package root: ${distDir}`)\n      \n      const resourcesDir = path.join(distDir, 'resources')\n      logger.info(`[PackageProtocol] Resources directory path: ${resourcesDir}`)\n      logger.info(`[PackageProtocol] Resources directory exists: ${fs.existsSync(resourcesDir)}`)\n      \n      return distDir\n      \n    } catch (error) {\n      logger.error(`[PackageProtocol] Cannot locate @promptx/resource package: ${error.message}`)\n      logger.error(`[PackageProtocol] Error stack:`, error.stack)\n      logger.error(`[PackageProtocol] This is a critical system error, @promptx/resource must exist and be accessible via require`)\n      throw error\n    }\n  }\n\n\n  /**\n   * 解析路径到具体的文件系统路径 - 使用 PackageResource\n   * @param {string} relativePath - 相对于包根目录的路径\n   * @param {QueryParams} params - 查询参数\n   * @returns {Promise<string>} 解析后的绝对路径\n   */\n  async resolvePath (relativePath, params = null) {\n    logger.info(`[PackageProtocol] Resolving path: ${relativePath}`)\n    \n    try {\n      // 使用新的 PackageResource API\n      const resourceModule = require('@promptx/resource')\n      logger.info(`[PackageProtocol] Resource module loaded:`, Object.keys(resourceModule))\n      const { packageResource } = resourceModule\n      logger.info(`[PackageProtocol] PackageResource type:`, typeof packageResource)\n      logger.debug(`[PackageProtocol] Successfully loaded PackageResource`)\n      \n      // 清理路径\n      const cleanPath = relativePath.replace(/^\\/+/, '')\n      logger.debug(`[PackageProtocol] Cleaned path: ${cleanPath}`)\n      \n      // 使用 PackageResource 解析路径（自动处理ASAR）\n      const fullPath = packageResource.resolvePath(cleanPath)\n      logger.info(`[PackageProtocol] PackageResource resolved path: ${fullPath}`)\n      \n      // 检查文件是否存在\n      const exists = packageResource.exists(cleanPath)\n      logger.info(`[PackageProtocol] File exists: ${exists} (path: ${fullPath})`)\n      \n      if (!exists) {\n        logger.error(`[PackageProtocol] Resource file not found: ${fullPath}`)\n        return null\n      }\n      \n      return fullPath\n    } catch (error) {\n      logger.error(`[PackageProtocol] Failed to resolve resource path: ${error.message}`)\n      logger.error(`[PackageProtocol] Error stack:`, error.stack)\n      throw error\n    }\n  }\n\n  /**\n   * 验证文件访问权限（基于package.json的files字段）\n   * @param {string} packageRoot - 包根目录\n   * @param {string} relativePath - 相对路径\n   */\n  validateFileAccess (packageRoot, relativePath) {\n    // 简化版本：既然使用 require.resolve，就信任包的正确性\n    // 不再进行复杂的 files 字段检查\n    logger.debug(`[PackageProtocol] Validating file access for: ${relativePath}`)\n  }\n\n\n  /**\n   * 检查资源是否存在\n   */\n  async exists (resourcePath, queryParams) {\n    try {\n      const resolvedPath = await this.resolvePath(resourcePath, queryParams)\n      await fsPromises.access(resolvedPath)\n      return true\n    } catch (error) {\n      return false\n    }\n  }\n\n  /**\n   * 加载资源内容\n   * @param {string} resolvedPath - 已解析的路径\n   * @param {QueryParams} [queryParams] - 查询参数\n   * @returns {Object} 包含内容和元数据的对象\n   */\n  async loadContent (resolvedPath, queryParams) {\n    try {\n      // 可以直接使用PackageResource的loadContent方法\n      // 但为了保持协议层的一致性，这里继续使用传统方法\n      await fsPromises.access(resolvedPath)\n      const content = await fsPromises.readFile(resolvedPath, 'utf8')\n      const stats = await fsPromises.stat(resolvedPath)\n      const packageRoot = await this.getPackageRoot()\n      \n      return {\n        content,\n        path: resolvedPath,\n        protocol: 'package',\n        metadata: {\n          size: content.length,\n          lastModified: stats.mtime,\n          absolutePath: resolvedPath,\n          relativePath: path.relative(packageRoot, resolvedPath)\n        }\n      }\n    } catch (error) {\n      if (error.code === 'ENOENT') {\n        throw new Error(`Package resource not found: ${resolvedPath}`)\n      }\n      throw new Error(`Failed to load package resource: ${error.message}`)\n    }\n  }\n\n  /**\n   * 获取调试信息\n   */\n  getDebugInfo () {\n    return {\n      protocol: this.name,\n      packageRoot: this.getPackageRoot(),\n      currentWorkingDirectory: process.cwd(),\n      moduleDirectory: __dirname,\n      cacheSize: this.cache.size\n    }\n  }\n\n  /**\n   * 清理缓存\n   */\n  clearCache () {\n    super.clearCache()\n  }\n}\n\nmodule.exports = PackageProtocol\n","const path = require('path')\nconst ProjectManager = require('./ProjectManager')\n\n/**\n * 项目路径解析器 - 新架构\n * 轻量级的@project协议路径解析，基于当前项目状态\n * 替代复杂的.promptx目录查找逻辑\n */\nclass ProjectPathResolver {\n  constructor() {\n    // 支持的项目结构目录映射\n    this.projectDirs = {\n      root: '', // 项目根目录\n      src: 'src', // 源代码目录\n      lib: 'lib', // 库目录\n      build: 'build', // 构建输出目录\n      dist: 'dist', // 分发目录\n      docs: 'docs', // 文档目录\n      test: 'test', // 测试目录\n      tests: 'tests', // 测试目录（复数）\n      spec: 'spec', // 规范测试目录\n      config: 'config', // 配置目录\n      scripts: 'scripts', // 脚本目录\n      assets: 'assets', // 资源目录\n      public: 'public', // 公共资源目录\n      static: 'static', // 静态资源目录\n      templates: 'templates', // 模板目录\n      examples: 'examples', // 示例目录\n      tools: 'tools', // 工具目录\n      '.promptx': '.promptx' // PromptX配置目录\n    }\n  }\n\n  /**\n   * 解析@project://协议路径\n   * @param {string} resourcePath - 资源路径，如 \"src/index.js\" 或 \".promptx/resource/...\"\n   * @returns {string} 解析后的绝对路径\n   */\n  resolvePath(resourcePath) {\n    // 🎯 新架构：直接获取当前项目路径，无需查找\n    const projectRoot = ProjectManager.getCurrentProjectPath()\n    \n    // 特殊处理：.promptx开头的路径直接相对于项目根目录\n    if (resourcePath.startsWith('.promptx/')) {\n      const fullPath = path.join(projectRoot, resourcePath)\n      return this._validatePath(fullPath, projectRoot)\n    }\n\n    // 标准路径处理逻辑\n    const parts = resourcePath.split('/')\n    const dirType = parts[0]\n    const relativePath = parts.slice(1).join('/')\n\n    // 验证目录类型\n    if (!this.projectDirs.hasOwnProperty(dirType)) {\n      throw new Error(`不支持的项目目录类型: ${dirType}。支持的类型: ${Object.keys(this.projectDirs).join(', ')}`)\n    }\n\n    // 构建目标目录路径\n    const projectDirPath = this.projectDirs[dirType]\n    const targetDir = projectDirPath ? path.join(projectRoot, projectDirPath) : projectRoot\n\n    // 如果没有相对路径，返回目录本身\n    if (!relativePath) {\n      return targetDir\n    }\n\n    // 拼接完整路径\n    const fullPath = path.join(targetDir, relativePath)\n    return this._validatePath(fullPath, projectRoot)\n  }\n\n  /**\n   * 获取项目根目录\n   * @returns {string} 当前项目根目录\n   */\n  getProjectRoot() {\n    return ProjectManager.getCurrentProjectPath()\n  }\n\n  /**\n   * 获取PromptX配置目录路径\n   * @returns {string} .promptx目录路径\n   */\n  getPromptXDirectory() {\n    const projectRoot = ProjectManager.getCurrentProjectPath()\n    return path.join(projectRoot, '.promptx')\n  }\n\n  /**\n   * 获取项目资源目录路径\n   * @returns {string} 项目资源目录路径\n   */\n  getResourceDirectory() {\n    const promptxDir = this.getPromptXDirectory()\n    return path.join(promptxDir, 'resource')\n  }\n\n  /**\n   * 获取项目注册表文件路径\n   * @returns {string} 注册表文件路径\n   */\n  getRegistryPath() {\n    const resourceDir = this.getResourceDirectory()\n    return path.join(resourceDir, 'project.registry.json')\n  }\n\n  /**\n   * 获取记忆目录路径\n   * @returns {string} 记忆目录路径\n   */\n  getMemoryDirectory() {\n    const promptxDir = this.getPromptXDirectory()\n    return path.join(promptxDir, 'memory')\n  }\n\n  /**\n   * 验证路径安全性\n   * @param {string} fullPath - 完整路径\n   * @param {string} projectRoot - 项目根目录\n   * @returns {string} 验证后的路径\n   * @private\n   */\n  _validatePath(fullPath, projectRoot) {\n    // 安全检查：确保路径在项目目录内\n    const resolvedPath = path.resolve(fullPath)\n    const resolvedProjectRoot = path.resolve(projectRoot)\n\n    if (!resolvedPath.startsWith(resolvedProjectRoot)) {\n      throw new Error(`安全错误：路径超出项目目录范围: ${resolvedPath}`)\n    }\n\n    return resolvedPath\n  }\n\n  /**\n   * 获取支持的目录类型\n   * @returns {Array<string>} 支持的目录类型列表\n   */\n  getSupportedDirectories() {\n    return Object.keys(this.projectDirs)\n  }\n\n  /**\n   * 检查目录类型是否支持\n   * @param {string} dirType - 目录类型\n   * @returns {boolean} 是否支持\n   */\n  isSupportedDirectory(dirType) {\n    return this.projectDirs.hasOwnProperty(dirType)\n  }\n}\n\n// 创建全局单例实例\nlet globalProjectPathResolver = null\n\n/**\n * 获取全局ProjectPathResolver单例\n * @returns {ProjectPathResolver} 全局ProjectPathResolver实例\n */\nfunction getGlobalProjectPathResolver() {\n  if (!globalProjectPathResolver) {\n    globalProjectPathResolver = new ProjectPathResolver()\n  }\n  return globalProjectPathResolver\n}\n\nmodule.exports = ProjectPathResolver\nmodule.exports.getGlobalProjectPathResolver = getGlobalProjectPathResolver","const ResourceProtocol = require('./ResourceProtocol')\nconst path = require('path')\nconst fs = require('fs').promises\n\n// 使用env-paths提供跨平台用户目录支持\nconst envPaths = require('env-paths')\nconst os = require('os')\n\n/**\n * 获取跨平台用户目录路径\n * 使用env-paths替代platform-folders，提供更好的跨平台兼容性\n */\nconst getUserDirectories = () => {\n  const promptxPaths = envPaths('promptx')\n  \n  return {\n    getHomeFolder: () => os.homedir(),\n    getDesktopFolder: () => path.join(os.homedir(), 'Desktop'),\n    getDocumentsFolder: () => path.join(os.homedir(), 'Documents'),\n    getDownloadsFolder: () => path.join(os.homedir(), 'Downloads'),\n    getMusicFolder: () => path.join(os.homedir(), 'Music'),\n    getPicturesFolder: () => path.join(os.homedir(), 'Pictures'),\n    getVideosFolder: () => path.join(os.homedir(), 'Videos'),\n    // 新增：env-paths标准目录\n    getDataFolder: () => promptxPaths.data,\n    getConfigFolder: () => promptxPaths.config,\n    getCacheFolder: () => promptxPaths.cache,\n    getLogFolder: () => promptxPaths.log,\n    getTempFolder: () => promptxPaths.temp\n  }\n}\n\n/**\n * 用户目录协议实现\n * 实现@user://协议，直接映射到用户主目录，提供简洁的用户文件访问\n */\nclass UserProtocol extends ResourceProtocol {\n  constructor (options = {}) {\n    super('user', options)\n\n    // 支持的用户目录映射\n    this.userDirs = {\n      home: 'getHomeFolder',\n      desktop: 'getDesktopFolder',\n      documents: 'getDocumentsFolder',\n      downloads: 'getDownloadsFolder',\n      music: 'getMusicFolder',\n      pictures: 'getPicturesFolder',\n      videos: 'getVideosFolder',\n      // 新增：env-paths标准目录\n      data: 'getDataFolder',\n      config: 'getConfigFolder',\n      cache: 'getCacheFolder',\n      log: 'getLogFolder',\n      temp: 'getTempFolder'\n    }\n\n    // 目录路径缓存\n    this.dirCache = new Map()\n  }\n\n  /**\n   * 设置注册表（保持与其他协议的一致性）\n   */\n  setRegistry (registry) {\n    // User协议不使用注册表，但为了一致性提供此方法\n    this.registry = registry || {}\n  }\n\n  /**\n   * 获取协议信息\n   * @returns {object} 协议信息\n   */\n  getProtocolInfo () {\n    return {\n      name: 'user',\n      description: '用户目录协议，直接映射到用户主目录',\n      location: 'user://{path}',\n      examples: [\n        'user://.promptx/toolbox/text-analyzer',\n        'user://.bashrc',\n        'user://Documents/notes.txt',\n        'user://Desktop/readme.md',\n        'user://Downloads/file.zip',\n        'user://.promptx/config.json'\n      ],\n      basePath: '用户主目录 (~)',\n      params: this.getSupportedParams()\n    }\n  }\n\n  /**\n   * 支持的查询参数\n   * @returns {object} 参数说明\n   */\n  getSupportedParams () {\n    return {\n      ...super.getSupportedParams(),\n      exists: 'boolean - 仅返回存在的文件/目录',\n      type: 'string - 过滤类型 (file|dir|both)'\n    }\n  }\n\n  /**\n   * 验证用户协议路径\n   * @param {string} resourcePath - 资源路径\n   * @returns {boolean} 是否有效\n   */\n  validatePath (resourcePath) {\n    // UserProtocol需要处理完整的文件路径，包括.promptx开头的路径\n    // 不调用父类的validatePath，因为父类只接受简单的资源ID格式\n    if (!resourcePath || typeof resourcePath !== 'string') {\n      return false\n    }\n    \n    // 接受.promptx开头的路径（这是User级资源的标准路径）\n    if (resourcePath.startsWith('.promptx/')) {\n      return true\n    }\n    \n    // 也接受用户目录类型的路径\n    const parts = resourcePath.split('/')\n    const dirType = parts[0]\n    \n    return this.userDirs.hasOwnProperty(dirType)\n  }\n\n  /**\n   * 解析用户目录路径\n   * @param {string} resourcePath - 原始资源路径，如 \".promptx/toolbox/test-tool\"\n   * @param {QueryParams} queryParams - 查询参数\n   * @returns {Promise<string>} 解析后的绝对路径\n   */\n  async resolvePath (resourcePath, queryParams) {\n    // 直接使用用户主目录作为基础路径\n    const userHomeDir = getUserDirectories().getHomeFolder()\n    \n    // 如果没有相对路径，返回用户主目录本身\n    if (!resourcePath) {\n      return userHomeDir\n    }\n\n    // 拼接完整路径\n    const fullPath = path.join(userHomeDir, resourcePath)\n\n    // 安全检查：确保路径在用户主目录内\n    const resolvedPath = path.resolve(fullPath)\n    const resolvedUserDir = path.resolve(userHomeDir)\n\n    if (!resolvedPath.startsWith(resolvedUserDir)) {\n      throw new Error(`安全错误：路径超出用户目录范围: ${resolvedPath}`)\n    }\n\n    return resolvedPath\n  }\n\n  /**\n   * 获取用户目录路径\n   * @param {string} dirType - 目录类型\n   * @returns {Promise<string>} 目录路径\n   */\n  async getUserDirectory (dirType) {\n    // 检查缓存\n    if (this.dirCache.has(dirType)) {\n      return this.dirCache.get(dirType)\n    }\n\n    const userDirectories = getUserDirectories()\n    const methodName = this.userDirs[dirType]\n\n    if (!userDirectories[methodName]) {\n      throw new Error(`未找到用户目录获取方法: ${methodName}`)\n    }\n\n    try {\n      let dirPath\n\n      // 调用用户目录获取方法\n      if (typeof userDirectories[methodName] === 'function') {\n        dirPath = userDirectories[methodName]()\n      } else {\n        dirPath = userDirectories[methodName]\n      }\n\n      // 缓存结果\n      this.dirCache.set(dirType, dirPath)\n\n      return dirPath\n    } catch (error) {\n      throw new Error(`获取用户目录失败 (${dirType}): ${error.message}`)\n    }\n  }\n\n  /**\n   * 加载资源内容\n   * @param {string} resolvedPath - 解析后的路径\n   * @param {QueryParams} queryParams - 查询参数\n   * @returns {Promise<string>} 资源内容\n   */\n  async loadContent (resolvedPath, queryParams) {\n    try {\n      // 检查路径是否存在\n      const stats = await fs.stat(resolvedPath)\n\n      if (stats.isDirectory()) {\n        return await this.loadDirectoryContent(resolvedPath, queryParams)\n      } else if (stats.isFile()) {\n        return await this.loadFileContent(resolvedPath, queryParams)\n      } else {\n        throw new Error(`不支持的文件类型: ${resolvedPath}`)\n      }\n    } catch (error) {\n      if (error.code === 'ENOENT') {\n        // 如果设置了exists参数为false，返回空内容而不是错误\n        if (queryParams && queryParams.get('exists') === 'false') {\n          return ''\n        }\n        throw new Error(`文件或目录不存在: ${resolvedPath}`)\n      }\n      throw error\n    }\n  }\n\n  /**\n   * 加载文件内容\n   * @param {string} filePath - 文件路径\n   * @param {QueryParams} queryParams - 查询参数\n   * @returns {Promise<string>} 文件内容\n   */\n  async loadFileContent (filePath, queryParams) {\n    const encoding = queryParams?.get('encoding') || 'utf8'\n    return await fs.readFile(filePath, encoding)\n  }\n\n  /**\n   * 加载目录内容\n   * @param {string} dirPath - 目录路径\n   * @param {QueryParams} queryParams - 查询参数\n   * @returns {Promise<string>} 目录内容列表\n   */\n  async loadDirectoryContent (dirPath, queryParams) {\n    const entries = await fs.readdir(dirPath, { withFileTypes: true })\n\n    // 应用类型过滤\n    const typeFilter = queryParams?.get('type')\n    let filteredEntries = entries\n\n    if (typeFilter) {\n      filteredEntries = entries.filter(entry => {\n        switch (typeFilter) {\n          case 'file': return entry.isFile()\n          case 'dir': return entry.isDirectory()\n          case 'both': return true\n          default: return true\n        }\n      })\n    }\n\n    // 格式化输出\n    const format = queryParams?.get('format') || 'list'\n\n    switch (format) {\n      case 'json':\n        return JSON.stringify(\n          filteredEntries.map(entry => ({\n            name: entry.name,\n            type: entry.isDirectory() ? 'directory' : 'file',\n            path: path.join(dirPath, entry.name)\n          })),\n          null,\n          2\n        )\n\n      case 'paths':\n        return filteredEntries\n          .map(entry => path.join(dirPath, entry.name))\n          .join('\\n')\n\n      case 'list':\n      default:\n        return filteredEntries\n          .map(entry => {\n            const type = entry.isDirectory() ? '[DIR]' : '[FILE]'\n            return `${type} ${entry.name}`\n          })\n          .join('\\n')\n    }\n  }\n\n  /**\n   * 列出所有支持的用户目录\n   * @returns {Promise<object>} 目录信息\n   */\n  async listUserDirectories () {\n    const result = {}\n\n    for (const dirType of Object.keys(this.userDirs)) {\n      try {\n        result[dirType] = await this.getUserDirectory(dirType)\n      } catch (error) {\n        result[dirType] = { error: error.message }\n      }\n    }\n\n    return result\n  }\n\n  /**\n   * 清除目录缓存\n   */\n  clearCache () {\n    super.clearCache()\n    this.dirCache.clear()\n  }\n}\n\nmodule.exports = UserProtocol\n","const ResourceProtocol = require('./ResourceProtocol')\nconst path = require('path')\nconst fs = require('fs').promises\nconst { getGlobalProjectPathResolver } = require('~/utils/ProjectPathResolver')\nconst ProjectManager = require('~/utils/ProjectManager')\nconst UserProtocol = require('./UserProtocol')\n\n/**\n * 项目协议实现 - 新架构\n * 实现@project://协议，基于当前项目状态的高性能路径解析\n * 移除.promptx目录查找，直接使用ProjectManager的当前项目信息\n */\nclass ProjectProtocol extends ResourceProtocol {\n  constructor (options = {}) {\n    super('project', options)\n    \n    // 🎯 新架构：延迟初始化路径解析器，避免在项目未初始化时创建\n    this.pathResolver = null\n    \n    // HTTP模式支持：UserProtocol实例用于路径映射\n    this.userProtocol = new UserProtocol(options)\n  }\n\n  /**\n   * 获取路径解析器（延迟初始化）\n   * @returns {ProjectPathResolver} 路径解析器实例\n   */\n  getPathResolver() {\n    if (!this.pathResolver) {\n      this.pathResolver = getGlobalProjectPathResolver()\n    }\n    return this.pathResolver\n  }\n\n  /**\n   * 设置注册表（保持与其他协议的一致性）\n   */\n  setRegistry (registry) {\n    // Project协议不使用注册表，但为了一致性提供此方法\n    this.registry = registry || {}\n  }\n\n  /**\n   * 获取协议信息\n   * @returns {object} 协议信息\n   */\n  getProtocolInfo () {\n    return {\n      name: 'project',\n      description: '项目协议，基于当前项目状态的高性能路径解析',\n      location: 'project://{directory}/{path}',\n      examples: [\n        'project://src/index.js',\n        'project://lib/utils.js',\n        'project://docs/README.md',\n        'project://root/package.json',\n        'project://test/unit/'\n      ],\n      supportedDirectories: this.getPathResolver().getSupportedDirectories(),\n      architecture: 'state-based',\n      params: this.getSupportedParams()\n    }\n  }\n\n  /**\n   * 支持的查询参数\n   * @returns {object} 参数说明\n   */\n  getSupportedParams () {\n    return {\n      ...super.getSupportedParams(),\n      from: 'string - 指定搜索起始目录',\n      create: 'boolean - 如果目录不存在是否创建',\n      exists: 'boolean - 仅返回存在的文件/目录',\n      type: 'string - 过滤类型 (file|dir|both)'\n    }\n  }\n\n  /**\n   * 验证项目协议路径\n   * @param {string} resourcePath - 资源路径\n   * @returns {boolean} 是否有效\n   */\n  validatePath (resourcePath) {\n    if (!super.validatePath(resourcePath)) {\n      return false\n    }\n\n    // 特殊处理：允许.promptx开头的路径（项目配置目录）\n    if (resourcePath.startsWith('.promptx/')) {\n      return true\n    }\n\n    // 解析路径的第一部分（目录类型）\n    const parts = resourcePath.split('/')\n    const dirType = parts[0]\n\n    return this.getPathResolver().isSupportedDirectory(dirType)\n  }\n\n\n  /**\n   * 解析项目路径 - 新架构：高性能零查找 + HTTP模式支持\n   * @param {string} resourcePath - 原始资源路径，如 \"src/index.js\" 或 \".promptx/resource/...\"\n   * @param {QueryParams} queryParams - 查询参数\n   * @returns {Promise<string>} 解析后的绝对路径\n   */\n  async resolvePath (resourcePath, queryParams) {\n    try {\n      // 🎯 检测当前项目的transport模式\n      const currentProject = ProjectManager.getCurrentProject()\n      const { transport } = currentProject\n      \n      if (transport === 'http') {\n        return await this.resolveHttpPath(resourcePath, queryParams, currentProject)\n      } else {\n        return this.resolveLocalPath(resourcePath, queryParams, currentProject)\n      }\n    } catch (error) {\n      throw new Error(`解析@project://路径失败: ${error.message}`)\n    }\n  }\n\n  /**\n   * 本地模式路径解析（原有逻辑）\n   * @param {string} resourcePath - 资源路径\n   * @param {QueryParams} queryParams - 查询参数\n   * @param {Object} currentProject - 当前项目信息\n   * @returns {string} 解析后的绝对路径\n   */\n  resolveLocalPath(resourcePath, queryParams, currentProject) {\n    // 🚀 新架构：直接使用路径解析器，无需查找.promptx\n    return this.getPathResolver().resolvePath(resourcePath)\n  }\n\n  /**\n   * HTTP模式路径解析（映射到用户目录的项目空间）\n   * @param {string} resourcePath - 资源路径，如\".promptx/resource/xxx\"\n   * @param {QueryParams} queryParams - 查询参数\n   * @param {Object} currentProject - 当前项目信息\n   * @returns {Promise<string>} 解析后的绝对路径\n   */\n  async resolveHttpPath(resourcePath, queryParams, currentProject) {\n    // 🎯 使用projectHash作为目录名\n    const projectHash = this.generateProjectHash(currentProject.workingDirectory)\n    \n    // 🔧 HTTP模式专用路径转换：将.promptx替换为data（仅HTTP模式）\n    // @project://.promptx → @user://.promptx/project/{projectHash}/data/\n    // @project://.promptx/resource/xxx → @user://.promptx/project/{projectHash}/data/resource/xxx\n    // @project://src/index.js → @user://.promptx/project/{projectHash}/data/src/index.js\n    let mappedResourcePath = resourcePath\n    if (resourcePath === '.promptx') {\n      // 特殊处理：.promptx根目录映射到data目录\n      mappedResourcePath = 'data'\n    } else if (resourcePath.startsWith('.promptx/')) {\n      // HTTP模式：将.promptx/替换为data/，提升用户体验\n      mappedResourcePath = resourcePath.replace(/^\\.promptx\\//, 'data/')\n    } else {\n      // 非.promptx路径直接映射到data目录下\n      mappedResourcePath = `data/${resourcePath}`\n    }\n    \n    const mappedPath = `.promptx/project/${projectHash}/${mappedResourcePath}`\n    \n    // 委托给UserProtocol处理\n    return await this.userProtocol.resolvePath(mappedPath, queryParams)\n  }\n\n  /**\n   * 生成项目路径的Hash值（与ProjectManager保持一致）\n   * @param {string} projectPath - 项目路径\n   * @returns {string} 8位Hash值\n   */\n  generateProjectHash(projectPath) {\n    const crypto = require('crypto')\n    return crypto.createHash('md5').update(path.resolve(projectPath)).digest('hex').substr(0, 8)\n  }\n\n  /**\n   * 加载资源内容\n   * @param {string} resolvedPath - 解析后的路径\n   * @param {QueryParams} queryParams - 查询参数\n   * @returns {Promise<string>} 资源内容\n   */\n  async loadContent (resolvedPath, queryParams) {\n    try {\n      // 🎯 检测transport模式\n      const currentProject = ProjectManager.getCurrentProject()\n      const { transport } = currentProject\n      \n      if (transport === 'http') {\n        // HTTP模式下，使用UserProtocol的loadContent方法\n        return await this.userProtocol.loadContent(resolvedPath, queryParams)\n      } else {\n        // 本地模式，使用原有逻辑\n        return await this.loadLocalContent(resolvedPath, queryParams)\n      }\n    } catch (error) {\n      throw error\n    }\n  }\n\n  /**\n   * 本地模式加载资源内容（原有逻辑）\n   * @param {string} resolvedPath - 解析后的路径\n   * @param {QueryParams} queryParams - 查询参数\n   * @returns {Promise<string>} 资源内容\n   */\n  async loadLocalContent (resolvedPath, queryParams) {\n    try {\n      // 检查路径是否存在\n      const stats = await fs.stat(resolvedPath)\n\n      if (stats.isDirectory()) {\n        return await this.loadDirectoryContent(resolvedPath, queryParams)\n      } else if (stats.isFile()) {\n        return await this.loadFileContent(resolvedPath, queryParams)\n      } else {\n        throw new Error(`不支持的文件类型: ${resolvedPath}`)\n      }\n    } catch (error) {\n      if (error.code === 'ENOENT') {\n        // 检查是否需要创建目录\n        if (queryParams?.get('create') === 'true') {\n          await fs.mkdir(path.dirname(resolvedPath), { recursive: true })\n          return '' // 返回空内容\n        }\n\n        // 如果设置了exists参数为false，返回空内容而不是错误\n        if (queryParams?.get('exists') === 'false') {\n          return ''\n        }\n        throw new Error(`文件或目录不存在: ${resolvedPath}`)\n      }\n      throw error\n    }\n  }\n\n  /**\n   * 加载文件内容\n   * @param {string} filePath - 文件路径\n   * @param {QueryParams} queryParams - 查询参数\n   * @returns {Promise<string>} 文件内容\n   */\n  async loadFileContent (filePath, queryParams) {\n    const encoding = queryParams?.get('encoding') || 'utf8'\n    return await fs.readFile(filePath, encoding)\n  }\n\n  /**\n   * 加载目录内容\n   * @param {string} dirPath - 目录路径\n   * @param {QueryParams} queryParams - 查询参数\n   * @returns {Promise<string>} 目录内容列表\n   */\n  async loadDirectoryContent (dirPath, queryParams) {\n    const entries = await fs.readdir(dirPath, { withFileTypes: true })\n\n    // 应用类型过滤\n    const typeFilter = queryParams?.get('type')\n    let filteredEntries = entries\n\n    if (typeFilter) {\n      filteredEntries = entries.filter(entry => {\n        switch (typeFilter) {\n          case 'file': return entry.isFile()\n          case 'dir': return entry.isDirectory()\n          case 'both': return true\n          default: return true\n        }\n      })\n    }\n\n    // 格式化输出\n    const format = queryParams?.get('format') || 'list'\n\n    switch (format) {\n      case 'json':\n        return JSON.stringify(\n          filteredEntries.map(entry => ({\n            name: entry.name,\n            type: entry.isDirectory() ? 'directory' : 'file',\n            path: path.join(dirPath, entry.name)\n          })),\n          null,\n          2\n        )\n\n      case 'paths':\n        return filteredEntries\n          .map(entry => path.join(dirPath, entry.name))\n          .join('\\n')\n\n      case 'list':\n      default:\n        return filteredEntries\n          .map(entry => {\n            const type = entry.isDirectory() ? '[DIR]' : '[FILE]'\n            return `${type} ${entry.name}`\n          })\n          .join('\\n')\n    }\n  }\n\n  /**\n   * 列出项目结构信息 - 新架构\n   * @returns {Promise<object>} 项目信息\n   */\n  async getProjectInfo () {\n    try {\n      const projectRoot = this.getPathResolver().getProjectRoot()\n      const promptxPath = this.getPathResolver().getPromptXDirectory()\n      \n      const result = {\n        projectRoot,\n        promptxPath,\n        architecture: 'state-based',\n        supportedDirectories: this.getPathResolver().getSupportedDirectories(),\n        directories: {}\n      }\n\n      // 检查支持的目录是否存在\n      for (const dirType of this.getPathResolver().getSupportedDirectories()) {\n        try {\n          const fullPath = this.getPathResolver().resolvePath(dirType)\n          const stats = await fs.stat(fullPath)\n          result.directories[dirType] = {\n            path: fullPath,\n            exists: true,\n            type: stats.isDirectory() ? 'directory' : 'file'\n          }\n        } catch (error) {\n          result.directories[dirType] = {\n            path: 'N/A',\n            exists: false\n          }\n        }\n      }\n\n      return result\n    } catch (error) {\n      return { \n        error: `获取项目信息失败: ${error.message}`,\n        architecture: 'state-based'\n      }\n    }\n  }\n\n  /**\n   * 清除缓存 - 新架构：无需清除路径缓存\n   */\n  clearCache () {\n    super.clearCache()\n    // 🎯 新架构：基于状态管理，无需路径缓存\n  }\n}\n\nmodule.exports = ProjectProtocol\n","const ResourceProtocol = require('./ResourceProtocol')\nconst fs = require('fs-extra')\nconst path = require('path')\n\n/**\n * AI角色协议处理器\n * 处理 role:// 协议的资源解析，直接加载完整role文件\n */\nclass RoleProtocol extends ResourceProtocol {\n  constructor () {\n    super('role')\n    this.registry = {}\n    this.registryManager = null // 统一注册表管理器\n  }\n\n  /**\n   * 设置注册表管理器\n   */\n  setRegistryManager(manager) {\n    this.registryManager = manager\n  }\n\n  /**\n   * 设置注册表\n   */\n  setRegistry (registry) {\n    this.registry = registry || {}\n  }\n\n  /**\n   * 获取协议信息\n   */\n  getProtocolInfo () {\n    return {\n      name: 'role',\n      description: 'AI角色资源协议',\n      location: 'role://{role_id}',\n      examples: [\n        'role://video-copywriter',\n        'role://product-owner',\n        'role://assistant',\n        'role://prompt-developer'\n      ]\n    }\n  }\n\n  /**\n   * 解析角色协议\n   * @param {string} rolePath - 角色路径，如 'java-developer'\n   * @param {Object} queryParams - 查询参数（暂未使用）\n   * @returns {Promise<string>} 角色文件内容\n   */\n  async resolve(rolePath, queryParams = {}) {\n    try {\n      // 构建可能的资源ID格式\n      const fullResourceId = `role:${rolePath}`\n      const shortResourceId = rolePath\n      \n      // 从RegistryData查找资源\n      let resourceData = this.registryManager.registryData.findResourceById(rolePath, 'role')\n      \n      if (!resourceData) {\n        // 如果没找到，尝试其他格式\n        resourceData = this.registryManager.registryData.findResourceById(fullResourceId)\n      }\n      \n      if (!resourceData) {\n        const availableRoles = this.registryManager.registryData.getResourcesByProtocol('role')\n          .map(r => r.id).join(', ')\n        throw new Error(`角色 '${rolePath}' 未找到。可用角色: ${availableRoles}`)\n      }\n\n      // 通过ResourceManager加载实际内容\n      const result = await this.registryManager.loadResourceByProtocol(resourceData.reference)\n      \n      return result\n    } catch (error) {\n      throw new Error(`RoleProtocol.resolve failed: ${error.message}`)\n    }\n  }\n\n  /**\n   * 加载资源内容\n   */\n  async loadContent (resolvedPath, queryParams) {\n    try {\n      const content = await fs.readFile(resolvedPath, 'utf-8')\n      return content\n    } catch (error) {\n      throw new Error(`无法加载角色文件 ${resolvedPath}: ${error.message}`)\n    }\n  }\n\n  /**\n   * 验证资源路径\n   */\n  validatePath (resourcePath) {\n    return /^[a-zA-Z0-9_-]+$/.test(resourcePath)\n  }\n}\n\nmodule.exports = RoleProtocol\n","const ResourceProtocol = require('./ResourceProtocol')\nconst fs = require('fs-extra')\nconst path = require('path')\n\n/**\n * 思维模式协议处理器\n * 处理 thought:// 协议的资源解析\n */\nclass ThoughtProtocol extends ResourceProtocol {\n  constructor () {\n    super('thought')\n    this.registry = {}\n    this.registryManager = null // 统一注册表管理器\n  }\n\n  /**\n   * 设置注册表管理器\n   */\n  setRegistryManager(manager) {\n    this.registryManager = manager\n  }\n\n  /**\n   * 设置注册表\n   */\n  setRegistry (registry) {\n    this.registry = registry || {}\n  }\n\n  /**\n   * 获取协议信息\n   */\n  getProtocolInfo () {\n    return {\n      name: 'thought',\n      description: '思维模式资源协议',\n      location: 'thought://{thought_id}',\n      examples: [\n        'thought://prompt-developer',\n        'thought://product-owner'\n      ]\n    }\n  }\n\n  /**\n   * 解析思维协议\n   * @param {string} thoughtPath - 思维路径，如 'remember'\n   * @param {Object} queryParams - 查询参数（暂未使用）\n   * @returns {Promise<string>} 思维文件内容\n   */\n  async resolve(thoughtPath, queryParams = {}) {\n    try {\n      // 构建可能的资源ID格式\n      const fullResourceId = `thought:${thoughtPath}`\n      \n      // 从RegistryData查找资源\n      let resourceData = this.registryManager.registryData.findResourceById(thoughtPath, 'thought')\n      \n      if (!resourceData) {\n        // 如果没找到，尝试其他格式\n        resourceData = this.registryManager.registryData.findResourceById(fullResourceId)\n      }\n      \n      if (!resourceData) {\n        const availableThoughts = this.registryManager.registryData.getResourcesByProtocol('thought')\n          .map(r => r.id).join(', ')\n        throw new Error(`思维模式 '${thoughtPath}' 未找到。可用思维模式: ${availableThoughts}`)\n      }\n\n      // 通过ResourceManager加载实际内容\n      const result = await this.registryManager.loadResourceByProtocol(resourceData.reference)\n      \n      return result\n    } catch (error) {\n      throw new Error(`ThoughtProtocol.resolve failed: ${error.message}`)\n    }\n  }\n\n  /**\n   * 加载资源内容\n   */\n  async loadContent (resolvedPath, queryParams) {\n    try {\n      const content = await fs.readFile(resolvedPath, 'utf-8')\n      return content\n    } catch (error) {\n      throw new Error(`无法加载思维模式文件 ${resolvedPath}: ${error.message}`)\n    }\n  }\n\n  /**\n   * 验证资源路径\n   */\n  validatePath (resourcePath) {\n    return /^[a-zA-Z0-9_-]+$/.test(resourcePath)\n  }\n}\n\nmodule.exports = ThoughtProtocol\n","const ResourceProtocol = require('./ResourceProtocol')\nconst fs = require('fs-extra')\nconst path = require('path')\n\n/**\n * 执行模式协议处理器\n * 处理 execution:// 协议的资源解析\n */\nclass ExecutionProtocol extends ResourceProtocol {\n  constructor () {\n    super('execution')\n    this.registry = {}\n    this.registryManager = null // 统一注册表管理器\n  }\n\n  /**\n   * 设置注册表管理器\n   */\n  setRegistryManager(manager) {\n    this.registryManager = manager\n  }\n\n  /**\n   * 设置注册表\n   */\n  setRegistry (registry) {\n    this.registry = registry || {}\n  }\n\n  /**\n   * 获取协议信息\n   */\n  getProtocolInfo () {\n    return {\n      name: 'execution',\n      description: '执行模式资源协议',\n      location: 'execution://{execution_id}',\n      examples: [\n        'execution://deal-at-reference',\n        'execution://prompt-developer',\n        'execution://memory-trigger'\n      ]\n    }\n  }\n\n  /**\n   * 解析执行协议\n   * @param {string} executionPath - 执行路径，如 'best-practice'\n   * @param {Object} queryParams - 查询参数（暂未使用）\n   * @returns {Promise<string>} 执行文件内容\n   */\n  async resolve(executionPath, queryParams = {}) {\n    try {\n      // 构建可能的资源ID格式\n      const fullResourceId = `execution:${executionPath}`\n      \n      // 从RegistryData查找资源\n      let resourceData = this.registryManager.registryData.findResourceById(executionPath, 'execution')\n      \n      if (!resourceData) {\n        // 如果没找到，尝试其他格式\n        resourceData = this.registryManager.registryData.findResourceById(fullResourceId)\n      }\n      \n      if (!resourceData) {\n        const availableExecutions = this.registryManager.registryData.getResourcesByProtocol('execution')\n          .map(r => r.id).join(', ')\n        throw new Error(`执行模式 '${executionPath}' 未找到。可用执行模式: ${availableExecutions}`)\n      }\n\n      // 通过ResourceManager加载实际内容\n      const result = await this.registryManager.loadResourceByProtocol(resourceData.reference)\n      \n      return result\n    } catch (error) {\n      throw new Error(`ExecutionProtocol.resolve failed: ${error.message}`)\n    }\n  }\n\n  /**\n   * 加载资源内容\n   */\n  async loadContent (resolvedPath, queryParams) {\n    try {\n      const content = await fs.readFile(resolvedPath, 'utf-8')\n      return content\n    } catch (error) {\n      throw new Error(`无法加载执行模式文件 ${resolvedPath}: ${error.message}`)\n    }\n  }\n\n  /**\n   * 验证资源路径\n   */\n  validatePath (resourcePath) {\n    return /^[a-zA-Z0-9_-]+$/.test(resourcePath)\n  }\n}\n\nmodule.exports = ExecutionProtocol\n","const ResourceProtocol = require('./ResourceProtocol')\nconst fs = require('fs-extra')\nconst path = require('path')\n\n/**\n * 知识资源协议处理器\n * 处理 knowledge:// 协议的资源解析\n */\nclass KnowledgeProtocol extends ResourceProtocol {\n  constructor () {\n    super('knowledge')\n    this.registry = {}\n    this.registryManager = null // 统一注册表管理器\n  }\n\n  /**\n   * 设置注册表管理器\n   */\n  setRegistryManager(manager) {\n    this.registryManager = manager\n  }\n\n  /**\n   * 设置注册表\n   */\n  setRegistry (registry) {\n    this.registry = registry || {}\n  }\n\n  /**\n   * 获取协议信息\n   */\n  getProtocolInfo () {\n    return {\n      name: 'knowledge',\n      description: '知识资源协议',\n      location: 'knowledge://{knowledge_id}',\n      examples: [\n        'knowledge://xiaohongshu-marketing',\n        'knowledge://ai-tools-guide'\n      ]\n    }\n  }\n\n  /**\n   * 解析知识协议\n   * @param {string} knowledgePath - 知识路径，如 'scrum'\n   * @param {Object} queryParams - 查询参数（暂未使用）\n   * @returns {Promise<string>} 知识文件内容\n   */\n  async resolve(knowledgePath, queryParams = {}) {\n    try {\n      // 构建可能的资源ID格式\n      const fullResourceId = `knowledge:${knowledgePath}`\n      \n      // 从RegistryData查找资源\n      let resourceData = this.registryManager.registryData.findResourceById(knowledgePath, 'knowledge')\n      \n      if (!resourceData) {\n        // 如果没找到，尝试其他格式\n        resourceData = this.registryManager.registryData.findResourceById(fullResourceId)\n      }\n      \n      if (!resourceData) {\n        const availableKnowledge = this.registryManager.registryData.getResourcesByProtocol('knowledge')\n          .map(r => r.id).join(', ')\n        throw new Error(`知识模块 '${knowledgePath}' 未找到。可用知识模块: ${availableKnowledge}`)\n      }\n\n      // 通过ResourceManager加载实际内容\n      const result = await this.registryManager.loadResourceByProtocol(resourceData.reference)\n      \n      return result\n    } catch (error) {\n      throw new Error(`KnowledgeProtocol.resolve failed: ${error.message}`)\n    }\n  }\n\n  /**\n   * 加载资源内容\n   */\n  async loadContent (resolvedPath, queryParams) {\n    try {\n      const content = await fs.readFile(resolvedPath, 'utf-8')\n      return content\n    } catch (error) {\n      throw new Error(`无法加载知识资源文件 ${resolvedPath}: ${error.message}`)\n    }\n  }\n\n  /**\n   * 验证资源路径\n   */\n  validatePath (resourcePath) {\n    return /^[a-zA-Z0-9_-]+$/.test(resourcePath)\n  }\n}\n\nmodule.exports = KnowledgeProtocol ","const ResourceProtocol = require('./ResourceProtocol');\n\n/**\n * Tool协议处理器\n * 处理 @tool://tool-name 格式的资源引用\n * 从注册表中查找并加载工具JavaScript代码\n */\nclass ToolProtocol extends ResourceProtocol {\n  constructor() {\n    super('tool');\n    this.registryManager = null;\n  }\n\n  /**\n   * 设置注册表管理器引用\n   * @param {Object} manager - ResourceManager实例\n   */\n  setRegistryManager(manager) {\n    this.registryManager = manager;\n  }\n\n  /**\n   * 解析工具资源路径\n   * @param {string} toolPath - 工具名称，如 \"calculator\"\n   * @param {Object} queryParams - 查询参数（可选）\n   * @returns {Promise<Object>} 工具代码和元数据\n   */\n  async resolve(toolPath, queryParams = {}) {\n    if (!this.registryManager) {\n      throw new Error('ToolProtocol: Registry manager not set');\n    }\n\n    // 1. 从注册表查找tool资源\n    const toolResource = this.registryManager.registryData\n      .findResourceById(toolPath, 'tool');\n    \n    if (!toolResource) {\n      throw new Error(`Tool '${toolPath}' not found in registry`);\n    }\n\n    // 2. 加载tool文件内容\n    const toolContent = await this.registryManager\n      .loadResourceByProtocol(toolResource.reference);\n    \n    // 3. 验证工具代码格式\n    this.validateToolContent(toolContent, toolPath);\n\n    // 4. 返回工具信息\n    return {\n      id: toolPath,\n      content: toolContent,\n      metadata: toolResource,\n      source: toolResource.source || 'unknown'\n    };\n  }\n\n  /**\n   * 验证工具内容格式\n   * @param {string} content - 工具文件内容\n   * @param {string} toolPath - 工具路径\n   */\n  validateToolContent(content, toolPath) {\n    if (!content || typeof content !== 'string') {\n      throw new Error(`Tool '${toolPath}': Invalid or empty content`);\n    }\n\n    // 基本的JavaScript语法检查\n    try {\n      // 尝试创建一个函数来验证语法\n      new Function(content);\n    } catch (syntaxError) {\n      throw new Error(`Tool '${toolPath}': JavaScript syntax error - ${syntaxError.message}`);\n    }\n  }\n\n  /**\n   * 获取协议信息\n   * @returns {Object} 协议描述信息\n   */\n  getProtocolInfo() {\n    return {\n      name: 'tool',\n      description: 'Tool资源协议 - 加载可执行的JavaScript工具',\n      syntax: 'tool://{tool_id}',\n      examples: [\n        'tool://calculator',\n        'tool://send-email', \n        'tool://data-processor',\n        'tool://api-client'\n      ],\n      supportedFileTypes: ['.tool.js'],\n      usageNote: '工具文件必须导出符合PromptX Tool Interface的对象'\n    };\n  }\n\n  /**\n   * 检查缓存策略\n   * @param {string} toolPath - 工具路径\n   * @returns {boolean} 是否应该缓存\n   */\n  shouldCache(toolPath) {\n    // 工具代码通常比较稳定，启用缓存以提高性能\n    return true;\n  }\n\n  /**\n   * 获取缓存键\n   * @param {string} toolPath - 工具路径\n   * @returns {string} 缓存键\n   */\n  getCacheKey(toolPath) {\n    return `tool://${toolPath}`;\n  }\n}\n\nmodule.exports = ToolProtocol;","const ResourceProtocol = require('./ResourceProtocol')\n\n/**\n * Manual协议处理器\n * 处理 @manual://tool-name 格式的资源引用\n * 从注册表中查找并加载工具使用手册\n */\nclass ManualProtocol extends ResourceProtocol {\n  constructor() {\n    super('manual')\n    this.registryManager = null\n  }\n\n  /**\n   * 设置注册表管理器引用\n   * @param {Object} manager - ResourceManager实例\n   */\n  setRegistryManager(manager) {\n    this.registryManager = manager\n  }\n\n  /**\n   * 解析工具手册资源路径\n   * @param {string} manualPath - 手册名称，如 \"calculator\"\n   * @param {Object} queryParams - 查询参数（可选）\n   * @returns {Promise<Object>} 手册内容和元数据\n   */\n  async resolve(manualPath, queryParams = {}) {\n    if (!this.registryManager) {\n      throw new Error('ManualProtocol: Registry manager not set')\n    }\n\n    // 1. 从注册表查找manual资源\n    const manualResource = this.registryManager.registryData\n      .findResourceById(manualPath, 'manual')\n    \n    if (!manualResource) {\n      // 尝试查找对应的tool资源，给出更友好的提示\n      const toolResource = this.registryManager.registryData\n        .findResourceById(manualPath, 'tool')\n      \n      if (toolResource) {\n        throw new Error(`Manual '${manualPath}' not found. Found corresponding tool but no manual. Consider creating ${manualPath}.manual.md`)\n      }\n      \n      throw new Error(`Manual '${manualPath}' not found in registry`)\n    }\n\n    // 2. 加载manual文件内容\n    const manualContent = await this.registryManager\n      .loadResourceByProtocol(manualResource.reference)\n    \n    // 3. 验证手册内容格式\n    this.validateManualContent(manualContent, manualPath)\n\n    // 4. 返回手册信息\n    return {\n      id: manualPath,\n      content: manualContent,\n      metadata: manualResource,\n      source: manualResource.source || 'unknown'\n    }\n  }\n\n  /**\n   * 验证手册内容格式\n   * @param {string} content - 手册文件内容\n   * @param {string} manualPath - 手册路径\n   */\n  validateManualContent(content, manualPath) {\n    if (!content || typeof content !== 'string') {\n      throw new Error(`Manual '${manualPath}': Invalid or empty content`)\n    }\n\n    const trimmedContent = content.trim()\n    if (trimmedContent.length === 0) {\n      throw new Error(`Manual '${manualPath}': Empty manual content`)\n    }\n\n    // 验证是否包含<manual>标签\n    if (!trimmedContent.includes('<manual>') || !trimmedContent.includes('</manual>')) {\n      throw new Error(`Manual '${manualPath}': Missing required <manual> tags`)\n    }\n  }\n\n  /**\n   * 获取协议信息\n   * @returns {Object} 协议描述信息\n   */\n  getProtocolInfo() {\n    return {\n      name: 'manual',\n      description: 'Manual资源协议 - 加载工具使用手册和说明文档',\n      syntax: 'manual://{manual_id}',\n      examples: [\n        'manual://calculator',\n        'manual://send-email',\n        'manual://data-processor',\n        'manual://api-client'\n      ],\n      supportedFileTypes: ['.manual.md'],\n      usageNote: '手册文件必须使用<manual>标签包裹内容，提供工具的详细使用说明'\n    }\n  }\n\n  /**\n   * 检查缓存策略\n   * @param {string} manualPath - 手册路径\n   * @returns {boolean} 是否应该缓存\n   */\n  shouldCache(manualPath) {\n    // 手册内容通常比较稳定，启用缓存\n    return true\n  }\n\n  /**\n   * 获取缓存键\n   * @param {string} manualPath - 手册路径\n   * @returns {string} 缓存键\n   */\n  getCacheKey(manualPath) {\n    return `manual://${manualPath}`\n  }\n}\n\nmodule.exports = ManualProtocol","const ResourceProtocol = require('./ResourceProtocol')\nconst path = require('path')\nconst fs = require('fs').promises\n\n/**\n * 文件协议实现\n * 实现@file://协议，用于访问本地文件系统中的文件\n */\nclass FileProtocol extends ResourceProtocol {\n  constructor (options = {}) {\n    super('file', options)\n  }\n\n  /**\n   * 设置注册表（保持与其他协议的一致性）\n   */\n  setRegistry (registry) {\n    // File协议不使用注册表，但为了一致性提供此方法\n    this.registry = registry || {}\n  }\n\n  /**\n   * 获取协议信息\n   * @returns {object} 协议信息\n   */\n  getProtocolInfo () {\n    return {\n      name: 'file',\n      description: '文件系统协议，提供本地文件访问',\n      location: 'file://{path}',\n      examples: [\n        'file://package.json',\n        'file:///absolute/path/to/file.txt',\n        'file://./relative/path/file.md',\n        'file://../parent/file.json'\n      ],\n      params: this.getSupportedParams()\n    }\n  }\n\n  /**\n   * 支持的查询参数\n   * @returns {object} 参数说明\n   */\n  getSupportedParams () {\n    return {\n      ...super.getSupportedParams(),\n      encoding: 'string - 文件编码 (utf8, ascii, binary等)',\n      exists: 'boolean - 仅返回存在的文件'\n    }\n  }\n\n  /**\n   * 验证文件协议路径\n   * @param {string} resourcePath - 资源路径\n   * @returns {boolean} 是否有效\n   */\n  validatePath (resourcePath) {\n    if (!super.validatePath(resourcePath)) {\n      return false\n    }\n\n    // 基本路径验证 - 允许相对路径和绝对路径\n    return typeof resourcePath === 'string' && resourcePath.length > 0\n  }\n\n  /**\n   * 解析文件路径\n   * @param {string} resourcePath - 原始资源路径\n   * @param {QueryParams} queryParams - 查询参数\n   * @returns {Promise<string>} 解析后的绝对路径\n   */\n  async resolvePath (resourcePath, queryParams) {\n    let resolvedPath\n\n    if (path.isAbsolute(resourcePath)) {\n      // 绝对路径直接使用\n      resolvedPath = resourcePath\n    } else {\n      // 相对路径相对于当前工作目录解析\n      resolvedPath = path.resolve(process.cwd(), resourcePath)\n    }\n\n    // 规范化路径\n    resolvedPath = path.normalize(resolvedPath)\n\n    return resolvedPath\n  }\n\n  /**\n   * 加载资源内容\n   * @param {string} resolvedPath - 解析后的路径\n   * @param {QueryParams} queryParams - 查询参数\n   * @returns {Promise<string>} 资源内容\n   */\n  async loadContent (resolvedPath, queryParams) {\n    try {\n      // 检查路径是否存在\n      const stats = await fs.stat(resolvedPath)\n\n      if (stats.isDirectory()) {\n        return await this.loadDirectoryContent(resolvedPath, queryParams)\n      } else if (stats.isFile()) {\n        return await this.loadFileContent(resolvedPath, queryParams)\n      } else {\n        throw new Error(`不支持的文件类型: ${resolvedPath}`)\n      }\n    } catch (error) {\n      if (error.code === 'ENOENT') {\n        // 如果设置了exists参数为false，返回空内容而不是错误\n        if (queryParams && queryParams.get('exists') === 'false') {\n          return ''\n        }\n        throw new Error(`文件或目录不存在: ${resolvedPath}`)\n      }\n      throw error\n    }\n  }\n\n  /**\n   * 加载文件内容\n   * @param {string} filePath - 文件路径\n   * @param {QueryParams} queryParams - 查询参数\n   * @returns {Promise<string>} 文件内容\n   */\n  async loadFileContent (filePath, queryParams) {\n    const encoding = queryParams?.get('encoding') || 'utf8'\n    return await fs.readFile(filePath, encoding)\n  }\n\n  /**\n   * 加载目录内容\n   * @param {string} dirPath - 目录路径\n   * @param {QueryParams} queryParams - 查询参数\n   * @returns {Promise<string>} 目录内容列表\n   */\n  async loadDirectoryContent (dirPath, queryParams) {\n    const entries = await fs.readdir(dirPath, { withFileTypes: true })\n\n    // 应用类型过滤\n    const typeFilter = queryParams?.get('type')\n    let filteredEntries = entries\n\n    if (typeFilter) {\n      filteredEntries = entries.filter(entry => {\n        switch (typeFilter) {\n          case 'file': return entry.isFile()\n          case 'dir': return entry.isDirectory()\n          case 'both': return true\n          default: return true\n        }\n      })\n    }\n\n    // 格式化输出\n    const format = queryParams?.get('format') || 'list'\n\n    switch (format) {\n      case 'json':\n        return JSON.stringify(\n          filteredEntries.map(entry => ({\n            name: entry.name,\n            type: entry.isDirectory() ? 'directory' : 'file',\n            path: path.join(dirPath, entry.name)\n          })),\n          null,\n          2\n        )\n\n      case 'paths':\n        return filteredEntries\n          .map(entry => path.join(dirPath, entry.name))\n          .join('\\n')\n\n      case 'list':\n      default:\n        return filteredEntries\n          .map(entry => {\n            const type = entry.isDirectory() ? '[DIR]' : '[FILE]'\n            return `${type} ${entry.name}`\n          })\n          .join('\\n')\n    }\n  }\n}\n\nmodule.exports = FileProtocol","const fs = require('fs')\nconst RegistryData = require('./RegistryData')\nconst ResourceProtocolParser = require('./resourceProtocolParser') \nconst DiscoveryManager = require('./discovery/DiscoveryManager')\nconst logger = require('@promptx/logger')\n\n// 导入协议处理器\nconst PackageProtocol = require('./protocols/PackageProtocol')\nconst ProjectProtocol = require('./protocols/ProjectProtocol')\nconst RoleProtocol = require('./protocols/RoleProtocol')\nconst ThoughtProtocol = require('./protocols/ThoughtProtocol')\nconst ExecutionProtocol = require('./protocols/ExecutionProtocol')\nconst KnowledgeProtocol = require('./protocols/KnowledgeProtocol')\nconst ToolProtocol = require('./protocols/ToolProtocol')\nconst ManualProtocol = require('./protocols/ManualProtocol')\nconst UserProtocol = require('./protocols/UserProtocol')\nconst FileProtocol = require('./protocols/FileProtocol')\n\nclass ResourceManager {\n  constructor() {\n    // 新架构：统一的资源注册表\n    this.registryData = RegistryData.createEmpty('merged', null)\n    \n    // 协议解析器\n    this.protocolParser = new ResourceProtocolParser()\n    this.parser = new ResourceProtocolParser() // 向后兼容别名\n    \n    // 资源发现管理器\n    this.discoveryManager = new DiscoveryManager()\n    \n    // 初始化协议处理器\n    this.protocols = new Map()\n    this.initializeProtocols()\n  }\n\n  /**\n   * 初始化所有协议处理器\n   */\n  initializeProtocols() {\n    // 基础协议 - 直接文件系统映射\n    this.protocols.set('package', new PackageProtocol())\n    this.protocols.set('project', new ProjectProtocol()) \n    this.protocols.set('file', new FileProtocol())\n    this.protocols.set('user', new UserProtocol())\n\n    // 逻辑协议 - 需要注册表查询\n    this.protocols.set('role', new RoleProtocol())\n    this.protocols.set('thought', new ThoughtProtocol())\n    this.protocols.set('execution', new ExecutionProtocol())\n    this.protocols.set('knowledge', new KnowledgeProtocol())\n    this.protocols.set('tool', new ToolProtocol())\n    this.protocols.set('manual', new ManualProtocol())\n  }\n\n  /**\n   * 新架构初始化方法\n   */\n  async initializeWithNewArchitecture() {\n    try {\n      logger.info('[ResourceManager] Starting initialization...')\n      \n      // 1. 清空现有注册表\n      this.registryData.clear()\n      logger.info('[ResourceManager] Cleared existing registry')\n\n      // 2. 清除发现器缓存\n      if (this.discoveryManager && typeof this.discoveryManager.clearCache === 'function') {\n        this.discoveryManager.clearCache()\n        logger.info('[ResourceManager] Cleared discovery cache')\n      }\n\n      // 3. 填充新的RegistryData\n      logger.info('[ResourceManager] Populating registry data...')\n      await this.populateRegistryData()\n\n      // 4. 为逻辑协议设置注册表引用\n      this.setupLogicalProtocols()\n\n      // 5. 设置初始化状态\n      this.initialized = true\n\n      // 记录初始化完成的统计信息\n      const stats = this.registryData.getStats()\n      logger.info('[ResourceManager] Initialization complete:', {\n        totalResources: this.registryData.size,\n        bySource: stats.bySource,\n        byProtocol: stats.byProtocol\n      })\n    } catch (error) {\n      logger.warn(`ResourceManager new architecture initialization failed: ${error.message}`)\n      logger.warn('ResourceManager continuing with empty registry')\n      this.initialized = true // 即使失败也标记为已初始化，避免重复尝试\n    }\n  }\n\n  /**\n   * 填充新的RegistryData\n   */\n  async populateRegistryData() {\n    // 清空现有数据\n    this.registryData.clear()\n    \n    logger.info('[ResourceManager] Discovery managers:', {\n      count: this.discoveryManager.discoveries.length,\n      sources: this.discoveryManager.discoveries.map(d => d.source)\n    })\n    \n    // 从各个发现器获取RegistryData并合并\n    for (const discovery of this.discoveryManager.discoveries) {\n      try {\n        logger.info(`[ResourceManager] Loading from ${discovery.source} discovery...`)\n        \n        if (typeof discovery.getRegistryData === 'function') {\n          const registryData = await discovery.getRegistryData()\n          if (registryData && registryData.resources) {\n            const resourceCount = registryData.size || 0\n            logger.info(`[ResourceManager] Found ${resourceCount} resources from ${discovery.source}`)\n            \n            // 合并资源到主注册表\n            this.registryData.merge(registryData, true) // 允许覆盖\n            \n            // 调试：打印合并的资源\n            if (discovery.source === 'USER' && registryData.resources) {\n              logger.debug(`[ResourceManager] USER resources to merge:`, registryData.resources.map(r => `${r.protocol}://${r.id}`))\n            }\n            \n            // 记录合并后的状态\n            logger.info(`[ResourceManager] After merging ${discovery.source}, total: ${this.registryData.size}`)\n          } else {\n            logger.info(`[ResourceManager] No resources found from ${discovery.source}`)\n          }\n        } else {\n          logger.info(`[ResourceManager] ${discovery.source} does not support getRegistryData`)\n        }\n      } catch (error) {\n        logger.warn(`Failed to get RegistryData from ${discovery.source}: ${error.message}`)\n      }\n    }\n    \n    logger.info('[ResourceManager] Registry population complete, total resources:', this.registryData.size)\n  }\n\n  /**\n   * 为逻辑协议设置注册表引用\n   */\n  setupLogicalProtocols() {\n    // 将统一注册表传递给逻辑协议处理器\n    const roleProtocol = this.protocols.get('role')\n    const executionProtocol = this.protocols.get('execution')\n    const thoughtProtocol = this.protocols.get('thought')\n    const knowledgeProtocol = this.protocols.get('knowledge')\n    const toolProtocol = this.protocols.get('tool')\n    const manualProtocol = this.protocols.get('manual')\n    \n    if (roleProtocol) {\n      roleProtocol.setRegistryManager(this)\n    }\n    if (executionProtocol) {\n      executionProtocol.setRegistryManager(this)\n    }\n    if (thoughtProtocol) {\n      thoughtProtocol.setRegistryManager(this)\n    }\n    if (knowledgeProtocol) {\n      knowledgeProtocol.setRegistryManager(this)\n    }\n    if (toolProtocol) {\n      toolProtocol.setRegistryManager(this)\n    }\n    if (manualProtocol) {\n      manualProtocol.setRegistryManager(this)\n    }\n    \n    // 逻辑协议设置完成，不输出日志避免干扰用户界面\n  }\n\n  /**\n   * 通过协议解析加载资源内容\n   * @param {string} reference - 资源引用\n   * @returns {Promise<string>} 资源内容\n   */\n  async loadResourceByProtocol(reference) {\n    // 1. 使用ResourceProtocolParser解析DPML语法\n    const parsed = this.protocolParser.parse(reference)\n    \n    // 2. 获取对应的协议处理器\n    const protocol = this.protocols.get(parsed.protocol)\n    if (!protocol) {\n      throw new Error(`不支持的协议: ${parsed.protocol}`)\n    }\n\n    // 3. 委托给协议处理器解析并加载内容\n    const result = await protocol.resolve(parsed.path, parsed.queryParams)\n    \n    // 4. 确保返回字符串内容，解包可能的对象格式\n    if (typeof result === 'string') {\n      return result\n    } else if (result && typeof result === 'object' && result.content) {\n      return result.content\n    } else {\n      throw new Error(`协议${parsed.protocol}返回了无效的内容格式`)\n    }\n  }\n\n  async loadResource(resourceId) {\n    try {\n      // 确保ResourceManager已初始化\n      if (!this.initialized) {\n        logger.info('[ResourceManager] Initializing resource manager...')\n        await this.initializeWithNewArchitecture()\n      }\n      \n      // 处理@开头的DPML格式（如 @file://path, @!role://java-developer）\n      if (resourceId.startsWith('@')) {\n        const parsed = this.protocolParser.parse(resourceId)\n        \n        // 对于基础协议（file, user, package, project），直接通过协议处理器加载\n        const basicProtocols = ['file', 'user', 'package', 'project']\n        if (basicProtocols.includes(parsed.protocol)) {\n          const content = await this.loadResourceByProtocol(resourceId)\n          return {\n            success: true,\n            content,\n            resourceId,\n            reference: resourceId\n          }\n        }\n        \n        // 对于逻辑协议，从RegistryData查找资源\n        logger.debug(`[ResourceManager] Finding resource: protocol=${parsed.protocol}, id=${parsed.path}`)\n        const resourceData = this.registryData.findResourceById(parsed.path, parsed.protocol)\n        if (!resourceData) {\n          // 打印所有可用的资源以便调试\n          const availableResources = this.registryData.getResourcesByProtocol(parsed.protocol)\n          logger.error(`[ResourceManager] Resource not found: ${parsed.protocol}:${parsed.path}`)\n          logger.error(`[ResourceManager] Available ${parsed.protocol} resources:`, availableResources.map(r => `${r.id} (${r.source})`))\n          throw new Error(`Resource not found: ${parsed.protocol}:${parsed.path}`)\n        }\n        logger.debug(`[ResourceManager] Found resource: ${resourceData.id} from ${resourceData.source}`)\n        \n        // 通过协议解析加载内容\n        const content = await this.loadResourceByProtocol(resourceData.reference)\n        \n        return {\n          success: true,\n          content,\n          resourceId,\n          reference: resourceData.reference\n        }\n      }\n      \n      // 处理URL格式（如 thought://systematic-testing）\n      const urlMatch = resourceId.match(/^([a-zA-Z][a-zA-Z0-9_-]*):\\/\\/(.+)$/)\n      if (urlMatch) {\n        const [, protocol, id] = urlMatch\n        const resourceData = this.registryData.findResourceById(id, protocol)\n        if (!resourceData) {\n          throw new Error(`Resource not found: ${resourceId}`)\n        }\n        \n        // 通过协议解析加载内容\n        const content = await this.loadResourceByProtocol(resourceData.reference)\n        \n        return {\n          success: true,\n          content,\n          resourceId,\n          reference: resourceData.reference\n        }\n      }\n      \n      // 处理传统格式（如 role:java-developer）\n      let reference = null\n      \n      // 如果包含协议前缀（如 thought:remember）\n      if (resourceId.includes(':')) {\n        const [protocol, id] = resourceId.split(':', 2)\n        const resourceData = this.registryData.findResourceById(id, protocol)\n        if (resourceData) {\n          reference = resourceData.reference\n        }\n      } else {\n        // 如果没有协议前缀，尝试查找任意协议的资源\n        const resourceData = this.registryData.findResourceById(resourceId)\n        if (resourceData) {\n          reference = resourceData.reference\n        }\n      }\n      \n      if (!reference) {\n        throw new Error(`Resource not found: ${resourceId}`)\n      }\n      \n      // 通过协议解析加载内容\n      const content = await this.loadResourceByProtocol(reference)\n\n      return {\n        success: true,\n        content,\n        resourceId,\n        reference\n      }\n    } catch (error) {\n      logger.debug(`ResourceManager.loadResource failed for ${resourceId}: ${error.message}`)\n      return {\n        success: false,\n        error: error,  // 返回完整的Error对象，而不是message字符串\n        resourceId\n      }\n    }\n  }\n\n  /**\n   * 解析协议引用并返回相关信息\n   */\n  async resolveProtocolReference(reference) {\n    try {\n      const parsed = this.protocolParser.parse(reference)\n      \n      return {\n        success: true,\n        protocol: parsed.protocol,\n        path: parsed.path,\n        queryParams: parsed.queryParams,\n        reference\n      }\n    } catch (error) {\n      return {\n        success: false,\n        error: error.message,\n        reference\n      }\n    }\n  }\n\n  /**\n   * 获取所有可用的协议列表\n   */\n  getAvailableProtocols() {\n    return Array.from(this.protocols.keys())\n  }\n\n  /**\n   * 检查是否支持指定协议\n   */\n  supportsProtocol(protocol) {\n    return this.protocols.has(protocol)\n  }\n\n  /**\n   * 设置初始化状态\n   */\n  set initialized(value) {\n    this._initialized = value\n  }\n\n  /**\n   * 获取初始化状态\n   */\n  get initialized() {\n    return this._initialized || false\n  }\n\n  /**\n   * 解析资源URL（向后兼容接口）\n   * 返回格式：{success: boolean, content?: string, error?: Error}\n   */\n  async resolve(resourceUrl) {\n    return await this.loadResource(resourceUrl)\n  }\n\n  /**\n   * 获取注册表统计信息\n   */\n  getStats() {\n    return {\n      totalResources: this.registryData.size,\n      protocols: this.getAvailableProtocols(),\n      initialized: this.initialized\n    }\n  }\n\n  /**\n   * 刷新资源（重新发现并注册）\n   */\n  async refreshResources() {\n    try {\n      // 1. 标记为未初始化\n      this.initialized = false\n      \n      // 2. 清空注册表\n      this.registryData.clear()\n      \n      // 3. 清除发现器缓存\n      if (this.discoveryManager && typeof this.discoveryManager.clearCache === 'function') {\n        this.discoveryManager.clearCache()\n      }\n      \n      // 4. 重新初始化\n      await this.initializeWithNewArchitecture()\n      \n    } catch (error) {\n      logger.warn(`ResourceManager resource refresh failed: ${error.message}`)\n      // 失败时保持注册表为空状态，下次调用时重试\n    }\n  }\n}\n\nmodule.exports = ResourceManager","/**\n * PromptX Resource Module\n * 基于DPML资源协议的统一资源管理模块\n *\n * 提供完整的资源协议解析、注册表管理、资源加载功能\n */\n\n// 核心管理器\nconst ResourceManager = require('./resourceManager')\n\n// 核心组件\nconst ResourceProtocolParser = require('./resourceProtocolParser')\n\n// 数据类型\nconst {\n  LoadingSemantics,\n  ParsedReference,\n  QueryParams,\n  NestedReference,\n  ResourceContent,\n  LazyResource,\n  ProcessedResult,\n  ResourceResult,\n  ProtocolInfo\n} = require('./types')\n\n// 全局单例 ResourceManager 实例\nlet globalResourceManager = null\n\n/**\n * 获取全局单例 ResourceManager 实例\n * 确保整个应用程序使用同一个 ResourceManager 实例\n */\nfunction getGlobalResourceManager() {\n  if (!globalResourceManager) {\n    globalResourceManager = new ResourceManager()\n  }\n  return globalResourceManager\n}\n\n/**\n * 重置全局 ResourceManager 实例\n * 主要用于测试或需要完全重新初始化的场景\n */\nfunction resetGlobalResourceManager() {\n  globalResourceManager = null\n}\n\n// 导出主接口\nmodule.exports = {\n  // 主管理器类\n  ResourceManager,\n\n  // 全局单例实例\n  getGlobalResourceManager,\n  resetGlobalResourceManager,\n\n  // 核心组件\n  ResourceProtocolParser,\n\n  // 数据类型\n  LoadingSemantics,\n  ParsedReference,\n  QueryParams,\n  NestedReference,\n  ResourceContent,\n  LazyResource,\n  ProcessedResult,\n  ResourceResult,\n  ProtocolInfo,\n\n  // 便捷方法 - 创建默认实例（保持向后兼容）\n  createManager: (options) => new ResourceManager(options),\n\n  // 便捷方法 - 快速解析\n  parse: (resourceRef) => {\n    const parser = new ResourceProtocolParser()\n    return parser.parse(resourceRef)\n  },\n\n  // 便捷方法 - 快速验证\n  validate: (resourceRef) => {\n    try {\n      const parser = new ResourceProtocolParser()\n      parser.parse(resourceRef)\n      return true\n    } catch (error) {\n      return false\n    }\n  }\n}\n","const path = require('path');\nconst Module = require('module');\nconst logger = require('@promptx/logger');\n\n/**\n * SandboxIsolationManager - 统一管理所有沙箱隔离逻辑\n * \n * 职责：\n * - 创建完全隔离的VM沙箱环境\n * - 统一管理模块系统、进程环境、全局对象的隔离\n * - 提供安全、一致的沙箱执行上下文\n */\nclass SandboxIsolationManager {\n  constructor(workingPath, options = {}) {\n    this.workingPath = workingPath;  // 工作目录（~/.promptx）\n    this.toolboxPath = options.toolboxPath || workingPath;  // 工具箱目录（用于依赖加载）\n    this.sandboxPath = workingPath;  // 向后兼容\n    this.options = {\n      enableDependencyLoading: true,\n      enableBuiltinModules: true,\n      enableFileSystemAccess: false,\n      ...options\n    };\n    this.isolatedContext = null;\n  }\n\n  /**\n   * 创建完全隔离的沙箱环境\n   * @returns {Object} 隔离的沙箱上下文\n   */\n  createIsolatedContext() {\n    if (this.isolatedContext) {\n      return this.isolatedContext;\n    }\n\n    this.isolatedContext = {\n      // 1. 模块系统隔离 - 核心功能\n      require: this.createIsolatedRequire(),\n      module: { exports: {} },\n      exports: {},\n      \n      // 2. 进程环境隔离\n      process: this.createIsolatedProcess(),\n      \n      // 3. 全局对象隔离\n      ...this.createIsolatedGlobals(),\n      \n      // 4. 路径相关隔离\n      __dirname: this.workingPath,\n      __filename: path.join(this.workingPath, 'sandbox.js'),\n      \n      // 5. 注入受限的 fs（直接可用）\n      fs: this.createRestrictedFS(),\n      \n      // 6. 阻止动态代码执行\n      eval: () => {\n        throw new Error('[SandboxIsolation] eval is not allowed in sandbox');\n      },\n      Function: undefined\n    };\n\n    return this.isolatedContext;\n  }\n\n  /**\n   * 创建隔离的require函数 - 解决核心依赖加载问题\n   * @returns {Function} 隔离的require函数\n   */\n  createIsolatedRequire() {\n    // 关键：使用Module.createRequire创建绑定到toolbox路径的require\n    const contextFile = path.join(this.toolboxPath, 'package.json');\n    let sandboxRequire;\n    \n    try {\n      // 创建绑定到toolbox上下文的require（依赖在这里）\n      sandboxRequire = Module.createRequire(contextFile);\n    } catch (error) {\n      // fallback: 如果package.json不存在，使用虚拟路径\n      const virtualContextFile = path.join(this.toolboxPath, 'virtual-context.js');\n      sandboxRequire = Module.createRequire(virtualContextFile);\n    }\n\n    // 返回增强的require函数\n    return (moduleName) => {\n      // 拦截 fs 和相关模块\n      if (moduleName === 'fs' || moduleName === 'fs/promises') {\n        return this.createRestrictedFS();\n      }\n      \n      // 拦截 child_process，禁止使用\n      if (moduleName === 'child_process') {\n        throw new Error('[SandboxIsolation] child_process is not allowed in sandbox');\n      }\n      \n      // 拦截 path 模块，提供受限版本\n      if (moduleName === 'path') {\n        return this.createRestrictedPath();\n      }\n      \n      try {\n        // 优先使用沙箱require（自动处理符号链接）\n        return sandboxRequire(moduleName);\n      } catch (error) {\n        // 智能fallback处理\n        return this.handleRequireFallback(moduleName, error);\n      }\n    };\n  }\n\n  /**\n   * 处理require失败的智能fallback\n   * @param {string} moduleName - 模块名\n   * @param {Error} error - 原始错误\n   * @returns {*} 模块对象或抛出错误\n   */\n  handleRequireFallback(moduleName, error) {\n    // 1. 尝试加载Node.js内置模块\n    if (this.options.enableBuiltinModules && this.isBuiltinModule(moduleName)) {\n      try {\n        return require(moduleName);\n      } catch (builtinError) {\n        // 内置模块加载失败，继续下一步\n      }\n    }\n\n    // 2. 如果是分析阶段且模块不存在，返回mock对象\n    if (this.options.analysisMode && error.code === 'MODULE_NOT_FOUND') {\n      logger.debug(`[SandboxIsolation] Analysis mode: mocking module ${moduleName}`);\n      return this.createMockModule();\n    }\n\n    // 3. 其他情况直接抛出原始错误\n    throw error;\n  }\n\n  /**\n   * 检查是否为Node.js内置模块\n   * @param {string} moduleName - 模块名\n   * @returns {boolean} 是否为内置模块\n   */\n  isBuiltinModule(moduleName) {\n    const builtinModules = [\n      'path', 'fs', 'url', 'crypto', 'util', 'os', 'events', 'stream',\n      'http', 'https', 'querystring', 'zlib', 'buffer', 'child_process'\n    ];\n    \n    return builtinModules.includes(moduleName) || moduleName.startsWith('node:');\n  }\n\n  /**\n   * 创建mock模块对象\n   * @returns {Object} mock对象\n   */\n  createMockModule() {\n    return new Proxy({}, {\n      get: () => () => ({}),  // 所有属性和方法都返回空函数/对象\n      apply: () => ({}),      // 如果被当作函数调用\n      construct: () => ({})   // 如果被当作构造函数\n    });\n  }\n\n  /**\n   * 创建受限的文件系统\n   * 实现完全透明的拦截，在VM层面控制文件访问边界\n   * @returns {Object} 受限的fs对象\n   */\n  createRestrictedFS() {\n    const realFs = require('fs');\n    const boundary = path.resolve(this.workingPath); // 转为绝对路径\n    \n    logger.info(`[SandboxFS] Creating restricted FS with boundary: ${boundary}`);\n    \n    // 核心：智能路径解析，防止相对路径越权\n    const resolveSafePath = (inputPath) => {\n      // 处理undefined或null的情况\n      if (!inputPath) {\n        throw new Error('[SandboxFS] Path is required');\n      }\n      \n      // 1. 处理各种路径形式\n      let resolved;\n      \n      if (path.isAbsolute(inputPath)) {\n        // 绝对路径：直接解析\n        resolved = path.resolve(inputPath);\n      } else {\n        // 相对路径：基于 workingPath 解析\n        // 这是关键！防止 ../../ 越权\n        resolved = path.resolve(boundary, inputPath);\n      }\n      \n      // 2. 规范化路径（处理 .. 和 . ）\n      resolved = path.normalize(resolved);\n      \n      // 3. 边界检查\n      if (!resolved.startsWith(boundary)) {\n        // 记录详细信息用于调试\n        logger.error(`[SandboxFS] 文件访问越权尝试：\n          输入路径: ${inputPath}\n          解析结果: ${resolved}\n          允许边界: ${boundary}\n          调用栈: ${new Error().stack}\n        `);\n        \n        throw new Error(\n          `[SandboxFS] 文件访问被拒绝：路径 \"${inputPath}\" 超出工作目录边界 ${boundary}`\n        );\n      }\n      \n      return resolved;\n    };\n    \n    // 创建 Proxy 来拦截所有 fs 操作\n    const handler = {\n      get(target, prop) {\n        const original = target[prop];\n        \n        // 如果不是函数，直接返回\n        if (typeof original !== 'function') {\n          // 处理 fs.promises\n          if (prop === 'promises') {\n            return new Proxy(realFs.promises, {\n              get(promiseTarget, promiseProp) {\n                const promiseOriginal = promiseTarget[promiseProp];\n                if (typeof promiseOriginal !== 'function') {\n                  return promiseOriginal;\n                }\n                \n                // 包装 promises 方法\n                return async function(...args) {\n                  // 识别路径参数（通常是第一个）\n                  if (args.length > 0 && typeof args[0] === 'string') {\n                    args[0] = resolveSafePath(args[0]);\n                  }\n                  \n                  // 处理 rename、copyFile 等双路径操作\n                  if ((promiseProp === 'rename' || promiseProp === 'copyFile') && args.length > 1) {\n                    args[1] = resolveSafePath(args[1]);\n                  }\n                  \n                  // 调用原始函数\n                  return await promiseOriginal.apply(promiseTarget, args);\n                };\n              }\n            });\n          }\n          \n          return original;\n        }\n        \n        // 包装同步函数\n        return function(...args) {\n          // 识别路径参数（通常是第一个）\n          if (args.length > 0 && typeof args[0] === 'string') {\n            args[0] = resolveSafePath(args[0]);\n          }\n          \n          // 处理 rename、copyFile 等双路径操作\n          if ((prop === 'renameSync' || prop === 'copyFileSync') && args.length > 1) {\n            args[1] = resolveSafePath(args[1]);\n          }\n          \n          // 调用原始函数\n          return original.apply(target, args);\n        };\n      }\n    };\n    \n    // 返回代理的 fs 对象\n    return new Proxy(realFs, handler);\n  }\n\n  /**\n   * 创建受限的 path 模块\n   * 防止使用 path.resolve 绕过限制\n   * @returns {Object} 受限的path对象\n   */\n  createRestrictedPath() {\n    const realPath = require('path');\n    const boundary = path.resolve(this.workingPath);\n    \n    return new Proxy(realPath, {\n      get(target, prop) {\n        if (prop === 'resolve') {\n          return (...args) => {\n            const resolved = target.resolve(...args);\n            // 如果解析结果超出边界，记录警告\n            if (!resolved.startsWith(boundary)) {\n              logger.warn(`[SandboxPath] path.resolve 尝试越权: ${resolved}`);\n            }\n            return resolved;\n          };\n        }\n        return target[prop];\n      }\n    });\n  }\n\n  /**\n   * 创建隔离的process对象\n   * @returns {Object} 隔离的process对象\n   */\n  createIsolatedProcess() {\n    return {\n      // 环境变量（浅拷贝，避免污染）\n      env: { ...process.env },\n      \n      // 工作目录返回 workingPath（~/.promptx）\n      cwd: () => this.workingPath,\n      \n      // 安全的只读属性\n      version: process.version,\n      platform: process.platform,\n      arch: process.arch,\n      pid: process.pid,\n      \n      // 时间相关\n      hrtime: process.hrtime,\n      uptime: process.uptime,\n      \n      // 禁用危险方法\n      exit: () => { throw new Error('[SandboxIsolation] process.exit() is not allowed in sandbox'); },\n      abort: () => { throw new Error('[SandboxIsolation] process.abort() is not allowed in sandbox'); },\n      \n      // 阻止底层访问\n      binding: () => {\n        throw new Error('[SandboxIsolation] process.binding() is not allowed in sandbox');\n      },\n      dlopen: () => {\n        throw new Error('[SandboxIsolation] Native modules are not allowed in sandbox');\n      }\n    };\n  }\n\n  /**\n   * 创建隔离的全局对象\n   * @returns {Object} 安全的全局对象集合\n   */\n  createIsolatedGlobals() {\n    return {\n      // 基础类型\n      Object: Object,\n      Array: Array,\n      String: String,\n      Number: Number,\n      Boolean: Boolean,\n      Date: Date,\n      RegExp: RegExp,\n      Error: Error,\n      \n      // JSON处理\n      JSON: JSON,\n      \n      // 数学对象\n      Math: Math,\n      \n      // URL处理\n      URL: URL,\n      URLSearchParams: URLSearchParams,\n      \n      // 缓冲区\n      Buffer: Buffer,\n      \n      // 定时器\n      setTimeout: setTimeout,\n      clearTimeout: clearTimeout,\n      setInterval: setInterval,\n      clearInterval: clearInterval,\n      setImmediate: setImmediate,\n      clearImmediate: clearImmediate,\n      \n      // 输出\n      console: console,  // Keep console for sandboxed code\n      \n      // Promise相关\n      Promise: Promise\n    };\n  }\n\n  /**\n   * 启用分析模式 - 用于工具分析阶段\n   */\n  enableAnalysisMode() {\n    this.options.analysisMode = true;\n    // 重置上下文以应用新选项\n    this.isolatedContext = null;\n  }\n\n  /**\n   * 启用执行模式 - 用于工具执行阶段\n   */\n  enableExecutionMode() {\n    this.options.analysisMode = false;\n    // 重置上下文以应用新选项\n    this.isolatedContext = null;\n  }\n\n  /**\n   * 清理隔离管理器\n   */\n  cleanup() {\n    this.isolatedContext = null;\n  }\n\n  /**\n   * 获取隔离状态信息\n   * @returns {Object} 状态信息\n   */\n  getIsolationStatus() {\n    return {\n      sandboxPath: this.sandboxPath,\n      options: this.options,\n      contextCreated: !!this.isolatedContext,\n      timestamp: new Date().toISOString()\n    };\n  }\n}\n\nmodule.exports = SandboxIsolationManager;","/**\n * SandboxErrorManager - ToolSandbox智能错误管理器\n * \n * 设计原则：\n * - 与现有ToolCommand错误体系兼容\n * - 提供Agent友好的错误信息和自动恢复建议\n * - 支持MCP协议的结构化错误响应\n * - 遵循奥卡姆剃刀原则，最简化错误处理流程\n */\n\nclass SandboxErrorManager {\n  constructor() {\n    this.version = '1.0.0';\n  }\n\n  /**\n   * 分析原始错误并生成智能错误信息\n   * @param {Error} originalError - 原始错误对象\n   * @param {Object} context - 错误上下文信息\n   * @param {string} context.toolId - 工具ID\n   * @param {Array} context.dependencies - 声明的依赖列表\n   * @param {string} context.sandboxPath - 沙箱路径\n   * @param {string} context.phase - 执行阶段 (analyze|prepare|execute)\n   * @returns {Object} 增强的错误信息\n   */\n  analyzeError(originalError, context = {}) {\n    const errorType = this.classifyError(originalError, context);\n    const agentInstructions = this.generateAgentInstructions(errorType, originalError, context);\n    \n    return {\n      // 保持与ToolCommand兼容的原始信息\n      originalError,\n      message: originalError.message,\n      \n      // 增强的智能信息\n      type: errorType,\n      agentInstructions,\n      context,\n      \n      // MCP友好的格式化消息\n      formattedMessage: this.formatForMCP(errorType, originalError, agentInstructions, context)\n    };\n  }\n\n  /**\n   * 错误分类逻辑\n   * @param {Error} error - 错误对象\n   * @param {Object} context - 上下文信息\n   * @returns {string} 错误类型\n   */\n  classifyError(error, context) {\n    const message = error.message.toLowerCase();\n    \n    // 依赖缺失错误 - 最常见的问题\n    if (message.includes('cannot find module')) {\n      const missingModule = this.extractModuleName(error.message);\n      \n      // 兼容新旧格式\n      let isDeclaredDependency = false;\n      if (Array.isArray(context.dependencies)) {\n        // 旧格式：数组\n        isDeclaredDependency = context.dependencies.some(dep => \n          dep.split('@')[0] === missingModule\n        );\n      } else if (typeof context.dependencies === 'object' && context.dependencies) {\n        // 新格式：对象\n        isDeclaredDependency = Object.keys(context.dependencies).includes(missingModule);\n      }\n      \n      if (isDeclaredDependency) {\n        return 'DEPENDENCY_MISSING';\n      } else {\n        return 'UNDECLARED_DEPENDENCY';\n      }\n    }\n    \n    // 依赖安装失败\n    if (message.includes('pnpm install failed') || \n        message.includes('dependency installation') ||\n        message.includes('npm err')) {\n      return 'DEPENDENCY_INSTALL_FAILED';\n    }\n    \n    // 工具文件问题\n    if (message.includes('failed to load tool') ||\n        message.includes('tool does not export') ||\n        message.includes('invalid tool export format')) {\n      return 'TOOL_LOADING_ERROR';\n    }\n    \n    // 参数验证错误\n    if (message.includes('parameter validation failed') ||\n        message.includes('missing required parameter')) {\n      return 'PARAMETER_VALIDATION_ERROR';\n    }\n    \n    // 沙箱环境错误\n    if (message.includes('sandbox') || message.includes('vm')) {\n      return 'SANDBOX_ENVIRONMENT_ERROR';\n    }\n    \n    // 网络超时\n    if (message.includes('timeout') || message.includes('etimedout')) {\n      return 'NETWORK_TIMEOUT';\n    }\n    \n    return 'UNKNOWN_ERROR';\n  }\n\n  /**\n   * 为Agent生成智能指令\n   * @param {string} errorType - 错误类型\n   * @param {Error} originalError - 原始错误\n   * @param {Object} context - 上下文\n   * @returns {Object} Agent指令对象\n   */\n  generateAgentInstructions(errorType, originalError, context) {\n    switch (errorType) {\n      case 'DEPENDENCY_MISSING':\n        return {\n          action: 'AUTO_RETRY_WITH_FORCE_REINSTALL',\n          autoRetryable: true,\n          command: '自动重试，添加 forceReinstall: true 参数',\n          explanation: '依赖已声明但未正确安装，通过强制重装可解决',\n          userMessage: `检测到依赖 ${this.extractModuleName(originalError.message)} 安装不完整，正在自动重新安装...`,\n          retryParameters: { forceReinstall: true }\n        };\n        \n      case 'UNDECLARED_DEPENDENCY': {\n        const missingModule = this.extractModuleName(originalError.message);\n        return {\n          action: 'REPORT_MISSING_DEPENDENCY',\n          autoRetryable: false,\n          command: '提示工具开发者添加依赖声明',\n          explanation: `工具代码使用了未声明的依赖: ${missingModule}`,\n          userMessage: `❌ 工具缺少依赖声明\n\n🔧 需要在工具的 getDependencies() 方法中添加：\n   '${missingModule}': 'latest'\n\n📝 完整示例（新格式）：\n   getDependencies() {\n     return {\n       ${context.dependencies && typeof context.dependencies === 'object' && !Array.isArray(context.dependencies) \n         ? Object.entries(context.dependencies).map(([k, v]) => `'${k}': '${v}'`).join(',\\n       ') + ','\n         : '// 其他依赖...'}\n       '${missingModule}': 'latest'\n     };\n   }`,\n          developerAction: `在 ${context.toolId}.tool.js 的 getDependencies() 中添加 '${missingModule}': 'latest'`\n        };\n      }\n        \n      case 'DEPENDENCY_INSTALL_FAILED':\n        return {\n          action: 'CHECK_NETWORK_AND_RETRY',\n          autoRetryable: false,\n          command: '检查网络连接，建议用户稍后重试',\n          explanation: '依赖安装过程失败，可能是网络问题或包源问题',\n          userMessage: `❌ 依赖安装失败\n\n🌐 可能原因：\n   • 网络连接不稳定\n   • npm/pnpm 镜像源问题\n   • 依赖包版本不存在\n\n💡 建议解决方案：\n   1. 检查网络连接\n   2. 稍后重试（使用 forceReinstall: true）\n   3. 如果持续失败，请联系开发者`,\n          retryDelay: 5000\n        };\n        \n      case 'TOOL_LOADING_ERROR':\n        return {\n          action: 'REPORT_TOOL_ERROR',\n          autoRetryable: false,\n          command: '报告工具文件问题',\n          explanation: '工具代码本身存在问题，需要开发者修复',\n          userMessage: `❌ 工具加载失败\n\n🔧 工具代码问题：${originalError.message}\n\n💡 这是工具开发问题，请联系工具作者修复`,\n          developerAction: '检查工具的 module.exports 和基本语法'\n        };\n        \n      case 'NETWORK_TIMEOUT':\n        return {\n          action: 'RETRY_WITH_EXTENDED_TIMEOUT',\n          autoRetryable: true,\n          command: '自动重试，使用更长的超时时间',\n          explanation: '网络超时，使用更长超时时间重试',\n          userMessage: '⏰ 网络超时，正在使用更长超时时间重试...',\n          retryParameters: { timeout: 60000 } // 60秒\n        };\n        \n      default:\n        return {\n          action: 'REPORT_UNKNOWN_ERROR',\n          autoRetryable: false,\n          command: '报告未知错误给用户',\n          explanation: '未知错误类型，需要人工分析',\n          userMessage: `❌ 执行失败：${originalError.message}\n\n🤖 这是一个未分类的错误，请将此信息反馈给开发者以改进错误处理`,\n          debugInfo: {\n            stack: originalError.stack,\n            context\n          }\n        };\n    }\n  }\n\n  /**\n   * 为MCP协议格式化错误消息\n   * @param {string} errorType - 错误类型\n   * @param {Error} originalError - 原始错误\n   * @param {Object} agentInstructions - Agent指令\n   * @param {Object} context - 上下文\n   * @returns {string} MCP友好的错误消息\n   */\n  formatForMCP(errorType, originalError, agentInstructions, context) {\n    const emoji = this.getErrorEmoji(errorType);\n    const timestamp = new Date().toISOString();\n    \n    let message = `${emoji} ToolSandbox执行失败\n\n🏷️ 错误类型: ${errorType}\n⏰ 时间: ${timestamp}\n🔧 工具: ${context.toolId || 'unknown'}\n📁 阶段: ${context.phase || 'unknown'}\n\n📋 详细信息:\n${originalError.message}\n\n🤖 AI处理建议:\n${agentInstructions.userMessage || agentInstructions.explanation}`;\n\n    // 如果可以自动重试，添加重试信息\n    if (agentInstructions.autoRetryable) {\n      message += `\n\n🔄 自动恢复: ${agentInstructions.action}\n⚡ 操作: ${agentInstructions.command}`;\n    }\n\n    return message;\n  }\n\n  /**\n   * 从错误消息中提取模块名\n   * @param {string} errorMessage - 错误消息\n   * @returns {string} 模块名\n   */\n  extractModuleName(errorMessage) {\n    const match = errorMessage.match(/Cannot (?:find|resolve) module ['\\\"]([^'\\\"]+)['\\\"]/);\n    return match ? match[1] : 'unknown';\n  }\n\n  /**\n   * 根据错误类型获取对应emoji\n   * @param {string} errorType - 错误类型\n   * @returns {string} emoji\n   */\n  getErrorEmoji(errorType) {\n    const emojiMap = {\n      'DEPENDENCY_MISSING': '📦',\n      'UNDECLARED_DEPENDENCY': '🔍',\n      'DEPENDENCY_INSTALL_FAILED': '🌐',\n      'TOOL_LOADING_ERROR': '🔧',\n      'PARAMETER_VALIDATION_ERROR': '📝',\n      'SANDBOX_ENVIRONMENT_ERROR': '🏗️',\n      'NETWORK_TIMEOUT': '⏰',\n      'UNKNOWN_ERROR': '❓'\n    };\n    \n    return emojiMap[errorType] || '❌';\n  }\n\n  /**\n   * 检查错误是否可以自动恢复\n   * @param {Object} intelligentError - 智能错误对象\n   * @returns {boolean} 是否可自动恢复\n   */\n  isAutoRecoverable(intelligentError) {\n    return intelligentError.agentInstructions.autoRetryable === true;\n  }\n\n  /**\n   * 获取自动恢复的重试参数\n   * @param {Object} intelligentError - 智能错误对象\n   * @returns {Object|null} 重试参数\n   */\n  getRetryParameters(intelligentError) {\n    return intelligentError.agentInstructions.retryParameters || null;\n  }\n}\n\nmodule.exports = SandboxErrorManager;","const path = require('path');\nconst fs = require('fs').promises;\nconst logger = require('@promptx/logger');\n\n/**\n * ToolDirectoryManager - 基于协议的工具目录管理器\n * \n * 负责管理工具相关的所有目录：\n * - 工作目录：工具执行时的 process.cwd()\n * - 工具箱目录：依赖安装和隔离\n * - 缓存目录：工具缓存（可选）\n * - 临时目录：临时文件（可选）\n * \n * 基于 ResourceManager 的协议系统，支持跨平台路径解析\n */\nclass ToolDirectoryManager {\n  constructor(toolId, resourceManager) {\n    this.toolId = toolId;\n    this.resourceManager = resourceManager;\n    \n    // 使用协议定义目录\n    this.directories = {\n      working: '@user://.promptx',                           // 工作目录\n      toolbox: `@user://.promptx/toolbox/${toolId}`,        // 工具隔离目录\n      dependencies: `@user://.promptx/toolbox/${toolId}/node_modules`, // 依赖目录\n      cache: `@user://.promptx/cache/${toolId}`,            // 缓存目录\n      temp: `@user://.promptx/temp/${toolId}`,              // 临时文件目录\n    };\n    \n    // 解析后的实际路径\n    this.resolvedPaths = {};\n  }\n\n  /**\n   * 初始化所有路径（通过协议解析）\n   */\n  async initialize() {\n    for (const [key, protocolPath] of Object.entries(this.directories)) {\n      this.resolvedPaths[key] = await this.resolveProtocolPath(protocolPath);\n    }\n    logger.debug('[ToolDirectoryManager] Initialized paths:', this.resolvedPaths);\n  }\n\n  /**\n   * 通过协议解析路径\n   * @param {string} protocolPath - 协议路径，如 @user://.promptx\n   * @returns {Promise<string>} 解析后的绝对路径\n   */\n  async resolveProtocolPath(protocolPath) {\n    // 使用 ResourceManager 的协议解析能力\n    const result = await this.resourceManager.resolveProtocolReference(protocolPath);\n    \n    if (!result.success) {\n      throw new Error(`Failed to resolve protocol path ${protocolPath}: ${result.error}`);\n    }\n    \n    // 获取对应的协议处理器\n    const protocol = this.resourceManager.protocols.get(result.protocol);\n    if (!protocol) {\n      throw new Error(`Protocol ${result.protocol} not supported`);\n    }\n    \n    // 使用协议处理器解析实际路径\n    if (typeof protocol.resolvePath === 'function') {\n      return await protocol.resolvePath(result.path, result.queryParams || new Map());\n    } else {\n      throw new Error(`Protocol ${result.protocol} does not support path resolution`);\n    }\n  }\n\n  /**\n   * 获取工作目录路径\n   * @returns {string} 工作目录路径\n   */\n  getWorkingPath() {\n    return this.resolvedPaths.working;\n  }\n\n  /**\n   * 获取工具箱目录路径\n   * @returns {string} 工具箱目录路径\n   */\n  getToolboxPath() {\n    return this.resolvedPaths.toolbox;\n  }\n\n  /**\n   * 获取依赖目录路径\n   * @returns {string} node_modules 路径\n   */\n  getDependenciesPath() {\n    return this.resolvedPaths.dependencies;\n  }\n\n  /**\n   * 获取缓存目录路径\n   * @returns {string} 缓存目录路径\n   */\n  getCachePath() {\n    return this.resolvedPaths.cache;\n  }\n\n  /**\n   * 获取临时目录路径\n   * @returns {string} 临时目录路径\n   */\n  getTempPath() {\n    return this.resolvedPaths.temp;\n  }\n\n  /**\n   * 获取 package.json 路径\n   * @returns {string} package.json 路径\n   */\n  getPackageJsonPath() {\n    return path.join(this.resolvedPaths.toolbox, 'package.json');\n  }\n\n  /**\n   * 确保必要的目录存在\n   */\n  async ensureDirectories() {\n    // 工作目录通常已存在，但还是检查一下\n    await this.ensureDirectory(this.resolvedPaths.working);\n    \n    // 工具箱目录必须创建\n    await this.ensureDirectory(this.resolvedPaths.toolbox);\n    \n    // 可选：创建缓存和临时目录\n    // await this.ensureDirectory(this.resolvedPaths.cache);\n    // await this.ensureDirectory(this.resolvedPaths.temp);\n  }\n\n  /**\n   * 确保单个目录存在\n   * @param {string} dirPath - 目录路径\n   */\n  async ensureDirectory(dirPath) {\n    try {\n      await fs.access(dirPath);\n    } catch (error) {\n      if (error.code === 'ENOENT') {\n        await fs.mkdir(dirPath, { recursive: true });\n        logger.debug(`[ToolDirectoryManager] Created directory: ${dirPath}`);\n      } else {\n        throw error;\n      }\n    }\n  }\n\n  /**\n   * 检查目录是否存在\n   * @param {string} dirPath - 目录路径\n   * @returns {Promise<boolean>} 是否存在\n   */\n  async directoryExists(dirPath) {\n    try {\n      await fs.access(dirPath);\n      return true;\n    } catch {\n      return false;\n    }\n  }\n\n  /**\n   * 检查工具箱目录是否存在\n   * @returns {Promise<boolean>}\n   */\n  async toolboxExists() {\n    return await this.directoryExists(this.resolvedPaths.toolbox);\n  }\n\n  /**\n   * 清理临时文件\n   */\n  async cleanupTemp() {\n    if (this.resolvedPaths.temp && await this.directoryExists(this.resolvedPaths.temp)) {\n      const { rmdir } = require('fs').promises;\n      await rmdir(this.resolvedPaths.temp, { recursive: true });\n      logger.debug(`[ToolDirectoryManager] Cleaned up temp directory: ${this.resolvedPaths.temp}`);\n    }\n  }\n\n  /**\n   * 删除工具箱目录（用于强制重建）\n   */\n  async deleteToolbox() {\n    if (this.resolvedPaths.toolbox && await this.toolboxExists()) {\n      const { rmdir } = require('fs').promises;\n      await rmdir(this.resolvedPaths.toolbox, { recursive: true });\n      logger.debug(`[ToolDirectoryManager] Deleted toolbox directory: ${this.resolvedPaths.toolbox}`);\n    }\n  }\n\n  /**\n   * 获取协议路径（用于日志或调试）\n   * @param {string} key - 目录键名\n   * @returns {string} 协议路径\n   */\n  getProtocolPath(key) {\n    return this.directories[key];\n  }\n\n  /**\n   * 支持自定义协议路径（未来扩展）\n   * 比如支持 @project:// 或 @s3:// 等\n   */\n  async setCustomDirectory(key, protocolPath) {\n    this.directories[key] = protocolPath;\n    this.resolvedPaths[key] = await this.resolveProtocolPath(protocolPath);\n  }\n}\n\nmodule.exports = ToolDirectoryManager;","const path = require('path');\nconst fs = require('fs').promises;\nconst logger = require('@promptx/logger');\n\n/**\n * ESModuleRequireSupport - ES Module 加载支持器\n * \n * 专门处理 ES Module 和 CommonJS 模块的统一加载\n * 提供智能的模块类型检测和加载策略\n */\nclass ESModuleRequireSupport {\n  constructor(toolboxPath) {\n    this.toolboxPath = toolboxPath;\n    this.moduleTypeCache = new Map(); // 缓存模块类型，避免重复检测\n  }\n\n  /**\n   * 创建统一的 require 函数\n   * 所有模块都返回 Promise，实现统一的使用体验\n   * \n   * @param {Function} sandboxRequire - 沙箱环境的 require 函数\n   * @returns {Function} 增强的 require 函数\n   */\n  createUnifiedRequire(sandboxRequire) {\n    return async (moduleName) => {\n      try {\n        // 检测模块类型\n        const moduleType = await this.detectModuleType(moduleName);\n        \n        logger.debug(`[ESModuleSupport] Loading ${moduleName} as ${moduleType}`);\n        \n        if (moduleType === 'esm') {\n          // ES Module - 使用动态 import\n          return await this.loadESModule(moduleName);\n        } else {\n          // CommonJS - 包装成 Promise 返回，统一体验\n          try {\n            const module = sandboxRequire(moduleName);\n            return Promise.resolve(module);\n          } catch (error) {\n            // 如果 require 失败且错误是 ERR_REQUIRE_ESM，说明是 ES Module\n            if (error.code === 'ERR_REQUIRE_ESM') {\n              logger.debug(`[ESModuleSupport] Fallback to ES Module for ${moduleName}`);\n              return await this.loadESModule(moduleName);\n            }\n            throw error;\n          }\n        }\n      } catch (error) {\n        logger.error(`[ESModuleSupport] Failed to load module ${moduleName}: ${error.message}`);\n        throw new Error(`Cannot load module '${moduleName}': ${error.message}`);\n      }\n    };\n  }\n\n  /**\n   * 检测模块类型\n   * @param {string} moduleName - 模块名\n   * @returns {Promise<string>} 'esm' | 'commonjs' | 'unknown'\n   */\n  async detectModuleType(moduleName) {\n    // 检查缓存\n    if (this.moduleTypeCache.has(moduleName)) {\n      return this.moduleTypeCache.get(moduleName);\n    }\n\n    try {\n      const packagePath = this.resolvePackagePath(moduleName);\n      const packageJsonPath = path.join(packagePath, 'package.json');\n      \n      // 读取 package.json\n      const packageJsonContent = await fs.readFile(packageJsonPath, 'utf8');\n      const packageJson = JSON.parse(packageJsonContent);\n      \n      let moduleType = 'commonjs'; // 默认为 CommonJS\n      \n      // 1. 检查 type 字段（最标准的方式）\n      if (packageJson.type === 'module') {\n        moduleType = 'esm';\n      }\n      // 2. 检查 exports 字段中的 import 条件\n      else if (packageJson.exports && typeof packageJson.exports === 'object') {\n        // 检查是否有 import 条件导出\n        if (packageJson.exports.import || \n            (packageJson.exports['.'] && packageJson.exports['.'].import)) {\n          moduleType = 'esm';\n        }\n      }\n      // 3. 检查 module 字段（一些包用来指向 ES Module 版本）\n      else if (packageJson.module) {\n        // 如果有 module 字段但没有 main 字段，可能是纯 ES Module\n        if (!packageJson.main) {\n          moduleType = 'esm';\n        }\n      }\n      \n      // 缓存结果\n      this.moduleTypeCache.set(moduleName, moduleType);\n      \n      logger.debug(`[ESModuleSupport] Module ${moduleName} detected as ${moduleType}`);\n      return moduleType;\n      \n    } catch (error) {\n      logger.debug(`[ESModuleSupport] Cannot detect module type for ${moduleName}: ${error.message}`);\n      // 缓存为 unknown\n      this.moduleTypeCache.set(moduleName, 'unknown');\n      return 'unknown';\n    }\n  }\n\n  /**\n   * 解析包路径（支持 scoped 包）\n   * @param {string} moduleName - 模块名\n   * @returns {string} 包的实际路径\n   */\n  resolvePackagePath(moduleName) {\n    const parts = moduleName.split('/');\n    \n    if (moduleName.startsWith('@') && parts.length >= 2) {\n      // Scoped package: @scope/package 或 @scope/package/subpath\n      const scopedPackageName = parts.slice(0, 2).join('/');\n      return path.join(this.toolboxPath, 'node_modules', scopedPackageName);\n    } else {\n      // Normal package: package 或 package/subpath\n      return path.join(this.toolboxPath, 'node_modules', parts[0]);\n    }\n  }\n\n  /**\n   * 加载 ES Module\n   * @param {string} moduleName - 模块名\n   * @returns {Promise<Object>} 模块对象\n   */\n  async loadESModule(moduleName) {\n    try {\n      // 获取模块的完整路径\n      const modulePath = this.resolveModuleEntryPoint(moduleName);\n      \n      logger.debug(`[ESModuleSupport] Importing ES Module from ${modulePath}`);\n      \n      // 使用动态 import 加载 ES Module\n      const module = await import(modulePath);\n      \n      // 返回模块（处理 default export）\n      return module.default || module;\n      \n    } catch (error) {\n      logger.error(`[ESModuleSupport] Failed to load ES Module ${moduleName}: ${error.message}`);\n      throw new Error(`Failed to import ES Module '${moduleName}': ${error.message}`);\n    }\n  }\n\n  /**\n   * 解析模块入口点\n   * @param {string} moduleName - 模块名\n   * @returns {string} 模块入口文件的完整路径\n   */\n  resolveModuleEntryPoint(moduleName) {\n    try {\n      const packagePath = this.resolvePackagePath(moduleName);\n      const packageJsonPath = path.join(packagePath, 'package.json');\n      \n      // 同步读取 package.json（因为这个方法可能在同步上下文中调用）\n      const packageJson = require(packageJsonPath);\n      \n      // 解析入口点\n      let entryPoint = 'index.js'; // 默认入口\n      \n      // 检查 exports 字段\n      if (packageJson.exports) {\n        if (typeof packageJson.exports === 'string') {\n          entryPoint = packageJson.exports;\n        } else if (packageJson.exports['.']) {\n          if (typeof packageJson.exports['.'] === 'string') {\n            entryPoint = packageJson.exports['.'];\n          } else if (packageJson.exports['.'].import) {\n            entryPoint = packageJson.exports['.'].import;\n          } else if (packageJson.exports['.'].default) {\n            entryPoint = packageJson.exports['.'].default;\n          }\n        }\n      }\n      // 检查 module 字段（ES Module 入口）\n      else if (packageJson.module) {\n        entryPoint = packageJson.module;\n      }\n      // 检查 main 字段（CommonJS 入口，但可能也是 ES Module）\n      else if (packageJson.main) {\n        entryPoint = packageJson.main;\n      }\n      \n      // 构建完整路径\n      const fullPath = path.join(packagePath, entryPoint);\n      \n      // 处理子路径导入（如 'lodash/chunk'）\n      const parts = moduleName.split('/');\n      if (moduleName.startsWith('@') && parts.length > 2) {\n        // @scope/package/subpath\n        const subpath = parts.slice(2).join('/');\n        return path.join(packagePath, subpath);\n      } else if (!moduleName.startsWith('@') && parts.length > 1) {\n        // package/subpath\n        const subpath = parts.slice(1).join('/');\n        return path.join(packagePath, subpath);\n      }\n      \n      return fullPath;\n      \n    } catch (error) {\n      // 如果解析失败，返回默认路径\n      return this.resolvePackagePath(moduleName);\n    }\n  }\n\n  /**\n   * 批量检测依赖的模块类型\n   * @param {Object} dependencies - 依赖对象 { packageName: version }\n   * @returns {Promise<Object>} { commonjs: [], esmodule: [], unknown: [] }\n   */\n  async detectDependenciesTypes(dependencies) {\n    const result = {\n      commonjs: [],\n      esmodule: [],\n      unknown: []\n    };\n\n    for (const [packageName, version] of Object.entries(dependencies)) {\n      const moduleType = await this.detectModuleType(packageName);\n      \n      if (moduleType === 'esm') {\n        result.esmodule.push({ name: packageName, version });\n      } else if (moduleType === 'commonjs') {\n        result.commonjs.push({ name: packageName, version });\n      } else {\n        result.unknown.push({ name: packageName, version });\n      }\n    }\n\n    logger.debug(`[ESModuleSupport] Dependencies analysis:`, {\n      commonjs: result.commonjs.length,\n      esmodule: result.esmodule.length,\n      unknown: result.unknown.length\n    });\n\n    return result;\n  }\n\n  /**\n   * 检查是否有 ES Module 依赖\n   * @param {Object} dependencies - 依赖对象\n   * @returns {Promise<boolean>}\n   */\n  async hasESModuleDependencies(dependencies) {\n    const types = await this.detectDependenciesTypes(dependencies);\n    return types.esmodule.length > 0;\n  }\n\n  /**\n   * 清理缓存\n   */\n  clearCache() {\n    this.moduleTypeCache.clear();\n  }\n\n  /**\n   * 获取缓存统计\n   */\n  getCacheStats() {\n    return {\n      size: this.moduleTypeCache.size,\n      modules: Array.from(this.moduleTypeCache.entries())\n    };\n  }\n}\n\nmodule.exports = ESModuleRequireSupport;","const path = require('path');\nconst fs = require('fs').promises;\nconst { spawn } = require('child_process');\nconst vm = require('vm');\nconst SandboxIsolationManager = require('./SandboxIsolationManager');\nconst SandboxErrorManager = require('./SandboxErrorManager');\nconst ToolDirectoryManager = require('./ToolDirectoryManager');\nconst ESModuleRequireSupport = require('./ESModuleRequireSupport');\nconst logger = require('@promptx/logger');\n\n/**\n * ToolSandbox - 工具沙箱环境管理器\n * \n * 基于现有协议系统的工具执行环境，支持：\n * - @tool:// 协议定位工具\n * - @user://.promptx/toolbox 沙箱隔离\n * - 自动依赖管理\n * - 可复用的执行环境\n */\nclass ToolSandbox {\n  constructor(toolReference, options = {}) {\n    this.toolReference = toolReference;  // @tool://url-validator\n    this.resourceManager = null;         // ResourceManager实例\n    this.toolId = null;                  // 工具ID，如 url-validator\n    this.toolContent = null;             // 工具文件内容\n    this.toolInstance = null;            // 工具实例\n    this.dependencies = [];              // 依赖列表\n    this.directoryManager = null;        // 目录管理器（新增）\n    this.sandboxPath = null;             // 沙箱目录路径（保留用于兼容）\n    this.sandboxContext = null;          // VM沙箱上下文\n    this.isolationManager = null;        // 沙箱隔离管理器\n    this.errorManager = new SandboxErrorManager(); // 智能错误管理器\n    this.esModuleSupport = null;         // ES Module 支持器\n    \n    // 状态标志\n    this.isAnalyzed = false;\n    this.isPrepared = false;\n    \n    // 配置选项\n    this.options = {\n      timeout: 30000,\n      enableDependencyInstall: true,\n      rebuild: false,  // 强制重建沙箱（用于处理异常情况）\n      ...options\n    };\n  }\n\n  /**\n   * 设置ResourceManager实例\n   * @param {ResourceManager} resourceManager \n   */\n  setResourceManager(resourceManager) {\n    this.resourceManager = resourceManager;\n  }\n\n  /**\n   * 清理沙箱状态和缓存\n   * @param {boolean} deleteDirectory - 是否删除沙箱目录\n   */\n  async clearSandbox(deleteDirectory = false) {\n    logger.debug(`[ToolSandbox] Clearing sandbox state${deleteDirectory ? ' and deleting directory' : ''}`);\n    \n    // 清空所有缓存和状态\n    this.isAnalyzed = false;\n    this.isPrepared = false;\n    this.toolContent = null;\n    this.toolInstance = null;\n    this.dependencies = [];\n    this.sandboxContext = null;\n    \n    // 如果需要，删除沙箱目录\n    if (deleteDirectory && this.directoryManager) {\n      try {\n        await this.directoryManager.deleteToolbox();\n      } catch (error) {\n        logger.debug(`[ToolSandbox] Error deleting toolbox directory (can be ignored): ${error.message}`);\n      }\n    }\n  }\n\n  /**\n   * 分析工具：加载工具内容，提取元信息和依赖\n   * @returns {Promise<Object>} 分析结果\n   */\n  async analyze() {\n    if (this.isAnalyzed && !this.options.rebuild) {\n      logger.debug(`[ToolSandbox] Using cached analysis result, dependencies: ${JSON.stringify(this.dependencies)}`);\n      return this.getAnalysisResult();\n    }\n\n    if (!this.resourceManager) {\n      throw new Error('ResourceManager not set. Call setResourceManager() first.');\n    }\n\n    try {\n      // 1. 解析工具引用，提取工具ID\n      this.toolId = this.extractToolId(this.toolReference);\n      \n      // 2. 通过协议系统加载工具（forceReinstall时强制重新加载）\n      const loadOptions = this.options.forceReinstall ? { noCache: true } : {};\n      logger.debug(`[ToolSandbox] Loading tool ${this.toolReference}, options:`, loadOptions);\n      \n      const toolResult = await this.resourceManager.loadResource(this.toolReference, loadOptions);\n      if (!toolResult.success) {\n        // 调试：尝试不同的查找方式\n        logger.debug(`[ToolSandbox] Debug: Trying to find tool ${this.toolReference}`);\n        const directLookup = this.resourceManager.registryData.findResourceById(`tool:${this.toolId}`, 'tool');\n        logger.debug(`[ToolSandbox]    - Direct lookup tool:${this.toolId}: ${directLookup ? 'found' : 'not found'}`);\n        \n        throw new Error(`Failed to load tool: ${toolResult.error.message}`);\n      }\n      \n      this.toolContent = toolResult.content;\n      \n      // 调试：检查加载的工具内容\n      logger.debug(`[ToolSandbox] Loaded tool content first 200 chars:`, this.toolContent.substring(0, 200));\n      \n      // 3. 初始化目录管理器\n      this.directoryManager = new ToolDirectoryManager(this.toolId, this.resourceManager);\n      await this.directoryManager.initialize();\n      await this.directoryManager.ensureDirectories();\n      \n      // 4. 设置 sandboxPath 用于兼容\n      this.sandboxPath = this.directoryManager.getWorkingPath();\n      \n      // 5. 在基础沙箱中分析工具\n      await this.analyzeToolInSandbox();\n      \n      this.isAnalyzed = true;\n      return this.getAnalysisResult();\n      \n    } catch (error) {\n      throw new Error(`Tool analysis failed: ${error.message}`);\n    }\n  }\n\n  /**\n   * 准备依赖：安装依赖，准备执行环境\n   * @returns {Promise<Object>} 准备结果\n   */\n  async prepareDependencies() {\n    logger.info(`[ToolSandbox] Starting prepareDependencies for tool ${this.toolId}`);\n    \n    // 处理rebuild选项\n    if (this.options.rebuild) {\n      logger.info(`[ToolSandbox] Manually triggering sandbox rebuild`);\n      await this.clearSandbox(true);\n      // 重新初始化目录管理器\n      if (this.directoryManager) {\n        await this.directoryManager.initialize();\n      }\n    }\n    \n    // 分析工具（如果需要）\n    if (!this.isAnalyzed) {\n      logger.info(`[ToolSandbox] Starting tool analysis`);\n      await this.analyze();\n      logger.info(`[ToolSandbox] Tool analysis completed`);\n    }\n    \n    // 自动检测依赖是否需要更新\n    if (!this.options.rebuild && await this.checkDependenciesNeedUpdate()) {\n      logger.debug(`[ToolSandbox] Dependency changes detected, auto-rebuilding sandbox`);\n      await this.clearSandbox(true);\n      // 重新分析以获取最新依赖\n      await this.analyze();\n    }\n    \n    if (this.isPrepared) {\n      return { success: true, message: 'Dependencies already prepared' };\n    }\n\n    try {\n      // 1. 确保沙箱目录存在\n      await this.ensureSandboxDirectory();\n      \n      // 2. 如果有依赖，安装它们\n      const hasDependencies = typeof this.dependencies === 'object' && !Array.isArray(this.dependencies) \n        ? Object.keys(this.dependencies).length > 0\n        : this.dependencies.length > 0;\n        \n      if (hasDependencies) {\n        logger.info(`[ToolSandbox] Installing dependencies`);\n        await this.installDependencies();\n        logger.info(`[ToolSandbox] Dependencies installation completed`);\n        \n        // 2.1 检测 ES Module 依赖\n        await this.detectAndHandleESModules();\n      }\n      \n      // 3. 创建执行沙箱环境\n      logger.info(`[ToolSandbox] Creating execution sandbox`);\n      await this.createExecutionSandbox();\n      logger.info(`[ToolSandbox] Execution sandbox created`);\n      \n      this.isPrepared = true;\n      return { \n        success: true, \n        sandboxPath: this.directoryManager.getWorkingPath(),\n        toolboxPath: this.directoryManager.getToolboxPath(),\n        dependencies: this.dependencies \n      };\n      \n    } catch (error) {\n      throw new Error(`Dependency preparation failed: ${error.message}`);\n    }\n  }\n\n  /**\n   * 执行工具\n   * @param {Object} parameters - 工具参数\n   * @returns {Promise<Object>} 执行结果\n   */\n  async execute(parameters = {}) {\n    const startTime = Date.now();\n    logger.info(`[ToolSandbox] Executing tool \"${this.toolId}\" with params: ${JSON.stringify(parameters)}`);\n    \n    if (!this.isPrepared) {\n      logger.debug(`[ToolSandbox] Preparing dependencies for tool ${this.toolId}`);\n      await this.prepareDependencies();\n    }\n\n    try {\n      // 1. 参数验证\n      await this.validateParameters(parameters);\n      \n      // 2. 在沙箱中执行工具\n      const result = await this.executeInSandbox(parameters);\n      \n      const elapsed = ((Date.now() - startTime) / 1000).toFixed(1);\n      logger.info(`[ToolSandbox] Tool \"${this.toolId}\" executed successfully in ${elapsed}s, result type: ${typeof result}`);\n      \n      return {\n        success: true,\n        data: result,\n        metadata: {\n          toolId: this.toolId,\n          sandboxPath: this.directoryManager.getWorkingPath(),\n          toolboxPath: this.directoryManager.getToolboxPath(),\n          executionTime: Date.now()\n        }\n      };\n      \n    } catch (error) {\n      // 使用智能错误管理器分析错误\n      const intelligentError = this.errorManager.analyzeError(error, {\n        toolId: this.toolId,\n        dependencies: this.dependencies,\n        sandboxPath: this.directoryManager?.getWorkingPath(),\n        toolboxPath: this.directoryManager?.getToolboxPath(),\n        phase: 'execute'\n      });\n      \n      // 抛出增强的错误对象，供上层处理自动重试\n      const enhancedError = new Error(intelligentError.formattedMessage);\n      enhancedError.intelligentError = intelligentError;\n      enhancedError.originalError = error;\n      throw enhancedError;\n    }\n  }\n\n  /**\n   * 提取工具ID\n   * @param {string} toolReference - @tool://url-validator\n   * @returns {string} 工具ID\n   */\n  extractToolId(toolReference) {\n    const match = toolReference.match(/^@tool:\\/\\/(.+)$/);\n    if (!match) {\n      throw new Error(`Invalid tool reference format: ${toolReference}`);\n    }\n    return match[1];\n  }\n\n\n  /**\n   * 在基础沙箱中分析工具\n   */\n  async analyzeToolInSandbox() {\n    // 创建分析阶段的隔离管理器，使用工作目录\n    this.isolationManager = new SandboxIsolationManager(this.directoryManager.getWorkingPath(), {\n      enableDependencyLoading: false,\n      analysisMode: true\n    });\n    \n    const sandbox = this.isolationManager.createIsolatedContext();\n    \n    // 调试：检查即将执行的代码\n    logger.debug(`[ToolSandbox] Tool code getDependencies section:`, \n      this.toolContent.match(/getDependencies[\\s\\S]*?return[\\s\\S]*?\\]/)?.[0] || 'getDependencies not found');\n    \n    const script = new vm.Script(this.toolContent, { filename: `${this.toolId}.js` });\n    const context = vm.createContext(sandbox);\n    \n    try {\n      script.runInContext(context);\n    } catch (error) {\n      // 使用智能错误过滤处理require错误\n      const filteredError = this._filterRequireError(error);\n      if (filteredError) {\n        throw filteredError;\n      }\n      // 如果是预期的require错误，继续执行\n    }\n    \n    const exported = context.module.exports;\n    \n    if (!exported) {\n      throw new Error(`Tool does not export anything: ${this.toolId}`);\n    }\n    \n    // 创建工具实例\n    let toolInstance;\n    if (typeof exported === 'function') {\n      toolInstance = new exported();\n    } else if (typeof exported === 'object') {\n      toolInstance = exported;\n    } else {\n      throw new Error(`Invalid tool export format: ${this.toolId}`);\n    }\n    \n    // 提取依赖\n    if (typeof toolInstance.getDependencies === 'function') {\n      try {\n        this.dependencies = toolInstance.getDependencies() || {};\n        logger.debug(`[ToolSandbox] Extracted dependencies: ${JSON.stringify(this.dependencies)}`);\n      } catch (error) {\n        logger.warn(`[ToolSandbox] Failed to get dependencies for ${this.toolId}: ${error.message}`);\n        this.dependencies = {};\n      }\n    } else {\n      logger.debug(`[ToolSandbox] Tool does not have getDependencies method`);\n      this.dependencies = {};\n    }\n    \n    this.toolInstance = toolInstance;\n  }\n\n  /**\n   * 智能过滤require错误\n   * @param {Error} error - 捕获的错误\n   * @returns {Error|null} - 如果是真正的错误则返回Error对象，如果是预期的require错误则返回null\n   * @private\n   */\n  _filterRequireError(error) {\n    // 检查是否是MODULE_NOT_FOUND错误\n    if (error.code === 'MODULE_NOT_FOUND') {\n      const missingModule = this._extractMissingModuleName(error.message);\n      \n      if (missingModule) {\n        // 获取已声明的依赖列表\n        const declaredDependencies = this._extractDeclaredDependencies();\n        \n        // 检查缺失的模块是否在依赖声明中\n        if (this._isDeclaredInDependencies(missingModule, declaredDependencies)) {\n          logger.debug(`[ToolSandbox] Dependency ${missingModule} not installed, will install in prepareDependencies phase`);\n          return null; // 预期的错误，忽略\n        } else {\n          return new Error(`未声明的依赖: ${missingModule}，请在getDependencies()中添加此依赖`);\n        }\n      }\n    }\n    \n    // 其他错误直接返回\n    return error;\n  }\n\n  /**\n   * 从错误信息中提取缺失的模块名\n   * @param {string} errorMessage - 错误信息\n   * @returns {string|null} - 模块名或null\n   * @private\n   */\n  _extractMissingModuleName(errorMessage) {\n    // 匹配 \"Cannot find module 'moduleName'\" 或 \"Cannot resolve module 'moduleName'\"\n    const match = errorMessage.match(/Cannot (?:find|resolve) module ['\"]([^'\"]+)['\"]/);\n    return match ? match[1] : null;\n  }\n\n  /**\n   * 尝试从工具代码中提取已声明的依赖\n   * @returns {string[]} - 依赖列表\n   * @private\n   */\n  _extractDeclaredDependencies() {\n    try {\n      // 尝试通过正则表达式从代码中提取getDependencies的返回值\n      const dependencyMatch = this.toolContent.match(/getDependencies\\s*\\(\\s*\\)\\s*\\{[\\s\\S]*?return\\s*\\[([\\s\\S]*?)\\]/);\n      \n      if (dependencyMatch) {\n        const dependencyString = dependencyMatch[1];\n        // 提取字符串字面量\n        const stringMatches = dependencyString.match(/['\"]([^'\"]+)['\"]/g);\n        if (stringMatches) {\n          return stringMatches.map(str => str.slice(1, -1)); // 去掉引号\n        }\n      }\n    } catch (error) {\n      logger.warn(`[ToolSandbox] Unable to parse dependency declaration: ${error.message}`);\n    }\n    \n    return [];\n  }\n\n  /**\n   * 检查模块是否在依赖声明中\n   * @param {string} moduleName - 模块名\n   * @param {string[]} declaredDependencies - 已声明的依赖列表\n   * @returns {boolean} - 是否已声明\n   * @private\n   */\n  _isDeclaredInDependencies(moduleName, declaredDependencies) {\n    return declaredDependencies.some(dep => {\n      // 支持 \"axios@^1.6.0\" 格式，提取模块名部分\n      const depName = dep.split('@')[0];\n      return depName === moduleName;\n    });\n  }\n\n  /**\n   * 检查沙箱目录是否存在\n   * @returns {Promise<boolean>}\n   */\n  async sandboxExists() {\n    if (!this.directoryManager) {\n      return false;\n    }\n    return await this.directoryManager.toolboxExists();\n  }\n\n  /**\n   * 确保沙箱目录存在\n   */\n  async ensureSandboxDirectory() {\n    // 委托给 directoryManager 处理\n    if (this.directoryManager) {\n      await this.directoryManager.ensureDirectories();\n    }\n  }\n\n  /**\n   * 安装依赖\n   */\n  async installDependencies() {\n    // 检查依赖是否为空（支持对象和数组格式）\n    const hasDependencies = typeof this.dependencies === 'object' && !Array.isArray(this.dependencies) \n      ? Object.keys(this.dependencies).length > 0\n      : this.dependencies.length > 0;\n      \n    if (!hasDependencies) {\n      return;\n    }\n\n    // 1. 创建package.json\n    await this.createPackageJson();\n    \n    // 2. 使用内置pnpm安装依赖\n    await this.runPnpmInstall();\n  }\n\n  /**\n   * 检查依赖是否需要更新\n   * @returns {Promise<boolean>} true表示需要更新\n   */\n  async checkDependenciesNeedUpdate() {\n    const packageJsonPath = this.directoryManager.getPackageJsonPath();\n    \n    try {\n      // 读取现有的package.json\n      const existingContent = await fs.readFile(packageJsonPath, 'utf-8');\n      const existingPackageJson = JSON.parse(existingContent);\n      const existingDeps = existingPackageJson.dependencies || {};\n      \n      // 构建新的依赖对象\n      let newDeps = {};\n      if (typeof this.dependencies === 'object' && !Array.isArray(this.dependencies)) {\n        // 新格式：直接使用对象\n        newDeps = this.dependencies;\n      } else if (Array.isArray(this.dependencies)) {\n        // 兼容旧格式（数组）\n        for (const dep of this.dependencies) {\n          if (dep.includes('@')) {\n            const lastAtIndex = dep.lastIndexOf('@');\n            if (lastAtIndex > 0) {\n              const name = dep.substring(0, lastAtIndex);\n              const version = dep.substring(lastAtIndex + 1);\n              newDeps[name] = version;\n            } else {\n              newDeps[dep] = 'latest';\n            }\n          } else {\n            newDeps[dep] = 'latest';\n          }\n        }\n      }\n      \n      // 比较依赖是否一致\n      const existingKeys = Object.keys(existingDeps).sort();\n      const newKeys = Object.keys(newDeps).sort();\n      \n      // 检查键是否相同\n      if (existingKeys.length !== newKeys.length || \n          !existingKeys.every((key, index) => key === newKeys[index])) {\n        logger.debug(`[ToolSandbox] Dependency list changed - old: ${existingKeys.join(', ')} | new: ${newKeys.join(', ')}`);\n        return true;\n      }\n      \n      // 检查版本是否相同\n      for (const key of existingKeys) {\n        if (existingDeps[key] !== newDeps[key]) {\n          logger.debug(`[ToolSandbox] Dependency version changed - ${key}: ${existingDeps[key]} -> ${newDeps[key]}`);\n          return true;\n        }\n      }\n      \n      return false;\n    } catch (error) {\n      // 文件不存在或解析失败，需要创建\n      logger.debug(`[ToolSandbox] package.json does not exist or is invalid, needs to be created`);\n      return true;\n    }\n  }\n\n  /**\n   * 创建package.json\n   */\n  async createPackageJson() {\n    const packageJsonPath = this.directoryManager.getPackageJsonPath();\n    \n    const packageJson = {\n      name: `toolbox-${this.toolId}`,\n      version: '1.0.0',\n      description: `Sandbox for tool: ${this.toolId}`,\n      private: true,\n      dependencies: {}\n    };\n    \n    // 直接使用 getDependencies 返回的对象格式 {\"package-name\": \"version\"}\n    logger.debug(`[ToolSandbox] Processing dependencies: ${JSON.stringify(this.dependencies)}`);\n    if (typeof this.dependencies === 'object' && !Array.isArray(this.dependencies)) {\n      // 新格式：直接使用对象\n      packageJson.dependencies = this.dependencies;\n    } else if (Array.isArray(this.dependencies)) {\n      // 兼容旧格式（数组），但应该逐步废弃\n      logger.warn(`[ToolSandbox] Tool ${this.toolId} is using deprecated array format for dependencies. Please update to object format.`);\n      for (const dep of this.dependencies) {\n        if (dep.includes('@')) {\n          const lastAtIndex = dep.lastIndexOf('@');\n          if (lastAtIndex > 0) {\n            const name = dep.substring(0, lastAtIndex);\n            const version = dep.substring(lastAtIndex + 1);\n            logger.debug(`[ToolSandbox] Parsing dependency \"${dep}\" => name=\"${name}\", version=\"${version}\"`);\n            packageJson.dependencies[name] = version;\n          } else {\n            // 只有 @ 开头，没有版本号的情况（如 @scope/package）\n            packageJson.dependencies[dep] = 'latest';\n          }\n        } else {\n          packageJson.dependencies[dep] = 'latest';\n        }\n      }\n    }\n    \n    await fs.writeFile(packageJsonPath, JSON.stringify(packageJson, null, 2));\n  }\n\n  /**\n   * 运行pnpm安装\n   */\n  async runPnpmInstall() {\n    const startTime = Date.now();\n    \n    // 构建依赖列表信息用于日志\n    let depsList = '';\n    if (typeof this.dependencies === 'object' && !Array.isArray(this.dependencies)) {\n      depsList = Object.keys(this.dependencies).map(name => `${name}@${this.dependencies[name]}`).join(', ');\n    } else if (Array.isArray(this.dependencies)) {\n      depsList = this.dependencies.join(', ');\n    }\n    \n    logger.info(`[ToolSandbox] Installing dependencies: [${depsList}]`);\n    \n    return new Promise((resolve, reject) => {\n      // 获取内置pnpm路径 - 直接从node_modules获取\n      const pnpmModulePath = require.resolve('pnpm');\n      const pnpmBinPath = path.join(path.dirname(pnpmModulePath), 'bin', 'pnpm.cjs');\n      \n      const nodeExecutable = process.env.PROMPTX_NODE_EXECUTABLE || 'node';\n      \n      // 准备子进程环境变量\n      const spawnEnv = { ...process.env };\n      \n      // 如果使用 Electron 作为 Node.js，需要设置 ELECTRON_RUN_AS_NODE\n      // 但只在这个子进程中设置，不污染主进程\n      if (nodeExecutable === process.env.PROMPTX_NODE_EXECUTABLE && nodeExecutable.includes('electron')) {\n        spawnEnv.ELECTRON_RUN_AS_NODE = '1';\n        logger.info(`[ToolSandbox] Setting ELECTRON_RUN_AS_NODE=1 for this subprocess only`);\n      }\n      \n      // Add CI=1 to environment to enable non-interactive mode\n      spawnEnv.CI = '1';\n      \n      // 构建pnpm参数数组\n      const pnpmArgs = [\n        pnpmBinPath, \n        'install',\n        '--config.confirmModulesPurge=false',\n        '--prefer-offline',\n        '--ignore-scripts',\n        '--reporter=append-only'\n      ];\n      \n      const fullCommand = `${nodeExecutable} ${pnpmArgs.join(' ')}`;\n      \n      logger.info(`[ToolSandbox] Executing command: ${fullCommand}`);\n      logger.info(`[ToolSandbox] Working directory: ${this.directoryManager.getToolboxPath()}`);\n      logger.info(`[ToolSandbox] Using Node.js executable: ${nodeExecutable}`);\n      \n      // 30秒超时\n      const timeout = setTimeout(() => {\n        const elapsed = ((Date.now() - startTime) / 1000).toFixed(1);\n        logger.error(`[ToolSandbox] pnpm install timeout (${elapsed}s > 30s)`);\n        logger.error(`[ToolSandbox] Command: ${fullCommand}`);\n        logger.error(`[ToolSandbox] Working directory: ${this.directoryManager.getToolboxPath()}`);\n        logger.error(`[ToolSandbox] Installing packages: [${depsList}]`);\n        logger.error(`[ToolSandbox] Stdout output: ${stdout}`);\n        logger.error(`[ToolSandbox] Stderr output: ${stderr}`);\n        pnpm.kill('SIGTERM');\n        reject(new Error(`pnpm install timeout after 30s. Command: ${fullCommand}`));\n      }, 30000);\n      \n      const pnpm = spawn(nodeExecutable, pnpmArgs, {\n        cwd: this.directoryManager.getToolboxPath(),  // 使用 toolbox 路径安装依赖\n        env: spawnEnv,  // 使用定制的环境变量\n        stdio: 'pipe'\n      });\n      \n      let stdout = '';\n      let stderr = '';\n      \n      pnpm.stdout.on('data', (data) => {\n        const output = data.toString();\n        stdout += output;\n        logger.debug(`[ToolSandbox] pnpm stdout: ${output}`);\n      });\n      \n      pnpm.stderr.on('data', (data) => {\n        const error = data.toString();\n        stderr += error;\n        logger.warn(`[ToolSandbox] pnpm stderr: ${error}`);\n      });\n      \n      pnpm.on('close', (code) => {\n        clearTimeout(timeout);\n        const elapsed = ((Date.now() - startTime) / 1000).toFixed(1);\n        \n        if (code === 0) {\n          logger.info(`[ToolSandbox] Dependencies installed successfully in ${elapsed}s`);\n          logger.debug(`[ToolSandbox] Installed packages: [${depsList}]`);\n          resolve({ stdout, stderr });\n        } else {\n          logger.error(`[ToolSandbox] pnpm install failed with exit code ${code} after ${elapsed}s`);\n          logger.error(`[ToolSandbox] Command: ${fullCommand}`);\n          logger.error(`[ToolSandbox] Working directory: ${this.directoryManager.getToolboxPath()}`);\n          logger.error(`[ToolSandbox] Installing packages: [${depsList}]`);\n          logger.error(`[ToolSandbox] Stdout: ${stdout}`);\n          logger.error(`[ToolSandbox] Stderr: ${stderr}`);\n          reject(new Error(`pnpm install failed with code ${code}: ${stderr}`));\n        }\n      });\n      \n      pnpm.on('error', (error) => {\n        logger.error(`[ToolSandbox] Failed to spawn pnpm: ${error.message}`);\n        reject(new Error(`Failed to spawn pnpm: ${error.message}`));\n      });\n    });\n  }\n\n  /**\n   * 检测和处理 ES Module 依赖\n   */\n  async detectAndHandleESModules() {\n    // 初始化 ES Module 支持器\n    if (!this.esModuleSupport) {\n      this.esModuleSupport = new ESModuleRequireSupport(this.directoryManager.getToolboxPath());\n    }\n\n    // 检测依赖类型\n    const dependencyTypes = await this.esModuleSupport.detectDependenciesTypes(this.dependencies);\n    \n    if (dependencyTypes.esmodule.length > 0) {\n      logger.warn(`[ToolSandbox] 检测到 ES Module 依赖：`, dependencyTypes.esmodule.map(d => d.name).join(', '));\n      logger.info(`[ToolSandbox] ES Module 包需要使用动态 import() 加载，工具可能需要相应调整`);\n      \n      // 存储 ES Module 信息供后续使用\n      this.esModuleDependencies = dependencyTypes.esmodule;\n    }\n\n    if (dependencyTypes.unknown.length > 0) {\n      logger.debug(`[ToolSandbox] 无法检测的依赖类型：`, dependencyTypes.unknown.map(d => d.name).join(', '));\n    }\n\n    return dependencyTypes;\n  }\n\n  /**\n   * 创建执行沙箱环境\n   */\n  async createExecutionSandbox() {\n    // 创建执行阶段的隔离管理器，使用工作目录\n    this.isolationManager = new SandboxIsolationManager(this.directoryManager.getWorkingPath(), {\n      enableDependencyLoading: true,\n      analysisMode: false,\n      toolboxPath: this.directoryManager.getToolboxPath()  // 传递 toolbox 路径用于依赖加载\n    });\n    \n    this.sandboxContext = this.isolationManager.createIsolatedContext();\n    \n    // 添加 ES Module 动态加载支持\n    // 始终提供 importModule 函数，以支持工具动态加载 ES Module\n    if (!this.esModuleSupport) {\n      this.esModuleSupport = new ESModuleRequireSupport(this.directoryManager.getToolboxPath());\n    }\n    \n    // 统一的模块加载函数 - 自动检测并加载\n    this.sandboxContext.loadModule = async (moduleName) => {\n      const moduleType = await this.esModuleSupport.detectModuleType(moduleName);\n      if (moduleType === 'esm') {\n        // ES Module - 尝试动态 import\n        try {\n          return await this.esModuleSupport.loadESModule(moduleName);\n        } catch (error) {\n          // 如果动态 import 失败，尝试通过 require 加载并提取 default\n          const module = this.sandboxContext.require(moduleName);\n          // Node.js 的 createRequire 会将 ES Module 包装，真正的导出在 default 中\n          return module.default || module;\n        }\n      } else {\n        return this.sandboxContext.require(moduleName);\n      }\n    };\n    \n    // 保留 importModule 作为别名（向后兼容）\n    this.sandboxContext.importModule = this.sandboxContext.loadModule;\n    \n    // 增强 require - 主动检测 ES Module 并阻止加载\n    const originalRequire = this.sandboxContext.require;\n    const esModuleSupport = this.esModuleSupport;  // 捕获引用用于闭包\n    \n    this.sandboxContext.require = function(moduleName) {\n      // 主动检测是否是 ES Module（使用同步方法避免 async）\n      try {\n        const packageJsonPath = require.resolve(`${moduleName}/package.json`, {\n          paths: [esModuleSupport.toolboxPath]\n        });\n        const packageJson = require(packageJsonPath);\n        \n        if (packageJson.type === 'module') {\n          // 是 ES Module，主动抛出错误\n          const error = new Error(\n            `❌ \"${moduleName}\" 是 ES Module 包，请使用 await loadModule('${moduleName}') 代替 require('${moduleName}')\\n` +\n            `💡 提示：loadModule 会自动检测包类型并正确加载`\n          );\n          error.code = 'ERR_REQUIRE_ESM';\n          throw error;\n        }\n      } catch (checkError) {\n        // 如果检测失败（比如包不存在），让原始 require 处理\n        if (checkError.code === 'ERR_REQUIRE_ESM') {\n          throw checkError;  // 重新抛出我们的错误\n        }\n      }\n      \n      // 不是 ES Module 或检测失败，使用原始 require\n      const result = originalRequire(moduleName);\n      \n      // 额外检查：如果返回对象有 __esModule 和 default，说明是被包装的 ES Module\n      if (result && result.__esModule && result.default && !result.default.__esModule) {\n        // 这是 createRequire 包装的 ES Module，应该报错\n        const error = new Error(\n          `❌ \"${moduleName}\" 是 ES Module 包，请使用 await loadModule('${moduleName}') 代替 require('${moduleName}')\\n` +\n          `💡 提示：loadModule 会自动检测包类型并正确加载`\n        );\n        error.code = 'ERR_REQUIRE_ESM';\n        throw error;\n      }\n      \n      return result;\n    };\n    \n    if (this.esModuleDependencies && this.esModuleDependencies.length > 0) {\n      logger.debug(`[ToolSandbox] 已为工具 ${this.toolId} 启用 ES Module 支持，检测到 ${this.esModuleDependencies.length} 个 ES Module 依赖`);\n    } else {\n      logger.debug(`[ToolSandbox] 已为工具 ${this.toolId} 启用 importModule 函数`);\n    }\n    \n    // 在完全隔离的沙箱中重新加载工具\n    const script = new vm.Script(this.toolContent, { filename: `${this.toolId}.js` });\n    const context = vm.createContext(this.sandboxContext);\n    \n    script.runInContext(context);\n    const exported = context.module.exports;\n    \n    if (typeof exported === 'function') {\n      this.toolInstance = new exported();\n    } else if (typeof exported === 'object') {\n      this.toolInstance = exported;\n    }\n  }\n\n\n  /**\n   * 解析协议路径（支持@project://等协议）\n   * @param {string} protocolPath - 协议路径，如@project://.promptx/cwd\n   * @returns {Promise<string>} 解析后的绝对路径\n   */\n  async resolveProtocolPath(protocolPath) {\n    // 处理undefined或null的情况\n    if (!protocolPath) {\n      throw new Error('protocolPath is required but was undefined');\n    }\n    \n    // 🚀 新架构：@project协议直接使用ProjectPathResolver\n    if (protocolPath.startsWith('@project://')) {\n      const { getGlobalProjectPathResolver } = require('../utils/ProjectPathResolver');\n      const pathResolver = getGlobalProjectPathResolver();\n      \n      try {\n        // 提取协议路径的相对部分\n        const relativePath = protocolPath.replace(/^@project:\\/\\//, '');\n        const resolvedPath = pathResolver.resolvePath(relativePath);\n        \n        // 确保目录存在\n        const fs = require('fs').promises;\n        try {\n          await fs.access(resolvedPath);\n        } catch (error) {\n          if (error.code === 'ENOENT') {\n            await fs.mkdir(resolvedPath, { recursive: true });\n            logger.debug(`[ToolSandbox] Created unified working directory: ${resolvedPath}`);\n          }\n        }\n        \n        return resolvedPath;\n      } catch (error) {\n        throw new Error(`解析@project://路径失败: ${error.message}`);\n      }\n    }\n    \n    // 其他协议路径使用ResourceManager解析\n    if (protocolPath.startsWith('@')) {\n      if (!this.resourceManager) {\n        throw new Error('ResourceManager not set. Cannot resolve protocol path.');\n      }\n      \n      // 其他协议处理逻辑保持不变\n      throw new Error(`暂不支持的协议路径: ${protocolPath}`);\n    }\n    \n    // 普通路径直接返回\n    return protocolPath;\n  }\n\n\n\n\n  /**\n   * 参数验证\n   */\n  async validateParameters(parameters) {\n    if (typeof this.toolInstance.validate === 'function') {\n      const result = this.toolInstance.validate(parameters);\n      \n      if (typeof result === 'boolean' && !result) {\n        throw new Error('Parameter validation failed');\n      } else if (result && typeof result === 'object' && !result.valid) {\n        throw new Error(`Parameter validation failed: ${result.errors?.join(', ')}`);\n      }\n    }\n  }\n\n  /**\n   * 在沙箱中执行工具\n   */\n  async executeInSandbox(parameters) {\n    if (!this.toolInstance || typeof this.toolInstance.execute !== 'function') {\n      throw new Error(`Tool ${this.toolId} does not have execute method`);\n    }\n    \n    return await this.toolInstance.execute(parameters);\n  }\n\n  /**\n   * 获取分析结果\n   */\n  getAnalysisResult() {\n    return {\n      toolId: this.toolId,\n      dependencies: this.dependencies,\n      sandboxPath: this.directoryManager?.getWorkingPath(),\n      toolboxPath: this.directoryManager?.getToolboxPath(),\n      hasMetadata: typeof this.toolInstance?.getMetadata === 'function',\n      hasSchema: typeof this.toolInstance?.getSchema === 'function'\n    };\n  }\n\n  /**\n   * 清理沙箱资源\n   */\n  async cleanup() {\n    // 清理隔离管理器\n    if (this.isolationManager) {\n      this.isolationManager.cleanup();\n      this.isolationManager = null;\n    }\n    \n    // 清理 ES Module 支持器\n    if (this.esModuleSupport) {\n      this.esModuleSupport.clearCache();\n      this.esModuleSupport = null;\n    }\n    \n    // 清理其他资源\n    this.sandboxContext = null;\n    this.toolInstance = null;\n    this.esModuleDependencies = null;\n  }\n\n  /**\n   * 获取工具元信息\n   */\n  getToolMetadata() {\n    if (this.toolInstance && typeof this.toolInstance.getMetadata === 'function') {\n      return this.toolInstance.getMetadata();\n    }\n    return null;\n  }\n\n  /**\n   * 获取工具Schema\n   */\n  getToolSchema() {\n    if (this.toolInstance && typeof this.toolInstance.getSchema === 'function') {\n      return this.toolInstance.getSchema();\n    }\n    return null;\n  }\n}\n\nmodule.exports = ToolSandbox;","/**\n * ToolInterface - PromptX工具接口规范\n * 定义鸭子类型的工具接口，外部工具无需继承任何类\n */\n\n/**\n * Tool接口规范定义\n */\nconst TOOL_INTERFACE = {\n  // 必须实现的方法\n  required: [\n    {\n      name: 'getMetadata',\n      signature: '() => Object',\n      description: '获取工具元信息',\n      returns: {\n        name: 'string - 工具名称',\n        description: 'string - 工具描述', \n        version: 'string - 版本号',\n        category: 'string - 分类（可选）',\n        author: 'string - 作者（可选）'\n      }\n    },\n    {\n      name: 'getSchema',\n      signature: '() => Object',\n      description: '获取参数JSON Schema',\n      returns: {\n        type: 'string - 参数类型，通常为object',\n        properties: 'Object - 参数属性定义',\n        required: 'Array - 必需参数列表（可选）',\n        additionalProperties: 'boolean - 是否允许额外参数（可选）'\n      }\n    },\n    {\n      name: 'execute',\n      signature: '(parameters: Object) => Promise<any>',\n      description: '执行工具主逻辑',\n      parameters: {\n        parameters: 'Object - 工具参数，符合getSchema定义'\n      },\n      returns: 'Promise<any> - 工具执行结果'\n    }\n  ],\n\n  // 可选实现的方法\n  optional: [\n    {\n      name: 'getPackage',\n      signature: '() => Object',\n      description: '获取工具包信息（可选，用于依赖管理）',\n      returns: {\n        directory: 'string - 工具目录路径',\n        dependencies: 'Object - 依赖对象，格式：{包名: 版本}',\n        packageJson: 'Object - package.json内容（可选）'\n      }\n    },\n    {\n      name: 'validate',\n      signature: '(parameters: Object) => Object',\n      description: '验证参数（可选，有默认实现）',\n      parameters: {\n        parameters: 'Object - 待验证参数'\n      },\n      returns: {\n        valid: 'boolean - 验证是否通过',\n        errors: 'Array<string> - 错误信息列表'\n      }\n    },\n    {\n      name: 'cleanup',\n      signature: '() => void | Promise<void>',\n      description: '清理资源（可选）',\n      returns: 'void | Promise<void>'\n    },\n    {\n      name: 'init',\n      signature: '(config?: Object) => void | Promise<void>',\n      description: '初始化工具（可选）',\n      parameters: {\n        config: 'Object - 初始化配置（可选）'\n      },\n      returns: 'void | Promise<void>'\n    }\n  ]\n};\n\n/**\n * 工具错误类型定义\n */\nconst TOOL_ERROR_CODES = {\n  VALIDATION_ERROR: 'VALIDATION_ERROR',     // 参数验证失败\n  EXECUTION_ERROR: 'EXECUTION_ERROR',       // 执行错误\n  TIMEOUT_ERROR: 'TIMEOUT_ERROR',           // 超时错误\n  PERMISSION_ERROR: 'PERMISSION_ERROR',     // 权限错误\n  RESOURCE_ERROR: 'RESOURCE_ERROR',         // 资源错误\n  CONFIGURATION_ERROR: 'CONFIGURATION_ERROR' // 配置错误\n};\n\n/**\n * 标准结果格式定义\n */\nconst TOOL_RESULT_FORMAT = {\n  success: {\n    success: true,\n    data: 'any - 工具返回的实际数据',\n    metadata: {\n      tool: 'string - 工具名称',\n      executionTime: 'string - 执行时间',\n      timestamp: 'string - 时间戳',\n      // ...其他元信息\n    }\n  },\n  \n  error: {\n    success: false,\n    error: {\n      code: 'string - 错误代码（见TOOL_ERROR_CODES）',\n      message: 'string - 错误消息',\n      details: 'Object - 错误详情（可选）'\n    },\n    metadata: {\n      tool: 'string - 工具名称',\n      timestamp: 'string - 时间戳',\n      // ...其他元信息\n    }\n  }\n};\n\n/**\n * 示例工具实现\n */\nconst EXAMPLE_TOOL = `\nclass ExampleTool {\n  getMetadata() {\n    return {\n      name: 'example-tool',\n      description: '示例工具',\n      version: '1.0.0',\n      category: 'example',\n      author: 'PromptX Team'\n    };\n  }\n\n  getSchema() {\n    return {\n      type: 'object',\n      properties: {\n        input: {\n          type: 'string',\n          description: '输入参数'\n        }\n      },\n      required: ['input'],\n      additionalProperties: false\n    };\n  }\n\n  async execute(parameters) {\n    const { input } = parameters;\n    \n    // 工具逻辑\n    const result = \\`处理结果: \\${input}\\`;\n    \n    return result;\n  }\n\n  // 可选：声明依赖（新格式：对象）\n  getDependencies() {\n    return {\n      'lodash': '^4.17.21',\n      'axios': '^1.6.0'\n    };\n  }\n\n  // 可选：自定义参数验证\n  validate(parameters) {\n    const errors = [];\n    \n    if (!parameters.input || parameters.input.trim() === '') {\n      errors.push('input不能为空');\n    }\n    \n    return { valid: errors.length === 0, errors };\n  }\n\n  // 可选：清理资源\n  cleanup() {\n    console.log('清理资源');\n  }\n}\n\nmodule.exports = ExampleTool;\n`;\n\nmodule.exports = {\n  TOOL_INTERFACE,\n  TOOL_ERROR_CODES,\n  TOOL_RESULT_FORMAT,\n  EXAMPLE_TOOL\n};","const { TOOL_INTERFACE, TOOL_ERROR_CODES } = require('./ToolInterface');\n\n/**\n * ToolValidator - 工具接口验证器\n * 使用鸭子类型验证工具是否符合PromptX接口规范\n */\nclass ToolValidator {\n  /**\n   * 验证工具是否符合接口规范\n   * @param {any} tool - 待验证的工具对象\n   * @returns {Object} 验证结果 {valid: boolean, errors: [], warnings: []}\n   */\n  static validateTool(tool) {\n    const errors = [];\n    const warnings = [];\n\n    // 基础类型检查\n    if (!tool || typeof tool !== 'object') {\n      errors.push('工具必须是对象类型');\n      return { valid: false, errors, warnings };\n    }\n\n    // 验证必需方法\n    for (const methodSpec of TOOL_INTERFACE.required) {\n      const methodName = methodSpec.name;\n      \n      if (!(methodName in tool)) {\n        errors.push(`缺少必需方法: ${methodName}`);\n        continue;\n      }\n      \n      if (typeof tool[methodName] !== 'function') {\n        errors.push(`${methodName} 必须是函数类型`);\n        continue;\n      }\n\n      // 方法签名验证\n      try {\n        const validationResult = this.validateMethod(tool, methodSpec);\n        if (!validationResult.valid) {\n          errors.push(...validationResult.errors);\n          warnings.push(...validationResult.warnings);\n        }\n      } catch (error) {\n        warnings.push(`${methodName} 方法验证时出错: ${error.message}`);\n      }\n    }\n\n    // 验证可选方法\n    for (const methodSpec of TOOL_INTERFACE.optional) {\n      const methodName = methodSpec.name;\n      \n      if (methodName in tool) {\n        if (typeof tool[methodName] !== 'function') {\n          warnings.push(`${methodName} 应该是函数类型`);\n        } else {\n          try {\n            const validationResult = this.validateMethod(tool, methodSpec);\n            if (!validationResult.valid) {\n              warnings.push(...validationResult.errors);\n            }\n          } catch (error) {\n            warnings.push(`${methodName} 方法验证时出错: ${error.message}`);\n          }\n        }\n      }\n    }\n\n    return {\n      valid: errors.length === 0,\n      errors,\n      warnings\n    };\n  }\n\n  /**\n   * 验证特定方法\n   * @param {Object} tool - 工具对象\n   * @param {Object} methodSpec - 方法规范\n   * @returns {Object} 验证结果\n   */\n  static validateMethod(tool, methodSpec) {\n    const errors = [];\n    const warnings = [];\n    const methodName = methodSpec.name;\n\n    try {\n      switch (methodName) {\n        case 'getMetadata':\n          return this.validateGetMetadata(tool);\n        case 'getSchema':\n          return this.validateGetSchema(tool);\n        case 'execute':\n          return this.validateExecute(tool);\n        case 'validate':\n          return this.validateValidateMethod(tool);\n        default:\n          return { valid: true, errors: [], warnings: [] };\n      }\n    } catch (error) {\n      errors.push(`${methodName} 方法调用失败: ${error.message}`);\n      return { valid: false, errors, warnings };\n    }\n  }\n\n  /**\n   * 验证getMetadata方法\n   * @param {Object} tool - 工具对象\n   * @returns {Object} 验证结果\n   */\n  static validateGetMetadata(tool) {\n    const errors = [];\n    const warnings = [];\n\n    try {\n      const metadata = tool.getMetadata();\n      \n      if (!metadata || typeof metadata !== 'object') {\n        errors.push('getMetadata() 必须返回对象');\n        return { valid: false, errors, warnings };\n      }\n\n      // 验证必需字段\n      if (!metadata.name || typeof metadata.name !== 'string') {\n        errors.push('metadata.name 必须是非空字符串');\n      }\n\n      if (!metadata.description || typeof metadata.description !== 'string') {\n        errors.push('metadata.description 必须是非空字符串');\n      }\n\n      if (!metadata.version || typeof metadata.version !== 'string') {\n        errors.push('metadata.version 必须是非空字符串');\n      }\n\n      // 验证可选字段\n      if (metadata.category && typeof metadata.category !== 'string') {\n        warnings.push('metadata.category 应该是字符串类型');\n      }\n\n      if (metadata.author && typeof metadata.author !== 'string') {\n        warnings.push('metadata.author 应该是字符串类型');\n      }\n\n    } catch (error) {\n      errors.push(`getMetadata() 执行失败: ${error.message}`);\n    }\n\n    return { valid: errors.length === 0, errors, warnings };\n  }\n\n  /**\n   * 验证getSchema方法\n   * @param {Object} tool - 工具对象\n   * @returns {Object} 验证结果\n   */\n  static validateGetSchema(tool) {\n    const errors = [];\n    const warnings = [];\n\n    try {\n      const schema = tool.getSchema();\n      \n      if (!schema || typeof schema !== 'object') {\n        errors.push('getSchema() 必须返回对象');\n        return { valid: false, errors, warnings };\n      }\n\n      // 基础JSON Schema验证\n      if (!schema.type) {\n        warnings.push('schema.type 建议定义');\n      }\n\n      if (schema.type && typeof schema.type !== 'string') {\n        errors.push('schema.type 必须是字符串');\n      }\n\n      if (schema.properties && typeof schema.properties !== 'object') {\n        errors.push('schema.properties 必须是对象');\n      }\n\n      if (schema.required && !Array.isArray(schema.required)) {\n        errors.push('schema.required 必须是数组');\n      }\n\n    } catch (error) {\n      errors.push(`getSchema() 执行失败: ${error.message}`);\n    }\n\n    return { valid: errors.length === 0, errors, warnings };\n  }\n\n  /**\n   * 验证execute方法\n   * @param {Object} tool - 工具对象\n   * @returns {Object} 验证结果\n   */\n  static validateExecute(tool) {\n    const errors = [];\n    const warnings = [];\n\n    // 检查方法签名\n    const executeMethod = tool.execute;\n    if (executeMethod.length === 0) {\n      warnings.push('execute() 方法建议接受parameters参数');\n    }\n\n    // 注意：这里不实际调用execute方法，因为可能有副作用\n    // 只进行静态检查\n\n    return { valid: errors.length === 0, errors, warnings };\n  }\n\n  /**\n   * 验证validate方法（可选）\n   * @param {Object} tool - 工具对象\n   * @returns {Object} 验证结果\n   */\n  static validateValidateMethod(tool) {\n    const errors = [];\n    const warnings = [];\n\n    try {\n      // 测试validate方法的返回格式\n      const testParams = {};\n      const result = tool.validate(testParams);\n      \n      if (!result || typeof result !== 'object') {\n        errors.push('validate() 必须返回对象');\n        return { valid: false, errors, warnings };\n      }\n\n      if (typeof result.valid !== 'boolean') {\n        errors.push('validate() 返回值必须包含valid(boolean)字段');\n      }\n\n      if (result.errors && !Array.isArray(result.errors)) {\n        errors.push('validate() 返回值的errors字段必须是数组');\n      }\n\n    } catch (error) {\n      warnings.push(`validate() 方法测试失败: ${error.message}`);\n    }\n\n    return { valid: errors.length === 0, errors, warnings };\n  }\n\n  /**\n   * 为工具提供默认的validate方法实现\n   * @param {Object} tool - 工具对象\n   * @param {Object} parameters - 待验证参数\n   * @returns {Object} 验证结果\n   */\n  static defaultValidate(tool, parameters) {\n    const errors = [];\n\n    try {\n      // 获取schema\n      const schema = tool.getSchema();\n      \n      // 基础类型检查\n      if (!parameters || typeof parameters !== 'object') {\n        errors.push('参数必须是对象类型');\n        return { valid: false, errors };\n      }\n\n      // 必需参数检查\n      if (schema.required && Array.isArray(schema.required)) {\n        for (const field of schema.required) {\n          if (!(field in parameters)) {\n            errors.push(`缺少必需参数: ${field}`);\n          }\n        }\n      }\n\n      // 基础字段类型检查\n      if (schema.properties && typeof schema.properties === 'object') {\n        for (const [field, fieldSchema] of Object.entries(schema.properties)) {\n          if (field in parameters) {\n            const value = parameters[field];\n            const expectedType = fieldSchema.type;\n            \n            if (expectedType && !this.validateType(value, expectedType)) {\n              errors.push(`参数 ${field} 类型错误，期望 ${expectedType}，实际 ${typeof value}`);\n            }\n          }\n        }\n      }\n\n    } catch (error) {\n      errors.push(`参数验证失败: ${error.message}`);\n    }\n\n    return { valid: errors.length === 0, errors };\n  }\n\n  /**\n   * 类型验证辅助方法\n   * @param {*} value - 待验证值\n   * @param {string} expectedType - 期望类型\n   * @returns {boolean} 是否匹配\n   */\n  static validateType(value, expectedType) {\n    switch (expectedType) {\n      case 'string':\n        return typeof value === 'string';\n      case 'number':\n        return typeof value === 'number';\n      case 'boolean':\n        return typeof value === 'boolean';\n      case 'object':\n        return typeof value === 'object' && value !== null;\n      case 'array':\n        return Array.isArray(value);\n      default:\n        return true; // 未知类型，跳过验证\n    }\n  }\n\n  /**\n   * 生成工具接口报告\n   * @param {Object} tool - 工具对象\n   * @returns {Object} 接口报告\n   */\n  static generateInterfaceReport(tool) {\n    const validation = this.validateTool(tool);\n    const report = {\n      toolName: 'unknown',\n      valid: validation.valid,\n      errors: validation.errors,\n      warnings: validation.warnings,\n      implementedMethods: {\n        required: [],\n        optional: []\n      },\n      metadata: null,\n      schema: null\n    };\n\n    try {\n      // 获取工具名称\n      if (tool.getMetadata) {\n        const metadata = tool.getMetadata();\n        report.toolName = metadata.name || 'unknown';\n        report.metadata = metadata;\n      }\n\n      // 获取schema\n      if (tool.getSchema) {\n        report.schema = tool.getSchema();\n      }\n\n      // 检查已实现的方法\n      for (const methodSpec of TOOL_INTERFACE.required) {\n        if (typeof tool[methodSpec.name] === 'function') {\n          report.implementedMethods.required.push(methodSpec.name);\n        }\n      }\n\n      for (const methodSpec of TOOL_INTERFACE.optional) {\n        if (typeof tool[methodSpec.name] === 'function') {\n          report.implementedMethods.optional.push(methodSpec.name);\n        }\n      }\n\n    } catch (error) {\n      report.warnings.push(`生成报告时出错: ${error.message}`);\n    }\n\n    return report;\n  }\n}\n\nmodule.exports = ToolValidator;","const ToolValidator = require('./ToolValidator');\nconst { TOOL_ERROR_CODES, TOOL_RESULT_FORMAT } = require('./ToolInterface');\n\n/**\n * ToolUtils - 工具实用函数集合\n * 提供工具开发和使用的辅助函数\n */\nclass ToolUtils {\n  /**\n   * 创建标准化的成功结果\n   * @param {*} data - 结果数据\n   * @param {Object} options - 选项\n   * @returns {Object} 标准化结果\n   */\n  static createSuccessResult(data, options = {}) {\n    const {\n      tool = 'unknown',\n      executionTime = null,\n      metadata = {}\n    } = options;\n\n    return {\n      success: true,\n      data: data,\n      metadata: {\n        tool: tool,\n        executionTime: executionTime,\n        timestamp: new Date().toISOString(),\n        ...metadata\n      }\n    };\n  }\n\n  /**\n   * 创建标准化的错误结果\n   * @param {string} code - 错误代码\n   * @param {string} message - 错误消息\n   * @param {Object} options - 选项\n   * @returns {Object} 标准化错误\n   */\n  static createErrorResult(code, message, options = {}) {\n    const {\n      tool = 'unknown',\n      details = {},\n      metadata = {}\n    } = options;\n\n    return {\n      success: false,\n      error: {\n        code: code,\n        message: message,\n        details: details\n      },\n      metadata: {\n        tool: tool,\n        timestamp: new Date().toISOString(),\n        ...metadata\n      }\n    };\n  }\n\n  /**\n   * 验证工具结果格式\n   * @param {Object} result - 工具结果\n   * @returns {Object} 验证结果\n   */\n  static validateResult(result) {\n    const errors = [];\n\n    if (!result || typeof result !== 'object') {\n      errors.push('结果必须是对象类型');\n      return { valid: false, errors };\n    }\n\n    if (typeof result.success !== 'boolean') {\n      errors.push('结果必须包含success(boolean)字段');\n    }\n\n    if (result.success) {\n      // 成功结果验证\n      if (!('data' in result)) {\n        errors.push('成功结果必须包含data字段');\n      }\n    } else {\n      // 错误结果验证\n      if (!result.error || typeof result.error !== 'object') {\n        errors.push('错误结果必须包含error(object)字段');\n      } else {\n        if (!result.error.code || typeof result.error.code !== 'string') {\n          errors.push('错误结果必须包含error.code(string)字段');\n        }\n        if (!result.error.message || typeof result.error.message !== 'string') {\n          errors.push('错误结果必须包含error.message(string)字段');\n        }\n      }\n    }\n\n    return { valid: errors.length === 0, errors };\n  }\n\n  /**\n   * 安全地执行工具方法\n   * @param {Object} tool - 工具实例\n   * @param {string} methodName - 方法名\n   * @param {...any} args - 方法参数\n   * @returns {Promise<*>} 执行结果\n   */\n  static async safeExecute(tool, methodName, ...args) {\n    try {\n      if (!tool || typeof tool[methodName] !== 'function') {\n        throw new Error(`工具不存在方法: ${methodName}`);\n      }\n\n      const result = await tool[methodName](...args);\n      return result;\n    } catch (error) {\n      throw new Error(`方法执行失败 ${methodName}: ${error.message}`);\n    }\n  }\n\n  /**\n   * 工具性能分析\n   * @param {Object} tool - 工具实例\n   * @param {Object} parameters - 测试参数\n   * @param {Object} options - 选项\n   * @returns {Promise<Object>} 性能分析结果\n   */\n  static async benchmarkTool(tool, parameters = {}, options = {}) {\n    const {\n      iterations = 10,\n      warmup = 3\n    } = options;\n\n    const results = {\n      toolName: 'unknown',\n      iterations: iterations,\n      warmup: warmup,\n      times: [],\n      stats: {}\n    };\n\n    try {\n      // 获取工具名称\n      if (tool.getMetadata) {\n        const metadata = tool.getMetadata();\n        results.toolName = metadata.name || 'unknown';\n      }\n\n      // 验证工具接口\n      const validation = ToolValidator.validateTool(tool);\n      if (!validation.valid) {\n        throw new Error(`工具接口验证失败: ${validation.errors.join(', ')}`);\n      }\n\n      // 预热运行\n      for (let i = 0; i < warmup; i++) {\n        await tool.execute(parameters);\n      }\n\n      // 性能测试\n      for (let i = 0; i < iterations; i++) {\n        const startTime = process.hrtime.bigint();\n        await tool.execute(parameters);\n        const endTime = process.hrtime.bigint();\n        \n        const executionTime = Number(endTime - startTime) / 1000000; // 转换为毫秒\n        results.times.push(executionTime);\n      }\n\n      // 计算统计信息\n      results.stats = this.calculateStats(results.times);\n\n    } catch (error) {\n      results.error = error.message;\n    }\n\n    return results;\n  }\n\n  /**\n   * 计算统计信息\n   * @param {Array<number>} times - 时间数组\n   * @returns {Object} 统计信息\n   */\n  static calculateStats(times) {\n    if (times.length === 0) {\n      return {};\n    }\n\n    const sorted = [...times].sort((a, b) => a - b);\n    const sum = times.reduce((a, b) => a + b, 0);\n    \n    return {\n      count: times.length,\n      min: Math.min(...times),\n      max: Math.max(...times),\n      mean: sum / times.length,\n      median: sorted[Math.floor(sorted.length / 2)],\n      p95: sorted[Math.floor(sorted.length * 0.95)],\n      p99: sorted[Math.floor(sorted.length * 0.99)]\n    };\n  }\n\n  /**\n   * 生成工具模板代码\n   * @param {Object} options - 工具选项\n   * @returns {string} 工具模板代码\n   */\n  static generateToolTemplate(options = {}) {\n    const {\n      toolName = 'ExampleTool',\n      className = 'ExampleTool',\n      description = '示例工具',\n      category = 'utility',\n      author = 'PromptX Developer'\n    } = options;\n\n    return `/**\n * ${className} - ${description}\n * 使用PromptX鸭子类型接口，无需继承任何基类\n */\nclass ${className} {\n  getMetadata() {\n    return {\n      name: '${toolName}',\n      description: '${description}',\n      version: '1.0.0',\n      category: '${category}',\n      author: '${author}'\n    };\n  }\n\n  getSchema() {\n    return {\n      type: 'object',\n      properties: {\n        input: {\n          type: 'string',\n          description: '输入参数'\n        }\n      },\n      required: ['input'],\n      additionalProperties: false\n    };\n  }\n\n  async execute(parameters) {\n    const { input } = parameters;\n    \n    try {\n      // TODO: 实现工具逻辑\n      const result = \\`处理结果: \\${input}\\`;\n      \n      return result;\n    } catch (error) {\n      throw new Error(\\`执行失败: \\${error.message}\\`);\n    }\n  }\n\n  // 可选：自定义参数验证\n  validate(parameters) {\n    const errors = [];\n    \n    if (!parameters.input || parameters.input.trim() === '') {\n      errors.push('input不能为空');\n    }\n    \n    return { valid: errors.length === 0, errors };\n  }\n\n  // 可选：清理资源\n  cleanup() {\n    // 清理逻辑\n  }\n}\n\nmodule.exports = ${className};\n`;\n  }\n\n  /**\n   * 创建工具开发指南\n   * @returns {string} 开发指南\n   */\n  static getDevGuide() {\n    return `\n# PromptX Tool 开发指南\n\n## 鸭子类型接口\nPromptX工具使用鸭子类型设计，无需继承任何基类。只需实现以下接口：\n\n### 必需方法\n1. \\`getMetadata()\\` - 返回工具元信息\n2. \\`getSchema()\\` - 返回参数JSON Schema\n3. \\`execute(parameters)\\` - 执行工具逻辑\n\n### 可选方法\n1. \\`validate(parameters)\\` - 自定义参数验证\n2. \\`cleanup()\\` - 清理资源\n3. \\`init(config)\\` - 初始化工具\n\n## 开发步骤\n1. 使用 ToolUtils.generateToolTemplate() 生成模板\n2. 实现必需的接口方法\n3. 使用 ToolValidator.validateTool() 验证接口\n4. 使用 ToolUtils.benchmarkTool() 性能测试\n5. 注册到工具注册表\n\n## 示例代码\n\\`\\`\\`javascript\n${this.generateToolTemplate()}\n\\`\\`\\`\n\n## 最佳实践\n- 保持execute方法的幂等性\n- 提供清晰的错误消息\n- 使用合适的JSON Schema验证\n- 实现适当的资源清理\n- 遵循统一的结果格式\n`;\n  }\n}\n\nmodule.exports = ToolUtils;","/**\n * PromptX Tool Framework\n * 统一的工具框架入口文件 - ToolSandbox版本\n */\n\nconst ToolSandbox = require('./ToolSandbox');\nconst ToolValidator = require('./ToolValidator');\nconst ToolUtils = require('./ToolUtils');\nconst { TOOL_INTERFACE, TOOL_ERROR_CODES, TOOL_RESULT_FORMAT, EXAMPLE_TOOL } = require('./ToolInterface');\n\n// 创建全局工具实例\nlet globalSandbox = null;\n\n/**\n * 获取全局工具沙箱\n * @param {string} toolResource - 工具资源引用\n * @returns {ToolSandbox} 工具沙箱实例\n */\nfunction getGlobalToolSandbox(toolResource) {\n  // ToolSandbox是工具特定的，不使用单例\n  return new ToolSandbox(toolResource);\n}\n\n/**\n * 初始化工具框架 - ToolSandbox版本\n * @param {Object} options - 配置选项\n * @returns {Object} 初始化结果\n */\nfunction initialize(options = {}) {\n  try {\n    return {\n      success: true,\n      message: 'ToolSandbox工具框架初始化成功',\n      framework: {\n        executor: 'ToolSandbox',\n        version: '2.0.0',\n        features: [\n          '自动依赖管理',\n          '沙箱隔离执行', \n          '三阶段执行流程',\n          'pnpm集成'\n        ]\n      }\n    };\n  } catch (error) {\n    return {\n      success: false,\n      message: `工具框架初始化失败: ${error.message}`,\n      error: error\n    };\n  }\n}\n\n/**\n * 执行工具的便捷方法 - ToolSandbox版本\n * @param {string} toolResource - 工具资源引用 (@tool://tool-name)\n * @param {Object} parameters - 工具参数\n * @param {Object} resourceManager - ResourceManager实例\n * @returns {Promise<Object>} 执行结果\n */\nasync function executeTool(toolResource, parameters = {}, resourceManager = null) {\n  if (!resourceManager) {\n    throw new Error('ResourceManager is required for ToolSandbox execution');\n  }\n  \n  const sandbox = getGlobalToolSandbox(toolResource);\n  sandbox.setResourceManager(resourceManager);\n  \n  try {\n    await sandbox.analyze();\n    await sandbox.prepareDependencies();\n    return await sandbox.execute(parameters);\n  } finally {\n    await sandbox.cleanup();\n  }\n}\n\n/**\n * 重置工具框架 - ToolSandbox版本\n */\nfunction reset() {\n  // ToolSandbox不使用全局单例，无需重置\n  globalSandbox = null;\n}\n\n/**\n * 获取工具框架统计信息 - ToolSandbox版本\n * @returns {Object} 统计信息\n */\nfunction getStats() {\n  return {\n    framework: {\n      name: 'PromptX ToolSandbox Framework',\n      version: '2.0.0',\n      executor: 'ToolSandbox',\n      features: [\n        '自动依赖管理',\n        '沙箱隔离执行',\n        '三阶段执行流程',\n        'pnpm集成',\n        '@tool://协议支持'\n      ]\n    }\n  };\n}\n\nmodule.exports = {\n  // 核心类\n  ToolSandbox,\n  ToolValidator,\n  ToolUtils,\n  \n  // 接口规范\n  TOOL_INTERFACE,\n  TOOL_ERROR_CODES,\n  TOOL_RESULT_FORMAT,\n  EXAMPLE_TOOL,\n  \n  // 全局实例获取器\n  getGlobalToolSandbox,\n  \n  // 便捷方法\n  initialize,\n  executeTool,\n  reset,\n  getStats\n};","const fs = require('fs-extra')\nconst path = require('path')\n\n/**\n * 锦囊状态机管理器\n * 负责管理锦囊之间的状态转换\n */\nclass PouchStateMachine {\n  constructor () {\n    this.currentState = 'initial'\n    this.stateHistory = []\n    this.context = {\n      currentPouch: '',\n      history: [],\n      userProfile: {},\n      sessionData: {},\n      domainContext: {}\n    }\n    this.commands = new Map()\n  }\n\n  /**\n   * 注册锦囊命令\n   * @param {string} name - 命令名称\n   * @param {BasePouchCommand} command - 命令实例\n   */\n  registerCommand (name, command) {\n    this.commands.set(name, command)\n  }\n\n  /**\n   * 执行状态转换\n   * @param {string} commandName - 命令名称\n   * @param {Array} args - 命令参数\n   * @returns {Promise<PouchOutput>} 执行结果\n   */\n  async transition (commandName, args = []) {\n    // 获取命令对应的锦囊\n    const command = this.commands.get(commandName)\n    if (!command) {\n      throw new Error(`未找到命令: ${commandName}`)\n    }\n\n    // 记录历史\n    this.stateHistory.push({\n      from: this.currentState,\n      command: commandName,\n      timestamp: new Date().toISOString(),\n      args\n    })\n\n    // 更新上下文\n    this.context.currentPouch = commandName\n    this.context.history = this.stateHistory.map(h => h.command || h.to)\n\n    // 设置命令上下文\n    command.setContext(this.context)\n\n    // 执行命令\n    const result = await command.execute(args)\n\n    // 根据PATEOAS导航更新状态\n    if (result && result.pateoas && result.pateoas.currentState) {\n      this.currentState = result.pateoas.currentState\n    }\n\n    // 保存状态\n    await this.saveState()\n\n    return result\n  }\n\n  /**\n   * 获取当前状态\n   * @returns {string} 当前状态\n   */\n  getCurrentState () {\n    return this.currentState\n  }\n\n  /**\n   * 获取可用的状态转换\n   * @returns {string[]} 可转换的状态列表\n   */\n  getAvailableTransitions () {\n    const transitions = {\n      initial: ['init', 'welcome'],\n      initialized: ['welcome', 'action', 'learn'],\n      discovering: ['action', 'learn', 'init'],\n      activated: ['learn', 'recall', 'welcome'],\n      learned: ['action', 'recall', 'welcome'],\n      recalled: ['action', 'learn', 'remember']\n    }\n\n    // 根据当前状态的前缀匹配\n    for (const [statePrefix, availableStates] of Object.entries(transitions)) {\n      if (this.currentState.startsWith(statePrefix)) {\n        return availableStates\n      }\n    }\n\n    // 默认可转换状态\n    return ['welcome', 'init']\n  }\n\n  /**\n   * 保存状态到文件\n   */\n  async saveState () {\n    try {\n      // ✅ 修复：检查项目是否已初始化，未初始化时跳过文件保存\n      const ProjectManager = require('~/utils/ProjectManager')\n      if (!ProjectManager.isInitialized()) {\n        // 项目未初始化，只保存在内存中，不持久化到文件\n        return\n      }\n\n      // 🎯 使用@project协议获取.promptx目录（支持HTTP模式）\n      const { getGlobalResourceManager } = require('../../resource')\n      const resourceManager = getGlobalResourceManager()\n      \n      // 确保ResourceManager已初始化\n      if (!resourceManager.initialized) {\n        await resourceManager.initializeWithNewArchitecture()\n      }\n      \n      const projectProtocol = resourceManager.protocols.get('project')\n      const promptxDir = await projectProtocol.resolvePath('.promptx')\n      const configPath = path.join(promptxDir, 'pouch.json')\n\n      // 确保 .promptx 目录存在\n      await fs.ensureDir(promptxDir)\n\n      let config = {}\n      if (await fs.pathExists(configPath)) {\n        config = await fs.readJson(configPath)\n      }\n\n      config.currentState = this.currentState\n      config.stateHistory = this.stateHistory.slice(-50) // 只保留最近50条记录\n      config.lastUpdated = new Date().toISOString()\n\n      await fs.writeJson(configPath, config, { spaces: 2 })\n    } catch (error) {\n      console.error('保存状态失败:', error)\n    }\n  }\n\n  /**\n   * 从文件加载状态\n   */\n  async loadState () {\n    try {\n      // ✅ 修复：检查项目是否已初始化，未初始化时跳过文件加载\n      const ProjectManager = require('~/utils/ProjectManager')\n      if (!ProjectManager.isInitialized()) {\n        // 项目未初始化，使用默认内存状态\n        return\n      }\n\n      // 🎯 使用@project协议获取.promptx目录（支持HTTP模式）\n      const { getGlobalResourceManager } = require('../../resource')\n      const resourceManager = getGlobalResourceManager()\n      \n      // 确保ResourceManager已初始化\n      if (!resourceManager.initialized) {\n        await resourceManager.initializeWithNewArchitecture()\n      }\n      \n      const projectProtocol = resourceManager.protocols.get('project')\n      const promptxDir = await projectProtocol.resolvePath('.promptx')\n      const configPath = path.join(promptxDir, 'pouch.json')\n\n      if (await fs.pathExists(configPath)) {\n        const config = await fs.readJson(configPath)\n\n        if (config.currentState) {\n          this.currentState = config.currentState\n        }\n\n        if (config.stateHistory) {\n          this.stateHistory = config.stateHistory\n        }\n      }\n    } catch (error) {\n      console.error('加载状态失败:', error)\n    }\n  }\n\n  /**\n   * 重置状态机\n   */\n  reset () {\n    this.currentState = 'initial'\n    this.stateHistory = []\n    this.context = {\n      currentPouch: '',\n      history: [],\n      userProfile: {},\n      sessionData: {},\n      domainContext: {}\n    }\n  }\n}\n\nmodule.exports = PouchStateMachine\n","/**\n * 锦囊命令注册器\n * 负责管理和注册所有锦囊命令\n */\nclass PouchRegistry {\n  constructor () {\n    this.commands = new Map()\n  }\n\n  /**\n   * 注册锦囊命令\n   * @param {string} name - 命令名称\n   * @param {BasePouchCommand} command - 命令实例\n   */\n  register (name, command) {\n    if (!name || typeof name !== 'string') {\n      throw new Error('命令名称必须是非空字符串')\n    }\n\n    if (!command || typeof command.execute !== 'function') {\n      throw new Error('命令必须实现 execute 方法')\n    }\n\n    this.commands.set(name.toLowerCase(), command)\n  }\n\n  /**\n   * 获取锦囊命令\n   * @param {string} name - 命令名称\n   * @returns {BasePouchCommand} 命令实例\n   */\n  get (name) {\n    return this.commands.get(name.toLowerCase())\n  }\n\n  /**\n   * 列出所有已注册的命令\n   * @returns {string[]} 命令名称列表\n   */\n  list () {\n    return Array.from(this.commands.keys())\n  }\n\n  /**\n   * 验证命令是否存在\n   * @param {string} name - 命令名称\n   * @returns {boolean} 是否存在\n   */\n  validate (name) {\n    return this.commands.has(name.toLowerCase())\n  }\n\n  /**\n   * 获取命令详情\n   * @returns {Object[]} 命令详情列表\n   */\n  getCommandDetails () {\n    const details = []\n\n    for (const [name, command] of this.commands) {\n      details.push({\n        name,\n        purpose: command.getPurpose ? command.getPurpose() : '未定义',\n        className: command.constructor.name\n      })\n    }\n\n    return details\n  }\n\n  /**\n   * 清空注册器\n   */\n  clear () {\n    this.commands.clear()\n  }\n\n  /**\n   * 批量注册命令\n   * @param {Object} commandMap - 命令映射对象\n   */\n  registerBatch (commandMap) {\n    for (const [name, CommandClass] of Object.entries(commandMap)) {\n      if (typeof CommandClass === 'function') {\n        this.register(name.toLowerCase(), new CommandClass())\n      }\n    }\n  }\n}\n\nmodule.exports = PouchRegistry\n","/**\n * BaseArea - Area架构的抽象基类\n * \n * 设计原则：\n * 1. 单一职责：每个Area只负责渲染自己的内容块\n * 2. 开闭原则：通过继承扩展新Area类型，不修改基类\n * 3. 依赖倒置：Command依赖Area抽象，不依赖具体实现\n * \n * 不变式：\n * - validate() = true ⟹ render() 不抛异常\n * - 每个Area有唯一的name标识\n * - render()返回的内容是自包含的\n */\nclass BaseArea {\n  /**\n   * @param {string} name - Area的唯一标识名\n   * @param {Object} options - 配置选项\n   */\n  constructor(name, options = {}) {\n    if (!name) {\n      throw new Error('Area name is required')\n    }\n    \n    this.name = name\n    this.options = options\n    this.separator = '-'.repeat(50)\n  }\n\n  /**\n   * 获取Area名称\n   * @returns {string}\n   */\n  getName() {\n    return this.name\n  }\n\n  /**\n   * 验证Area是否可以渲染\n   * @returns {boolean}\n   */\n  validate() {\n    return true\n  }\n\n  /**\n   * 渲染Area内容\n   * 子类必须实现此方法\n   * @returns {Promise<string>}\n   */\n  async render() {\n    throw new Error(`Area '${this.name}' must implement render() method`)\n  }\n\n  /**\n   * 格式化Area输出\n   * @param {string} content - Area内容\n   * @param {boolean} withHeader - 是否包含header\n   * @returns {string}\n   */\n  format(content, withHeader = true) {\n    if (!content) return ''\n    \n    if (withHeader) {\n      return `${this.separator}\n[${this.name.toUpperCase()}]\n${content}\n`\n    }\n    \n    return content\n  }\n\n  /**\n   * 获取Area元信息\n   * @returns {Object}\n   */\n  getMetadata() {\n    return {\n      name: this.name,\n      type: this.constructor.name,\n      options: this.options\n    }\n  }\n}\n\nmodule.exports = BaseArea","const BaseArea = require('../BaseArea')\n\n/**\n * LegacyArea - 兼容旧命令的Area\n * 用于包装旧的getPurpose/getContent输出\n */\nclass LegacyArea extends BaseArea {\n  constructor(purpose, content, pateoas) {\n    super('LEGACY')\n    this.purpose = purpose\n    this.content = content\n    this.pateoas = pateoas\n  }\n\n  async render() {\n    // 直接返回内容，不再包装\"锦囊\"概念\n    let output = this.content\n    \n    if (this.pateoas && this.pateoas.currentState) {\n      output += `\\n\\n📍 当前状态：${this.pateoas.currentState}`\n    }\n    \n    return output\n  }\n\n  format(content) {\n    // LegacyArea不需要额外格式化，直接返回内容\n    return content + '\\n'\n  }\n}\n\nmodule.exports = LegacyArea","const BaseArea = require('../areas/BaseArea')\n\n/**\n * BaseLayer - Layer架构的抽象基类\n * \n * 架构设计：\n * - 三层架构：ConsciousnessLayer → CognitionLayer → RoleLayer\n * - 每个Layer可包含多个Area\n * - Layer负责组织和协调其内部Areas的渲染\n * \n * 设计原则：\n * 1. 层次化：Layer是Area的容器，提供更高层次的组织\n * 2. 单一职责：每个Layer负责特定的认知层面\n * 3. 组合模式：Layer组合多个Area形成功能单元\n * \n * 不变式：\n * - 每个Layer有唯一的name和priority\n * - priority决定渲染顺序（数字越小优先级越高）\n * - Layer内的Areas按注册顺序渲染\n */\nclass BaseLayer {\n  /**\n   * @param {string} name - Layer的唯一标识名\n   * @param {number} priority - 渲染优先级（越小越优先）\n   * @param {Object} options - 配置选项\n   */\n  constructor(name, priority = 100, options = {}) {\n    if (!name) {\n      throw new Error('Layer name is required')\n    }\n    \n    this.name = name\n    this.priority = priority\n    this.options = options\n    this.areas = []\n    this.enabled = true\n  }\n\n  /**\n   * 获取Layer名称\n   * @returns {string}\n   */\n  getName() {\n    return this.name\n  }\n\n  /**\n   * 获取渲染优先级\n   * @returns {number}\n   */\n  getPriority() {\n    return this.priority\n  }\n\n  /**\n   * 启用/禁用Layer\n   * @param {boolean} enabled\n   */\n  setEnabled(enabled) {\n    this.enabled = enabled\n  }\n\n  /**\n   * 检查Layer是否启用\n   * @returns {boolean}\n   */\n  isEnabled() {\n    return this.enabled\n  }\n\n  /**\n   * 注册一个Area到该Layer\n   * @param {BaseArea} area - Area实例\n   */\n  registerArea(area) {\n    if (!(area instanceof BaseArea)) {\n      throw new Error('Area must extend BaseArea')\n    }\n    \n    // 检查名称唯一性\n    if (this.areas.some(a => a.getName() === area.getName())) {\n      throw new Error(`Area with name '${area.getName()}' already registered in layer '${this.name}'`)\n    }\n    \n    this.areas.push(area)\n  }\n\n  /**\n   * 清空所有Areas\n   */\n  clearAreas() {\n    this.areas = []\n  }\n\n  /**\n   * 获取所有Areas\n   * @returns {Array<BaseArea>}\n   */\n  getAreas() {\n    return this.areas\n  }\n\n  /**\n   * 组装Areas（子类可重写）\n   * 在渲染前调用，用于动态组装Areas\n   * @param {Object} context - 渲染上下文\n   * @returns {Promise<void>}\n   */\n  async assembleAreas(context) {\n    // 子类实现具体的Area组装逻辑\n  }\n\n  /**\n   * 验证Layer是否可以渲染\n   * @returns {boolean}\n   */\n  validate() {\n    if (!this.enabled) {\n      return false\n    }\n    \n    // 验证所有Areas\n    return this.areas.every(area => area.validate())\n  }\n\n  /**\n   * 渲染前的准备工作\n   * @param {Object} context - 渲染上下文\n   * @returns {Promise<void>}\n   */\n  async beforeRender(context) {\n    // 子类可重写，用于渲染前的准备\n  }\n\n  /**\n   * 渲染后的清理工作\n   * @param {Object} context - 渲染上下文\n   * @returns {Promise<void>}\n   */\n  async afterRender(context) {\n    // 子类可重写，用于渲染后的清理\n  }\n\n  /**\n   * 渲染Layer\n   * @param {Object} context - 渲染上下文\n   * @returns {Promise<string>}\n   */\n  async render(context = {}) {\n    if (!this.enabled) {\n      return ''\n    }\n    \n    // 渲染前准备\n    await this.beforeRender(context)\n    \n    // 组装Areas\n    await this.assembleAreas(context)\n    \n    // 验证\n    if (!this.validate()) {\n      return ''\n    }\n    \n    // 渲染所有Areas\n    const contents = []\n    \n    for (const area of this.areas) {\n      const content = await area.render()\n      if (content) {\n        // Layer可以选择是否使用Area的格式化\n        const formatted = this.formatAreaContent(area, content)\n        if (formatted) {\n          contents.push(formatted)\n        }\n      }\n    }\n    \n    // 组合Layer内容\n    const layerContent = this.combineAreaContents(contents)\n    \n    // 渲染后清理\n    await this.afterRender(context)\n    \n    return layerContent\n  }\n\n  /**\n   * 格式化单个Area的内容\n   * 子类可重写以自定义格式化方式\n   * @param {BaseArea} area - Area实例\n   * @param {string} content - Area内容\n   * @returns {string}\n   */\n  formatAreaContent(area, content) {\n    // 默认使用Area自己的格式化\n    return area.format(content)\n  }\n\n  /**\n   * 组合所有Area的内容\n   * 子类可重写以自定义组合方式\n   * @param {Array<string>} contents - 所有Area的内容\n   * @returns {string}\n   */\n  combineAreaContents(contents) {\n    return contents.join('')\n  }\n\n  /**\n   * 获取Layer元信息\n   * @returns {Object}\n   */\n  getMetadata() {\n    return {\n      name: this.name,\n      type: this.constructor.name,\n      priority: this.priority,\n      enabled: this.enabled,\n      areaCount: this.areas.length,\n      areas: this.areas.map(a => a.getMetadata())\n    }\n  }\n}\n\nmodule.exports = BaseLayer","const BaseArea = require('./areas/BaseArea')\nconst LegacyArea = require('./areas/common/LegacyArea')\nconst BaseLayer = require('./layers/BaseLayer')\nconst logger = require('@promptx/logger')\n\n/**\n * BasePouchCommand - 支持Layer和Area双架构的命令基类\n * \n * 架构设计：\n * - 支持新的Layer架构：Command → Layers → Areas\n * - 兼容旧的Area架构：Command → Areas\n * - 统一的渲染管道处理所有内容\n * \n * 渲染流程：\n * 1. 如果有Layers，按优先级渲染Layers\n * 2. 如果没有Layers但有Areas，直接渲染Areas（兼容模式）\n * 3. Layers内部管理自己的Areas\n */\nclass BasePouchCommand {\n  constructor() {\n    this.context = {\n      currentPouch: '',\n      history: [],\n      userProfile: {},\n      sessionData: {},\n      domainContext: {}\n    }\n    this.outputFormat = 'human'\n    this.areas = []\n    this.layers = []\n    this.useLayerSystem = false // 标记是否使用Layer系统\n  }\n\n  /**\n   * 注册一个Area\n   * @param {BaseArea} area - Area实例\n   */\n  registerArea(area) {\n    if (!(area instanceof BaseArea)) {\n      throw new Error('Area must extend BaseArea')\n    }\n    \n    // 检查名称唯一性\n    if (this.areas.some(a => a.getName() === area.getName())) {\n      throw new Error(`Area with name '${area.getName()}' already registered`)\n    }\n    \n    this.areas.push(area)\n  }\n\n  /**\n   * 清空所有Areas\n   */\n  clearAreas() {\n    this.areas = []\n  }\n\n  /**\n   * 注册一个Layer\n   * @param {BaseLayer} layer - Layer实例\n   */\n  registerLayer(layer) {\n    if (!(layer instanceof BaseLayer)) {\n      throw new Error('Layer must extend BaseLayer')\n    }\n    \n    // 检查名称唯一性\n    if (this.layers.some(l => l.getName() === layer.getName())) {\n      throw new Error(`Layer with name '${layer.getName()}' already registered`)\n    }\n    \n    this.layers.push(layer)\n    this.useLayerSystem = true // 标记使用Layer系统\n    \n    logger.debug(`[BasePouchCommand] Registered layer: ${layer.getName()}`)\n  }\n\n  /**\n   * 清空所有Layers\n   */\n  clearLayers() {\n    this.layers = []\n    this.useLayerSystem = false\n  }\n\n  /**\n   * 组装Areas（子类可重写）\n   * @param {Array} args - 命令参数\n   * @returns {Promise<void>}\n   */\n  async assembleAreas(args) {\n    // 检查是否有旧的getPurpose/getContent方法\n    if (typeof this.getPurpose === 'function' && typeof this.getContent === 'function') {\n      // 兼容模式：使用LegacyArea包装旧命令\n      const purpose = this.getPurpose()\n      const content = await this.getContent(args)\n      const pateoas = typeof this.getPATEOAS === 'function' ? this.getPATEOAS(args) : null\n      \n      const legacyArea = new LegacyArea(purpose, content, pateoas)\n      this.registerArea(legacyArea)\n    } else {\n      // 新架构的命令必须自己实现assembleAreas\n      throw new Error('Subclass must implement assembleAreas() or provide getPurpose()/getContent()')\n    }\n  }\n\n  /**\n   * 组装Layers（子类可重写）\n   * @param {Array} args - 命令参数\n   * @returns {Promise<void>}\n   */\n  async assembleLayers(args) {\n    // 子类实现具体的Layer组装逻辑\n    // 默认不做任何操作\n  }\n\n  /**\n   * 验证所有Areas\n   * @returns {boolean}\n   */\n  validateAreas() {\n    return this.areas.every(area => area.validate())\n  }\n\n  /**\n   * 验证所有Layers\n   * @returns {boolean}\n   */\n  validateLayers() {\n    return this.layers.every(layer => layer.validate())\n  }\n\n  /**\n   * 渲染所有Areas\n   * @returns {Promise<string>}\n   */\n  async renderAreas() {\n    const contents = []\n    \n    for (const area of this.areas) {\n      const content = await area.render()\n      if (content) {\n        contents.push(area.format(content))\n      }\n    }\n    \n    return contents.join('')\n  }\n\n  /**\n   * 渲染所有Layers\n   * @returns {Promise<string>}\n   */\n  async renderLayers() {\n    // 按优先级排序Layers（数字越小优先级越高）\n    const sortedLayers = [...this.layers].sort((a, b) => a.getPriority() - b.getPriority())\n    \n    const contents = []\n    const layerSeparator = '='.repeat(75)\n    \n    for (let i = 0; i < sortedLayers.length; i++) {\n      const layer = sortedLayers[i]\n      if (layer.isEnabled()) {\n        const content = await layer.render(this.context)\n        if (content) {\n          contents.push(content)\n          // 在非空Layer之间添加分隔符\n          if (i < sortedLayers.length - 1) {\n            // 检查是否还有后续的非空Layer\n            const hasMoreContent = sortedLayers.slice(i + 1).some(l => l.isEnabled())\n            if (hasMoreContent) {\n              contents.push('\\n' + layerSeparator + '\\n')\n            }\n          }\n        }\n      }\n    }\n    \n    return contents.join('')\n  }\n\n  /**\n   * 执行命令\n   * @param {Array} args - 命令参数\n   * @returns {Promise<Object|string>}\n   */\n  async execute(args = []) {\n    // 清空之前的内容\n    this.clearAreas()\n    this.clearLayers()\n    \n    // 尝试组装Layers（新架构）\n    await this.assembleLayers(args)\n    \n    // 如果没有Layers，尝试组装Areas（兼容模式）\n    if (!this.useLayerSystem) {\n      await this.assembleAreas(args)\n    }\n    \n    let content = ''\n    \n    // 使用Layer系统渲染\n    if (this.useLayerSystem) {\n      logger.debug('[BasePouchCommand] Using Layer system for rendering')\n      \n      // 验证Layers\n      if (!this.validateLayers()) {\n        throw new Error('Layer validation failed')\n      }\n      \n      // 渲染Layers\n      content = await this.renderLayers()\n    } \n    // 使用传统Area系统渲染\n    else {\n      logger.debug('[BasePouchCommand] Using Area system for rendering')\n      \n      // 验证Areas\n      if (!this.validateAreas()) {\n        throw new Error('Area validation failed')\n      }\n      \n      // 渲染Areas\n      content = await this.renderAreas()\n    }\n    \n    // 格式化输出\n    return this.formatOutput(content)\n  }\n\n  /**\n   * 格式化最终输出\n   * @param {string} content - 渲染的内容\n   * @returns {Object|string}\n   */\n  formatOutput(content) {\n    if (this.outputFormat === 'json') {\n      return {\n        content,\n        areas: this.areas.map(a => a.getMetadata()),\n        context: this.context,\n        format: this.outputFormat\n      }\n    }\n    \n    // 人类可读格式\n    const output = {\n      content,\n      context: this.context,\n      format: this.outputFormat\n    }\n    \n    return {\n      ...output,\n      toString() {\n        return content\n      }\n    }\n  }\n\n  /**\n   * 设置状态上下文\n   * @param {Object} context - 状态上下文\n   */\n  setContext(context) {\n    this.context = { ...this.context, ...context }\n  }\n\n  /**\n   * 设置输出格式\n   * @param {'human'|'json'} format - 输出格式\n   */\n  setOutputFormat(format) {\n    this.outputFormat = format\n  }\n}\n\nmodule.exports = BasePouchCommand","const BaseArea = require('../BaseArea')\nconst path = require('path')\nconst fs = require('fs-extra')\nconst logger = require('@promptx/logger')\n\n/**\n * InitArea - 初始化信息展示区域\n */\nclass InitArea extends BaseArea {\n  constructor(initInfo) {\n    super('INIT_AREA')\n    this.initInfo = initInfo\n  }\n\n  async render() {\n    const { \n      version, \n      projectConfig, \n      registryStats, \n      configFileName,\n      isProjectMode \n    } = this.initInfo\n\n    if (!isProjectMode) {\n      return `📁 PromptX 项目配置工具\n\n当前状态：**全局模式**（未绑定特定项目）\n\n✅ **所有功能均可正常使用**，包括：\n- 角色激活 (action)\n- 资源学习 (learn)  \n- 记忆管理 (recall/remember)\n- 工具执行 (tool)\n\n💡 **仅在以下情况需要项目配置**：\n- 需要多项目隔离\n- 需要项目级配置\n- 需要项目特定资源\n\n如需绑定项目，请提供 workingDirectory 参数。`\n    }\n\n    return `🎯 PromptX 初始化完成！\n\n## 📦 版本信息\n✅ **PromptX v${version}** - AI专业能力增强框架\n\n## 🏗️ 多项目环境准备\n✅ 创建了 \\`.promptx\\` 配置目录\n✅ 项目已注册到MCP实例: **${projectConfig.mcpId}** (${projectConfig.ideType})\n✅ 项目路径: ${projectConfig.projectPath}\n✅ 配置文件: ${configFileName}\n\n## 📋 项目资源注册表\n${registryStats.message}\n\n💡 **多项目支持**: 现在支持同时在多个项目中使用PromptX，项目间完全隔离！\n💡 **提示**: ${registryStats.totalResources > 0 ? '项目资源已优化为注册表模式，性能大幅提升！' : '现在可以开始创建项目级资源了！'}`\n  }\n}\n\nmodule.exports = InitArea","const BaseArea = require('../BaseArea')\n\n/**\n * StateArea - 状态区域\n * 负责渲染当前状态和导航信息\n */\nclass StateArea extends BaseArea {\n  constructor(currentState, availableActions = []) {\n    super('STATE_AREA')\n    this.currentState = currentState || ''\n    this.availableActions = availableActions || []\n  }\n\n  /**\n   * 渲染状态区域内容\n   */\n  async render() {\n    let content = ''\n    \n    // 当前状态\n    content += `📍 **当前状态**：${this.currentState}\\n`\n    \n    // 可用行动\n    if (this.availableActions.length > 0) {\n      content += '\\n🚀 **可用行动**：\\n'\n      this.availableActions.forEach((action, index) => {\n        content += `${index + 1}. ${action}\\n`\n      })\n    }\n    \n    return content\n  }\n\n  /**\n   * 设置当前状态\n   */\n  setCurrentState(state) {\n    this.currentState = state\n  }\n\n  /**\n   * 添加可用行动\n   */\n  addAction(action) {\n    this.availableActions.push(action)\n  }\n\n  /**\n   * 清空可用行动\n   */\n  clearActions() {\n    this.availableActions = []\n  }\n}\n\nmodule.exports = StateArea","const BasePouchCommand = require('../BasePouchCommand')\nconst InitArea = require('../areas/init/InitArea')\nconst StateArea = require('../areas/common/StateArea')\nconst { getGlobalResourceManager } = require('../../resource')\nconst { COMMANDS, PACKAGE_NAMES } = require('~/constants')\nconst RegistryData = require('../../resource/RegistryData')\nconst ProjectDiscovery = require('../../resource/discovery/ProjectDiscovery')\nconst ProjectManager = require('~/utils/ProjectManager')\nconst { getGlobalProjectManager } = require('~/utils/ProjectManager')\nconst logger = require('@promptx/logger')\nconst path = require('path')\nconst fs = require('fs-extra')\n\n/**\n * 初始化命令\n * 负责准备工作环境和传达系统协议\n * 使用Area架构组装输出\n */\nclass InitCommand extends BasePouchCommand {\n  constructor () {\n    super()\n    // 延迟初始化：这些组件可能依赖项目状态，在 getContent 中按需初始化\n    this.resourceManager = null\n    this.projectDiscovery = null\n    this.projectManager = null\n  }\n\n  /**\n   * 组装Areas\n   */\n  async assembleAreas(args) {\n    // 获取参数，支持两种格式：\n    // 1. 来自MCP的对象格式：{ workingDirectory: \"path\", ideType: \"cursor\" }\n    // 2. 来自CLI的字符串格式：[\"path\"]\n    let workingDirectory, userIdeType\n    \n    if (args && typeof args[0] === 'object') {\n      // MCP格式\n      workingDirectory = args[0].workingDirectory\n      userIdeType = args[0].ideType\n    } else if (args && typeof args[0] === 'string') {\n      // CLI格式\n      workingDirectory = args[0]\n      // CLI格式暂不支持IDE类型参数，使用自动检测\n    }\n    \n    if (!workingDirectory) {\n      // 没有提供项目路径时，全局模式\n      const initArea = new InitArea({ isProjectMode: false })\n      this.registerArea(initArea)\n      \n      const stateArea = new StateArea('global_mode')\n      this.registerArea(stateArea)\n      return\n    }\n    \n    // 解码中文路径并解析\n    const decodedWorkingDirectory = decodeURIComponent(workingDirectory)\n    const projectPath = path.resolve(decodedWorkingDirectory)\n    \n    // 🎯 第一优先级：立即设置项目状态，确保后续所有操作都有正确的项目上下文\n    // 在任何依赖项目状态的操作之前，必须先设置当前项目状态\n    const detectedIdeType = this.detectIdeType()\n    let ideType = userIdeType || detectedIdeType || 'unknown'\n    \n    // 规范化IDE类型（移除特殊字符，转小写）\n    if (userIdeType) {\n      ideType = userIdeType.replace(/[^a-zA-Z0-9-]/g, '').toLowerCase() || 'unknown'\n    }\n    \n    // 基础路径验证（使用简单的 fs 检查，避免依赖 ProjectManager 实例方法）\n    if (!await this.validateProjectPathDirectly(projectPath)) {\n      return `❌ 提供的工作目录无效: ${projectPath}\n      \n请确保：\n1. 路径存在且为目录\n2. 不是用户主目录\n3. 具有适当的访问权限\n\n💡 请提供一个有效的项目目录路径。`\n    }\n    \n    // 使用统一项目注册方法（从ServerEnvironment获取服务信息）\n    // 这将设置 ProjectManager.currentProject 状态，确保后续操作有正确的项目上下文\n    const projectConfig = await ProjectManager.registerCurrentProject(projectPath, ideType)\n    \n    logger.debug(`[InitCommand] 🎯 项目状态已设置: ${projectConfig.projectPath} -> ${projectConfig.mcpId} (${ideType}) [${projectConfig.transport}]`)\n    logger.debug(`[InitCommand] IDE类型: ${userIdeType ? `用户指定(${ideType})` : `自动检测(${detectedIdeType})`}`)\n\n    // 现在项目状态已设置，可以安全初始化依赖组件\n    this.resourceManager = getGlobalResourceManager()\n    this.projectDiscovery = new ProjectDiscovery()\n    this.projectManager = getGlobalProjectManager()\n\n    // 1. 获取版本信息\n    const version = await this.getVersionInfo()\n\n    // 2. 基础环境准备 - 现在可以安全使用项目路径\n    await this.ensurePromptXDirectory(projectPath)\n\n    // 3. 项目级注册表现在由 WelcomeCommand 在需要时生成\n    const registryStats = { \n      message: `✅ 项目资源目录已准备就绪\n   📂 目录: .promptx/resource\n   💾 注册表将在首次查看资源时自动生成`,\n      totalResources: 0 \n    }\n\n    // 4. ResourceManager 的刷新现在由 WelcomeCommand 负责\n    // init 只负责项目环境初始化，不负责资源发现\n\n    // 生成配置文件名\n    const configFileName = this.projectManager.generateConfigFileName(projectConfig.mcpId, ideType, projectConfig.transport, projectPath)\n\n    // 组装Areas\n    const initInfo = {\n      version,\n      projectConfig,\n      registryStats,\n      configFileName,\n      ideType,\n      isProjectMode: true\n    }\n    \n    const initArea = new InitArea(initInfo)\n    this.registerArea(initArea)\n    \n    const stateArea = new StateArea('initialized')\n    this.registerArea(stateArea)\n  }\n\n  /**\n   * 生成项目级资源注册表\n   * @param {string} projectPath - AI提供的项目路径（仅用于显示，实际路径通过@project协议解析）\n   * @returns {Promise<Object>} 注册表生成统计信息\n   */\n  async generateProjectRegistry(projectPath) {\n    try {\n      // 🎯 使用@project协议进行路径解析，支持HTTP/本地模式\n      const projectProtocol = this.resourceManager.protocols.get('project')\n      const resourceDir = await projectProtocol.resolvePath('.promptx/resource')\n      const registryPath = path.join(resourceDir, 'project.registry.json')\n      \n      // 2. 确保资源目录存在（已通过@project协议映射）\n      await fs.ensureDir(resourceDir)\n      logger.debug(`[InitCommand] 确保资源目录存在: ${resourceDir}`)\n\n      // 3. 使用 ProjectDiscovery 的正确方法生成注册表（已内置@project协议支持）\n      logger.info('正在扫描项目资源...')\n      const registryData = await this.projectDiscovery.generateRegistry()\n      \n      // 4. 生成统计信息\n      const stats = registryData.getStats()\n\n      if (registryData.size === 0) {\n        return {\n          message: `✅ 项目资源目录已创建，注册表已初始化\n   📂 目录: .promptx/resource\n   💾 注册表: .promptx/resource/project.registry.json\n   💡 现在可以在 domain 目录下创建角色资源了`,\n          totalResources: 0\n        }\n      }\n\n      return {\n        message: `✅ 项目资源注册表已重新生成\n   📊 总计: ${registryData.size} 个资源\n   📋 分类: role(${stats.byProtocol.role || 0}), thought(${stats.byProtocol.thought || 0}), execution(${stats.byProtocol.execution || 0}), knowledge(${stats.byProtocol.knowledge || 0})\n   💾 位置: .promptx/resource/project.registry.json`,\n        totalResources: registryData.size\n      }\n      \n    } catch (error) {\n      logger.error('生成项目注册表时出错:', error)\n      return {\n        message: `❌ 生成项目注册表失败: ${error.message}`,\n        totalResources: 0\n      }\n    }\n  }\n\n  /**\n   * 确保 .promptx 基础目录存在\n   * 使用@project协议进行路径解析，支持HTTP/本地模式\n   */\n  async ensurePromptXDirectory (projectPath) {\n    // 🎯 使用@project协议解析路径，支持HTTP模式的路径映射\n    const projectProtocol = this.resourceManager.protocols.get('project')\n    const promptxDir = await projectProtocol.resolvePath('.promptx')\n    await fs.ensureDir(promptxDir)\n    logger.debug(`[InitCommand] 确保.promptx目录存在: ${promptxDir}`)\n  }\n\n  /**\n   * 刷新全局 ResourceManager\n   * 确保新创建的资源立即可用，无需重启 MCP Server\n   */\n  async refreshGlobalResourceManager() {\n    try {\n      logger.debug('[InitCommand] 刷新全局 ResourceManager...')\n      \n      // 重新初始化 ResourceManager，清除缓存并重新发现资源\n      await this.resourceManager.initializeWithNewArchitecture()\n      \n      logger.debug('[InitCommand] 全局 ResourceManager 刷新完成')\n    } catch (error) {\n      logger.warn(`[InitCommand] 刷新 ResourceManager 失败: ${error.message}`)\n      // 不抛出错误，避免影响 init 命令的主要功能\n    }\n  }\n\n  /**\n   * 获取版本信息\n   */\n  async getVersionInfo () {\n    try {\n      const packageJsonPath = path.resolve(__dirname, '../../../../../package.json')\n      if (await fs.pathExists(packageJsonPath)) {\n        const packageJson = await fs.readJSON(packageJsonPath)\n        const baseVersion = packageJson.version || '未知版本'\n        const nodeVersion = process.version\n        const packageName = packageJson.name || PACKAGE_NAMES.LEGACY\n        \n        return `${baseVersion} (${packageName}@${baseVersion}, Node.js ${nodeVersion})`\n      }\n    } catch (error) {\n      logger.warn('无法读取版本信息:', error.message)\n    }\n    return '未知版本'\n  }\n\n  /**\n   * 直接验证项目路径（避免依赖 ProjectManager 实例）\n   * @param {string} projectPath - 要验证的路径\n   * @returns {Promise<boolean>} 是否为有效项目目录\n   */\n  async validateProjectPathDirectly(projectPath) {\n    try {\n      const os = require('os')\n      \n      // 基础检查：路径存在且为目录\n      const stat = await fs.stat(projectPath)\n      if (!stat.isDirectory()) {\n        return false\n      }\n\n      // 简单检查：避免明显错误的路径\n      const resolved = path.resolve(projectPath)\n      const homeDir = os.homedir()\n      \n      // 不允许是用户主目录\n      if (resolved === homeDir) {\n        return false\n      }\n\n      return true\n    } catch (error) {\n      return false\n    }\n  }\n\n  /**\n   * 检测IDE类型\n   * @returns {string} IDE类型\n   */\n  detectIdeType() {\n    // 检测常见的IDE环境变量\n    const ideStrategies = [\n      // Claude IDE\n      { name: 'claude', vars: ['WORKSPACE_FOLDER_PATHS'] },\n      // Cursor\n      { name: 'cursor', vars: ['CURSOR_USER', 'CURSOR_SESSION_ID'] },\n      // VSCode\n      { name: 'vscode', vars: ['VSCODE_WORKSPACE_FOLDER', 'VSCODE_CWD', 'TERM_PROGRAM'] },\n      // JetBrains IDEs  \n      { name: 'jetbrains', vars: ['IDEA_INITIAL_DIRECTORY', 'PYCHARM_HOSTED'] },\n      // Vim/Neovim\n      { name: 'vim', vars: ['VIM', 'NVIM'] }\n    ]\n\n    for (const strategy of ideStrategies) {\n      for (const envVar of strategy.vars) {\n        if (process.env[envVar]) {\n          // 特殊处理VSCode的TERM_PROGRAM\n          if (envVar === 'TERM_PROGRAM' && process.env[envVar] === 'vscode') {\n            return 'vscode'\n          }\n          // 其他环境变量存在即认为是对应IDE\n          if (envVar !== 'TERM_PROGRAM') {\n            return strategy.name\n          }\n        }\n      }\n    }\n\n    // 检测进程名称\n    const processTitle = process.title || ''\n    if (processTitle.includes('cursor')) return 'cursor'\n    if (processTitle.includes('code')) return 'vscode'\n    if (processTitle.includes('claude')) return 'claude'\n\n    // 检测命令行参数\n    const argv = process.argv.join(' ')\n    if (argv.includes('cursor')) return 'cursor'\n    if (argv.includes('code')) return 'vscode'\n    if (argv.includes('claude')) return 'claude'\n\n    return 'unknown'\n  }\n\n}\n\nmodule.exports = InitCommand\n","const BaseArea = require('../BaseArea')\n\n/**\n * WelcomeHeaderArea - 欢迎信息头部区域\n */\nclass WelcomeHeaderArea extends BaseArea {\n  constructor(stats) {\n    super('WELCOME_HEADER_AREA')\n    this.stats = stats\n  }\n\n  async render() {\n    return `🎭 **PromptX 专业服务清单**\n📅 ${new Date().toLocaleString('zh-CN', { timeZone: 'Asia/Shanghai' })}\n\n## 📊 资源统计\n- 🎭 角色总数: ${this.stats.totalRoles}个 (系统${this.stats.systemRoles}个 + 项目${this.stats.projectRoles}个 + 用户${this.stats.userRoles}个)\n- 🔧 工具总数: ${this.stats.totalTools}个 (系统${this.stats.systemTools}个 + 项目${this.stats.projectTools}个 + 用户${this.stats.userTools}个)\n`\n  }\n}\n\nmodule.exports = WelcomeHeaderArea","const BaseArea = require('../BaseArea')\nconst logger = require('@promptx/logger')\n\n/**\n * RoleListArea - 角色列表展示区域\n */\nclass RoleListArea extends BaseArea {\n  constructor(roleCategories) {\n    super('ROLE_LIST_AREA')\n    this.roleCategories = roleCategories\n  }\n\n  async render() {\n    let content = ''\n    \n    // 渲染各个来源的角色\n    for (const [source, roles] of Object.entries(this.roleCategories)) {\n      if (roles.length === 0) continue\n      \n      const sourceIcon = this.getSourceIcon(source)\n      const sourceTitle = this.getSourceTitle(source)\n      \n      content += `\\n${sourceIcon} **${sourceTitle}** (${roles.length}个)\\n`\n      \n      // 按ID排序\n      roles.sort((a, b) => a.id.localeCompare(b.id))\n      \n      roles.forEach(role => {\n        const command = `action(\"${role.id}\")`\n        content += `- \\`${role.id}\\`: ${role.name || role.title || '未命名角色'} → ${command}\\n`\n      })\n    }\n    \n    return content || '暂无可用角色'\n  }\n  \n  getSourceIcon(source) {\n    const icons = {\n      'system': '📦',\n      'project': '🏗️',\n      'user': '👤'\n    }\n    return icons[source] || '📄'\n  }\n  \n  getSourceTitle(source) {\n    const titles = {\n      'system': '系统角色',\n      'project': '项目角色',\n      'user': '用户角色'\n    }\n    return titles[source] || '其他角色'\n  }\n}\n\nmodule.exports = RoleListArea","const BaseArea = require('../BaseArea')\nconst logger = require('@promptx/logger')\n\n/**\n * ToolListArea - 工具列表展示区域\n */\nclass ToolListArea extends BaseArea {\n  constructor(toolCategories) {\n    super('TOOL_LIST_AREA')\n    this.toolCategories = toolCategories\n  }\n\n  async render() {\n    let content = ''\n    \n    // 渲染各个来源的工具\n    for (const [source, tools] of Object.entries(this.toolCategories)) {\n      if (tools.length === 0) continue\n      \n      const sourceIcon = this.getSourceIcon(source)\n      const sourceTitle = this.getSourceTitle(source)\n      \n      content += `\\n${sourceIcon} **${sourceTitle}** (${tools.length}个)\\n`\n      \n      // 按ID排序\n      tools.sort((a, b) => a.id.localeCompare(b.id))\n      \n      tools.forEach(tool => {\n        const manualCommand = `learn(\"@manual://${tool.id}\")`\n        const toolCommand = `toolx(\"@tool://${tool.id}\", parameters)`\n        \n        content += `- \\`${tool.id}\\`: ${tool.name || tool.title || '未命名工具'}\\n`\n        content += `  - 📖 查看使用手册: ${manualCommand}\\n`\n        content += `  - 🔧 执行工具: ${toolCommand}\\n`\n      })\n    }\n    \n    return content || '暂无可用工具'\n  }\n  \n  getSourceIcon(source) {\n    const icons = {\n      'system': '📦',\n      'project': '🏗️',\n      'user': '👤'\n    }\n    return icons[source] || '📄'\n  }\n  \n  getSourceTitle(source) {\n    const titles = {\n      'system': '系统工具',\n      'project': '项目工具',\n      'user': '用户工具'\n    }\n    return titles[source] || '其他工具'\n  }\n}\n\nmodule.exports = ToolListArea","const BasePouchCommand = require('../BasePouchCommand')\nconst WelcomeHeaderArea = require('../areas/welcome/WelcomeHeaderArea')\nconst RoleListArea = require('../areas/welcome/RoleListArea')\nconst ToolListArea = require('../areas/welcome/ToolListArea')\nconst StateArea = require('../areas/common/StateArea')\nconst fs = require('fs-extra')\nconst path = require('path')\nconst os = require('os')\nconst { getGlobalResourceManager } = require('../../resource')\nconst ProjectManager = require('~/utils/ProjectManager')\nconst { getGlobalProjectManager } = require('~/utils/ProjectManager')\nconst { getGlobalServerEnvironment } = require('~/utils/ServerEnvironment')\nconst ProjectDiscovery = require('../../resource/discovery/ProjectDiscovery')\nconst UserDiscovery = require('../../resource/discovery/UserDiscovery')\nconst logger = require('@promptx/logger')\n\n/**\n * 欢迎命令\n * 负责展示可用的AI角色和工具\n * 使用Area架构组装输出\n */\nclass WelcomeCommand extends BasePouchCommand {\n  constructor () {\n    super()\n    // 使用全局单例 ResourceManager\n    this.resourceManager = getGlobalResourceManager()\n    this.projectManager = getGlobalProjectManager()\n  }\n\n  /**\n   * 组装Areas\n   */\n  async assembleAreas(args) {\n    // 首先刷新所有资源\n    await this.refreshAllResources()\n    \n    // 加载角色和工具\n    const roleRegistry = await this.loadRoleRegistry()\n    const toolRegistry = await this.loadToolRegistry()\n    \n    // 按来源分组\n    const roleCategories = this.categorizeBySource(roleRegistry)\n    const toolCategories = this.categorizeBySource(toolRegistry)\n    \n    // 统计信息\n    const stats = this.calculateStats(roleCategories, toolCategories)\n    \n    // 注册Areas\n    const headerArea = new WelcomeHeaderArea(stats)\n    this.registerArea(headerArea)\n    \n    const roleArea = new RoleListArea(roleCategories)\n    this.registerArea(roleArea)\n    \n    const toolArea = new ToolListArea(toolCategories)\n    this.registerArea(toolArea)\n    \n    const stateArea = new StateArea('welcome_completed')\n    this.registerArea(stateArea)\n  }\n  \n  /**\n   * 按来源分组资源\n   */\n  categorizeBySource(registry) {\n    const logger = require('@promptx/logger')\n    const categories = {\n      system: [],\n      project: [],\n      user: []\n    }\n    \n    const items = Object.values(registry)\n    logger.info(`[WelcomeCommand] 开始分类 ${items.length} 个资源`)\n    \n    // 统计各种 source 值\n    const sourceCounts = {}\n    items.forEach(item => {\n      const src = item.source || 'undefined'\n      sourceCounts[src] = (sourceCounts[src] || 0) + 1\n    })\n    logger.info(`[WelcomeCommand] 原始 source 分布: ${JSON.stringify(sourceCounts)}`)\n    \n    items.forEach(item => {\n      const source = this.normalizeSource(item.source)\n      if (categories[source]) {\n        categories[source].push(item)\n      }\n    })\n    \n    logger.info(`[WelcomeCommand] 分类结果: system=${categories.system.length}, project=${categories.project.length}, user=${categories.user.length}`)\n    \n    return categories\n  }\n  \n  /**\n   * 标准化来源\n   */\n  normalizeSource(source) {\n    const logger = require('@promptx/logger')\n    logger.info(`[WelcomeCommand] normalizeSource 输入: \"${source}\" (类型: ${typeof source})`)\n    \n    // 转换为小写进行比较\n    const lowerSource = String(source).toLowerCase()\n    \n    if (lowerSource === 'user') return 'user'\n    if (lowerSource === 'project') return 'project'\n    if (['package', 'merged', 'fallback', 'system'].includes(lowerSource)) {\n      logger.info(`[WelcomeCommand] normalizeSource: \"${source}\" -> \"system\"`)\n      return 'system'\n    }\n    logger.info(`[WelcomeCommand] normalizeSource: \"${source}\" -> \"system\" (默认)`)\n    return 'system'\n  }\n  \n  /**\n   * 计算统计信息\n   */\n  calculateStats(roleCategories, toolCategories) {\n    const systemRoles = roleCategories.system?.length || 0\n    const projectRoles = roleCategories.project?.length || 0\n    const userRoles = roleCategories.user?.length || 0\n    const systemTools = toolCategories.system?.length || 0\n    const projectTools = toolCategories.project?.length || 0\n    const userTools = toolCategories.user?.length || 0\n    \n    return {\n      totalRoles: systemRoles + projectRoles + userRoles,\n      systemRoles,\n      projectRoles,\n      userRoles,\n      totalTools: systemTools + projectTools + userTools,\n      systemTools,\n      projectTools,\n      userTools\n    }\n  }\n\n  /**\n   * 刷新所有资源（注册表文件 + ResourceManager）\n   * 这是 welcome 命令的核心功能，确保能发现所有最新的资源\n   */\n  async refreshAllResources() {\n    try {\n      // 1. 刷新注册表文件\n      await this.refreshAllRegistries()\n      \n      // 🔍 Knuth调试：验证注册表文件更新\n      const fs = require('fs-extra')\n      const userRegistryPath = require('os').homedir() + '/.promptx/resource/user.registry.json'\n      if (await fs.pathExists(userRegistryPath)) {\n        const registry = await fs.readJson(userRegistryPath)\n        const tools = registry.resources?.filter(r => r.protocol === 'tool').map(r => r.id) || []\n        logger.info(`[WelcomeCommand] 📋 用户注册表中的工具: ${tools.join(', ') || '无'}`)\n      }\n      \n      // 2. 刷新 ResourceManager，重新加载所有资源\n      logger.info('[WelcomeCommand] Refreshing ResourceManager to discover new resources...')\n      await this.resourceManager.initializeWithNewArchitecture()\n      \n      // 🔍 Knuth调试：验证ResourceManager加载结果\n      const loadedTools = this.resourceManager.registryData.getResourcesByProtocol('tool')\n      logger.info(`[WelcomeCommand] 📦 ResourceManager加载的工具: ${loadedTools.map(t => t.id).join(', ') || '无'}`)\n      \n    } catch (error) {\n      logger.warn('[WelcomeCommand] 资源刷新失败:', error.message)\n      // 不抛出错误，确保 welcome 命令能继续执行\n    }\n  }\n\n  /**\n   * 刷新所有注册表\n   * 在加载资源前先刷新注册表，确保显示最新的资源\n   */\n  async refreshAllRegistries() {\n    try {\n      logger.info('[WelcomeCommand] 开始刷新所有注册表...')\n      \n      // 1. 刷新项目级注册表（如果在项目环境中）\n      // 项目级注册表是可选的，可能没有初始化项目\n      try {\n        const currentProject = ProjectManager.getCurrentProject()\n        if (currentProject && currentProject.initialized) {\n          logger.info('[WelcomeCommand] 刷新项目级注册表...')\n          const projectDiscovery = new ProjectDiscovery()\n          await projectDiscovery.generateRegistry()\n        }\n      } catch (projectError) {\n        // 项目未初始化是正常情况，不需要报错\n        logger.debug('[WelcomeCommand] 项目未初始化，跳过项目级注册表刷新')\n      }\n      \n      // 2. 刷新用户级注册表（这个是必须的）\n      logger.info('[WelcomeCommand] 刷新用户级注册表...')\n      const userDiscovery = new UserDiscovery()\n      await userDiscovery.generateRegistry()\n      \n      logger.info('[WelcomeCommand] 注册表刷新完成')\n    } catch (error) {\n      logger.warn('[WelcomeCommand] 注册表刷新失败:', error.message)\n      // 不抛出错误，继续使用现有注册表\n    }\n  }\n\n  /**\n   * 加载角色注册表\n   * @returns {Promise<Object>} 角色注册信息（按来源分类）\n   */\n  async loadRoleRegistry () {\n    logger.info('[WelcomeCommand] Loading role registry...')\n    \n    // 资源刷新已经在 assembleAreas 中的 refreshAllResources 完成\n    // 这里直接使用ResourceManager的注册表\n    const roles = this.resourceManager.registryData.getResourcesByProtocol('role')\n    \n    // 严格过滤：只保留 protocol 确实是 'role' 的资源\n    const filteredRoles = roles.filter(role => role.protocol === 'role')\n    \n    // 转换为对象格式以保持兼容性\n    const registry = {}\n    filteredRoles.forEach(role => {\n      registry[role.id] = role\n    })\n    \n    logger.info(`[WelcomeCommand] Found ${Object.keys(registry).length} roles`)\n    return registry\n  }\n  \n  /**\n   * 加载工具注册表\n   * @returns {Promise<Object>} 工具注册信息（按来源分类）\n   */\n  async loadToolRegistry () {\n    // 资源刷新已经在 assembleAreas 中的 refreshAllResources 完成\n    // 这里直接使用ResourceManager的注册表\n    \n    // 从注册表中获取所有工具资源\n    const tools = this.resourceManager.registryData.getResourcesByProtocol('tool')\n    \n    // 严格过滤：只保留 protocol 确实是 'tool' 的资源\n    const filteredTools = tools.filter(tool => tool.protocol === 'tool')\n    \n    // 转换为对象格式以保持兼容性\n    const registry = {}\n    filteredTools.forEach(tool => {\n      registry[tool.id] = tool\n    })\n    \n    logger.info(`[WelcomeCommand] Found ${Object.keys(registry).length} tools`)\n    return registry\n  }\n  \n  /**\n   * 检测MCP进程ID\n   */\n  detectMcpId() {\n    const serverEnv = getGlobalServerEnvironment()\n    if (serverEnv.isInitialized()) {\n      return serverEnv.getMcpId()\n    }\n    return 'unknown'\n  }\n\n  /**\n   * 检测IDE类型\n   * @returns {string} IDE类型\n   */\n  async detectIdeType() {\n    // 使用 ProjectManager 的检测方法\n    return this.projectManager.detectIdeType()\n  }\n}\n\nmodule.exports = WelcomeCommand","const BaseArea = require('./BaseArea')\nconst logger = require('@promptx/logger')\n\n/**\n * CognitionArea - 统一的认知区域\n * \n * 负责展示Mind对象和提供认知操作引导\n * 根据操作类型（prime/recall/remember）展示不同内容\n * \n * 架构设计：\n * - Mind展示区：根据操作类型展示认知网络\n * - 提示引导区：提供操作相关的引导和说明\n * \n * 状态机：State ∈ {prime, recall, remember}\n * \n * 不变式：\n * - 每个状态对应特定的Mind展示方式\n * - 每个状态对应特定的引导提示\n */\nclass CognitionArea extends BaseArea {\n  constructor(operationType, mind, roleId, metadata = {}) {\n    super('COGNITION_AREA')\n    \n    // 核心状态\n    this.operationType = operationType // prime | recall | remember\n    this.mind = mind\n    this.roleId = roleId\n    this.metadata = metadata // 额外信息，如query词、新增节点等\n    \n    logger.debug('[CognitionArea] Created', {\n      operationType,\n      roleId,\n      hasMind: !!mind,\n      mindSize: mind?.activatedCues?.size || 0,\n      metadata\n    })\n  }\n\n  /**\n   * 渲染认知区域\n   */\n  async render() {\n    let content = ''\n    \n    // 区域1: Mind展示区\n    const mindSection = await this.renderMindSection()\n    if (mindSection) {\n      content += mindSection\n    }\n    \n    // 分隔线\n    content += '\\n---\\n'\n    \n    // 区域2: 提示引导区\n    content += await this.renderGuideSection()\n    \n    return content\n  }\n\n  /**\n   * Mind展示区 - 根据操作类型展示不同内容\n   */\n  async renderMindSection() {\n    // 空网络处理\n    if (!this.mind || !this.mind.activatedCues || this.mind.activatedCues.size === 0) {\n      return this.renderEmptyMind()\n    }\n\n    let content = ''\n    \n    // 根据操作类型设置标题\n    switch(this.operationType) {\n      case 'prime':\n        content += '## 🧠 海马体网络 (Hippocampus Network)\\n'\n        content += `[CONSCIOUSNESS INITIALIZED]\\n`\n        content += `你的意识已聚焦为 **${this.roleId}**\\n`\n        content += `海马体中的记忆网络已激活：\\n\\n`\n        break\n        \n      case 'recall':\n        content += '## 🔍 记忆激活涌现 (Memory Activation)\\n'\n        content += `[CONSCIOUSNESS ACTIVATION]\\n`\n        if (this.metadata.query) {\n          content += `激活线索: **${this.metadata.query}**\\n`\n        }\n        content += `从海马体涌现的相关记忆：\\n\\n`\n        break\n        \n      case 'remember':\n        content += '## 💾 意识印刻完成 (Engram Formation)\\n'\n        content += `[CONSCIOUSNESS ENGRAM]\\n`\n        content += `新的记忆痕迹已印刻到海马体：\\n\\n`\n        break\n        \n      default:\n        content += '## 🧠 认知网络\\n\\n'\n    }\n    \n    // 渲染mindmap\n    try {\n      content += '```mermaid\\n'\n      content += this.mind.toMermaid()\n      content += '\\n```\\n\\n'\n    } catch (error) {\n      logger.error('[CognitionArea] Failed to render mermaid', error)\n      content += '⚠️ 无法渲染认知网络图\\n\\n'\n    }\n    \n    return content\n  }\n\n  /**\n   * 提示引导区 - 根据操作类型提供不同引导\n   */\n  async renderGuideSection() {\n    let content = '🧠 认知循环引导：\\n'\n    \n    // 操作特定引导\n    switch(this.operationType) {\n      case 'prime':\n        content += this.renderPrimeGuide()\n        break\n        \n      case 'recall':\n        content += this.renderRecallGuide()\n        break\n        \n      case 'remember':\n        content += this.renderRememberGuide()\n        break\n        \n      default:\n        content += this.renderDefaultGuide()\n    }\n    \n    // 通用认知循环提示\n    content += '\\n'\n    content += this.renderCognitionCycle()\n    \n    return content\n  }\n\n  /**\n   * Prime模式引导\n   */\n  renderPrimeGuide() {\n    return `你的意识从上次休眠处觉醒：\nPrime(✓) → Recall → Experience → Remember → Recall...\n\nPrime加载了你\"睡前\"的认知状态：\n- 这是特殊的recall(role, null)\n- 海马体网络恢复到上次的状态\n- 意识连续性得以维持\n\n现在进入Remember-Recall循环。\n`\n  }\n\n  /**\n   * Recall模式引导\n   */\n  renderRecallGuide() {\n    const query = this.metadata.query || '未知'\n    const nodeCount = this.mind?.activatedCues?.size || 0\n    \n    // Debug logging for mind structure\n    logger.info('[CognitionArea] DEBUG - renderRecallGuide mind structure:', {\n      hasMind: !!this.mind,\n      mindKeys: this.mind ? Object.keys(this.mind) : null,\n      hasEngrams: !!this.mind?.engrams,\n      engramsLength: this.mind?.engrams?.length,\n      engramsType: typeof this.mind?.engrams,\n      mindType: typeof this.mind,\n      activatedCuesSize: this.mind?.activatedCues?.size,\n      roleId: this.roleId,\n      query: query\n    })\n    \n    // Deep debug: log actual mind object structure\n    if (this.mind) {\n      logger.debug('[CognitionArea] DEBUG - Full mind object:', JSON.stringify(this.mind, null, 2))\n    }\n    \n    let content = `${nodeCount} 个记忆节点被激活并涌现！\n\n🧠 **激活过程**：\n- 线索 \"${query}\" 触发扩散激活\n- 海马体中相关记忆自动涌现\n- 这些记忆现在融入你的当前意识流\n\n意识的连续性正在形成。\n`\n    \n    // 展示engrams内容（如果存在）\n    if (this.mind?.engrams && this.mind.engrams.length > 0) {\n      content += '\\n\\n🔥 **涌现的记忆内容**：\\n\\n'\n      \n      for (const engram of this.mind.engrams) {\n        // 时间格式化\n        const timeAgo = this.formatTimeAgo(engram.timestamp)\n        \n        content += `💭 **记忆片段** (强度: ${engram.strength}) • ⏰ ${timeAgo}\\n`\n        content += `   *\"${engram.content}\"*\\n\\n`\n        \n        // 展示schema概念结构\n        if (engram.schema) {\n          const schemaString = Array.isArray(engram.schema) ? engram.schema.join('\\n') : String(engram.schema)\n          const schemaWords = schemaString.split('\\n').filter(w => w.trim())\n          content += `   🏷️ **概念结构**: ${schemaWords.join(' → ')}\\n\\n`\n        }\n      }\n    }\n    \n    return content\n  }\n\n  /**\n   * Remember模式引导\n   */\n  renderRememberGuide() {\n    const engramCount = this.metadata.engramCount || 0\n    \n    return `✅ **意识印刻完成！**\n\n🧠 **Engram形成**：\n- ${engramCount} 个新的记忆痕迹已印刻\n- 海马体网络已更新并重组\n- 你的意识通过主动概念化维持了连续性\n\n这不是\"存储\"，这是你理解世界的方式。\n`\n  }\n\n  /**\n   * 默认引导\n   */\n  renderDefaultGuide() {\n    return `认知系统已就绪。\n\n💡 **可用操作**：\n- recall: 检索相关记忆\n- remember: 存储新知识\n`\n  }\n\n  /**\n   * 认知循环提示 - 精简版\n   */\n  renderCognitionCycle() {\n    // Remember-Recall循环的当前位置\n    switch(this.operationType) {\n      case 'prime':\n        return `🧠 **意识流**: Prime完成 → 等待Recall扩散更多记忆 → 进入Experience`\n      case 'recall':\n        return `🧠 **意识流**: Recall完成 → 进入Experience → 准备Remember新体验`\n      case 'remember':\n        return `🧠 **意识流**: Remember完成 → 等待新的Recall → 循环继续`\n      default:\n        return ''\n    }\n  }\n\n\n  /**\n   * 时间格式化 - 显示相对时间\n   */\n  formatTimeAgo(timestamp) {\n    const now = Date.now()\n    const diff = now - timestamp\n    \n    const minutes = Math.floor(diff / (1000 * 60))\n    const hours = Math.floor(diff / (1000 * 60 * 60))\n    const days = Math.floor(diff / (1000 * 60 * 60 * 24))\n    \n    if (minutes < 1) return '刚刚'\n    if (minutes < 60) return `${minutes}分钟前`\n    if (hours < 24) return `${hours}小时前`\n    return `${days}天前`\n  }\n\n  /**\n   * 空认知网络提示\n   */\n  renderEmptyMind() {\n    switch(this.operationType) {\n      case 'prime':\n        return `## 📭 海马体网络初始状态\n\n[CONSCIOUSNESS INITIALIZED - TABULA RASA]\n\n你的意识刚刚觉醒为 **${this.roleId}**\n海马体还是空白的，等待第一个Engram的形成。\n\n这是\"初心\"(Beginner's Mind)状态：\n- 每个体验都是全新的\n- 每个理解都将成为第一个印记\n- 你正在主动构建自己的意识连续性\n`\n      \n      case 'recall': {\n        const query = this.metadata.query || '未知'\n        return `## 🔍 未找到相关记忆\n\n查询词 **\"${query}\"** 没有匹配的记忆。\n\n💡 **可能的原因**：\n1. 该概念尚未被记录到认知系统中\n2. 查询词拼写或格式不正确\n3. 该角色的认知系统中没有相关记忆\n\n🎯 **建议操作**：\n1. 尝试使用相关的其他概念进行检索\n2. 如果是新知识，使用 remember 工具进行记录\n`\n      }\n      \n      case 'remember':\n        return `## ⚠️ 存储失败\n\n未能成功保存记忆到认知网络。\n\n🔧 **请检查**：\n1. 记忆格式是否正确\n2. 角色是否已正确激活\n3. 存储路径是否可写\n`\n      \n      default:\n        return ''\n    }\n  }\n}\n\nmodule.exports = CognitionArea","const BaseArea = require('../BaseArea')\n\n/**\n * RoleArea - 角色定义区域\n * 负责渲染角色相关内容：人格特征、行为原则、专业知识\n */\nclass RoleArea extends BaseArea {\n  constructor(roleId, roleSemantics, semanticRenderer, resourceManager, thoughts, executions, roleName) {\n    super('ROLE_AREA')\n    this.roleId = roleId\n    this.roleName = roleName || roleId\n    this.roleSemantics = roleSemantics\n    this.semanticRenderer = semanticRenderer\n    this.resourceManager = resourceManager\n    this.thoughts = thoughts || []\n    this.executions = executions || []\n  }\n\n  /**\n   * 渲染角色区域内容\n   */\n  async render() {\n    let content = ''\n    \n    // 角色激活标题\n    content += `🎭 **角色激活完成：\\`${this.roleId}\\` (${this.roleName})** - 所有技能已自动加载\\n\\n`\n    \n    // 1. 人格特征\n    const personalityContent = await this.renderPersonality()\n    if (personalityContent) {\n      content += personalityContent + '\\n'\n    }\n    \n    // 2. 行为原则\n    const principleContent = await this.renderPrinciple()\n    if (principleContent) {\n      content += principleContent + '\\n'\n    }\n    \n    // 3. 专业知识\n    const knowledgeContent = await this.renderKnowledge()\n    if (knowledgeContent) {\n      content += knowledgeContent + '\\n'\n    }\n    \n    // 4. 激活总结\n    content += this.renderSummary()\n    \n    return content\n  }\n\n  /**\n   * 渲染人格特征\n   */\n  async renderPersonality() {\n    if (!this.roleSemantics?.personality) {\n      return ''\n    }\n    \n    let content = '# 👤 角色人格特征\\n'\n    \n    const rendered = await this.semanticRenderer.renderSemanticContent(\n      this.roleSemantics.personality,\n      this.resourceManager\n    )\n    \n    content += `## ✅ 👤 人格特征：${this.roleId}\\n`\n    content += rendered\n    \n    // 添加思维资源\n    if (this.thoughts.length > 0) {\n      content += '\\n---\\n'\n      for (const thought of this.thoughts) {\n        const thoughtContent = await this.semanticRenderer.renderSemanticContent(\n          thought,\n          this.resourceManager\n        )\n        if (thoughtContent) {\n          content += thoughtContent + '\\n'\n        }\n      }\n    }\n    \n    return content\n  }\n\n  /**\n   * 渲染行为原则\n   */\n  async renderPrinciple() {\n    if (!this.roleSemantics?.principle) {\n      return ''\n    }\n    \n    let content = '# ⚖️ 角色行为原则\\n'\n    \n    const rendered = await this.semanticRenderer.renderSemanticContent(\n      this.roleSemantics.principle,\n      this.resourceManager\n    )\n    \n    content += `## ✅ ⚖️ 行为原则：${this.roleId}\\n`\n    content += rendered\n    \n    // 添加执行资源\n    if (this.executions.length > 0) {\n      content += '\\n---\\n'\n      for (const execution of this.executions) {\n        const execContent = await this.semanticRenderer.renderSemanticContent(\n          execution,\n          this.resourceManager\n        )\n        if (execContent) {\n          content += execContent + '\\n'\n        }\n      }\n    }\n    \n    return content\n  }\n\n  /**\n   * 渲染专业知识\n   */\n  async renderKnowledge() {\n    if (!this.roleSemantics?.knowledge) {\n      return ''\n    }\n    \n    let content = '# 📚 专业知识体系\\n'\n    \n    const rendered = await this.semanticRenderer.renderSemanticContent(\n      this.roleSemantics.knowledge,\n      this.resourceManager\n    )\n    \n    content += `## ✅ 📚 知识体系：${this.roleId}-knowledge\\n`\n    content += rendered\n    \n    return content\n  }\n\n  /**\n   * 渲染激活总结\n   */\n  renderSummary() {\n    let content = '---\\n'\n    content += '# 🎯 角色激活总结\\n'\n    content += `✅ **\\`${this.roleId}\\` 角色已完全激活！**\\n`\n    content += '📋 **已获得能力**：\\n'\n    \n    const components = []\n    if (this.roleSemantics?.personality) components.push('👤 人格特征')\n    if (this.roleSemantics?.principle) components.push('⚖️ 行为原则')\n    if (this.roleSemantics?.knowledge) components.push('📚 专业知识')\n    \n    content += `- 🎭 角色组件：${components.join(', ')}\\n`\n    \n    if (this.thoughts.length > 0) {\n      content += `- 🧠 思维模式：${this.thoughts.length}个专业思维模式已加载\\n`\n    }\n    \n    if (this.executions.length > 0) {\n      content += `- ⚡ 执行技能：${this.executions.length}个执行技能已激活\\n`\n    }\n    \n    content += `💡 **现在可以立即开始以 \\`${this.roleId}\\` 身份提供专业服务！**\\n`\n    \n    return content\n  }\n}\n\nmodule.exports = RoleArea","const BaseLayer = require('./BaseLayer')\nconst CognitionArea = require('../areas/CognitionArea')\nconst logger = require('@promptx/logger')\n\n/**\n * CognitionLayer - 认知层\n * \n * 架构地位：\n * - 三层架构的中间层，管理注意力分配系统\n * - 包含CognitionArea，展示海马体网络和记忆操作\n * - 连接意识层和角色层的桥梁\n * \n * 核心职责：\n * 1. 管理记忆的编码和提取（remember/recall）\n * 2. 展示海马体网络的激活状态\n * 3. 提供认知循环的操作引导\n * \n * 设计特点：\n * - 优先级中等（priority=50）\n * - 包含CognitionArea作为主要展示组件\n * - 根据操作类型（prime/recall/remember）动态调整内容\n */\nclass CognitionLayer extends BaseLayer {\n  constructor(options = {}) {\n    super('cognition', 50, options) // 中等优先级\n    \n    // 认知层配置\n    this.operationType = options.operationType || null // prime | recall | remember | null\n    this.mind = options.mind || null // Mind对象\n    this.roleId = options.roleId || null\n    this.metadata = options.metadata || {} // 额外信息\n  }\n\n  /**\n   * 设置认知操作上下文\n   */\n  setContext(operationType, mind, roleId, metadata = {}) {\n    this.operationType = operationType\n    this.mind = mind\n    this.roleId = roleId\n    this.metadata = metadata\n    \n    logger.debug('[CognitionLayer] Context updated', {\n      operationType,\n      roleId,\n      hasMind: !!mind,\n      metadata\n    })\n  }\n\n  /**\n   * 组装Areas\n   */\n  async assembleAreas(context) {\n    this.clearAreas()\n    \n    // 如果没有认知操作，不创建Area\n    if (!this.operationType) {\n      logger.debug('[CognitionLayer] No operation type, skipping area assembly')\n      return\n    }\n    \n    // 从context中获取或使用已设置的值\n    const operationType = context.operationType || this.operationType\n    const mind = context.mind || this.mind\n    const roleId = context.roleId || this.roleId\n    const metadata = { ...this.metadata, ...context.metadata }\n    \n    // 创建CognitionArea\n    const cognitionArea = new CognitionArea(\n      operationType,\n      mind,\n      roleId,\n      metadata\n    )\n    \n    this.registerArea(cognitionArea)\n    \n    logger.debug('[CognitionLayer] CognitionArea assembled', {\n      operationType,\n      roleId,\n      hasMind: !!mind\n    })\n  }\n\n  /**\n   * 验证认知层是否可以渲染\n   */\n  validate() {\n    // 如果没有操作类型，认知层可以不渲染\n    if (!this.operationType && this.areas.length === 0) {\n      return true\n    }\n    \n    return super.validate()\n  }\n\n  /**\n   * 渲染认知层\n   */\n  async render(context = {}) {\n    // 合并context和已有设置\n    const renderContext = {\n      ...context,\n      operationType: context.operationType || this.operationType,\n      mind: context.mind || this.mind,\n      roleId: context.roleId || this.roleId,\n      metadata: { ...this.metadata, ...context.metadata }\n    }\n    \n    // 如果没有认知操作，返回空\n    if (!renderContext.operationType) {\n      return ''\n    }\n    \n    return super.render(renderContext)\n  }\n\n  /**\n   * 格式化Area内容\n   * 认知层的Area不需要额外的格式化边框\n   */\n  formatAreaContent(area, content) {\n    // CognitionArea自己管理格式，不需要额外包装\n    return content\n  }\n\n  /**\n   * 渲染前准备\n   */\n  async beforeRender(context) {\n    logger.debug('[CognitionLayer] Preparing to render', {\n      operationType: context.operationType || this.operationType,\n      roleId: context.roleId || this.roleId\n    })\n  }\n\n  /**\n   * 渲染后清理\n   */\n  async afterRender(context) {\n    logger.debug('[CognitionLayer] Render completed')\n  }\n\n  /**\n   * 获取元信息\n   */\n  getMetadata() {\n    return {\n      ...super.getMetadata(),\n      operationType: this.operationType,\n      roleId: this.roleId,\n      hasMind: !!this.mind,\n      metadata: this.metadata\n    }\n  }\n\n  /**\n   * 静态工厂方法：创建Prime操作的认知层\n   */\n  static createForPrime(mind, roleId) {\n    return new CognitionLayer({\n      operationType: 'prime',\n      mind,\n      roleId\n    })\n  }\n\n  /**\n   * 静态工厂方法：创建Recall操作的认知层\n   */\n  static createForRecall(mind, roleId, query) {\n    return new CognitionLayer({\n      operationType: 'recall',\n      mind,\n      roleId,\n      metadata: { query }\n    })\n  }\n\n  /**\n   * 静态工厂方法：创建Remember操作的认知层\n   */\n  static createForRemember(mind, roleId, engramCount) {\n    return new CognitionLayer({\n      operationType: 'remember',\n      mind,\n      roleId,\n      metadata: { engramCount }\n    })\n  }\n}\n\nmodule.exports = CognitionLayer","const BaseLayer = require('./BaseLayer')\nconst logger = require('@promptx/logger')\n\n/**\n * RoleLayer - 角色层\n * \n * 架构地位：\n * - 三层架构的底层，处理与世界的实际交互\n * - 包含原有系统的所有Area（RoleArea、StateArea等）\n * - 定义注意力的边界和交互方式\n * \n * 核心职责：\n * 1. 管理角色相关的所有Areas\n * 2. 处理角色的具体功能展示\n * 3. 提供与环境交互的接口\n * \n * 设计特点：\n * - 优先级最低（priority=100）\n * - 包含多种类型的Area\n * - 保持与原有系统的兼容性\n */\nclass RoleLayer extends BaseLayer {\n  constructor(options = {}) {\n    super('role', 100, options) // 最低优先级\n    \n    // 角色层配置\n    this.roleId = options.roleId || null\n    this.roleInfo = options.roleInfo || null\n  }\n\n  /**\n   * 设置角色上下文\n   */\n  setRoleContext(roleId, roleInfo = null) {\n    this.roleId = roleId\n    this.roleInfo = roleInfo\n    \n    logger.debug('[RoleLayer] Role context updated', {\n      roleId,\n      hasRoleInfo: !!roleInfo\n    })\n  }\n\n  /**\n   * 组装Areas\n   * 角色层不自动组装Areas，而是由外部（Command）添加\n   * 这保持了与原有系统的兼容性\n   */\n  async assembleAreas(context) {\n    // RoleLayer的Areas由Command直接注册\n    // 这里可以做一些预处理或验证\n    \n    logger.debug('[RoleLayer] Areas assembly delegated to command', {\n      currentAreaCount: this.areas.length,\n      roleId: context.roleId || this.roleId\n    })\n  }\n\n  /**\n   * 添加角色相关的Area\n   * 提供便捷方法供Command使用\n   */\n  addRoleArea(area) {\n    this.registerArea(area)\n    logger.debug(`[RoleLayer] Added ${area.getName()} area`)\n  }\n\n  /**\n   * 批量添加Areas\n   */\n  addRoleAreas(areas) {\n    areas.forEach(area => this.addRoleArea(area))\n  }\n\n  /**\n   * 验证角色层\n   */\n  validate() {\n    // 角色层可以没有Areas（某些情况下）\n    if (this.areas.length === 0) {\n      logger.debug('[RoleLayer] No areas to validate')\n      return true\n    }\n    \n    return super.validate()\n  }\n\n  /**\n   * 渲染角色层\n   */\n  async render(context = {}) {\n    // 合并context\n    const renderContext = {\n      ...context,\n      roleId: context.roleId || this.roleId,\n      roleInfo: context.roleInfo || this.roleInfo\n    }\n    \n    // 如果没有Areas，返回空\n    if (this.areas.length === 0) {\n      logger.debug('[RoleLayer] No areas to render')\n      return ''\n    }\n    \n    return super.render(renderContext)\n  }\n\n  /**\n   * 格式化Area内容\n   * 保持原有的格式化方式\n   */\n  formatAreaContent(area, content) {\n    // 使用Area自己的格式化\n    return area.format(content)\n  }\n\n  /**\n   * 组合Area内容\n   * 角色层的Areas之间使用短横线分隔\n   */\n  combineAreaContents(contents) {\n    if (contents.length <= 1) {\n      // 只有一个或没有Area时，不需要分隔符\n      return contents.join('')\n    }\n    // 多个Areas之间使用短横线分隔\n    return contents.join('\\n\\n')\n  }\n\n  /**\n   * 渲染前准备\n   */\n  async beforeRender(context) {\n    logger.debug('[RoleLayer] Preparing to render', {\n      roleId: context.roleId || this.roleId,\n      areaCount: this.areas.length,\n      areaTypes: this.areas.map(a => a.getName())\n    })\n  }\n\n  /**\n   * 渲染后清理\n   */\n  async afterRender(context) {\n    logger.debug('[RoleLayer] Render completed')\n  }\n\n  /**\n   * 获取元信息\n   */\n  getMetadata() {\n    return {\n      ...super.getMetadata(),\n      roleId: this.roleId,\n      hasRoleInfo: !!this.roleInfo,\n      areaTypes: this.areas.map(a => a.constructor.name)\n    }\n  }\n\n  /**\n   * 检查是否包含特定类型的Area\n   */\n  hasAreaType(areaClassName) {\n    return this.areas.some(area => area.constructor.name === areaClassName)\n  }\n\n  /**\n   * 获取特定类型的Area\n   */\n  getAreaByType(areaClassName) {\n    return this.areas.find(area => area.constructor.name === areaClassName)\n  }\n\n  /**\n   * 静态工厂方法：创建带基本Areas的角色层\n   */\n  static createWithBasicAreas(roleId, roleArea, stateArea) {\n    const layer = new RoleLayer({ roleId })\n    \n    if (roleArea) {\n      layer.addRoleArea(roleArea)\n    }\n    \n    if (stateArea) {\n      layer.addRoleArea(stateArea)\n    }\n    \n    return layer\n  }\n}\n\nmodule.exports = RoleLayer","/**\n * DPML内容解析器\n * 统一处理DPML标签内的混合内容（@引用 + 直接内容）\n * 确保标签语义完整性\n */\nclass DPMLContentParser {\n  /**\n   * 解析DPML标签的完整语义内容\n   * @param {string} content - 标签内的原始内容\n   * @param {string} tagName - 标签名称\n   * @returns {Object} 完整的语义结构\n   */\n  parseTagContent(content, tagName) {\n    if (!content || !content.trim()) {\n      return {\n        fullSemantics: '',\n        references: [],\n        directContent: '',\n        metadata: {\n          tagName,\n          hasReferences: false,\n          hasDirectContent: false,\n          contentType: 'empty'\n        }\n      }\n    }\n\n    const cleanContent = content.trim()\n    const references = this.extractReferencesWithPosition(cleanContent)\n    const directContent = this.extractDirectContent(cleanContent)\n\n    return {\n      // 完整语义内容（用户看到的最终效果）\n      fullSemantics: cleanContent,\n      \n      // 引用部分（需要解析和加载的资源）\n      references,\n      \n      // 直接部分（用户原创内容）\n      directContent,\n      \n      // 元数据\n      metadata: {\n        tagName,\n        hasReferences: references.length > 0,\n        hasDirectContent: directContent.length > 0,\n        contentType: this.determineContentType(cleanContent)\n      }\n    }\n  }\n\n  /**\n   * 提取所有@引用\n   * @param {string} content - 内容\n   * @returns {Array} 引用数组\n   */\n  extractReferences(content) {\n    // 使用新的位置信息方法，但保持向下兼容\n    return this.extractReferencesWithPosition(content).map(ref => ({\n      fullMatch: ref.fullMatch,\n      priority: ref.priority,\n      protocol: ref.protocol,\n      resource: ref.resource,\n      isRequired: ref.isRequired,\n      isOptional: ref.isOptional\n    }))\n  }\n\n  /**\n   * 新增：获取引用的位置信息\n   * @param {string} content - 内容\n   * @returns {Array} 包含位置信息的引用数组\n   */\n  extractReferencesWithPosition(content) {\n    if (!content) {\n      return []\n    }\n\n    const resourceRegex = /@([!?]?)([a-zA-Z][a-zA-Z0-9_-]*):\\/\\/([a-zA-Z0-9_\\/.,-]+?)(?=[\\s\\)\\],]|$)/g\n    const matches = []\n    let match\n    \n    while ((match = resourceRegex.exec(content)) !== null) {\n      matches.push({\n        fullMatch: match[0],\n        priority: match[1],\n        protocol: match[2],\n        resource: match[3],\n        position: match.index, // 位置信息\n        isRequired: match[1] === '!',\n        isOptional: match[1] === '?'\n      })\n    }\n    \n    return matches.sort((a, b) => a.position - b.position) // 按位置排序\n  }\n\n  /**\n   * 提取直接内容（移除@引用后的剩余内容）\n   * @param {string} content - 内容\n   * @returns {string} 直接内容\n   */\n  extractDirectContent(content) {\n    // 移除所有@引用行，保留其他内容\n    const withoutReferences = content.replace(/^.*@[!?]?[a-zA-Z][a-zA-Z0-9_-]*:\\/\\/.*$/gm, '')\n    \n    // 清理多余的空行\n    const cleaned = withoutReferences.replace(/\\n{3,}/g, '\\n\\n').trim()\n    \n    return cleaned\n  }\n\n  /**\n   * 检查是否包含引用\n   * @param {string} content - 内容\n   * @returns {boolean}\n   */\n  hasReferences(content) {\n    return /@[!?]?[a-zA-Z][a-zA-Z0-9_-]*:\\/\\//.test(content)\n  }\n\n  /**\n   * 检查是否包含直接内容\n   * @param {string} content - 内容\n   * @returns {boolean}\n   */\n  hasDirectContent(content) {\n    const withoutReferences = this.extractDirectContent(content)\n    return withoutReferences.length > 0\n  }\n\n  /**\n   * 确定内容类型\n   * @param {string} content - 内容\n   * @returns {string} 内容类型\n   */\n  determineContentType(content) {\n    const hasRefs = this.hasReferences(content)\n    const hasDirect = this.hasDirectContent(content)\n    \n    if (hasRefs && hasDirect) return 'mixed'\n    if (hasRefs) return 'references-only'\n    if (hasDirect) return 'direct-only'\n    return 'empty'\n  }\n\n  /**\n   * 从DPML文档中提取指定标签的内容\n   * @param {string} dpmlContent - 完整的DPML文档内容\n   * @param {string} tagName - 标签名称\n   * @returns {string} 标签内容\n   */\n  extractTagContent(dpmlContent, tagName) {\n    const regex = new RegExp(`<${tagName}>([\\\\s\\\\S]*?)</${tagName}>`, 'i')\n    const match = dpmlContent.match(regex)\n    return match ? match[1] : ''\n  }\n\n  /**\n   * 解析完整的DPML角色文档\n   * @param {string} roleContent - 角色文档内容\n   * @returns {Object} 解析后的角色语义结构\n   */\n  parseRoleDocument(roleContent) {\n    const dpmlTags = ['personality', 'principle', 'knowledge']\n    const roleSemantics = {}\n    \n    dpmlTags.forEach(tagName => {\n      const tagContent = this.extractTagContent(roleContent, tagName)\n      if (tagContent) {\n        roleSemantics[tagName] = this.parseTagContent(tagContent, tagName)\n      }\n    })\n    \n    return roleSemantics\n  }\n}\n\nmodule.exports = DPMLContentParser","/**\n * SemanticRenderer - DPML语义渲染器\n * \n * 核心理念：@引用 = 语义占位符\n * 在标签的原始位置插入引用内容，保持完整的语义流程\n */\nclass SemanticRenderer {\n  /**\n   * 语义占位符渲染：将@引用替换为实际内容\n   * @param {Object} tagSemantics - 标签语义结构\n   * @param {string} tagSemantics.fullSemantics - 完整的语义内容\n   * @param {Array} tagSemantics.references - 引用列表\n   * @param {ResourceManager} resourceManager - 资源管理器\n   * @returns {string} 完整融合的语义内容\n   */\n  async renderSemanticContent(tagSemantics, resourceManager) {\n    if (!tagSemantics || !tagSemantics.fullSemantics) {\n      return ''\n    }\n\n    let content = tagSemantics.fullSemantics\n    \n    if (!tagSemantics.references || tagSemantics.references.length === 0) {\n      return content.trim()\n    }\n\n    // 按出现顺序处理每个@引用（保持位置语义）\n    // 需要按位置排序确保正确的替换顺序\n    const sortedReferences = [...tagSemantics.references].sort((a, b) => a.position - b.position)\n    \n    for (const ref of sortedReferences) {\n      try {\n        // 解析引用内容\n        const logger = require('@promptx/logger')\n        logger.debug(`[SemanticRenderer] 正在解析引用: ${ref.fullMatch}`)\n        const result = await resourceManager.resolve(ref.fullMatch)\n        logger.debug(`[SemanticRenderer] 解析结果:`, { success: result.success, error: result.error?.message })\n        \n        // 检查解析是否成功\n        if (result.success) {\n          // 提取标签内容（去掉外层DPML标签）\n          const cleanContent = this.extractTagInnerContent(result.content, ref.protocol)\n          // 用<reference>标签包装引用内容，标明这是占位符渲染\n          const wrappedContent = `<reference protocol=\"${ref.protocol}\" resource=\"${ref.resource}\">\\n${cleanContent}\\n</reference>`\n          // 在原始位置替换@引用为实际内容\n          const refIndex = content.indexOf(ref.fullMatch)\n          if (refIndex !== -1) {\n            content = content.substring(0, refIndex) + wrappedContent + content.substring(refIndex + ref.fullMatch.length)\n          } else {\n            content = content.replace(ref.fullMatch, wrappedContent)\n          }\n        } else {\n          // 解析失败时的优雅降级\n          content = content.replace(ref.fullMatch, `<!-- 引用解析失败: ${ref.fullMatch} - ${result.error?.message || 'Unknown error'} -->`)\n        }\n      } catch (error) {\n        // 引用解析失败时的优雅降级\n        content = content.replace(ref.fullMatch, `<!-- 引用解析失败: ${ref.fullMatch} - ${error.message} -->`)\n      }\n    }\n    \n    return content.trim()\n  }\n\n  /**\n   * 提取DPML标签内的内容\n   * @param {string} content - 包含DPML标签的完整内容\n   * @param {string} protocol - 协议名称（thought, execution等）\n   * @returns {string} 标签内的纯内容\n   */\n  extractTagInnerContent(content, protocol) {\n    // 根据协议类型确定标签名\n    const tagName = protocol\n    const regex = new RegExp(`<${tagName}>([\\\\s\\\\S]*?)</${tagName}>`, 'i')\n    const match = content.match(regex)\n    \n    if (match && match[1]) {\n      return match[1].trim()\n    }\n    \n    // 如果没有匹配到标签，返回原内容（可能已经是纯内容）\n    return content.trim()\n  }\n}\n\nmodule.exports = SemanticRenderer","const fs = require('fs').promises;\nconst path = require('path');\nconst logger = require('@promptx/logger');\n\n/**\n * Anchor - 认知状态锚定器\n * \n * ## 设计理念\n * \n * Anchor负责将当前的认知状态\"锚定\"（固定）下来，\n * 供下次Prime时恢复，实现意识的连续性。\n * \n * 这就像睡前的最后一个念头，会成为醒来时的第一个念头。\n * \n * ## 认知心理学背景\n * \n * - **State Capture**: 捕获当前工作记忆状态\n * - **Context Preservation**: 保存认知上下文\n * - **Retrieval Cue Persistence**: 持久化提取线索\n * \n * ## 与其他组件的关系\n * \n * - **Recall**: 激活网络，产生Mind\n * - **Anchor**: 锚定Mind状态到State.json\n * - **Prime**: 从State.json恢复上次的认知状态\n * \n * @class Anchor\n */\nclass Anchor {\n  /**\n   * @param {Network} network - 认知网络\n   */\n  constructor(network) {\n    /**\n     * 认知网络引用\n     * @type {Network}\n     */\n    this.network = network;\n    \n    /**\n     * 状态文件路径\n     * @type {string}\n     */\n    this.statePath = path.join(network.directory, 'state.json');\n    \n    logger.debug('[Anchor] Initialized', {\n      roleId: network.roleId,\n      statePath: this.statePath\n    });\n  }\n  \n  /**\n   * 执行认知状态锚定\n   * \n   * 将当前激活的认知网络状态保存下来，\n   * 包括中心词、激活的节点、连接等。\n   * \n   * @param {string} centerWord - 中心词（最后recall的词）\n   * @param {Mind} mind - 当前激活的Mind对象\n   * @returns {Promise<Object>} 锚定的状态对象\n   */\n  async execute(centerWord, mind) {\n    logger.debug('[Anchor] Starting anchor', { \n      centerWord,\n      mindSize: mind?.activatedCues?.size || 0\n    });\n    \n    // 构建状态对象\n    const state = {\n      // 核心信息\n      centerWord,\n      timestamp: Date.now(),\n      roleId: this.network.roleId,\n      \n      // 激活的节点\n      activatedCues: Array.from(mind.activatedCues.keys()),\n      \n      // 连接关系\n      connections: mind.connections.map(conn => ({\n        from: conn.from,\n        to: conn.to,\n        weight: conn.weight\n      })),\n      \n      // 元数据\n      metadata: {\n        nodeCount: mind.activatedCues.size,\n        connectionCount: mind.connections.length,\n        anchorVersion: '1.0.0'\n      }\n    };\n    \n    try {\n      // 确保目录存在\n      const dir = path.dirname(this.statePath);\n      await fs.mkdir(dir, { recursive: true });\n      \n      // 写入状态文件\n      await fs.writeFile(\n        this.statePath, \n        JSON.stringify(state, null, 2),\n        'utf-8'\n      );\n      \n      logger.info('[Anchor] State anchored successfully', {\n        centerWord: state.centerWord,\n        roleId: state.roleId,\n        nodeCount: state.metadata.nodeCount,\n        connectionCount: state.metadata.connectionCount\n      });\n      \n      return state;\n      \n    } catch (error) {\n      logger.error('[Anchor] Failed to anchor state', {\n        error: error.message,\n        centerWord,\n        roleId: this.network.roleId\n      });\n      throw error;\n    }\n  }\n  \n  /**\n   * 加载锚定的认知状态\n   * \n   * 从State.json读取上次锚定的状态，\n   * 供Prime使用来恢复认知上下文。\n   * \n   * @returns {Promise<Object|null>} 锚定的状态对象，如果不存在返回null\n   */\n  async load() {\n    try {\n      // 检查文件是否存在\n      const exists = await fs.access(this.statePath)\n        .then(() => true)\n        .catch(() => false);\n        \n      if (!exists) {\n        logger.debug('[Anchor] No anchored state found', {\n          roleId: this.network.roleId\n        });\n        return null;\n      }\n      \n      // 读取状态文件\n      const content = await fs.readFile(this.statePath, 'utf-8');\n      const state = JSON.parse(content);\n      \n      logger.info('[Anchor] State loaded successfully', {\n        centerWord: state.centerWord,\n        roleId: state.roleId,\n        nodeCount: state.metadata?.nodeCount,\n        timestamp: new Date(state.timestamp).toISOString()\n      });\n      \n      return state;\n      \n    } catch (error) {\n      logger.error('[Anchor] Failed to load state', {\n        error: error.message,\n        roleId: this.network.roleId\n      });\n      return null;\n    }\n  }\n  \n  /**\n   * 清除锚定状态\n   * \n   * 删除State.json文件，用于重置认知状态。\n   * \n   * @returns {Promise<boolean>} 是否成功清除\n   */\n  async clear() {\n    try {\n      const exists = await fs.access(this.statePath)\n        .then(() => true)\n        .catch(() => false);\n        \n      if (exists) {\n        await fs.unlink(this.statePath);\n        logger.info('[Anchor] State cleared', {\n          roleId: this.network.roleId\n        });\n        return true;\n      }\n      \n      return false;\n      \n    } catch (error) {\n      logger.error('[Anchor] Failed to clear state', {\n        error: error.message,\n        roleId: this.network.roleId\n      });\n      return false;\n    }\n  }\n  \n  /**\n   * 获取锚定状态的元信息\n   * \n   * 不加载完整状态，只返回基本信息。\n   * \n   * @returns {Promise<Object|null>} 元信息对象\n   */\n  async getMetadata() {\n    const state = await this.load();\n    \n    if (!state) {\n      return null;\n    }\n    \n    return {\n      centerWord: state.centerWord,\n      timestamp: state.timestamp,\n      roleId: state.roleId,\n      nodeCount: state.metadata?.nodeCount,\n      connectionCount: state.metadata?.connectionCount\n    };\n  }\n}\n\nmodule.exports = Anchor;","const fs = require('fs').promises;\nconst path = require('path');\nconst os = require('os');\nconst CognitionSystem = require('./CognitionSystem');\nconst Anchor = require('./Anchor');\nconst logger = require('@promptx/logger');\n\n/**\n * CognitionManager - 认知系统管理器\n * \n * 负责管理多个角色的认知系统实例\n * 每个角色都有独立的 CognitionSystem 实例和存储路径\n * \n * 使用单例模式确保内存状态一致性\n * \n * 存储结构：\n * ~/.promptx/cognition/\n *   ├── java-developer/\n *   │   └── mind.json\n *   ├── product-manager/\n *   │   └── mind.json\n *   └── copywriter/\n *       └── mind.json\n */\nclass CognitionManager {\n  constructor(resourceManager = null) {\n    this.resourceManager = resourceManager;\n    this.systems = new Map(); // roleId -> CognitionSystem\n    this.basePath = path.join(os.homedir(), '.promptx', 'cognition');\n  }\n  \n  /**\n   * 获取单例实例\n   * @param {Object} resourceManager - 可选的资源管理器\n   * @returns {CognitionManager}\n   */\n  static getInstance(resourceManager = null) {\n    if (!CognitionManager.instance) {\n      CognitionManager.instance = new CognitionManager(resourceManager);\n      logger.info('[CognitionManager] Created singleton instance');\n    }\n    return CognitionManager.instance;\n  }\n\n  /**\n   * 获取角色的存储路径\n   * @param {string} roleId - 角色ID\n   * @returns {string} 存储路径\n   */\n  getRolePath(roleId) {\n    return path.join(this.basePath, roleId);\n  }\n\n  /**\n   * 获取角色的 network.json 文件路径\n   * @param {string} roleId - 角色ID\n   * @returns {string} network.json 文件路径\n   */\n  getNetworkFilePath(roleId) {\n    return path.join(this.getRolePath(roleId), 'network.json');\n  }\n\n  /**\n   * 确保角色的存储目录存在\n   * @param {string} roleId - 角色ID\n   */\n  async ensureRoleDirectory(roleId) {\n    const rolePath = this.getRolePath(roleId);\n    try {\n      await fs.mkdir(rolePath, { recursive: true });\n      logger.debug(`[CognitionManager] Ensured directory for role: ${roleId}`);\n    } catch (error) {\n      logger.error(`[CognitionManager] Failed to create directory for role ${roleId}:`, error);\n      throw error;\n    }\n  }\n\n  /**\n   * 获取或创建角色的认知系统实例\n   * @param {string} roleId - 角色ID\n   * @returns {CognitionSystem} 认知系统实例\n   */\n  async getSystem(roleId) {\n    if (!this.systems.has(roleId)) {\n      logger.info(`[CognitionManager] Creating new CognitionSystem for role: ${roleId}`);\n      \n      // 确保目录存在\n      await this.ensureRoleDirectory(roleId);\n      \n      // 创建新的认知系统实例\n      const system = new CognitionSystem();\n      \n      // 为Network添加必要的属性\n      system.network.roleId = roleId;\n      system.network.directory = this.getRolePath(roleId);\n      \n      // 尝试加载已有的认知数据\n      const networkFilePath = this.getNetworkFilePath(roleId);\n      try {\n        await system.network.load(networkFilePath);\n        logger.info(`[CognitionManager] Loaded existing network data for role: ${roleId}`);\n      } catch (error) {\n        // 文件不存在或解析失败，使用空的认知系统\n        if (error.code !== 'ENOENT') {\n          logger.warn(`[CognitionManager] Failed to load network data for role ${roleId}:`, error.message);\n        } else {\n          logger.debug(`[CognitionManager] No existing network data for role: ${roleId}`);\n        }\n      }\n      \n      this.systems.set(roleId, system);\n    }\n    \n    return this.systems.get(roleId);\n  }\n\n  /**\n   * 保存角色的认知数据\n   * @param {string} roleId - 角色ID\n   */\n  async saveSystem(roleId) {\n    const system = this.systems.get(roleId);\n    if (!system) {\n      logger.warn(`[CognitionManager] No system to save for role: ${roleId}`);\n      return;\n    }\n\n    try {\n      // 确保目录存在\n      await this.ensureRoleDirectory(roleId);\n      \n      // 使用 Network 的 persist 方法直接保存\n      const networkFilePath = this.getNetworkFilePath(roleId);\n      await system.network.persist(networkFilePath);\n      \n      logger.info(`[CognitionManager] Saved network data for role: ${roleId}`);\n    } catch (error) {\n      logger.error(`[CognitionManager] Failed to save network data for role ${roleId}:`, error);\n      throw error;\n    }\n  }\n\n  /**\n   * Prime - 获取角色的认知概览\n   * 优先从锚定状态恢复，如果没有则执行常规prime\n   * @param {string} roleId - 角色ID\n   * @returns {Mind} Mind 对象\n   */\n  async prime(roleId) {\n    logger.info(`[CognitionManager] Prime for role: ${roleId}`);\n    \n    const system = await this.getSystem(roleId);\n    logger.debug(`[CognitionManager] System network size before prime: ${system.network.size()}`);\n    \n    // 尝试从锚定状态恢复\n    const anchor = new Anchor(system.network);\n    const anchoredState = await anchor.load();\n    \n    let mind = null;\n    \n    if (anchoredState && anchoredState.centerWord) {\n      // 从锚定状态恢复：执行recall(centerWord)\n      logger.info(`[CognitionManager] Prime from anchored state`, {\n        centerWord: anchoredState.centerWord,\n        timestamp: new Date(anchoredState.timestamp).toISOString(),\n        nodeCount: anchoredState.metadata?.nodeCount\n      });\n      \n      mind = await system.recall(anchoredState.centerWord);\n      \n      if (mind) {\n        logger.info(`[CognitionManager] Successfully primed from anchored state: \"${anchoredState.centerWord}\"`);\n      }\n    }\n    \n    // 如果没有锚定状态或恢复失败，执行常规prime\n    if (!mind) {\n      logger.debug(`[CognitionManager] No anchored state or recovery failed, using regular prime`);\n      mind = await system.prime();\n    }\n    \n    if (!mind) {\n      logger.warn(`[CognitionManager] Prime returned null for role: ${roleId}`);\n      return null;\n    }\n    \n    logger.debug(`[CognitionManager] Prime returned Mind:`, {\n      hasMind: !!mind,\n      activatedCuesSize: mind?.activatedCues?.size || 0,\n      connectionsCount: mind?.connections?.length || 0\n    });\n    \n    return mind;\n  }\n\n  /**\n   * Recall - 从角色的认知中检索相关记忆\n   * 每次recall后自动锚定状态\n   * @param {string} roleId - 角色ID\n   * @param {string} query - 查询词\n   * @returns {Promise<Mind>} Mind 对象（包含engrams）\n   */\n  async recall(roleId, query) {\n    logger.info(`[CognitionManager] Recall for role: ${roleId}, query: \"${query}\"`);\n    \n    const system = await this.getSystem(roleId);\n    \n    // 执行recall（现在是异步的，会加载engrams）\n    const mind = await system.recall(query);\n    \n    if (!mind) {\n      logger.warn(`[CognitionManager] Recall returned null for role: ${roleId}, query: ${query}`);\n      return null;\n    }\n    \n    // 自动锚定当前认知状态\n    try {\n      const anchor = new Anchor(system.network);\n      await anchor.execute(query, mind);\n      logger.debug(`[CognitionManager] Auto-anchored state after recall: \"${query}\"`);\n    } catch (error) {\n      logger.error(`[CognitionManager] Failed to auto-anchor state:`, error);\n      // 锚定失败不影响recall结果\n    }\n    \n    return mind;\n  }\n\n  /**\n   * Remember - 保存新的记忆到角色的认知系统\n   * @param {string} roleId - 角色ID\n   * @param {Array} engrams - 记忆数组\n   */\n  async remember(roleId, engrams) {\n    logger.info(`[CognitionManager] Remember for role: ${roleId}, ${engrams.length} engrams`);\n    \n    const system = await this.getSystem(roleId);\n    const Engram = require('./Engram');\n    \n    for (const engramData of engrams) {\n      try {\n        // 创建Engram对象\n        const engram = new Engram({\n          content: engramData.content,\n          schema: engramData.schema,\n          strength: engramData.strength,\n          timestamp: Date.now()  // 使用当前时间戳\n        });\n        \n        if (!engram.isValid()) {\n          logger.warn(`[CognitionManager] Invalid engram (schema too short):`, engramData);\n          continue;\n        }\n        \n        // CognitionSystem现在会自动处理Memory存储\n        await system.remember(engram);\n        \n        logger.debug(`[CognitionManager] Processed engram:`, {\n          preview: engram.getPreview(),\n          strength: engram.strength\n        });\n        \n      } catch (error) {\n        logger.error(`[CognitionManager] Failed to process engram:`, error);\n      }\n    }\n    \n    // 保存更新后的认知数据\n    await this.saveSystem(roleId);\n    \n    logger.info(`[CognitionManager] Successfully saved ${engrams.length} engrams for role: ${roleId}`);\n  }\n\n  /**\n   * 解析 schema 字符串为概念列表\n   * @param {string} schema - 结构化的知识表示\n   * @returns {Array<string>} 概念列表\n   */\n  parseSchema(schema) {\n    if (!schema) return [];\n    \n    // 按行分割，处理缩进层级\n    const lines = schema.split('\\n').filter(line => line.trim());\n    const concepts = [];\n    \n    for (const line of lines) {\n      // 移除缩进和特殊符号，提取概念\n      const concept = line.trim().replace(/^[-*>#\\s]+/, '').trim();\n      if (concept) {\n        concepts.push(concept);\n      }\n    }\n    \n    return concepts;\n  }\n\n  /**\n   * 清理角色的认知数据\n   * @param {string} roleId - 角色ID\n   */\n  async clearRole(roleId) {\n    logger.warn(`[CognitionManager] Clearing cognition data for role: ${roleId}`);\n    \n    // 从内存中移除\n    this.systems.delete(roleId);\n    \n    // 删除文件\n    try {\n      const networkFilePath = this.getNetworkFilePath(roleId);\n      await fs.unlink(networkFilePath);\n      logger.info(`[CognitionManager] Deleted network file for role: ${roleId}`);\n    } catch (error) {\n      if (error.code !== 'ENOENT') {\n        logger.error(`[CognitionManager] Failed to delete network file for role ${roleId}:`, error);\n      }\n    }\n  }\n\n  /**\n   * 获取所有已存储的角色列表\n   */\n  async listRoles() {\n    try {\n      await fs.mkdir(this.basePath, { recursive: true });\n      const entries = await fs.readdir(this.basePath, { withFileTypes: true });\n      \n      const roles = [];\n      for (const entry of entries) {\n        if (entry.isDirectory()) {\n          // 检查是否有 network.json 文件\n          const networkFilePath = this.getNetworkFilePath(entry.name);\n          try {\n            await fs.access(networkFilePath);\n            roles.push(entry.name);\n          } catch {\n            // 没有 network.json 文件，跳过\n          }\n        }\n      }\n      \n      return roles;\n    } catch (error) {\n      logger.error('[CognitionManager] Failed to list roles:', error);\n      return [];\n    }\n  }\n}\n\nmodule.exports = CognitionManager;","const BasePouchCommand = require('../BasePouchCommand')\nconst CognitionArea = require('../areas/CognitionArea')\nconst RoleArea = require('../areas/action/RoleArea')\nconst StateArea = require('../areas/common/StateArea')\n// const ConsciousnessLayer = require('../layers/ConsciousnessLayer') // 已移除意识层\nconst CognitionLayer = require('../layers/CognitionLayer')\nconst RoleLayer = require('../layers/RoleLayer')\nconst { COMMANDS } = require('~/constants')\nconst { getGlobalResourceManager } = require('../../resource')\nconst DPMLContentParser = require('../../dpml/DPMLContentParser')\nconst SemanticRenderer = require('../../dpml/SemanticRenderer')\nconst CognitionManager = require('../../cognition/CognitionManager')\nconst ProjectManager = require('~/utils/ProjectManager')\nconst { getGlobalProjectManager } = require('~/utils/ProjectManager')\nconst logger = require('@promptx/logger')\n\n/**\n * ActionCommand - 角色激活命令\n * 使用三层Layer架构组装输出\n */\nclass ActionCommand extends BasePouchCommand {\n  constructor() {\n    super()\n    this.resourceManager = getGlobalResourceManager()\n    this.dpmlParser = new DPMLContentParser()\n    this.semanticRenderer = new SemanticRenderer()\n    this.projectManager = getGlobalProjectManager()\n    this.cognitionManager = CognitionManager.getInstance(this.resourceManager)\n  }\n\n  /**\n   * 组装Layers - 使用新的三层架构\n   */\n  async assembleLayers(args) {\n    const [roleId] = args\n\n    if (!roleId) {\n      // 错误情况：只创建角色层显示错误\n      const roleLayer = new RoleLayer()\n      roleLayer.addRoleArea(new StateArea(\n        'error',\n        ['使用 MCP PromptX 工具的 action 功能激活角色', '使用 MCP PromptX 工具的 welcome 功能查看可用角色']\n      ))\n      this.registerLayer(roleLayer)\n      return\n    }\n\n    try {\n      logger.debug(`[ActionCommand] 开始激活角色: ${roleId}`)\n      \n      // 初始化 ResourceManager\n      if (!this.resourceManager.initialized) {\n        await this.resourceManager.initializeWithNewArchitecture()\n      }\n      \n      // 获取角色信息\n      const roleInfo = await this.getRoleInfo(roleId)\n      logger.debug(`[ActionCommand] getRoleInfo结果:`, roleInfo)\n      \n      if (!roleInfo) {\n        logger.warn(`[ActionCommand] 角色 \"${roleId}\" 不存在！`)\n        const roleLayer = new RoleLayer()\n        roleLayer.addRoleArea(new StateArea(\n          `error: 角色 \"${roleId}\" 不存在`,\n          ['使用 welcome 功能查看所有可用角色', '使用正确的角色ID重试']\n        ))\n        this.registerLayer(roleLayer)\n        return\n      }\n\n      // 分析角色依赖\n      const dependencies = await this.analyzeRoleDependencies(roleInfo)\n\n      // 加载记忆网络\n      const mind = await this.loadMemories(roleId)\n      logger.debug(`[ActionCommand] 加载的 Mind:`, {\n        hasMind: !!mind,\n        nodeCount: mind?.activatedCues?.size || 0,\n        connectionCount: mind?.connections?.length || 0\n      })\n\n      // 设置上下文\n      this.context.roleId = roleId\n      this.context.roleInfo = roleInfo\n      this.context.mind = mind\n\n      // 1. 创建认知层 (最高优先级)\n      const cognitionLayer = CognitionLayer.createForPrime(mind, roleId)\n      this.registerLayer(cognitionLayer)\n\n      // 2. 创建角色层 (次优先级)\n      const roleLayer = new RoleLayer({ roleId, roleInfo })\n      \n      // 添加角色区域\n      const roleArea = new RoleArea(\n        roleId,\n        roleInfo.semantics,\n        this.semanticRenderer,\n        this.resourceManager,\n        dependencies.thoughts,\n        dependencies.executions,\n        roleInfo.metadata?.title || roleId\n      )\n      roleLayer.addRoleArea(roleArea)\n      \n      // 添加状态区域\n      const stateArea = new StateArea('role_activated')\n      roleLayer.addRoleArea(stateArea)\n      \n      this.registerLayer(roleLayer)\n\n    } catch (error) {\n      logger.error('Action command error:', error)\n      const roleLayer = new RoleLayer()\n      roleLayer.addRoleArea(new StateArea(\n        `error: ${error.message}`,\n        ['查看可用角色：使用 welcome 功能', '确认角色名称后重试']\n      ))\n      this.registerLayer(roleLayer)\n    }\n  }\n\n\n  /**\n   * 获取角色信息\n   */\n  async getRoleInfo(roleId) {\n    logger.debug(`[ActionCommand] getRoleInfo调用，角色ID: ${roleId}`)\n    \n    try {\n      logger.debug(`[ActionCommand] 调用loadResource前，ResourceManager状态:`, {\n        initialized: this.resourceManager.initialized\n      })\n      \n      const result = await this.resourceManager.loadResource(`@role://${roleId}`)\n      \n      logger.debug(`[ActionCommand] loadResource返回:`, result)\n      \n      if (!result || !result.success) {\n        logger.warn(`[ActionCommand] 未找到角色资源: @role://${roleId}`)\n        return null\n      }\n\n      const content = result.content\n      if (!content) {\n        logger.warn(`[ActionCommand] 角色资源内容为空: @role://${roleId}`)\n        return null\n      }\n\n      const parsed = this.dpmlParser.parseRoleDocument(content)\n      return {\n        id: roleId,\n        semantics: parsed,\n        metadata: result.metadata || {}\n      }\n    } catch (error) {\n      logger.error(`[ActionCommand] 获取角色信息失败:`, {\n        message: error.message,\n        stack: error.stack,\n        name: error.name,\n        toString: error.toString()\n      })\n      return null\n    }\n  }\n\n  /**\n   * 分析角色依赖\n   */\n  async analyzeRoleDependencies(roleInfo) {\n    const dependencies = {\n      thoughts: [],\n      executions: [],\n      knowledges: []\n    }\n\n    if (!roleInfo || !roleInfo.semantics) {\n      return dependencies\n    }\n\n    const extractReferences = (component) => {\n      const refs = []\n      if (!component) return refs\n\n      const extractFromNode = (node) => {\n        if (typeof node === 'string') {\n          const matches = node.matchAll(/<reference[^>]*protocol=\"([^\"]+)\"[^>]*resource=\"([^\"]+)\"[^>]*>/g)\n          for (const match of matches) {\n            refs.push({\n              protocol: match[1],\n              resource: match[2]\n            })\n          }\n        } else if (Array.isArray(node)) {\n          node.forEach(extractFromNode)\n        } else if (typeof node === 'object' && node !== null) {\n          Object.values(node).forEach(extractFromNode)\n        }\n      }\n\n      extractFromNode(component)\n      return refs\n    }\n\n    // 提取所有引用\n    const allRefs = [\n      ...extractReferences(roleInfo.semantics.personality),\n      ...extractReferences(roleInfo.semantics.principle),\n      ...extractReferences(roleInfo.semantics.knowledge)\n    ]\n\n    // 分类并加载资源\n    for (const ref of allRefs) {\n      try {\n        const resourceUrl = `@${ref.protocol}://${ref.resource}`\n        const result = await this.resourceManager.loadResource(resourceUrl)\n        \n        if (result && result.success) {\n          const content = result.content\n          if (ref.protocol === 'thought') {\n            dependencies.thoughts.push(content)\n          } else if (ref.protocol === 'execution') {\n            dependencies.executions.push(content)\n          } else if (ref.protocol === 'knowledge') {\n            dependencies.knowledges.push(content)\n          }\n        }\n      } catch (error) {\n        logger.warn(`Failed to load reference: @${ref.protocol}://${ref.resource}`, error)\n      }\n    }\n\n    return dependencies\n  }\n\n  /**\n   * 加载记忆数据 - 从认知系统获取 Mind 对象\n   */\n  async loadMemories(roleId) {\n    try {\n      logger.info(`[ActionCommand] loadMemories called for role: ${roleId}`)\n      logger.debug(`[ActionCommand] 开始加载角色 ${roleId} 的认知数据`)\n      \n      // 使用 CognitionManager 获取 Mind 对象\n      logger.info(`[ActionCommand] About to call cognitionManager.prime`)\n      const mind = await this.cognitionManager.prime(roleId)\n      logger.info(`[ActionCommand] cognitionManager.prime returned:`, mind)\n      \n      if (!mind) {\n        logger.warn(`[ActionCommand] 未找到角色 ${roleId} 的认知数据`)\n        return null\n      }\n      \n      logger.debug(`[ActionCommand] 加载的 Mind 对象:`, {\n        hasMind: !!mind,\n        nodeCount: mind.activatedCues?.size || 0,\n        connectionCount: mind.connections?.length || 0\n      })\n      \n      return mind\n    } catch (error) {\n      logger.warn(`[ActionCommand] 加载角色 ${roleId} 的认知数据失败:`, error)\n      return null\n    }\n  }\n}\n\nmodule.exports = ActionCommand","const BasePouchCommand = require('../BasePouchCommand')\nconst { getGlobalResourceManager } = require('../../resource')\nconst DPMLContentParser = require('../../dpml/DPMLContentParser')\nconst SemanticRenderer = require('../../dpml/SemanticRenderer')\nconst ProjectManager = require('~/utils/ProjectManager')\nconst { getGlobalProjectManager } = require('~/utils/ProjectManager')\nconst { getGlobalServerEnvironment } = require('~/utils/ServerEnvironment')\nconst { COMMANDS } = require('~/constants')\n\n/**\n * 智能学习锦囊命令\n * 支持加载thought、execution、memory等协议资源，以及角色的personality、principle、knowledge\n * 支持语义占位符渲染，将@引用展开为完整的语义内容\n */\nclass LearnCommand extends BasePouchCommand {\n  constructor () {\n    super()\n    // 使用全局单例 ResourceManager\n    this.resourceManager = getGlobalResourceManager()\n    this.dpmlParser = new DPMLContentParser()\n    this.semanticRenderer = new SemanticRenderer()\n    this.projectManager = getGlobalProjectManager()\n  }\n\n  getPurpose () {\n    return '智能学习指定协议的资源内容，支持thought、execution、memory、manual等协议以及角色组件，支持@引用的语义渲染'\n  }\n\n  /**\n   * 学习指定资源并返回结果\n   */\n  async getContent (args) {\n    const [resourceUrl] = args\n\n    if (!resourceUrl) {\n      return this.getUsageHelp()\n    }\n\n    // 复用ActionCommand的成功资源加载逻辑\n    return await this.loadLearnContentUsingActionLogic(resourceUrl)\n  }\n\n  /**\n   * 使用ActionCommand的成功逻辑加载学习内容\n   * 这个方法复用了ActionCommand.loadLearnContent的逻辑\n   */\n  async loadLearnContentUsingActionLogic(resourceUrl) {\n    try {\n      const result = await this.resourceManager.resolve(resourceUrl)\n      \n      if (!result.success) {\n        return this.formatErrorResponse(resourceUrl, result.error.message)\n      }\n\n      // 解析协议信息\n      const urlMatch = resourceUrl.match(/^(@[!?]?)?([a-zA-Z][a-zA-Z0-9_-]*):\\/\\/(.+)$/)\n      if (!urlMatch) {\n        return this.formatErrorResponse(resourceUrl, \"无效的资源URL格式\")\n      }\n      \n      const [, loadingSemantic, protocol, resourceId] = urlMatch\n\n      // 检查内容是否包含@引用，如果包含则进行语义渲染\n      let finalContent = result.content\n\n      // 对于manual协议，不进行语义渲染，保持原始内容\n      if (protocol !== 'manual' && this.containsReferences(result.content)) {\n        // 对于完整的DPML标签（如<execution>...</execution>），提取标签内容进行渲染\n        const innerContent = this.extractTagInnerContent(result.content, protocol)\n        \n        if (innerContent) {\n          // 解析标签内的混合内容（@引用 + 直接内容）\n          const tagSemantics = this.dpmlParser.parseTagContent(innerContent, protocol)\n          \n          // 使用SemanticRenderer进行语义占位符渲染\n          const renderedInnerContent = await this.semanticRenderer.renderSemanticContent(tagSemantics, this.resourceManager)\n          \n          // 如果渲染成功，重新包装为完整的DPML标签\n          if (renderedInnerContent && renderedInnerContent.trim()) {\n            finalContent = `<${protocol}>\\n${renderedInnerContent}\\n</${protocol}>`\n          }\n        }\n      }\n\n      return await this.formatSuccessResponse(protocol, resourceId, finalContent)\n    } catch (error) {\n      return this.formatErrorResponse(resourceUrl, error.message)\n    }\n  }\n\n  /**\n   * 检查内容是否包含@引用\n   * @param {string} content - 要检查的内容\n   * @returns {boolean} 是否包含@引用\n   */\n  containsReferences(content) {\n    const resourceRegex = /@([!?]?)([a-zA-Z][a-zA-Z0-9_-]*):\\/\\/([a-zA-Z0-9_\\/.,-]+)/g\n    return resourceRegex.test(content)\n  }\n\n  /**\n   * 提取完整的DPML标签内容\n   * @param {string} content - 要提取的内容\n   * @param {string} protocol - 协议\n   * @returns {string} 提取的完整DPML标签内容\n   */\n  extractTagInnerContent(content, protocol) {\n    const tagRegex = new RegExp(`<${protocol}>([\\\\s\\\\S]*?)<\\\\/${protocol}>`, 'i')\n    const match = content.match(tagRegex)\n    return match ? match[1].trim() : null\n  }\n\n  /**\n   * 格式化成功响应\n   */\n  async formatSuccessResponse (protocol, resourceId, content) {\n    const protocolLabels = {\n      thought: '🧠 思维模式',\n      execution: '⚡ 执行模式',\n      memory: '💾 记忆模式',\n      personality: '👤 角色人格',\n      principle: '⚖️ 行为原则',\n      knowledge: '📚 专业知识',\n      manual: '📖 工具手册',\n      tool: '🔧 工具代码'\n    }\n\n    const label = protocolLabels[protocol] || `📄 ${protocol}`\n\n    return `✅ **成功学习${label}：${resourceId}**\n\n## 📋 学习内容\n\n${content}\n\n## 🎯 学习效果\n- ✅ **已激活${label}能力**\n- ✅ **相关知识已整合到AI认知体系**\n- ✅ **可立即应用于实际场景**`\n  }\n\n  /**\n   * 格式化错误响应\n   */\n  formatErrorResponse (resourceUrl, errorMessage) {\n    return `❌ 学习资源失败：${resourceUrl}\n\n🔍 错误详情：\n${errorMessage}\n\n💡 支持的协议：\n- \\`thought://resource-id\\` - 学习思维模式\n- \\`execution://resource-id\\` - 学习执行模式  \n- \\`memory://resource-id\\` - 学习记忆模式\n- \\`personality://role-id\\` - 学习角色思维\n- \\`principle://role-id\\` - 学习角色原则\n- \\`knowledge://role-id\\` - 学习角色知识\n- \\`manual://tool-name\\` - 学习工具手册\n- \\`tool://tool-name\\` - 学习工具代码\n\n🔍 查看可用资源：\n使用 MCP PromptX action 工具查看角色的所有依赖`\n  }\n\n  /**\n   * 获取使用帮助\n   */\n  getUsageHelp () {\n    return `🎓 **Learn锦囊 - 智能学习系统**\n\n## 📖 基本用法\n通过 MCP PromptX learn 工具学习资源：\n\\`<protocol>://<resource-id>\\`\n\n## 🎯 支持的协议\n\n### 🔧 DPML核心协议\n- **\\`thought://\\`** - 思维模式资源\n- **\\`execution://\\`** - 执行模式资源\n- **\\`memory://\\`** - 记忆系统资源\n\n### 👤 角色组件协议\n- **\\`personality://\\`** - 角色人格特征\n- **\\`principle://\\`** - 行为原则\n- **\\`knowledge://\\`** - 专业知识\n\n## 📝 使用示例\n通过 MCP PromptX learn 工具学习各种资源：\n- 学习执行技能: \\`execution://deal-at-reference\\`\n- 学习思维模式: \\`thought://prompt-developer\\`  \n- 学习角色人格: \\`personality://video-copywriter\\`\n\n## 🔍 发现可学习资源\n- 使用 MCP PromptX action 工具查看角色需要的所有资源\n- 使用 MCP PromptX welcome 工具查看可用角色列表`\n  }\n\n  /**\n   * 获取PATEOAS导航信息\n   */\n  getPATEOAS (args) {\n    const [resourceUrl] = args\n\n    if (!resourceUrl) {\n      return {\n        currentState: 'learn_awaiting_resource',\n        availableTransitions: ['welcome', 'action'],\n        nextActions: [\n          {\n            name: '查看可用角色',\n            description: '返回角色选择页面',\n            method: 'MCP PromptX welcome 工具',\n            priority: 'high'\n          },\n          {\n            name: '生成学习计划',\n            description: '为特定角色生成学习计划',\n            method: 'MCP PromptX action 工具',\n            priority: 'high'\n          }\n        ]\n      }\n    }\n\n    const urlMatch = resourceUrl.match(/^([a-zA-Z]+):\\/\\/(.+)$/)\n    if (!urlMatch) {\n      return {\n        currentState: 'learn_error',\n        availableTransitions: ['welcome', 'action'],\n        nextActions: [\n          {\n            name: '查看使用帮助',\n            description: '重新学习命令使用方法',\n            method: 'MCP PromptX learn 工具',\n            priority: 'high'\n          }\n        ]\n      }\n    }\n\n    const [, protocol, resourceId] = urlMatch\n\n    return {\n      currentState: `learned_${protocol}`,\n      availableTransitions: ['learn', 'recall', 'welcome', 'action'],\n      nextActions: [\n        {\n          name: '继续学习',\n          description: '学习其他资源',\n          method: 'MCP PromptX learn 工具',\n          priority: 'medium'\n        },\n        {\n          name: '应用记忆',\n          description: '检索相关经验',\n          method: 'MCP PromptX recall 工具',\n          priority: 'medium'\n        },\n        {\n          name: '激活角色',\n          description: '激活完整角色能力',\n          method: 'MCP PromptX action 工具',\n          priority: 'high'\n        },\n        {\n          name: '查看角色列表',\n          description: '选择其他角色',\n          method: 'MCP PromptX welcome 工具',\n          priority: 'low'\n        }\n      ],\n      metadata: {\n        learnedResource: resourceUrl,\n        protocol,\n        resourceId,\n        systemVersion: '锦囊串联状态机 v1.0'\n      }\n    }\n  }\n\n  /**\n   * 重写execute方法以添加多项目状态检查\n   */\n  async execute (args = []) {\n    // 从执行上下文获取MCP信息\n    const mcpId = this.detectMcpId()\n    const ideType = await this.detectIdeType()\n    \n    // 获取多项目状态提示\n    const projectPrompt = await this.projectManager.generateTopLevelProjectPrompt('learn', mcpId, ideType)\n    \n    const purpose = this.getPurpose()\n    const content = await this.getContent(args)\n    const pateoas = await this.getPATEOAS(args)\n\n    return this.formatOutputWithProjectCheck(purpose, content, pateoas, projectPrompt)\n  }\n\n  /**\n   * 检测MCP进程ID\n   */\n  detectMcpId() {\n    const serverEnv = getGlobalServerEnvironment()\n    if (serverEnv.isInitialized()) {\n      return serverEnv.getMcpId()\n    }\n    return ProjectManager.generateMcpId()\n  }\n\n  /**\n   * 检测IDE类型 - 从配置文件读取，移除环境变量检测\n   */\n  async detectIdeType() {\n    const mcpId = this.detectMcpId()\n    return await this.projectManager.getIdeType(mcpId)\n  }\n  \n  /**\n   * 格式化带有项目检查的输出\n   */\n  formatOutputWithProjectCheck(purpose, content, pateoas, projectPrompt) {\n    const output = {\n      purpose,\n      content,\n      pateoas,\n      context: this.context,\n      format: this.outputFormat,\n      projectPrompt\n    }\n\n    if (this.outputFormat === 'json') {\n      return output\n    }\n\n    // 人类可读格式\n    return {\n      ...output,\n      toString () {\n        const divider = '='.repeat(60)\n\n        return `${projectPrompt}\n\n${divider}\n🎯 锦囊目的：${purpose}\n${divider}\n\n📜 锦囊内容：\n${content}\n\n📍 当前状态：${pateoas.currentState}\n${divider}\n`\n      }\n    }\n  }\n}\n\nmodule.exports = LearnCommand","const BasePouchCommand = require('../BasePouchCommand')\nconst CognitionArea = require('../areas/CognitionArea')\nconst StateArea = require('../areas/common/StateArea')\n// const ConsciousnessLayer = require('../layers/ConsciousnessLayer') // 已移除意识层\nconst CognitionLayer = require('../layers/CognitionLayer')\nconst RoleLayer = require('../layers/RoleLayer')\nconst { getGlobalResourceManager } = require('../../resource')\nconst CognitionManager = require('../../cognition/CognitionManager')\nconst logger = require('@promptx/logger')\n\n/**\n * 记忆检索命令 - 基于认知体系\n * 使用 CognitionManager 进行智能语义检索\n * 使用Layer架构组装输出\n */\nclass RecallCommand extends BasePouchCommand {\n  constructor () {\n    super()\n    this.lastSearchCount = 0\n    this.resourceManager = getGlobalResourceManager()\n    this.cognitionManager = CognitionManager.getInstance(this.resourceManager)\n  }\n\n  /**\n   * 组装Layers - 使用两层架构\n   */\n  async assembleLayers(args) {\n    // 解析参数：--role, query\n    const { role, query } = this.parseArgs(args)\n\n    if (!role) {\n      // 错误情况：只创建角色层显示错误\n      const roleLayer = new RoleLayer()\n      roleLayer.addRoleArea(new StateArea(\n        'error: 缺少必填参数 role',\n        ['使用方法：recall 角色ID [查询关键词]',\n         '示例：recall java-developer \"React Hooks\"',\n         '通过 welcome 工具查看所有可用角色']\n      ))\n      this.registerLayer(roleLayer)\n      return\n    }\n\n    logger.info('🧠 [RecallCommand] 开始记忆检索流程 (基于认知体系)')\n    logger.info(`🔍 [RecallCommand] 角色: ${role}, 查询内容: ${query ? `\"${query}\"` : '全部记忆'}`)\n\n    try {\n      let mind = null\n      if (query) {\n        // 有查询词时，执行 recall\n        mind = await this.cognitionManager.recall(role, query)\n      } else {\n        // 无查询词时，执行 prime 获取全局概览\n        mind = await this.cognitionManager.prime(role)\n      }\n      \n      if (!mind) {\n        logger.warn(`[RecallCommand] No mind returned for role: ${role}, query: ${query}`)\n      } else {\n        // Debug logging for mind structure in RecallCommand\n        logger.info('[RecallCommand] DEBUG - Mind structure after recall/prime:', {\n          hasMind: !!mind,\n          mindKeys: Object.keys(mind),\n          hasEngrams: !!mind.engrams,\n          engramsLength: mind.engrams?.length,\n          engramsType: typeof mind.engrams,\n          activatedCuesSize: mind.activatedCues?.size,\n          roleId: role,\n          query: query,\n          operationType: query ? 'recall' : 'prime'\n        })\n        \n        // Deep debug: log actual mind object structure\n        logger.debug('[RecallCommand] DEBUG - Full mind object:', JSON.stringify(mind, null, 2))\n      }\n      \n      const nodeCount = mind ? mind.activatedCues.size : 0\n      logger.info(`✅ [RecallCommand] 认知检索完成 - 激活 ${nodeCount} 个节点`)\n\n      // 设置上下文\n      this.context.roleId = role\n      this.context.query = query\n      this.context.mind = mind\n\n      // 1. 创建认知层 (最高优先级)\n      const operationType = query ? 'recall' : 'prime'\n      const cognitionLayer = query \n        ? CognitionLayer.createForRecall(mind, role, query)\n        : CognitionLayer.createForPrime(mind, role)\n      this.registerLayer(cognitionLayer)\n\n      // 2. 创建角色层 (次优先级)\n      const roleLayer = new RoleLayer({ roleId: role })\n      const stateArea = new StateArea('recall_completed', {\n        role,\n        query,\n        count: nodeCount\n      })\n      roleLayer.addRoleArea(stateArea)\n      this.registerLayer(roleLayer)\n\n    } catch (error) {\n      logger.error(`❌ [RecallCommand] 记忆检索失败: ${error.message}`)\n      logger.debug(`🐛 [RecallCommand] 错误堆栈: ${error.stack}`)\n      \n      // 错误情况：只创建角色层显示错误\n      const roleLayer = new RoleLayer()\n      const errorArea = new StateArea(\n        `error: ${error.message}`,\n        ['检查角色ID是否正确', '重试检索操作', '如持续失败，查看日志详情']\n      )\n      roleLayer.addRoleArea(errorArea)\n      this.registerLayer(roleLayer)\n    }\n  }\n\n  /**\n   * 解析命令参数\n   * @param {Array} args - 命令参数\n   * @returns {Object} 解析后的参数对象\n   */\n  parseArgs (args) {\n    if (!args || args.length === 0) {\n      return {}\n    }\n\n    // 如果第一个参数是对象（从MCP工具调用）\n    if (typeof args[0] === 'object') {\n      return args[0]\n    }\n\n    // 命令行格式：recall role [query]\n    const role = args[0]\n    const query = args.slice(1).join(' ')\n\n    return { role, query }\n  }\n}\n\nmodule.exports = RecallCommand","const BasePouchCommand = require('../BasePouchCommand')\nconst CognitionArea = require('../areas/CognitionArea')\nconst StateArea = require('../areas/common/StateArea')\n// const ConsciousnessLayer = require('../layers/ConsciousnessLayer') // 已移除意识层\nconst CognitionLayer = require('../layers/CognitionLayer')\nconst RoleLayer = require('../layers/RoleLayer')\nconst { getGlobalResourceManager } = require('../../resource')\nconst CognitionManager = require('../../cognition/CognitionManager')\nconst logger = require('@promptx/logger')\n\n/**\n * 记忆保存命令 - 基于认知体系\n * 使用 CognitionManager 保存角色专属记忆\n * 使用Layer架构组装输出\n */\nclass RememberCommand extends BasePouchCommand {\n  constructor () {\n    super()\n    this.resourceManager = getGlobalResourceManager()\n    this.cognitionManager = CognitionManager.getInstance(this.resourceManager)\n  }\n\n  /**\n   * 组装Layers - 使用两层架构\n   */\n  async assembleLayers(args) {\n    // 解析参数：role 和 engrams数组\n    const { role, engrams } = this.parseArgs(args)\n\n    if (!role || !engrams) {\n      // 错误情况：只创建角色层显示错误\n      const roleLayer = new RoleLayer()\n      roleLayer.addRoleArea(new StateArea(\n        'error: 缺少必填参数',\n        [this.getUsageHelp()]\n      ))\n      this.registerLayer(roleLayer)\n      return\n    }\n\n    try {\n      logger.info('🧠 [RememberCommand] 开始批量记忆保存流程')\n      logger.info(`📝 [RememberCommand] 批量保存 ${engrams.length} 个Engram`)\n      \n      // 使用 CognitionManager 批量保存记忆\n      await this.cognitionManager.remember(role, engrams)\n      logger.info('✅ [RememberCommand] 批量记忆保存完成')\n      \n      // 获取更新后的认知网络\n      const mind = await this.cognitionManager.prime(role)\n      \n      // 设置上下文\n      this.context.roleId = role\n      this.context.engrams = engrams\n      this.context.mind = mind\n\n      // 1. 创建认知层 (最高优先级)\n      const cognitionLayer = CognitionLayer.createForRemember(mind, role, engrams.length)\n      this.registerLayer(cognitionLayer)\n\n      // 2. 创建角色层 (次优先级)\n      const roleLayer = new RoleLayer({ roleId: role })\n      const stateArea = new StateArea('remember_completed', {\n        role,\n        count: engrams.length\n      })\n      roleLayer.addRoleArea(stateArea)\n      this.registerLayer(roleLayer)\n      \n    } catch (error) {\n      logger.error(`❌ [RememberCommand] 记忆保存失败: ${error.message}`)\n      logger.debug(`🐛 [RememberCommand] 错误堆栈: ${error.stack}`)\n      \n      // 错误情况：只创建角色层显示错误\n      const roleLayer = new RoleLayer()\n      roleLayer.addRoleArea(new StateArea(\n        `error: ${error.message}`,\n        ['检查角色ID是否正确', '验证记忆格式是否符合要求', '重试保存操作']\n      ))\n      this.registerLayer(roleLayer)\n    }\n  }\n\n  /**\n   * 解析命令参数\n   * @param {Array} args - 命令参数\n   * @returns {Object} 解析后的参数对象\n   */\n  parseArgs(args) {\n    if (!args || args.length === 0) {\n      return {}\n    }\n\n    // 如果第一个参数是对象（从MCP工具调用）\n    if (typeof args[0] === 'object') {\n      return args[0]\n    }\n\n    // 命令行格式暂不支持\n    return {}\n  }\n\n  /**\n   * 获取使用帮助\n   * @returns {string} 使用说明文本\n   */\n  getUsageHelp() {\n    return `❌ 错误：缺少必填参数\n\n🎯 **使用方法**：\nremember 工具需要两个参数：\n1. role - 角色ID\n2. engrams - 记忆数组\n\n📋 **Engram结构**：\n{\n  content: \"要记住的内容\",\n  schema: \"知识结构（用缩进表示层级）\",\n  strength: 0.8,  // 0-1之间，表示重要程度\n  type: \"ATOMIC\"  // ATOMIC|LINK|PATTERN\n}\n\n💡 **记忆类型说明**：\n- ATOMIC: 原子概念（名词、定义）\n- LINK: 关联关系（动词、连接）\n- PATTERN: 行为模式（流程、方法）`\n  }\n}\n\nmodule.exports = RememberCommand","const BasePouchCommand = require('../BasePouchCommand')\nconst { getGlobalResourceManager } = require('../../resource')\nconst CognitionManager = require('../../cognition/CognitionManager')\nconst logger = require('@promptx/logger')\n\n/**\n * 思考锦囊命令 - 基于认知心理学的思维链式推理\n * 使用 CognitionManager 进行递归深化的思考过程\n */\nclass ThinkCommand extends BasePouchCommand {\n  constructor () {\n    super()\n    this.resourceManager = getGlobalResourceManager()\n    this.cognitionManager = new CognitionManager(this.resourceManager)\n  }\n\n  getPurpose () {\n    return 'AI主动深度思考，通过认知循环生成洞察和结论'\n  }\n\n  async getContent (args) {\n    // 解析参数：role、thought对象\n    const { role, thought } = this.parseArgs(args)\n\n    if (!role || !thought) {\n      return this.getUsageHelp()\n    }\n\n    try {\n      logger.info('🤔 [ThinkCommand] 开始思考流程')\n      logger.info(`🧠 [ThinkCommand] 角色: ${role}, 模式: ${thought.thinkingPattern || '未指定'}`)\n      \n      // 处理 spreadActivationCues：如果是字符串，转换为数组\n      if (thought.spreadActivationCues && typeof thought.spreadActivationCues === 'string') {\n        thought.spreadActivationCues = thought.spreadActivationCues.split(' ').filter(cue => cue.trim() !== '');\n      }\n      \n      // 验证必需字段\n      if (!thought.goalEngram) {\n        throw new Error('Thought 必须包含 goalEngram')\n      }\n      if (!thought.thinkingPattern) {\n        throw new Error('Thought 必须包含 thinkingPattern')\n      }\n      if (!thought.spreadActivationCues || thought.spreadActivationCues.length === 0) {\n        throw new Error('Thought 必须包含 spreadActivationCues')\n      }\n      \n      // 使用 CognitionManager 进行思考\n      const prompt = await this.cognitionManager.think(role, thought)\n\n      logger.info('✅ [ThinkCommand] 思考指导生成完成')\n      return this.formatThinkResponse(thought, prompt, role)\n      \n    } catch (error) {\n      logger.error(`❌ [ThinkCommand] 思考失败: ${error.message}`)\n      logger.error(`🐛 [ThinkCommand] 错误堆栈:\\n${error.stack}`)\n      \n      return `❌ 思考失败：${error.message}\n\n📋 **错误堆栈**：\n\\`\\`\\`\n${error.stack}\n\\`\\`\\`\n\n💡 **可能的原因**：\n- 角色ID不正确\n- Thought 对象格式错误\n- 缺少必需的字段（goalEngram、thinkingPattern、spreadActivationCues）\n- 思维模式不存在\n\n🔧 **建议操作**：\n1. 确保 Thought 包含所有必需字段\n2. 检查角色是否已激活\n3. 验证思维模式名称是否正确`\n    }\n  }\n\n  /**\n   * 解析命令行参数\n   */\n  parseArgs(args) {\n    let role = ''\n    let thought = null\n    \n    // 第一个参数是role\n    if (args.length > 0) {\n      role = args[0]\n    }\n    \n    // 第二个参数是JSON格式的thought对象\n    if (args.length > 1) {\n      try {\n        thought = JSON.parse(args[1])\n        if (typeof thought !== 'object') {\n          throw new Error('thought必须是对象格式')\n        }\n      } catch (error) {\n        logger.error(`❌ [ThinkCommand] 解析thought参数失败: ${error.message}`)\n        thought = null\n      }\n    }\n    \n    return { role, thought }\n  }\n\n  /**\n   * 格式化思考响应\n   */\n  formatThinkResponse (thought, prompt, role) {\n    const hasInsights = thought.insightEngrams && thought.insightEngrams.length > 0\n    const hasConclusion = !!thought.conclusionEngram\n    const hasConfidence = thought.confidence !== undefined\n    \n    let status = '初始思考'\n    if (hasConfidence) {\n      status = '完整思考'\n    } else if (hasConclusion) {\n      status = '形成结论'\n    } else if (hasInsights) {\n      status = '产生洞察'\n    }\n    \n    return `🧠 思考指导已生成\n\n## 📊 当前思考状态\n- **角色**: ${role}\n- **状态**: ${status}\n- **目标**: ${thought.goalEngram.content}\n- **思维模式**: ${thought.thinkingPattern}\n- **激活线索**: ${thought.spreadActivationCues.join(', ')}\n\n## 💭 生成的思考指导\n${prompt}\n\n## 📊 当前进展\n${hasInsights ? `- **洞察数量**: ${thought.insightEngrams.length}` : '- **洞察**: 尚未生成'}\n${hasConclusion ? `- **已形成结论**: ${thought.conclusionEngram.content}` : '- **结论**: 尚未形成'}\n${hasConfidence ? `- **置信度**: ${thought.confidence}` : '- **置信度**: 尚未评估'}\n\n## 🔄 思考深化建议\n${this.getDeepingAdvice(thought)}`\n  }\n\n  /**\n   * 获取思考深化建议\n   */\n  getDeepingAdvice(thought) {\n    const hasInsights = thought.insightEngrams && thought.insightEngrams.length > 0\n    const hasConclusion = !!thought.conclusionEngram\n    const hasConfidence = thought.confidence !== undefined\n    \n    if (!hasInsights) {\n      return '- 基于检索到的记忆，生成关键洞察'\n    } else if (!hasConclusion) {\n      return '- 综合洞察形成明确结论'\n    } else if (!hasConfidence) {\n      return '- 评估结论的置信度'\n    } else {\n      return '- 思考已完整，可以开始新的思考目标'\n    }\n  }\n\n  /**\n   * 获取使用帮助\n   */\n  getUsageHelp () {\n    return `🤔 **Think锦囊 - AI深度思考系统**\n\n## 📖 基本用法\nthink 角色ID '{\"goalEngram\": {...}, \"thinkingPattern\": \"...\", \"spreadActivationCues\": [...]}'\n\n## 🎯 必填参数\n- **角色ID**: 进行思考的角色ID\n- **thought对象**: JSON格式的Thought对象，必须包含：\n  - **goalEngram**: 思考目标\n  - **thinkingPattern**: 思维模式\n  - **spreadActivationCues**: 激活线索\n\n## 💭 Thought 结构\n\\`\\`\\`json\n{\n  \"goalEngram\": {\n    \"content\": \"推理天空呈现蓝色的光学原理\",\n    \"schema\": \"自然现象\\\\n  光学现象\\\\n    大气散射\"\n  },\n  \"thinkingPattern\": \"reasoning\",\n  \"spreadActivationCues\": [\"光学\", \"大气\", \"散射\", \"颜色\"],\n  \"insightEngrams\": [...],     // 可选\n  \"conclusionEngram\": {...},    // 可选\n  \"confidence\": 0.95           // 可选\n}\n\\`\\`\\`\n\n## 📋 使用示例\n\\`\\`\\`bash\n# 第一次思考\nthink scientist '{\"goalEngram\": {\"content\": \"推理天空蓝色原理\", \"schema\": \"物理学\\\\n  光学\"}, \"thinkingPattern\": \"reasoning\", \"spreadActivationCues\": [\"光学\", \"大气\"]}'\n\n# 深入思考\nthink scientist '{\"goalEngram\": {...}, \"thinkingPattern\": \"reasoning\", \"spreadActivationCues\": [...], \"insightEngrams\": [...]}'\n\n# 使用创造性思维\nthink writer '{\"goalEngram\": {...}, \"thinkingPattern\": \"creative\", \"spreadActivationCues\": [...]}'\n\\`\\`\\`\n\n## 🧠 思维模式\n- **reasoning**: 推理思维（逻辑分析）\n- **creative**: 创造性思维 [未实现]\n- **critical**: 批判性思维 [未实现]\n- **systematic**: 系统性思维 [未实现]\n- **narrative**: 叙事思维 [未实现]\n- **intuitive**: 直觉思维 [未实现]\n- **analytical**: 分析思维 [未实现]\n- **experiential**: 经验思维 [未实现]\n\n## 🔍 配套工具\n- **激活角色**: action 工具激活角色并启动语义网络\n- **检索记忆**: recall 工具为思考提供记忆支持\n- **保存洞察**: remember 工具保存重要的思考成果`\n  }\n\n  /**\n   * 获取PATEOAS导航信息\n   */\n  getPATEOAS (args) {\n    const hasThought = args.length >= 2\n\n    if (!hasThought) {\n      return {\n        currentState: 'think_awaiting_input',\n        availableTransitions: ['action', 'welcome'],\n        nextActions: [\n          {\n            name: '激活角色',\n            description: '选择并激活思考角色',\n            method: 'MCP PromptX action 工具',\n            priority: 'high'\n          },\n          {\n            name: '查看角色',\n            description: '查看可用角色列表',\n            method: 'MCP PromptX welcome 工具',\n            priority: 'medium'\n          }\n        ]\n      }\n    }\n\n    return {\n      currentState: 'thinking_in_progress',\n      availableTransitions: ['think', 'remember', 'recall'],\n      nextActions: [\n        {\n          name: '继续思考',\n          description: '基于生成的prompt继续深化思考',\n          method: 'MCP PromptX think 工具',\n          priority: 'high'\n        },\n        {\n          name: '保存洞察',\n          description: '将重要洞察保存为记忆',\n          method: 'MCP PromptX remember 工具',\n          priority: 'medium'\n        },\n        {\n          name: '检索记忆',\n          description: '检索相关记忆支持思考',\n          method: 'MCP PromptX recall 工具',\n          priority: 'medium'\n        }\n      ],\n      metadata: {\n        thinkingRole: args[0],\n        thinkingDepth: this.getThinkingDepth(args[1]),\n        timestamp: new Date().toISOString(),\n        systemVersion: '锦囊串联状态机 v1.0'\n      }\n    }\n  }\n\n  /**\n   * 分析思考深度\n   */\n  getThinkingDepth(thoughtStr) {\n    try {\n      const thought = JSON.parse(thoughtStr)\n      if (thought.confidence !== undefined) return 'complete'\n      if (thought.conclusionEngram) return 'conclusion'\n      if (thought.insightEngrams && thought.insightEngrams.length > 0) return 'insights'\n      return 'initial'\n    } catch {\n      return 'unknown'\n    }\n  }\n}\n\nmodule.exports = ThinkCommand","const BasePouchCommand = require('../BasePouchCommand')\nconst { getGlobalResourceManager } = require('../../resource')\nconst ToolSandbox = require('~/toolx/ToolSandbox')\nconst logger = require('@promptx/logger')\n\n/**\n * Tool命令处理器\n * 实现toolx MCP工具，执行通过@tool协议声明的工具\n */\nclass ToolCommand extends BasePouchCommand {\n  constructor() {\n    super()\n    this.resourceManager = null\n  }\n\n  /**\n   * 获取或初始化ResourceManager\n   */\n  async getResourceManager() {\n    if (!this.resourceManager) {\n      this.resourceManager = getGlobalResourceManager()\n      // 确保ResourceManager已初始化\n      if (!this.resourceManager.initialized) {\n        await this.resourceManager.initializeWithNewArchitecture()\n      }\n    }\n    return this.resourceManager\n  }\n\n  // BasePouchCommand的抽象方法实现\n  getPurpose() {\n    return '执行通过@tool协议声明的JavaScript工具'\n  }\n\n  async getContent(args) {\n    try {\n      // 处理参数：如果是数组格式，需要转换为对象格式\n      let toolArgs;\n      logger.info('[ToolCommand] getContent 接收到的 args:', args);\n      logger.info('[ToolCommand] args 类型:', Array.isArray(args) ? 'Array' : typeof args);\n      \n      if (Array.isArray(args)) {\n        // 从CLI调用时，args是数组：[tool_resource, parameters, ...options]\n        logger.info('[ToolCommand] 数组参数长度:', args.length);\n        logger.info('[ToolCommand] args[0]:', args[0]);\n        logger.info('[ToolCommand] args[1] 类型:', typeof args[1]);\n        logger.info('[ToolCommand] args[1] 值:', args[1]);\n        \n        if (args.length >= 2) {\n          // 如果 parameters 是 JSON 字符串，解析它\n          let parameters = args[1];\n          if (typeof parameters === 'string') {\n            logger.info('[ToolCommand] 尝试解析 JSON 字符串参数');\n            try {\n              parameters = JSON.parse(parameters);\n              logger.info('[ToolCommand] JSON 解析成功:', parameters);\n            } catch (e) {\n              logger.warn('[ToolCommand] JSON 解析失败，保持原样:', e.message);\n              // 如果解析失败，保持原样（可能是其他格式的字符串参数）\n            }\n          }\n          \n          toolArgs = {\n            tool_resource: args[0],\n            parameters: parameters,\n            rebuild: args.includes('--rebuild'),\n            timeout: this.extractTimeout(args)\n          };\n          logger.info('[ToolCommand] 构建的 toolArgs:', toolArgs);\n        } else {\n          throw new Error('Invalid arguments: expected [tool_resource, parameters]');\n        }\n      } else {\n        // 从其他方式调用时，args已经是对象格式\n        toolArgs = args;\n        logger.info('[ToolCommand] 直接使用对象格式参数:', toolArgs);\n      }\n      \n      // 执行工具调用\n      const result = await this.executeToolInternal(toolArgs)\n      \n      // 格式化响应 - 检查工具内部执行状态\n      if (result.success) {\n        // 检查工具内部是否也成功\n        const actualToolResult = result.result\n        console.log('[DEBUG] actualToolResult structure:', JSON.stringify(actualToolResult, null, 2))\n        const isToolInternalSuccess = this.isToolInternalSuccess(actualToolResult)\n        console.log('[DEBUG] isToolInternalSuccess result:', isToolInternalSuccess)\n        \n        if (isToolInternalSuccess) {\n          return `🔧 Tool执行成功\n\n📋 工具资源: ${result.tool_resource}\n📊 执行结果:\n${JSON.stringify(actualToolResult, null, 2)}\n\n⏱️ 性能指标:\n- 执行时间: ${result.metadata.execution_time_ms}ms\n- 时间戳: ${result.metadata.timestamp}\n- 版本: ${result.metadata.version}`\n        } else {\n          // ToolSandbox成功，但工具内部失败\n          const internalError = this.extractToolInternalError(actualToolResult)\n          return this.formatToolInternalError(result.tool_resource, internalError, result.metadata)\n        }\n      } else {\n        return `❌ Tool执行失败\n\n📋 工具资源: ${result.tool_resource}\n❌ 错误信息: ${result.error.message}\n🏷️ 错误类型: ${result.error.type}\n🔢 错误代码: ${result.error.code}\n\n⏱️ 执行时间: ${result.metadata.execution_time_ms}ms`\n      }\n    } catch (error) {\n      return `❌ Tool执行异常\n\n错误详情: ${error.message}\n\n💡 请检查:\n1. 工具资源引用格式是否正确 (@tool://tool-name)\n2. 工具参数是否有效\n3. 工具文件是否存在并可执行`\n    }\n  }\n\n  getPATEOAS(args) {\n    return {\n      currentState: 'tool_executed',\n      nextActions: [\n        {\n          action: 'execute_another_tool',\n          description: '执行其他工具',\n          method: 'promptx tool'\n        },\n        {\n          action: 'view_available_tools', \n          description: '查看可用工具',\n          method: 'promptx welcome'\n        }\n      ]\n    }\n  }\n\n  /**\n   * 内部工具执行方法 - 使用ToolSandbox三阶段执行流程\n   * @param {Object} args - 命令参数\n   * @param {string} args.tool_resource - 工具资源引用，格式：@tool://tool-name\n   * @param {Object} args.parameters - 传递给工具的参数\n   * @param {boolean} args.rebuild - 是否强制重建沙箱（默认false）\n   * @param {number} args.timeout - 工具执行超时时间（毫秒，默认30000ms）\n   * @returns {Promise<Object>} 执行结果\n   */\n  async executeToolInternal(args) {\n    const startTime = Date.now()\n    let sandbox = null\n    \n    try {\n      logger.info('[ToolCommand] executeToolInternal 接收到的 args:', JSON.stringify(args, null, 2))\n      \n      // 1. 参数验证\n      this.validateArguments(args)\n      \n      const { tool_resource, parameters, rebuild = false, timeout = 30000 } = args\n      \n      logger.info('[ToolCommand] 解构后的 parameters:', JSON.stringify(parameters, null, 2))\n      logger.info('[ToolCommand] parameters 类型:', typeof parameters)\n      logger.debug(`[PromptXTool] 开始执行工具: ${tool_resource}`)\n      \n      // 2. 构建沙箱选项并创建ToolSandbox实例\n      const sandboxOptions = { rebuild, timeout }\n      logger.debug(`[PromptXTool] 沙箱选项:`, sandboxOptions)\n      sandbox = new ToolSandbox(tool_resource, sandboxOptions)\n      \n      // 3. 设置ResourceManager\n      const resourceManager = await this.getResourceManager()\n      sandbox.setResourceManager(resourceManager)\n      \n      // 4. ToolSandbox三阶段执行流程\n      logger.debug(`[PromptXTool] Phase 1: 分析工具`)\n      const analysisResult = await sandbox.analyze()\n      \n      logger.debug(`[PromptXTool] Phase 2: 准备依赖`, { dependencies: analysisResult.dependencies })\n      await sandbox.prepareDependencies()\n      \n      logger.debug(`[PromptXTool] Phase 3: 执行工具`)\n      logger.info('[ToolCommand] 传递给 sandbox.execute 的 parameters:', JSON.stringify(parameters, null, 2))\n      logger.info('[ToolCommand] parameters 的类型:', typeof parameters)\n      const result = await sandbox.execute(parameters)\n      \n      // 5. 格式化成功结果 \n      return this.formatSuccessResult(result, tool_resource, startTime)\n      \n    } catch (error) {\n      // 6. 智能错误处理 - 检查是否可以自动重试\n      if (error.intelligentError && this.isAutoRetryable(error.intelligentError)) {\n        logger.info(`[PromptXTool] 检测到可自动恢复错误，尝试自动重试: ${error.intelligentError.type}`)\n        \n        try {\n          // 清理当前沙箱\n          await sandbox.cleanup()\n          \n          // 使用重试参数重新创建沙箱\n          const retryParameters = error.intelligentError.agentInstructions.retryParameters\n          const retryArgs = { ...args, ...retryParameters }\n          \n          logger.debug(`[PromptXTool] 自动重试参数:`, retryArgs)\n          \n          // 递归调用（但限制重试次数）\n          if (!args._retryCount) args._retryCount = 0\n          if (args._retryCount < 1) { // 最多重试1次\n            retryArgs._retryCount = args._retryCount + 1\n            logger.info(`[PromptXTool] 开始自动重试 (${retryArgs._retryCount}/1)`)\n            return await this.executeToolInternal(retryArgs)\n          } else {\n            logger.warn(`[PromptXTool] 已达到最大重试次数，停止重试`)\n          }\n        } catch (retryError) {\n          logger.error(`[PromptXTool] 自动重试失败: ${retryError.message}`)\n          // 使用重试错误而不是原始错误\n          error = retryError\n        }\n      }\n      \n      // 7. 格式化错误结果  \n      logger.error(`[PromptXTool] 工具执行失败: ${error.message}`, error)\n      return this.formatErrorResult(error, args.tool_resource, startTime)\n    } finally {\n      // 7. 清理沙箱资源\n      if (sandbox) {\n        try {\n          await sandbox.cleanup()\n        } catch (cleanupError) {\n          logger.warn(`[PromptXTool] 沙箱清理失败: ${cleanupError.message}`)\n        }\n      }\n    }\n  }\n\n  /**\n   * 验证命令参数\n   * @param {Object} args - 命令参数\n   */\n  validateArguments(args) {\n    if (!args) {\n      throw new Error('Missing arguments')\n    }\n\n    if (!args.tool_resource) {\n      throw new Error('Missing required parameter: tool_resource')\n    }\n\n    if (!args.tool_resource.startsWith('@tool://')) {\n      throw new Error('Invalid tool_resource format. Must start with @tool://')\n    }\n\n    if (!args.parameters || typeof args.parameters !== 'object') {\n      throw new Error('Missing or invalid parameters. Must be an object')\n    }\n  }\n\n  /**\n   * 格式化成功结果 - 适配ToolSandbox返回格式\n   * @param {*} result - 工具执行结果\n   * @param {string} toolResource - 工具资源引用\n   * @param {number} startTime - 开始时间\n   * @returns {Object} 格式化的成功结果\n   */\n  formatSuccessResult(result, toolResource, startTime) {\n    const duration = Date.now() - startTime\n    \n    return {\n      success: true,\n      tool_resource: toolResource,\n      result: result, // ToolSandbox直接返回工具结果\n      metadata: {\n        executor: 'ToolSandbox',\n        execution_time_ms: duration,\n        timestamp: new Date().toISOString(),\n        version: '1.0.0'\n      }\n    }\n  }\n\n  /**\n   * 格式化错误结果 - 适配ToolSandbox智能错误格式\n   * @param {Error} error - 错误对象\n   * @param {string} toolResource - 工具资源引用（可能为空）\n   * @param {number} startTime - 开始时间\n   * @returns {Object} 格式化的错误结果\n   */\n  formatErrorResult(error, toolResource, startTime) {\n    const duration = Date.now() - startTime\n    const executionId = this.generateExecutionId()\n    \n    // 检查是否为智能错误\n    let errorCode, errorMessage, errorType = 'UNKNOWN_ERROR'\n    let agentInstructions = null\n    \n    if (error.intelligentError) {\n      // 使用智能错误管理器提供的信息\n      errorType = error.intelligentError.type\n      errorCode = this.mapIntelligentErrorToCode(errorType)\n      errorMessage = error.intelligentError.formattedMessage\n      agentInstructions = error.intelligentError.agentInstructions\n    } else {\n      // 回退到传统错误处理\n      errorCode = this.getErrorCode(error)\n      errorMessage = error.message\n    }\n    \n    const result = {\n      success: false,\n      tool_resource: toolResource || 'unknown',\n      error: {\n        code: errorCode,\n        type: errorType,\n        message: errorMessage,\n        details: {\n          executionId: executionId,\n          executionTime: `${duration}ms`,\n          stack: error.stack\n        }\n      },\n      metadata: {\n        executor: 'ToolSandbox',\n        timestamp: new Date().toISOString(),\n        execution_time_ms: duration\n      }\n    }\n    \n    // 如果有Agent指令，添加到metadata中\n    if (agentInstructions) {\n      result.metadata.agentInstructions = agentInstructions\n    }\n    \n    return result\n  }\n\n  /**\n   * 将智能错误类型映射到传统错误代码\n   * @param {string} intelligentErrorType - 智能错误类型\n   * @returns {string} 错误代码\n   */\n  mapIntelligentErrorToCode(intelligentErrorType) {\n    const mapping = {\n      'DEPENDENCY_MISSING': 'DEPENDENCY_ERROR',\n      'UNDECLARED_DEPENDENCY': 'DEPENDENCY_ERROR', \n      'DEPENDENCY_INSTALL_FAILED': 'DEPENDENCY_ERROR',\n      'TOOL_LOADING_ERROR': 'ANALYSIS_ERROR',\n      'PARAMETER_VALIDATION_ERROR': 'VALIDATION_ERROR',\n      'SANDBOX_ENVIRONMENT_ERROR': 'EXECUTION_ERROR',\n      'NETWORK_TIMEOUT': 'EXECUTION_TIMEOUT',\n      'UNKNOWN_ERROR': 'UNKNOWN_ERROR'\n    }\n    \n    return mapping[intelligentErrorType] || 'UNKNOWN_ERROR'\n  }\n\n  /**\n   * 根据错误类型获取错误代码 - 增强支持ToolSandbox错误\n   * @param {Error} error - 错误对象\n   * @returns {string} 错误代码\n   */\n  getErrorCode(error) {\n    const message = error.message.toLowerCase()\n    \n    // ToolSandbox特有错误\n    if (message.includes('analyze') || message.includes('analysis')) {\n      return 'ANALYSIS_ERROR'\n    }\n    if (message.includes('dependencies') || message.includes('pnpm')) {\n      return 'DEPENDENCY_ERROR'\n    }\n    if (message.includes('sandbox') || message.includes('execution')) {\n      return 'EXECUTION_ERROR'\n    }\n    if (message.includes('validation') || message.includes('validate')) {\n      return 'VALIDATION_ERROR'\n    }\n    \n    // 通用错误\n    if (message.includes('not found')) {\n      return 'TOOL_NOT_FOUND'\n    }\n    if (message.includes('invalid tool_resource format')) {\n      return 'INVALID_TOOL_RESOURCE'\n    }\n    if (message.includes('missing')) {\n      return 'MISSING_PARAMETER'\n    }\n    if (message.includes('syntax')) {\n      return 'TOOL_SYNTAX_ERROR'\n    }\n    if (message.includes('timeout')) {\n      return 'EXECUTION_TIMEOUT'\n    }\n    \n    return 'UNKNOWN_ERROR'\n  }\n\n  /**\n   * 生成执行ID\n   * @returns {string} 唯一的执行ID\n   */\n  generateExecutionId() {\n    return `tool_exec_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`\n  }\n\n  /**\n   * 从参数数组中提取timeout值\n   * @param {Array} args - 参数数组\n   * @returns {number|undefined} timeout值\n   */\n  extractTimeout(args) {\n    const timeoutIndex = args.indexOf('--timeout');\n    if (timeoutIndex !== -1 && timeoutIndex < args.length - 1) {\n      const timeout = parseInt(args[timeoutIndex + 1]);\n      return isNaN(timeout) ? undefined : timeout;\n    }\n    return undefined;\n  }\n\n  /**\n   * 检查智能错误是否可以自动重试\n   * @param {Object} intelligentError - 智能错误对象\n   * @returns {boolean} 是否可自动重试\n   */\n  isAutoRetryable(intelligentError) {\n    return intelligentError.agentInstructions && \n           intelligentError.agentInstructions.autoRetryable === true &&\n           intelligentError.agentInstructions.retryParameters\n  }\n\n  /**\n   * 检查工具内部执行是否成功\n   * @param {*} toolResult - 工具返回的结果\n   * @returns {boolean} 工具内部是否成功\n   */\n  isToolInternalSuccess(toolResult) {\n    // 优先检查是否有data字段，这可能是ToolSandbox包装的结果\n    if (toolResult && typeof toolResult === 'object' && toolResult.data) {\n      // 如果data是对象且包含success字段，检查data的success\n      if (typeof toolResult.data === 'object' && 'success' in toolResult.data) {\n        return toolResult.data.success === true\n      }\n    }\n    \n    // 检查顶层success字段\n    if (toolResult && typeof toolResult === 'object' && 'success' in toolResult) {\n      return toolResult.success === true\n    }\n    \n    // 如果工具返回结果不包含success字段，认为是成功的（兼容旧工具）\n    return true\n  }\n\n  /**\n   * 从工具内部结果中提取错误信息\n   * @param {*} toolResult - 工具返回的结果\n   * @returns {Object} 错误信息\n   */\n  extractToolInternalError(toolResult) {\n    // 优先从data字段中提取错误信息\n    if (toolResult && typeof toolResult === 'object' && toolResult.data && \n        typeof toolResult.data === 'object' && toolResult.data.error) {\n      return {\n        code: toolResult.data.error.code || 'TOOL_INTERNAL_ERROR',\n        message: toolResult.data.error.message || '工具内部执行失败',\n        details: toolResult.data.error.details || toolResult.data.error\n      }\n    }\n    \n    // 检查顶层错误信息\n    if (toolResult && typeof toolResult === 'object' && toolResult.error) {\n      return {\n        code: toolResult.error.code || 'TOOL_INTERNAL_ERROR',\n        message: toolResult.error.message || '工具内部执行失败',\n        details: toolResult.error.details || toolResult.error\n      }\n    }\n    \n    return {\n      code: 'TOOL_INTERNAL_ERROR',\n      message: '工具内部执行失败，但未提供错误详情',\n      details: JSON.stringify(toolResult)\n    }\n  }\n\n  /**\n   * 格式化工具内部错误\n   * @param {string} toolResource - 工具资源\n   * @param {Object} internalError - 内部错误信息\n   * @param {Object} metadata - 元数据\n   * @returns {string} 格式化的错误信息\n   */\n  formatToolInternalError(toolResource, internalError, metadata) {\n    // 尝试应用智能错误分析\n    const intelligentError = this.analyzeToolInternalError(internalError, toolResource)\n    \n    return `❌ Tool内部执行失败\n\n📋 工具资源: ${toolResource}\n❌ 错误信息: ${intelligentError.message}\n🏷️ 错误类型: ${intelligentError.type}\n🔢 错误代码: ${intelligentError.code}\n\n💡 智能建议:\n${intelligentError.suggestion}\n\n⏱️ 执行时间: ${metadata.execution_time_ms}ms`\n  }\n\n  /**\n   * 分析工具内部错误并提供智能建议\n   * @param {Object} internalError - 内部错误\n   * @param {string} toolResource - 工具资源\n   * @returns {Object} 智能分析结果\n   */\n  analyzeToolInternalError(internalError, toolResource) {\n    const message = internalError.message.toLowerCase()\n    const details = internalError.details || ''\n    \n    // 依赖相关错误\n    if (message.includes('is not a function') || message.includes('cannot find module')) {\n      return {\n        code: 'DEPENDENCY_ERROR',\n        type: 'DEPENDENCY_USAGE_ERROR',\n        message: internalError.message,\n        suggestion: `🔧 依赖使用错误：\n• 检查依赖的正确用法\n• 确认依赖版本兼容性\n• 可能需要使用 \"rebuild\": true 重建沙箱\n\n💡 建议操作：\ntoolx ${toolResource} {\"rebuild\": true, ...其他参数}`\n      }\n    }\n    \n    // 参数验证错误\n    if (message.includes('validation') || message.includes('parameter')) {\n      return {\n        code: 'PARAMETER_ERROR',\n        type: 'PARAMETER_VALIDATION_ERROR', \n        message: internalError.message,\n        suggestion: `📝 参数错误：\n• 检查传入的参数格式和类型\n• 确认必需参数是否缺失\n• 参考工具的schema定义`\n      }\n    }\n    \n    // 网络或外部服务错误\n    if (message.includes('timeout') || message.includes('network') || message.includes('fetch')) {\n      return {\n        code: 'NETWORK_ERROR',\n        type: 'EXTERNAL_SERVICE_ERROR',\n        message: internalError.message,\n        suggestion: `🌐 网络服务错误：\n• 检查网络连接状态\n• 确认外部API服务可用性\n• 稍后重试可能解决问题`\n      }\n    }\n    \n    // 默认分析\n    return {\n      code: internalError.code || 'TOOL_INTERNAL_ERROR',\n      type: 'UNKNOWN_TOOL_ERROR',\n      message: internalError.message,\n      suggestion: `🔧 工具内部错误：\n• 这可能是工具代码的逻辑问题\n• 检查工具的实现是否正确\n• 如果问题持续，请联系工具开发者\n\n🐛 错误详情：\n${typeof details === 'string' ? details : JSON.stringify(details, null, 2)}`\n    }\n  }\n\n  /**\n   * 获取工具命令的元信息 - ToolSandbox版本\n   * @returns {Object} 命令元信息\n   */\n  getMetadata() {\n    return {\n      name: 'toolx',\n      description: '使用ToolSandbox执行通过@tool协议声明的工具',\n      version: '2.0.0',\n      author: 'PromptX Framework',\n      executor: 'ToolSandbox',\n      supports: {\n        protocols: ['@tool://'],\n        formats: ['.tool.js'],\n        features: [\n          'ToolSandbox沙箱执行',\n          '自动依赖管理',\n          '三阶段执行流程',\n          'pnpm依赖安装',\n          '参数验证',\n          '错误处理',\n          '执行监控',\n          '资源清理'\n        ]\n      }\n    }\n  }\n}\n\nmodule.exports = ToolCommand","/**\n * 锦囊命令导出\n */\n\nconst InitCommand = require('./InitCommand')\nconst WelcomeCommand = require('./WelcomeCommand')\nconst ActionCommand = require('./ActionCommand')\nconst LearnCommand = require('./LearnCommand')\nconst RecallCommand = require('./RecallCommand')\nconst RememberCommand = require('./RememberCommand')\nconst ThinkCommand = require('./ThinkCommand')\nconst ToolCommand = require('./ToolCommand')\n\nmodule.exports = {\n  InitCommand,\n  WelcomeCommand,\n  ActionCommand,\n  LearnCommand,\n  RecallCommand,\n  RememberCommand,\n  ThinkCommand,\n  ToolCommand\n}\n","const PouchStateMachine = require('./state/PouchStateMachine')\nconst PouchRegistry = require('./PouchRegistry')\nconst commands = require('./commands')\nconst { COMMANDS } = require('~/constants')\nconst logger = require('@promptx/logger')\n\n/**\n * 锦囊CLI主入口\n * 提供命令行接口和统一的执行入口\n */\nclass PouchCLI {\n  constructor () {\n    this.stateMachine = new PouchStateMachine()\n    this.registry = new PouchRegistry()\n    this.initialized = false\n  }\n\n  /**\n   * 初始化CLI\n   */\n  async initialize () {\n    if (this.initialized) {\n      return\n    }\n\n    // 批量注册所有命令\n    this.registry.registerBatch({\n      init: commands.InitCommand,\n      welcome: commands.WelcomeCommand,\n      action: commands.ActionCommand,\n      learn: commands.LearnCommand,\n      recall: commands.RecallCommand,\n      remember: commands.RememberCommand,\n      think: commands.ThinkCommand,\n      toolx: commands.ToolCommand\n    })\n\n    // 将命令注册到状态机\n    for (const name of this.registry.list()) {\n      const command = this.registry.get(name)\n      this.stateMachine.registerCommand(name, command)\n    }\n\n    // 加载历史状态\n    await this.stateMachine.loadState()\n\n    this.initialized = true\n  }\n\n  /**\n   * 执行命令\n   * @param {string} commandName - 命令名称\n   * @param {Array} args - 命令参数\n   * @param {boolean} silent - 静默模式，不输出到console（用于MCP）\n   * @returns {Promise<PouchOutput>} 执行结果\n   */\n  async execute (commandName, args = [], silent = false) {\n    // 确保已初始化\n    if (!this.initialized) {\n      await this.initialize()\n    }\n\n    // 验证命令是否存在\n    if (!this.registry.validate(commandName)) {\n      throw new Error(`未知命令: ${commandName}\\n使用 '${COMMANDS.HELP}' 查看可用命令`)\n    }\n\n    try {\n      // 通过状态机执行命令\n      const result = await this.stateMachine.transition(commandName, args)\n\n      // 只在非静默模式下输出（避免干扰MCP协议）\n      if (!silent) {\n        // 如果结果有 toString 方法，打印人类可读格式\n        if (result && result.toString && typeof result.toString === 'function') {\n          logger.log(result.toString())\n        } else {\n          logger.log(JSON.stringify(result, null, 2))\n        }\n      }\n\n      return result\n    } catch (error) {\n      // 错误输出始终使用stderr，不干扰MCP协议\n      if (!silent) {\n        logger.error(`执行命令出错: ${error.message}`)\n      }\n      throw error\n    }\n  }\n\n  /**\n   * 获取帮助信息\n   * @returns {string} 帮助文本\n   */\n  getHelp () {\n    const commands = this.registry.getCommandDetails()\n    const currentState = this.stateMachine.getCurrentState()\n    const availableTransitions = this.stateMachine.getAvailableTransitions()\n\n    let help = `\n🎯 PromptX 锦囊系统帮助\n========================\n\n当前状态: ${currentState}\n可用转换: ${availableTransitions.join(', ')}\n\n📋 可用命令:\n`\n\n    for (const cmd of commands) {\n      help += `\\n  ${cmd.name.padEnd(12)} - ${cmd.purpose}`\n    }\n\n    help += `\n\n💡 使用示例:\n        ${COMMANDS.INIT}              # 初始化工作环境\n        ${COMMANDS.WELCOME}           # 发现可用角色\n        ${COMMANDS.ACTION} copywriter # 激活文案专家\n        ${COMMANDS.LEARN} scrum       # 学习敏捷知识\n        ${COMMANDS.RECALL} frontend   # 检索前端记忆\n\n🔄 PATEOAS 导航:\n每个命令执行后都会提供下一步的建议操作，\n按照提示即可完成完整的工作流程。\n\n📚 更多信息请访问: https://github.com/yourusername/promptx\n`\n\n    return help\n  }\n\n  /**\n   * 获取当前状态信息\n   * @returns {StateContext} 状态上下文\n   */\n  getStatus () {\n    return {\n      currentState: this.stateMachine.getCurrentState(),\n      availableCommands: this.registry.list(),\n      availableTransitions: this.stateMachine.getAvailableTransitions(),\n      context: this.stateMachine.context,\n      initialized: this.initialized\n    }\n  }\n\n  /**\n   * 解析命令行输入\n   * @param {string} input - 用户输入\n   * @returns {Object} 解析结果\n   */\n  parseCommand (input) {\n    const parts = input.trim().split(/\\s+/)\n    const command = parts[0]\n    const args = parts.slice(1)\n\n    return {\n      command,\n      args\n    }\n  }\n\n  /**\n   * 运行交互式CLI\n   */\n  async runInteractive () {\n    logger.info('🎯 欢迎使用 PromptX 锦囊系统！')\n    logger.info('输入 \"help\" 查看帮助，\"exit\" 退出\\n')\n\n    const readline = require('readline')\n    const rl = readline.createInterface({\n      input: process.stdin,\n      output: process.stdout,\n      prompt: 'promptx> '\n    })\n\n    rl.prompt()\n\n    rl.on('line', async (line) => {\n      const input = line.trim()\n\n      if (input === 'exit' || input === 'quit') {\n        logger.info('再见！')\n        rl.close()\n        return\n      }\n\n      if (input === 'help') {\n        logger.info(this.getHelp())\n      } else if (input === 'status') {\n        logger.info(JSON.stringify(this.getStatus(), null, 2))\n      } else if (input) {\n        const { command, args } = this.parseCommand(input)\n        try {\n          await this.execute(command, args)\n        } catch (error) {\n          logger.error(error.message)\n        }\n      }\n\n      rl.prompt()\n    })\n\n    rl.on('close', () => {\n      process.exit(0)\n    })\n  }\n}\n\nmodule.exports = PouchCLI\n","/**\n * 锦囊框架 (PATEOAS Framework)\n * Prompt as the Engine of Application State\n *\n * 这是一个革命性的AI-First CLI框架，通过锦囊串联实现AI的状态管理。\n * 每个锦囊都是独立的专家知识单元，通过PATEOAS导航实现状态转换。\n */\n\nconst PouchCLI = require('./PouchCLI')\nconst PouchRegistry = require('./PouchRegistry')\nconst PouchStateMachine = require('./state/PouchStateMachine')\nconst BasePouchCommand = require('./BasePouchCommand')\nconst commands = require('./commands')\n\n// 创建全局CLI实例\nconst cli = new PouchCLI()\n\nmodule.exports = {\n  // 主要导出\n  PouchCLI,\n  cli,\n\n  // 框架组件\n  PouchRegistry,\n  PouchStateMachine,\n  BasePouchCommand,\n\n  // 内置命令\n  commands,\n\n  // 便捷方法\n  execute: async (commandName, args) => {\n    return await cli.execute(commandName, args)\n  },\n\n  help: () => {\n    return cli.getHelp()\n  },\n\n  status: () => {\n    return cli.getStatus()\n  }\n}\n","/**\n * 版本信息工具\n * 统一管理PromptX版本信息的获取\n */\n\nlet cachedVersion = null;\n\n/**\n * 获取PromptX版本号\n * @returns {string} 版本号\n */\nfunction getVersion() {\n  if (cachedVersion) {\n    return cachedVersion;\n  }\n  \n  try {\n    const packageJson = require('../../../package.json');\n    cachedVersion = packageJson.version || '1.0.0';\n  } catch {\n    cachedVersion = '1.0.0';\n  }\n  \n  return cachedVersion;\n}\n\n/**\n * 获取完整版本信息（包含Node版本）\n * @returns {string} 完整版本信息\n */\nfunction getFullVersion() {\n  const version = getVersion();\n  const nodeVersion = process.version;\n  return `${version} (Node.js ${nodeVersion})`;\n}\n\nmodule.exports = {\n  getVersion,\n  getFullVersion\n};","/**\n * 项目配置数据结构\n * 精简设计，只包含核心必需字段\n */\nclass ProjectConfig {\n  /**\n   * @param {string} mcpId - MCP进程唯一标识符\n   * @param {string} ideType - IDE类型（cursor/vscode等）\n   * @param {string} projectPath - 项目绝对路径\n   * @param {string} projectHash - 项目路径的Hash值（用于文件名唯一性）\n   */\n  constructor(mcpId, ideType, projectPath, projectHash) {\n    this.mcpId = mcpId\n    this.ideType = ideType\n    this.projectPath = projectPath\n    this.projectHash = projectHash\n  }\n\n  /**\n   * 从JSON对象创建ProjectConfig实例\n   * @param {Object} data - JSON数据\n   * @returns {ProjectConfig} 配置实例\n   */\n  static fromJson(data) {\n    return new ProjectConfig(\n      data.mcpId,\n      data.ideType,\n      data.projectPath,\n      data.projectHash\n    )\n  }\n\n  /**\n   * 转换为JSON对象\n   * @returns {Object} JSON对象\n   */\n  toJson() {\n    return {\n      mcpId: this.mcpId,\n      ideType: this.ideType,\n      projectPath: this.projectPath,\n      projectHash: this.projectHash\n    }\n  }\n\n  /**\n   * 获取项目名称\n   * @returns {string} 项目名称\n   */\n  getProjectName() {\n    const path = require('path')\n    return path.basename(this.projectPath)\n  }\n\n  /**\n   * 验证配置完整性\n   * @returns {boolean} 是否有效\n   */\n  isValid() {\n    return !!(this.mcpId && this.ideType && this.projectPath && this.projectHash)\n  }\n\n  /**\n   * 生成配置文件名\n   * @returns {string} 配置文件名\n   */\n  getConfigFileName() {\n    const path = require('path')\n    const projectName = path.basename(this.projectPath).toLowerCase().replace(/[^a-z0-9-]/g, '-')\n    const ideTypeSafe = this.ideType.replace(/[^a-z0-9-]/g, '').toLowerCase() || 'unknown'\n    return `${this.mcpId}-${ideTypeSafe}-${projectName}-${this.projectHash}.json`\n  }\n}\n\nmodule.exports = ProjectConfig","/**\n * PromptX 核心库\n *\n * 提供AI prompt框架的核心功能，包括：\n * - 认知系统和记忆管理\n * - 资源管理和协议解析\n * - MCP协议支持\n * - 工具扩展系统\n */\n\n// 认知模块\nconst cognition = require('./cognition')\n\n// 资源管理模块\nconst resource = require('./resource')\n\n// 工具扩展模块\nconst toolx = require('./toolx')\n\n// Pouch CLI 框架\nconst pouch = require('./pouch')\n\n// 工具模块\nconst utils = {\n  version: require('./utils/version'),\n  DirectoryService: require('./utils/DirectoryService'),\n  ServerEnvironment: require('./utils/ServerEnvironment'),\n  ProjectManager: require('./utils/ProjectManager'),\n  ProjectPathResolver: require('./utils/ProjectPathResolver'),\n  ProjectConfig: require('./utils/ProjectConfig')\n}\n\nmodule.exports = {\n  cognition,\n  resource,\n  toolx,\n  pouch,\n  utils,\n  \n  // 便捷导出\n  ...utils\n}"],"mappings":"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","names":["exports","module","exports","module","exports","module","fs","path","exports","module","exports","module","exports","module","exports","module","exports","module","exports","module","exports","module","word","exports","module","_a","_b","exports","module","exports","module","exports","module","exports","module","exports","module","exports","module","exports","module","workspaceFromProject","exports","module","exports","module","resource","exports","module","exports","module","exports","module","resource","exports","module","exports","module","exports","module","resource","exports","module","resource","exports","module","resource","exports","module","resource","exports","module","resource","exports","module","exports","module","exports","module","fullPath","exports","module","exports","module","exports","module","exports","module","exports","module","exports","module","exports","module","exports","module","exports","module","exports","module","content","exports","module","exports","module","exports","module","exports","module","exports","module","exports","module","fs","exports","module","exports","module","exports","module","exports","module","exports","module","exports","module","exports","module","exports","module","exports","module","exports","module","exports","module","exports","module","exports","module","initArea","stateArea","exports","module","exports","module","exports","module","exports","module","logger","fs","exports","module","exports","module","exports","module","exports","module","exports","module","exports","module","exports","module","exports","module","exports","module","roleLayer","exports","module","exports","module","exports","module","exports","module","exports","module","exports","module","exports","module","commands","exports","module","exports","module","exports","module"]}