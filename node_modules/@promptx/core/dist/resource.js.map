{"version":3,"sources":["../../../node_modules/.pnpm/tsup@8.5.0_jiti@2.5.1_postcss@8.5.6_tsx@4.20.5_typescript@5.9.2_yaml@2.8.1/node_modules/tsup/assets/cjs_shims.js","../src/utils/ServerEnvironment.js","../src/utils/ProjectManager.js","../src/utils/DirectoryLocator.js","../src/utils/DirectoryService.js","../src/constants.js","../src/resource/ProtocolResolver.js","../src/resource/ResourceData.js","../src/resource/RegistryData.js","../src/resource/types.js","../src/resource/resourceProtocolParser.js","../src/resource/discovery/BaseDiscovery.js","../src/resource/discovery/PackageDiscovery.js","../src/resource/discovery/ProjectDiscovery.js","../src/resource/discovery/UserDiscovery.js","../src/resource/discovery/DiscoveryManager.js","../src/resource/protocols/ResourceProtocol.js","../src/resource/protocols/PackageProtocol.js","../src/utils/ProjectPathResolver.js","../src/resource/protocols/UserProtocol.js","../src/resource/protocols/ProjectProtocol.js","../src/resource/protocols/RoleProtocol.js","../src/resource/protocols/ThoughtProtocol.js","../src/resource/protocols/ExecutionProtocol.js","../src/resource/protocols/KnowledgeProtocol.js","../src/resource/protocols/ToolProtocol.js","../src/resource/protocols/ManualProtocol.js","../src/resource/protocols/FileProtocol.js","../src/resource/resourceManager.js","../src/resource/index.js"],"sourcesContent":["// Shim globals in cjs bundle\n// There's a weird bug that esbuild will always inject importMetaUrl\n// if we export it as `const importMetaUrl = ... __filename ...`\n// But using a function will not cause this issue\n\nconst getImportMetaUrl = () =>\n  typeof document === 'undefined'\n    ? new URL(`file:${__filename}`).href\n    : (document.currentScript && document.currentScript.src) ||\n      new URL('main.js', document.baseURI).href\n\nexport const importMetaUrl = /* @__PURE__ */ getImportMetaUrl()\n","/**\n * 服务器环境全局管理器\n * 管理MCP服务器的核心运行时属性：transport、host、port、processId\n * 启动时装配，运行时直接获取，避免参数传递错误\n */\nclass ServerEnvironment {\n  constructor() {\n    this.transport = null   // 'stdio' | 'http' | 'sse'\n    this.host = null       // 'localhost' | '0.0.0.0' 等\n    this.port = null       // 端口号（stdio模式为null）\n    this.processId = null  // 进程ID，用于生成mcpId\n    this.initialized = false\n  }\n\n  /**\n   * 初始化服务环境（各启动渠道调用一次）\n   * @param {Object} config - 配置对象\n   * @param {string} config.transport - 传输协议\n   * @param {string} config.host - 主机地址（可选）\n   * @param {number} config.port - 端口号（可选）\n   */\n  initialize(config) {\n    this.transport = config.transport\n    this.host = config.host || null\n    this.port = config.port || null\n    this.processId = process.pid\n    this.initialized = true\n  }\n\n  /**\n   * 获取MCP ID（基于processId生成）\n   * @returns {string} MCP进程ID\n   */\n  getMcpId() {\n    if (!this.initialized) {\n      throw new Error('ServerEnvironment not initialized')\n    }\n    return `mcp-${this.processId}`\n  }\n\n  /**\n   * 获取传输协议\n   * @returns {string} transport类型\n   */\n  getTransport() {\n    if (!this.initialized) {\n      throw new Error('ServerEnvironment not initialized')\n    }\n    return this.transport\n  }\n\n  /**\n   * 获取服务器地址信息（仅HTTP/SSE模式）\n   * @returns {Object|null} {host, port} 或 null\n   */\n  getServerAddress() {\n    if (!this.initialized) {\n      throw new Error('ServerEnvironment not initialized')\n    }\n    if (this.transport === 'stdio') {\n      return null\n    }\n    return {\n      host: this.host,\n      port: this.port\n    }\n  }\n\n  /**\n   * 检查是否已初始化\n   * @returns {boolean}\n   */\n  isInitialized() {\n    return this.initialized\n  }\n}\n\n// 创建全局单例实例\nlet globalServerEnvironment = null\n\n/**\n * 获取全局ServerEnvironment单例\n * @returns {ServerEnvironment} 全局ServerEnvironment实例\n */\nfunction getGlobalServerEnvironment() {\n  if (!globalServerEnvironment) {\n    globalServerEnvironment = new ServerEnvironment()\n  }\n  return globalServerEnvironment\n}\n\nmodule.exports = ServerEnvironment\nmodule.exports.getGlobalServerEnvironment = getGlobalServerEnvironment","const fs = require('fs-extra')\nconst path = require('path')\nconst os = require('os')\nconst crypto = require('crypto')\nconst { getGlobalServerEnvironment } = require('./ServerEnvironment')\nconst logger = require('@promptx/logger')\n\n/**\n * 统一项目管理器 - 新架构\n * 核心原则：一次设置，全程使用\n * 负责当前项目状态管理和多项目配置持久化\n */\nclass ProjectManager {\n  constructor() {\n    this.promptxHomeDir = path.join(os.homedir(), '.promptx')\n    this.projectsDir = path.join(this.promptxHomeDir, 'project')\n  }\n\n  // 🎯 新架构：当前项目状态管理\n  static currentProject = {\n    workingDirectory: null,\n    mcpId: null,\n    ideType: null,\n    transport: null,\n    initialized: false\n  }\n\n  /**\n   * 设置当前项目（init时调用）\n   * @param {string} workingDirectory - 项目工作目录绝对路径\n   * @param {string} mcpId - MCP进程ID\n   * @param {string} ideType - IDE类型\n   * @param {string} transport - 传输协议类型\n   */\n  static setCurrentProject(workingDirectory, mcpId, ideType, transport) {\n    this.currentProject = {\n      workingDirectory: path.resolve(workingDirectory),\n      mcpId,\n      ideType,\n      transport,\n      initialized: true\n    }\n  }\n\n  /**\n   * 获取当前项目路径（@project协议使用）\n   * @returns {string} 当前项目工作目录\n   */\n  static getCurrentProjectPath() {\n    logger.debug(`[ProjectManager DEBUG] getCurrentProjectPath被调用`)\n    logger.debug(`[ProjectManager DEBUG] currentProject.initialized: ${this.currentProject.initialized}`)\n    logger.debug(`[ProjectManager DEBUG] currentProject状态:`, JSON.stringify(this.currentProject, null, 2))\n    \n    // 输出完整的调用栈，包含文件名和行号\n    const stack = new Error().stack\n    const stackLines = stack.split('\\n').slice(1, 8) // 取前7层调用栈\n    logger.error(`[ProjectManager DEBUG] 完整调用栈:`)\n    stackLines.forEach((line, index) => {\n      logger.error(`[ProjectManager DEBUG]   ${index + 1}. ${line.trim()}`)\n    })\n    \n    if (!this.currentProject.initialized) {\n      logger.error(`[ProjectManager DEBUG] ❌ 项目未初始化，将抛出错误`)\n      throw new Error('项目未初始化，请先调用 init 命令')\n    }\n    \n    logger.debug(`[ProjectManager DEBUG] ✅ 返回项目路径: ${this.currentProject.workingDirectory}`)\n    return this.currentProject.workingDirectory\n  }\n\n  /**\n   * 获取当前项目信息\n   * @returns {Object} 当前项目完整信息\n   */\n  static getCurrentProject() {\n    logger.debug(`[ProjectManager DEBUG] getCurrentProject被调用`)\n    logger.debug(`[ProjectManager DEBUG] currentProject.initialized: ${this.currentProject.initialized}`)\n    logger.debug(`[ProjectManager DEBUG] currentProject状态:`, JSON.stringify(this.currentProject, null, 2))\n    \n    if (!this.currentProject.initialized) {\n      logger.error(`[ProjectManager DEBUG] ❌ 项目未初始化，将抛出错误`)\n      throw new Error('项目未初始化，请先调用 init 命令')\n    }\n    \n    logger.debug(`[ProjectManager DEBUG] ✅ 返回项目信息`)\n    return { ...this.currentProject }\n  }\n\n  /**\n   * 检查项目是否已初始化\n   * @returns {boolean} 是否已初始化\n   */\n  static isInitialized() {\n    return this.currentProject.initialized\n  }\n\n  /**\n   * 注册项目到MCP实例 - 使用Hash目录结构\n   * @param {string} projectPath - 项目绝对路径\n   * @param {string} mcpId - MCP进程ID\n   * @param {string} ideType - IDE类型（cursor/vscode等）\n   * @param {string} transport - 传输协议类型（stdio/http/sse）\n   * @returns {Promise<Object>} 项目配置对象\n   */\n  async registerProject(projectPath, mcpId, ideType, transport = 'stdio') {\n    // 验证项目路径\n    if (!await this.validateProjectPath(projectPath)) {\n      throw new Error(`无效的项目路径: ${projectPath}`)\n    }\n\n    // 生成项目配置\n    const projectConfig = {\n      mcpId: mcpId,\n      ideType: ideType.toLowerCase(),\n      transport: transport.toLowerCase(),\n      projectPath: path.resolve(projectPath),\n      projectHash: this.generateProjectHash(projectPath)\n    }\n\n    // 生成项目Hash目录\n    const projectHash = this.generateProjectHash(projectPath)\n    const projectConfigDir = path.join(this.projectsDir, projectHash)\n\n    // 🎯 确保Hash目录和.promptx子目录存在\n    await fs.ensureDir(projectConfigDir)\n    await fs.ensureDir(path.join(projectConfigDir, '.promptx'))\n    await fs.ensureDir(path.join(projectConfigDir, '.promptx', 'memory'))\n    await fs.ensureDir(path.join(projectConfigDir, '.promptx', 'resource'))\n\n    // 生成配置文件名并保存到Hash目录下\n    const fileName = this.generateConfigFileName(mcpId, ideType, transport, projectPath)\n    const configPath = path.join(projectConfigDir, fileName)\n    \n    await fs.writeJson(configPath, projectConfig, { spaces: 2 })\n    \n    return projectConfig\n  }\n\n  /**\n   * 根据MCP ID获取单个项目配置（假设只有一个项目）\n   * @param {string} mcpId - MCP进程ID\n   * @returns {Promise<Object|null>} 项目配置对象\n   */\n  async getProjectByMcpId(mcpId) {\n    const projects = await this.getProjectsByMcpId(mcpId)\n    return projects.length > 0 ? projects[0] : null\n  }\n\n  /**\n   * 根据MCP ID获取所有绑定的项目配置 - 支持Hash目录结构\n   * @param {string} mcpId - MCP进程ID\n   * @returns {Promise<Array>} 项目配置数组\n   */\n  async getProjectsByMcpId(mcpId) {\n    if (!await fs.pathExists(this.projectsDir)) {\n      return []\n    }\n\n    const hashDirs = await fs.readdir(this.projectsDir)\n    const projects = []\n\n    for (const hashDir of hashDirs) {\n      const hashDirPath = path.join(this.projectsDir, hashDir)\n      \n      // 🎯 只处理Hash目录（忽略旧的平铺文件）\n      if (!(await fs.stat(hashDirPath)).isDirectory()) {\n        continue\n      }\n      \n      try {\n        const configFiles = await fs.readdir(hashDirPath)\n        for (const file of configFiles) {\n          // 查找MCP配置文件\n          if (file.startsWith('mcp-') && file.endsWith('.json')) {\n            try {\n              const configPath = path.join(hashDirPath, file)\n              const config = await fs.readJson(configPath)\n              if (config.mcpId === mcpId) {\n                projects.push(config)\n              }\n            } catch (error) {\n              // 忽略损坏的配置文件\n              logger.warn(`跳过损坏的配置文件: ${file}`)\n            }\n          }\n        }\n      } catch (error) {\n        // 忽略无法读取的目录\n        logger.warn(`跳过无法读取的目录: ${hashDir}`)\n      }\n    }\n\n    return projects\n  }\n\n  /**\n   * 获取特定项目的所有实例（不同IDE/MCP的绑定） - 支持Hash目录结构\n   * @param {string} projectPath - 项目路径\n   * @returns {Promise<Array>} 项目实例数组\n   */\n  async getProjectInstances(projectPath) {\n    if (!await fs.pathExists(this.projectsDir)) {\n      return []\n    }\n\n    const projectHash = this.generateProjectHash(projectPath)\n    const projectConfigDir = path.join(this.projectsDir, projectHash)\n    \n    // 检查Hash目录是否存在\n    if (!await fs.pathExists(projectConfigDir)) {\n      return []\n    }\n\n    const instances = []\n    \n    try {\n      const configFiles = await fs.readdir(projectConfigDir)\n      \n      for (const file of configFiles) {\n        // 查找MCP配置文件\n        if (file.startsWith('mcp-') && file.endsWith('.json')) {\n          try {\n            const configPath = path.join(projectConfigDir, file)\n            const config = await fs.readJson(configPath)\n            if (config.projectHash === projectHash) {\n              instances.push(config)\n            }\n          } catch (error) {\n            logger.warn(`跳过损坏的配置文件: ${file}`)\n          }\n        }\n      }\n    } catch (error) {\n      logger.warn(`无法读取项目配置目录: ${projectConfigDir}`)\n    }\n\n    return instances\n  }\n\n  /**\n   * 删除项目绑定 - 支持Hash目录结构\n   * @param {string} mcpId - MCP进程ID\n   * @param {string} ideType - IDE类型\n   * @param {string} transport - 传输协议类型\n   * @param {string} projectPath - 项目路径\n   * @returns {Promise<boolean>} 是否删除成功\n   */\n  async removeProject(mcpId, ideType, transport, projectPath) {\n    const projectHash = this.generateProjectHash(projectPath)\n    const projectConfigDir = path.join(this.projectsDir, projectHash)\n    const fileName = this.generateConfigFileName(mcpId, ideType, transport, projectPath)\n    const configPath = path.join(projectConfigDir, fileName)\n    \n    if (await fs.pathExists(configPath)) {\n      await fs.remove(configPath)\n      \n      // 🎯 检查Hash目录是否为空，如果为空则删除整个目录\n      try {\n        const remainingFiles = await fs.readdir(projectConfigDir)\n        const mcpConfigFiles = remainingFiles.filter(file => file.startsWith('mcp-') && file.endsWith('.json'))\n        \n        if (mcpConfigFiles.length === 0) {\n          // 没有其他MCP配置文件，删除整个Hash目录\n          await fs.remove(projectConfigDir)\n        }\n      } catch (error) {\n        // 目录可能已经被删除，忽略错误\n      }\n      \n      return true\n    }\n    \n    return false\n  }\n\n  /**\n   * 清理过期的项目配置 - 支持Hash目录结构\n   * @returns {Promise<number>} 清理的配置文件数量\n   */\n  async cleanupExpiredProjects() {\n    if (!await fs.pathExists(this.projectsDir)) {\n      return 0\n    }\n\n    const hashDirs = await fs.readdir(this.projectsDir)\n    let cleanedCount = 0\n\n    for (const hashDir of hashDirs) {\n      const hashDirPath = path.join(this.projectsDir, hashDir)\n      \n      // 只处理Hash目录\n      if (!(await fs.stat(hashDirPath)).isDirectory()) {\n        continue\n      }\n      \n      try {\n        const configFiles = await fs.readdir(hashDirPath)\n        let hasValidConfig = false\n        \n        for (const file of configFiles) {\n          if (file.startsWith('mcp-') && file.endsWith('.json')) {\n            try {\n              const configPath = path.join(hashDirPath, file)\n              const config = await fs.readJson(configPath)\n              \n              // 检查项目路径是否仍然存在\n              if (!await fs.pathExists(config.projectPath)) {\n                await fs.remove(configPath)\n                cleanedCount++\n                logger.info(`清理过期项目配置: ${file}`)\n              } else {\n                hasValidConfig = true\n              }\n            } catch (error) {\n              // 清理损坏的配置文件\n              await fs.remove(path.join(hashDirPath, file))\n              cleanedCount++\n              logger.info(`清理损坏配置文件: ${file}`)\n            }\n          }\n        }\n        \n        // 如果Hash目录中没有有效的配置文件，删除整个目录\n        if (!hasValidConfig) {\n          await fs.remove(hashDirPath)\n          logger.info(`清理空的项目Hash目录: ${hashDir}`)\n        }\n      } catch (error) {\n        // 清理无法访问的目录\n        await fs.remove(hashDirPath)\n        cleanedCount++\n        logger.info(`清理无法访问的目录: ${hashDir}`)\n      }\n    }\n\n    return cleanedCount\n  }\n\n  /**\n   * 生成多项目环境下的AI提示词\n   * @param {string} contextType - 上下文类型：'list'/'action'/'learn'\n   * @param {string} mcpId - MCP进程ID\n   * @param {string} ideType - IDE类型\n   * @returns {Promise<string>} 格式化的AI提示词\n   */\n  async generateTopLevelProjectPrompt(contextType = 'list', mcpId, ideType) {\n    const projects = await this.getProjectsByMcpId(mcpId)\n    \n    if (projects.length === 0) {\n      // 未绑定项目，但这是正常的，不需要特别提示\n      return ''\n    }\n    \n    if (projects.length === 1) {\n      // 单项目环境（保持现有体验）\n      const project = projects[0]\n      const basePrompt = `🛑 **项目环境验证** 🛑\n📍 当前绑定项目: ${project.projectPath}\n🔗 MCP实例: ${mcpId} (${ideType})\n\n⚠️ **执行前确认**：上述路径是否为你当前工作的项目？`\n\n      switch (contextType) {\n        case 'action':\n          return `${basePrompt}\n如不一致，立即停止所有操作并使用 \\`promptx_init\\` 更新！\n\n💥 **严重警告**：在错误项目路径下操作将导致不可预知的错误！`\n        \n        case 'learn':\n          return `${basePrompt}\n错误环境将导致知识关联失效！\n\n💥 **严重警告**：项目环境不匹配将影响学习效果！`\n        \n        default:\n          return `${basePrompt}\n如不一致，必须使用 \\`promptx_init\\` 更新正确路径！\n\n💥 **严重警告**：错误的项目环境将导致服务异常！`\n      }\n    }\n    \n    // 多项目环境\n    const projectList = projects.map((proj, index) => \n      `${index + 1}. ${path.basename(proj.projectPath)} (${proj.projectPath})`\n    ).join('\\n')\n    \n    return `🎯 **多项目环境检测** 🎯\n📍 当前MCP实例(${mcpId})已绑定 ${projects.length} 个项目：\n\n${projectList}\n\n⚠️ **请明确指定**：你要在哪个项目中执行操作？\n💡 **建议**：在对话中明确说明项目名称或路径`\n  }\n\n  /**\n   * 验证路径是否为有效的项目目录\n   * @param {string} projectPath - 要验证的路径\n   * @returns {Promise<boolean>} 是否为有效项目目录\n   */\n  async validateProjectPath(projectPath) {\n    try {\n      // 基础检查：路径存在且为目录\n      const stat = await fs.stat(projectPath)\n      if (!stat.isDirectory()) {\n        return false\n      }\n\n      // 简单检查：避免明显错误的路径\n      const resolved = path.resolve(projectPath)\n      const homeDir = os.homedir()\n      \n      // 不允许是用户主目录\n      if (resolved === homeDir) {\n        return false\n      }\n\n      return true\n    } catch (error) {\n      return false\n    }\n  }\n\n  /**\n   * 生成配置文件名\n   * @param {string} mcpId - MCP进程ID\n   * @param {string} ideType - IDE类型\n   * @param {string} transport - 传输协议类型\n   * @param {string} projectPath - 项目路径\n   * @returns {string} 配置文件名\n   */\n  generateConfigFileName(mcpId, ideType, transport, projectPath) {\n    const projectHash = this.generateProjectHash(projectPath)\n    const projectName = path.basename(projectPath).toLowerCase().replace(/[^a-z0-9-]/g, '-')\n    const ideTypeSafe = ideType.replace(/[^a-z0-9-]/g, '').toLowerCase() || 'unknown'\n    const transportSafe = transport.replace(/[^a-z0-9-]/g, '').toLowerCase() || 'unknown'\n    // 格式：mcp-transport-id-idetype-projectname-hash.json\n    return `mcp-${transportSafe}-${mcpId.replace('mcp-', '')}-${ideTypeSafe}-${projectName}-${projectHash}.json`\n  }\n\n  /**\n   * 生成项目路径的Hash值\n   * @param {string} projectPath - 项目路径\n   * @returns {string} 8位Hash值\n   */\n  generateProjectHash(projectPath) {\n    return crypto.createHash('md5').update(path.resolve(projectPath)).digest('hex').substr(0, 8)\n  }\n\n  /**\n   * 从配置文件中获取IDE类型\n   * @param {string} mcpId - MCP进程ID\n   * @returns {Promise<string>} IDE类型\n   */\n  async getIdeType(mcpId) {\n    const project = await this.getProjectByMcpId(mcpId)\n    return project ? project.ideType : 'unknown'\n  }\n\n  /**\n   * 生成MCP进程ID - 基于进程ID确保实例唯一\n   * @param {string} ideType - IDE类型（保留参数兼容性，实际不使用）\n   * @returns {string} MCP进程ID\n   */\n  static generateMcpId(ideType = 'unknown') {\n    const serverEnv = getGlobalServerEnvironment()\n    if (serverEnv.isInitialized()) {\n      return serverEnv.getMcpId()\n    }\n    // fallback到原逻辑\n    return `mcp-${process.pid}`\n  }\n\n  /**\n   * 统一项目注册方法 - 新架构：设置当前项目并持久化配置\n   * @param {string} workingDirectory - 项目工作目录\n   * @param {string} ideType - IDE类型（可选，默认'unknown'）\n   * @returns {Promise<Object>} 项目配置对象\n   */\n  static async registerCurrentProject(workingDirectory, ideType = 'unknown') {\n    logger.debug(`[ProjectManager DEBUG] ======= registerCurrentProject开始 =======`)\n    logger.debug(`[ProjectManager DEBUG] 参数 - workingDirectory: ${workingDirectory}`)\n    logger.debug(`[ProjectManager DEBUG] 参数 - ideType: ${ideType}`)\n    logger.debug(`[ProjectManager DEBUG] 注册前 currentProject状态:`, JSON.stringify(this.currentProject, null, 2))\n    \n    const serverEnv = getGlobalServerEnvironment()\n    if (!serverEnv.isInitialized()) {\n      logger.error(`[ProjectManager DEBUG] ❌ ServerEnvironment未初始化`)\n      throw new Error('ServerEnvironment not initialized')\n    }\n    \n    const mcpId = serverEnv.getMcpId()\n    const transport = serverEnv.getTransport()\n    logger.debug(`[ProjectManager DEBUG] ServerEnvironment信息 - mcpId: ${mcpId}, transport: ${transport}`)\n    \n    // 🎯 新架构：设置当前项目状态\n    logger.debug(`[ProjectManager DEBUG] 调用 setCurrentProject...`)\n    this.setCurrentProject(workingDirectory, mcpId, ideType, transport)\n    logger.debug(`[ProjectManager DEBUG] setCurrentProject完成后 currentProject状态:`, JSON.stringify(this.currentProject, null, 2))\n    \n    // 持久化项目配置（保持多项目管理功能）\n    logger.debug(`[ProjectManager DEBUG] 开始持久化项目配置...`)\n    const projectManager = getGlobalProjectManager()\n    const result = await projectManager.registerProject(workingDirectory, mcpId, ideType, transport)\n    logger.debug(`[ProjectManager DEBUG] 项目配置持久化完成:`, JSON.stringify(result, null, 2))\n    logger.debug(`[ProjectManager DEBUG] ======= registerCurrentProject结束 =======`)\n    \n    return result\n  }\n}\n\n// 创建全局单例实例\nlet globalProjectManager = null\n\n/**\n * 获取全局ProjectManager单例\n * @returns {ProjectManager} 全局ProjectManager实例\n */\nfunction getGlobalProjectManager() {\n  if (!globalProjectManager) {\n    globalProjectManager = new ProjectManager()\n  }\n  return globalProjectManager\n}\n\nmodule.exports = ProjectManager\nmodule.exports.ProjectManager = ProjectManager\nmodule.exports.getGlobalProjectManager = getGlobalProjectManager","const fs = require('fs-extra')\nconst path = require('path')\nconst os = require('os')\nconst ProjectManager = require('./ProjectManager')\n\n/**\n * 目录定位器基础抽象类\n * 统一管理所有路径解析逻辑，支持跨平台差异化实现\n */\nclass DirectoryLocator {\n  constructor(options = {}) {\n    this.options = options\n    this.cache = new Map()\n    this.platform = process.platform\n  }\n\n  /**\n   * 抽象方法：定位目录\n   * @param {Object} context - 定位上下文\n   * @returns {Promise<string>} 定位到的目录路径\n   */\n  async locate(context = {}) {\n    throw new Error('子类必须实现 locate 方法')\n  }\n\n  /**\n   * 获取缓存\n   */\n  getCached(key) {\n    return this.cache.get(key)\n  }\n\n  /**\n   * 设置缓存\n   */\n  setCached(key, value) {\n    this.cache.set(key, value)\n    return value\n  }\n\n  /**\n   * 清除缓存\n   */\n  clearCache() {\n    this.cache.clear()\n  }\n\n  /**\n   * 检查路径是否存在且是目录\n   */\n  async isValidDirectory(dirPath) {\n    try {\n      const stat = await fs.stat(dirPath)\n      return stat.isDirectory()\n    } catch {\n      return false\n    }\n  }\n\n  /**\n   * 规范化路径\n   */\n  normalizePath(inputPath) {\n    if (!inputPath || typeof inputPath !== 'string') {\n      return null\n    }\n    return path.resolve(inputPath)\n  }\n\n  /**\n   * 展开家目录路径\n   */\n  expandHome(filepath) {\n    if (!filepath || typeof filepath !== 'string') {\n      return ''\n    }\n    \n    if (filepath.startsWith('~/') || filepath === '~') {\n      return path.join(os.homedir(), filepath.slice(2))\n    }\n    \n    return filepath\n  }\n}\n\n/**\n * 项目根目录定位器\n * 负责查找项目的根目录\n */\nclass ProjectRootLocator extends DirectoryLocator {\n  constructor(options = {}) {\n    super(options)\n    \n    // 初始化AI驱动的项目管理器\n    this.projectManager = new ProjectManager()\n    \n    // 可配置的查找策略优先级（按可靠性和准确性排序）\n    this.strategies = options.strategies || [\n      'aiProvidedProjectPath',              // 1. AI提供的项目路径（最可靠，由AI告知）\n      'existingPromptxDirectory',           // 2. 现有.promptx目录（最可靠的项目标识）\n      'packageJsonDirectory',               // 3. 向上查找项目标识文件（最准确的项目边界）\n      'gitRootDirectory',                   // 4. Git根目录（通用可靠）\n      'currentWorkingDirectoryIfHasMarkers', // 5. 当前目录项目标识（降级策略）\n      'currentWorkingDirectory'             // 6. 纯当前目录（最后回退）\n    ]\n    \n    // 项目标识文件\n    this.projectMarkers = options.projectMarkers || [\n      'package.json',\n      '.git',\n      'pyproject.toml',\n      'Cargo.toml',\n      'pom.xml',\n      'build.gradle',\n      'composer.json'\n    ]\n  }\n\n  /**\n   * 定位项目根目录\n   */\n  async locate(context = {}) {\n    const { startDir = process.cwd() } = context\n    const cacheKey = `projectRoot:${startDir}`\n    \n    // 检查缓存\n    const cached = this.getCached(cacheKey)\n    if (cached) {\n      return cached\n    }\n\n    // 使用上下文中的策略或默认策略\n    const strategies = context.strategies || this.strategies\n\n    // 按策略优先级查找\n    for (const strategy of strategies) {\n      const result = await this._executeStrategy(strategy, startDir, context)\n      if (result && await this._validateProjectRoot(result, context)) {\n        return this.setCached(cacheKey, result)\n      }\n    }\n\n    // 如果所有策略都失败，返回起始目录\n    return this.setCached(cacheKey, startDir)\n  }\n\n  /**\n   * 执行特定的查找策略\n   */\n  async _executeStrategy(strategy, startDir, context) {\n    switch (strategy) {\n      case 'aiProvidedProjectPath':\n        return await this._findByAIProvidedPath()\n      \n      case 'existingPromptxDirectory':\n        return await this._findByExistingPromptx(startDir)\n      \n      case 'currentWorkingDirectoryIfHasMarkers':\n        return await this._checkCurrentDirForMarkers(startDir)\n      \n      case 'packageJsonDirectory':\n        return await this._findByProjectMarkers(startDir)\n      \n      case 'gitRootDirectory':\n        return await this._findByGitRoot(startDir)\n      \n      case 'currentWorkingDirectory':\n        return startDir\n      \n      default:\n        return null\n    }\n  }\n\n  /**\n   * 通过AI提供的项目路径查找（最高优先级）\n   */\n  async _findByAIProvidedPath() {\n    try {\n      // 注意：多项目环境下需要传入mcpId，这里使用临时ID\n      const tempMcpId = process.env.PROMPTX_MCP_ID || `temp-${process.pid}`\n      const projects = await this.projectManager.getProjectsByMcpId(tempMcpId)\n      const aiProvidedPath = projects.length > 0 ? projects[0].projectPath : null\n      if (aiProvidedPath && await this.isValidDirectory(aiProvidedPath)) {\n        return aiProvidedPath\n      }\n    } catch (error) {\n      // AI提供的路径获取失败，继续使用其他策略\n    }\n    return null\n  }\n\n  /**\n   * 检查当前目录是否包含项目标识文件\n   */\n  async _checkCurrentDirForMarkers(startDir) {\n    const currentDir = path.resolve(startDir)\n    \n    // 检查当前目录是否包含项目标识文件\n    for (const marker of this.projectMarkers) {\n      const markerPath = path.join(currentDir, marker)\n      if (await fs.pathExists(markerPath)) {\n        return currentDir\n      }\n    }\n    \n    return null\n  }\n\n  /**\n   * 通过现有.promptx目录查找\n   */\n  async _findByExistingPromptx(startDir) {\n    let currentDir = path.resolve(startDir)\n    const root = path.parse(currentDir).root\n\n    while (currentDir !== root) {\n      const promptxPath = path.join(currentDir, '.promptx')\n      if (await this.isValidDirectory(promptxPath)) {\n        return currentDir\n      }\n      \n      const parentDir = path.dirname(currentDir)\n      if (parentDir === currentDir) break\n      currentDir = parentDir\n    }\n\n    return null\n  }\n\n  /**\n   * 通过项目标识文件查找\n   */\n  async _findByProjectMarkers(startDir) {\n    let currentDir = path.resolve(startDir)\n    const root = path.parse(currentDir).root\n\n    while (currentDir !== root) {\n      for (const marker of this.projectMarkers) {\n        const markerPath = path.join(currentDir, marker)\n        if (await fs.pathExists(markerPath)) {\n          return currentDir\n        }\n      }\n      \n      const parentDir = path.dirname(currentDir)\n      if (parentDir === currentDir) break\n      currentDir = parentDir\n    }\n\n    return null\n  }\n\n  /**\n   * 通过Git根目录查找\n   */\n  async _findByGitRoot(startDir) {\n    let currentDir = path.resolve(startDir)\n    const root = path.parse(currentDir).root\n\n    while (currentDir !== root) {\n      const gitPath = path.join(currentDir, '.git')\n      if (await fs.pathExists(gitPath)) {\n        return currentDir\n      }\n      \n      const parentDir = path.dirname(currentDir)\n      if (parentDir === currentDir) break\n      currentDir = parentDir\n    }\n\n    return null\n  }\n\n  /**\n   * 验证项目根目录\n   */\n  async _validateProjectRoot(projectRoot, context = {}) {\n    // Windows平台：避免用户家目录\n    if (this.platform === 'win32' && context.avoidUserHome !== false) {\n      const homeDir = os.homedir()\n      if (path.resolve(projectRoot) === path.resolve(homeDir)) {\n        return false\n      }\n    }\n\n    return await this.isValidDirectory(projectRoot)\n  }\n}\n\n/**\n * PromptX工作空间定位器\n * 负责确定.promptx目录的位置\n */\nclass PromptXWorkspaceLocator extends DirectoryLocator {\n  constructor(options = {}) {\n    super(options)\n    this.projectRootLocator = options.projectRootLocator || new ProjectRootLocator(options)\n    this.projectManager = new ProjectManager()\n  }\n\n  /**\n   * 定位PromptX工作空间\n   */\n  async locate(context = {}) {\n    const cacheKey = `promptxWorkspace:${JSON.stringify(context)}`\n\n    // 检查缓存\n    const cached = this.getCached(cacheKey)\n    if (cached) {\n      return cached\n    }\n\n    // 策略1：AI提供的项目路径（最高优先级 - AI驱动的路径管理）\n    const workspaceFromAI = await this._fromAIProvidedPath()\n    if (workspaceFromAI) {\n      return this.setCached(cacheKey, workspaceFromAI)\n    }\n\n    // 策略2：IDE环境变量（用户/IDE明确指定）\n    const workspaceFromIDE = await this._fromIDEEnvironment()\n    if (workspaceFromIDE) {\n      return this.setCached(cacheKey, workspaceFromIDE)\n    }\n\n    // 策略3：PromptX专用环境变量（用户手动配置）\n    const workspaceFromEnv = await this._fromPromptXEnvironment()\n    if (workspaceFromEnv) {\n      return this.setCached(cacheKey, workspaceFromEnv)\n    }\n\n    // 策略4：特定上下文策略（如init命令的强制指定）\n    if (context.strategies) {\n      const workspaceFromProject = await this._fromProjectRoot(context)\n      if (workspaceFromProject) {\n        return this.setCached(cacheKey, workspaceFromProject)\n      }\n    }\n\n    // 策略5：现有.promptx目录（已初始化的项目）\n    const workspaceFromExisting = await this._fromExistingDirectory(context.startDir)\n    if (workspaceFromExisting) {\n      return this.setCached(cacheKey, workspaceFromExisting)\n    }\n\n    // 策略6：项目根目录（基于项目结构推断）\n    const workspaceFromProject = await this._fromProjectRoot(context)\n    if (workspaceFromProject) {\n      return this.setCached(cacheKey, workspaceFromProject)\n    }\n\n    // 策略7：智能回退策略（兜底方案）\n    return this.setCached(cacheKey, await this._getSmartFallback(context))\n  }\n\n  /**\n   * 从AI提供的项目路径获取（最高优先级）\n   */\n  async _fromAIProvidedPath() {\n    try {\n      // 注意：多项目环境下需要传入mcpId，这里使用临时ID\n      const tempMcpId = process.env.PROMPTX_MCP_ID || `temp-${process.pid}`\n      const projects = await this.projectManager.getProjectsByMcpId(tempMcpId)\n      const aiProvidedPath = projects.length > 0 ? projects[0].projectPath : null\n      if (aiProvidedPath && await this.isValidDirectory(aiProvidedPath)) {\n        return aiProvidedPath\n      }\n    } catch (error) {\n      // AI提供的路径获取失败，继续使用其他策略\n    }\n    return null\n  }\n\n  /**\n   * 从IDE环境变量获取（支持多种IDE）\n   */\n  async _fromIDEEnvironment() {\n    // IDE环境变量检测策略（按优先级排序）\n    const ideStrategies = [\n      // Claude IDE (现有格式)\n      {\n        name: 'Claude IDE',\n        vars: ['WORKSPACE_FOLDER_PATHS'],\n        parse: (value, varName) => {\n          try {\n            const folders = JSON.parse(value)\n            return Array.isArray(folders) && folders.length > 0 ? folders[0] : null\n          } catch {\n            return null\n          }\n        }\n      },\n      \n      // VSCode\n      {\n        name: 'VSCode',\n        vars: ['VSCODE_WORKSPACE_FOLDER', 'VSCODE_CWD'],\n        parse: (value, varName) => value\n      },\n      \n      // IntelliJ IDEA / WebStorm / PhpStorm\n      {\n        name: 'JetBrains IDEs',\n        vars: ['PROJECT_ROOT', 'IDEA_INITIAL_DIRECTORY', 'WEBSTORM_PROJECT_PATH'],\n        parse: (value, varName) => value\n      },\n      \n      // Sublime Text\n      {\n        name: 'Sublime Text',\n        vars: ['SUBLIME_PROJECT_PATH', 'SUBL_PROJECT_DIR'],\n        parse: (value, varName) => value\n      },\n      \n      // Atom\n      {\n        name: 'Atom',\n        vars: ['ATOM_PROJECT_PATH', 'ATOM_HOME_PROJECT'],\n        parse: (value, varName) => value\n      },\n      \n      // Vim/Neovim\n      {\n        name: 'Vim/Neovim',\n        vars: ['VIM_PROJECT_ROOT', 'NVIM_PROJECT_ROOT'],\n        parse: (value, varName) => value\n      },\n      \n      // 字节跳动 Trae 和其他基于PWD的IDE\n      {\n        name: 'ByteDance Trae & PWD-based IDEs',\n        vars: ['PWD', 'TRAE_WORKSPACE', 'BYTEDANCE_WORKSPACE'],\n        parse: (value, varName) => {\n          // 对于专用环境变量，直接使用\n          if (varName === 'TRAE_WORKSPACE' || varName === 'BYTEDANCE_WORKSPACE') {\n            return value\n          }\n          \n          // 对于PWD，只有当它与process.cwd()不同时，才认为是IDE设置的项目路径\n          if (varName === 'PWD') {\n            const currentCwd = process.cwd()\n            if (value && value !== currentCwd) {\n              return value\n            }\n          }\n          \n          return null\n        }\n      },\n      \n      // 通用工作目录\n      {\n        name: 'Generic',\n        vars: ['WORKSPACE_ROOT', 'PROJECT_DIR', 'WORKING_DIRECTORY'],\n        parse: (value, varName) => value\n      }\n    ]\n\n    // 按策略逐一检测\n    for (const strategy of ideStrategies) {\n      for (const varName of strategy.vars) {\n        const envValue = process.env[varName]\n        if (envValue && envValue.trim() !== '') {\n          // 传递varName给parse函数，支持变量名相关的解析逻辑\n          const parsedPath = strategy.parse(envValue.trim(), varName)\n          if (parsedPath) {\n            const normalizedPath = this.normalizePath(this.expandHome(parsedPath))\n            if (normalizedPath && await this.isValidDirectory(normalizedPath)) {\n              // 记录检测到的IDE类型（用于调试）\n              this._detectedIDE = strategy.name\n              return normalizedPath\n            }\n          }\n        }\n      }\n    }\n    \n    return null\n  }\n\n  /**\n   * 从PromptX环境变量获取\n   */\n  async _fromPromptXEnvironment() {\n    const promptxWorkspaceEnv = process.env.PROMPTX_WORKSPACE\n    if (promptxWorkspaceEnv && promptxWorkspaceEnv.trim() !== '') {\n      const workspacePath = this.normalizePath(this.expandHome(promptxWorkspaceEnv))\n      if (workspacePath && await this.isValidDirectory(workspacePath)) {\n        return workspacePath\n      }\n    }\n    return null\n  }\n\n  /**\n   * 从现有.promptx目录获取\n   */\n  async _fromExistingDirectory(startDir) {\n    const projectRoot = await this.projectRootLocator._findByExistingPromptx(startDir || process.cwd())\n    return projectRoot\n  }\n\n  /**\n   * 从项目根目录获取\n   */\n  async _fromProjectRoot(context) {\n    const projectRoot = await this.projectRootLocator.locate(context)\n    return projectRoot\n  }\n\n  /**\n   * 智能回退策略\n   */\n  async _getSmartFallback(context) {\n    // 1. 尝试从命令行参数推断\n    const argPath = await this._fromProcessArguments()\n    if (argPath && await this.isValidDirectory(argPath)) {\n      return argPath\n    }\n\n    // 2. 尝试从进程的工作目录\n    const processCwd = process.cwd()\n    if (await this.isValidDirectory(processCwd)) {\n      return processCwd\n    }\n\n    // 3. 最后回退到用户主目录\n    return os.homedir()\n  }\n\n  /**\n   * 从进程参数推断项目路径\n   */\n  async _fromProcessArguments() {\n    const args = process.argv\n    \n    // 查找可能的路径参数\n    for (let i = 0; i < args.length; i++) {\n      const arg = args[i]\n      \n      // 查找 --project-path 或类似参数\n      if (arg.startsWith('--project-path=')) {\n        return arg.split('=')[1]\n      }\n      \n      if (arg === '--project-path' && i + 1 < args.length) {\n        return args[i + 1]\n      }\n      \n      // 查找 --cwd 参数\n      if (arg.startsWith('--cwd=')) {\n        return arg.split('=')[1]\n      }\n      \n      if (arg === '--cwd' && i + 1 < args.length) {\n        return args[i + 1]\n      }\n    }\n    \n    return null\n  }\n\n  /**\n   * 获取检测调试信息\n   */\n  getDetectionInfo() {\n    return {\n      detectedIDE: this._detectedIDE || 'Unknown',\n      availableEnvVars: this._getAvailableEnvVars(),\n      platform: process.platform,\n      cwd: process.cwd(),\n      args: process.argv\n    }\n  }\n\n  /**\n   * 获取可用的环境变量\n   */\n  _getAvailableEnvVars() {\n    const relevantVars = [\n      'WORKSPACE_FOLDER_PATHS', 'VSCODE_WORKSPACE_FOLDER', 'VSCODE_CWD',\n      'PROJECT_ROOT', 'IDEA_INITIAL_DIRECTORY', 'WEBSTORM_PROJECT_PATH',\n      'SUBLIME_PROJECT_PATH', 'SUBL_PROJECT_DIR',\n      'ATOM_PROJECT_PATH', 'ATOM_HOME_PROJECT',\n      'VIM_PROJECT_ROOT', 'NVIM_PROJECT_ROOT',\n      'PWD', 'TRAE_WORKSPACE', 'BYTEDANCE_WORKSPACE',\n      'WORKSPACE_ROOT', 'PROJECT_DIR', 'WORKING_DIRECTORY',\n      'PROMPTX_WORKSPACE'\n    ]\n    \n    const available = {}\n    for (const varName of relevantVars) {\n      if (process.env[varName]) {\n        available[varName] = process.env[varName]\n      }\n    }\n    \n    return available\n  }\n}\n\n/**\n * 目录定位器工厂\n */\nclass DirectoryLocatorFactory {\n  /**\n   * 创建项目根目录定位器\n   */\n  static createProjectRootLocator(options = {}) {\n    const platform = process.platform\n    \n    // 根据平台创建特定实现\n    if (platform === 'win32') {\n      return new WindowsProjectRootLocator(options)\n    } else {\n      return new ProjectRootLocator(options)\n    }\n  }\n\n  /**\n   * 创建PromptX工作空间定位器\n   */\n  static createPromptXWorkspaceLocator(options = {}) {\n    const projectRootLocator = this.createProjectRootLocator(options)\n    return new PromptXWorkspaceLocator({\n      ...options,\n      projectRootLocator\n    })\n  }\n\n  /**\n   * 获取平台信息\n   */\n  static getPlatform() {\n    return process.platform\n  }\n}\n\n/**\n * Windows平台的项目根目录定位器\n * 特殊处理Windows环境下的路径问题\n */\nclass WindowsProjectRootLocator extends ProjectRootLocator {\n  constructor(options = {}) {\n    super({\n      ...options,\n      // Windows默认避免用户家目录\n      avoidUserHome: options.avoidUserHome !== false\n    })\n  }\n\n  /**\n   * Windows特有的项目根目录验证\n   */\n  async _validateProjectRoot(projectRoot, context = {}) {\n    // 调用基类验证\n    const baseValid = await super._validateProjectRoot(projectRoot, context)\n    if (!baseValid) {\n      return false\n    }\n\n    // Windows特有：避免系统关键目录\n    const systemPaths = [\n      'C:\\\\Windows',\n      'C:\\\\Program Files',\n      'C:\\\\Program Files (x86)',\n      'C:\\\\System Volume Information'\n    ]\n\n    const resolvedPath = path.resolve(projectRoot).toUpperCase()\n    for (const systemPath of systemPaths) {\n      if (resolvedPath.startsWith(systemPath.toUpperCase())) {\n        return false\n      }\n    }\n\n    return true\n  }\n}\n\nmodule.exports = {\n  DirectoryLocator,\n  ProjectRootLocator,\n  PromptXWorkspaceLocator,\n  DirectoryLocatorFactory,\n  WindowsProjectRootLocator\n} ","const { DirectoryLocatorFactory } = require('./DirectoryLocator')\nconst logger = require('@promptx/logger')\n\n/**\n * IDE环境检测服务 - 新架构\n * 专注于IDE环境变量检测和配置建议\n * 项目路径管理已移交ProjectManager和ProjectPathResolver\n */\nclass DirectoryService {\n  constructor() {\n    this.workspaceLocator = null\n    this.initialized = false\n  }\n\n  /**\n   * 初始化服务\n   */\n  async initialize(options = {}) {\n    if (this.initialized) {\n      return\n    }\n\n    try {\n      this.workspaceLocator = DirectoryLocatorFactory.createPromptXWorkspaceLocator(options)\n      this.initialized = true\n      \n      logger.debug('[DirectoryService] 初始化完成')\n    } catch (error) {\n      logger.error('[DirectoryService] 初始化失败:', error)\n      throw error\n    }\n  }\n\n  /**\n   * 获取IDE环境检测调试信息\n   */\n  async getDebugInfo(context = {}) {\n    await this._ensureInitialized()\n    \n    // 获取IDE检测信息\n    const ideDetectionInfo = this.workspaceLocator?.getDetectionInfo() || {}\n    \n    return {\n      platform: process.platform,\n      ideDetection: {\n        detectedIDE: ideDetectionInfo.detectedIDE,\n        availableEnvVars: ideDetectionInfo.availableEnvVars,\n        cwd: process.cwd(),\n        args: process.argv.slice(2)\n      },\n      environment: {\n        // 主要IDE环境变量\n        WORKSPACE_FOLDER_PATHS: process.env.WORKSPACE_FOLDER_PATHS,\n        VSCODE_WORKSPACE_FOLDER: process.env.VSCODE_WORKSPACE_FOLDER,\n        PROJECT_ROOT: process.env.PROJECT_ROOT,\n        SUBLIME_PROJECT_PATH: process.env.SUBLIME_PROJECT_PATH,\n        // PromptX专用\n        PROMPTX_WORKSPACE: process.env.PROMPTX_WORKSPACE,\n        // 系统环境\n        PWD: process.env.PWD,\n        NODE_ENV: process.env.NODE_ENV\n      },\n      recommendations: this._getPathRecommendations(ideDetectionInfo)\n    }\n  }\n\n  /**\n   * 获取路径配置建议\n   */\n  _getPathRecommendations(ideDetectionInfo = {}) {\n    const recommendations = []\n    \n    if (!ideDetectionInfo.detectedIDE || ideDetectionInfo.detectedIDE === 'Unknown') {\n      recommendations.push({\n        type: 'env_var',\n        message: '未检测到IDE环境变量，建议设置项目路径环境变量',\n        suggestions: [\n          'export PROMPTX_WORKSPACE=\"/path/to/your/project\"',\n          'export PROJECT_ROOT=\"/path/to/your/project\"',\n          'export WORKSPACE_ROOT=\"/path/to/your/project\"'\n        ]\n      })\n    }\n    \n    if (!ideDetectionInfo.availableEnvVars || Object.keys(ideDetectionInfo.availableEnvVars).length === 0) {\n      recommendations.push({\n        type: 'manual_config',\n        message: '建议在IDE中配置MCP工作目录',\n        suggestions: [\n          'VSCode: 在settings.json中设置workspace.folders',\n          'IntelliJ: 在Run Configuration中设置Working directory',\n          'Claude IDE: 确保workspace路径正确传递'\n        ]\n      })\n    }\n    \n    return recommendations\n  }\n\n  /**\n   * 清除缓存\n   */\n  clearCache() {\n    if (this.workspaceLocator) {\n      this.workspaceLocator.clearCache()\n    }\n    logger.debug('[DirectoryService] 缓存已清除')\n  }\n\n  /**\n   * 确保服务已初始化\n   */\n  async _ensureInitialized() {\n    if (!this.initialized) {\n      await this.initialize()\n    }\n  }\n\n  /**\n   * 重新加载配置\n   */\n  async reload(options = {}) {\n    this.initialized = false\n    this.clearCache()\n    await this.initialize(options)\n  }\n}\n\n// 创建全局单例\nconst globalDirectoryService = new DirectoryService()\n\n/**\n * 获取全局目录服务实例\n */\nfunction getDirectoryService() {\n  return globalDirectoryService\n}\n\nmodule.exports = {\n  DirectoryService,\n  getDirectoryService\n}","/**\n * PromptX 系统常量配置\n * 统一管理命令格式、路径等配置信息\n */\n\n// 包名配置（支持新旧两个包名）\nconst PACKAGE_NAMES = {\n  CURRENT: '@promptx/cli',    // 当前使用的包名\n  LEGACY: 'dpml-prompt',       // 旧版包名（向后兼容）\n  ALL: ['@promptx/cli', 'dpml-prompt']  // 所有支持的包名\n}\n\n// 根据环境变量决定命令前缀\nfunction getCommandPrefix() {\n  const env = process.env.PROMPTX_ENV\n  \n  if (env === 'development') {\n    return 'pnpm start'\n  } else {\n    return `npx ${PACKAGE_NAMES.CURRENT}@snapshot`\n  }\n}\n\nconst COMMAND_PREFIX = getCommandPrefix()\n\n// 静态命令常量\nconst COMMANDS = {\n  INIT: `${COMMAND_PREFIX} init`,\n  WELCOME: `${COMMAND_PREFIX} welcome`,\n  ACTION: `${COMMAND_PREFIX} action`,\n  LEARN: `${COMMAND_PREFIX} learn`,\n  RECALL: `${COMMAND_PREFIX} recall`,\n  REMEMBER: `${COMMAND_PREFIX} remember`,\n  HELP: `${COMMAND_PREFIX} help`\n}\n\n// 带参数的命令构建函数\nconst buildCommand = {\n  action: (roleId) => `${COMMAND_PREFIX} action ${roleId}`,\n  learn: (resource) => `${COMMAND_PREFIX} learn ${resource}`,\n  recall: (query = '') => `${COMMAND_PREFIX} recall${query ? ' ' + query : ''}`,\n  remember: (content = '<content>') => `${COMMAND_PREFIX} remember${content !== '<content>' ? ' \"' + content + '\"' : ' <content>'}`\n}\n\n// 为了向后兼容，保留函数式API\nfunction getCommands() {\n  return COMMANDS\n}\n\nfunction getBuildCommand() {\n  return buildCommand\n}\n\nfunction detectCommandPrefix() {\n  return COMMAND_PREFIX\n}\n\n\n\n// 系统路径配置（静态）\nconst PATHS = {\n  POUCH_DIR: '.promptx',\n  MEMORY_DIR: '.promptx/memory',\n  STATE_FILE: '.promptx/pouch.json',\n  MEMORY_FILE: '.promptx/memory/declarative.md'\n}\n\n// 版本信息\nconst VERSION = '0.0.1'\n\n// 系统状态\nconst STATES = {\n  INITIALIZED: 'initialized',\n  ROLE_DISCOVERY: 'role_discovery',\n  ACTION_PLAN_GENERATED: 'action_plan_generated',\n  LEARNED_ROLE: 'learned_role',\n  MEMORY_SAVED: 'memory_saved',\n  RECALL_WAITING: 'recall-waiting'\n}\n\n// 导出\nmodule.exports = {\n  // 固定命令前缀\n  COMMAND_PREFIX,\n  \n  // 命令常量\n  COMMANDS,\n  buildCommand,\n  \n  // 向后兼容的函数式API\n  getCommands,\n  getBuildCommand,\n  detectCommandPrefix,\n  \n  // 其他静态常量\n  PATHS,\n  PACKAGE_NAMES,\n  VERSION,\n  STATES\n}\n","const path = require('path')\nconst fs = require('fs')\nconst { getDirectoryService } = require('~/utils/DirectoryService')\nconst { PACKAGE_NAMES } = require('~/constants')\n\nclass ProtocolResolver {\n  constructor() {\n    this.packageRoot = null\n    this.__dirname = __dirname\n    this.directoryService = getDirectoryService()\n  }\n\n  parseReference(reference) {\n    // 支持 @、@!、@? 三种加载语义前缀\n    const match = reference.match(/^@([!?]?)(\\w+):\\/\\/(.+)$/)\n    if (!match) {\n      throw new Error(`Invalid reference format: ${reference}`)\n    }\n    \n    const loadingSemantic = match[1] || '' // '', '!', 或 '?'\n    const protocol = match[2]\n    const resourcePath = match[3]\n    \n    return {\n      loadingSemantic,\n      protocol,\n      resourcePath,\n      fullReference: reference\n    }\n  }\n\n  async resolve(reference) {\n    const { protocol, resourcePath, loadingSemantic } = this.parseReference(reference)\n    \n    switch (protocol) {\n      case 'package':\n        return await this.resolvePackage(resourcePath)\n      case 'project':\n        return await this.resolveProject(resourcePath)\n      case 'file':\n        return await this.resolveFile(resourcePath)\n      default:\n        throw new Error(`Unsupported protocol: ${protocol}`)\n    }\n  }\n\n  async resolvePackage(relativePath) {\n    if (!this.packageRoot) {\n      this.packageRoot = await this.findPackageRoot()\n    }\n    return path.resolve(this.packageRoot, relativePath)\n  }\n\n  async resolveProject(relativePath) {\n    try {\n      const context = {\n        startDir: process.cwd(),\n        platform: process.platform,\n        avoidUserHome: true\n      }\n      const projectRoot = await this.directoryService.getProjectRoot(context)\n      return path.resolve(projectRoot, relativePath)\n    } catch (error) {\n      // 回退到原始逻辑\n      return path.resolve(process.cwd(), relativePath)\n    }\n  }\n\n  async resolveFile(filePath) {\n    if (path.isAbsolute(filePath)) {\n      return filePath\n    }\n    \n    try {\n      const context = {\n        startDir: process.cwd(),\n        platform: process.platform,\n        avoidUserHome: true\n      }\n      const projectRoot = await this.directoryService.getProjectRoot(context)\n      return path.resolve(projectRoot, filePath)\n    } catch (error) {\n      // 回退到原始逻辑\n      return path.resolve(process.cwd(), filePath)\n    }\n  }\n\n  async findPackageRoot() {\n    let dir = this.__dirname\n    while (dir !== path.parse(dir).root) {\n      const packageJson = path.join(dir, 'package.json')\n      if (fs.existsSync(packageJson)) {\n        const pkg = JSON.parse(fs.readFileSync(packageJson, 'utf8'))\n        // 支持配置的包名列表，同时也支持 'promptx' 作为开发版本名称\n        if (pkg.name === 'promptx' || PACKAGE_NAMES.ALL.includes(pkg.name)) {\n          return dir\n        }\n      }\n      dir = path.dirname(dir)\n    }\n    throw new Error('PromptX package root not found')\n  }\n}\n\nmodule.exports = ProtocolResolver","/**\n * 资源数据类\n * 描述单个资源的完整元信息\n */\nclass ResourceData {\n  /**\n   * @param {Object} options - 资源配置选项\n   * @param {string} options.id - 资源唯一标识\n   * @param {string} options.source - 资源来源 ('package' | 'project' | 'user')\n   * @param {string} options.protocol - 资源协议/类型 ('role' | 'thought' | 'execution' | 'knowledge')\n   * @param {string} options.name - 资源名称\n   * @param {string} options.description - 资源描述\n   * @param {string} options.reference - 资源引用路径\n   * @param {Object} options.metadata - 额外元数据\n   */\n  constructor({\n    id,\n    source,\n    protocol,\n    name,\n    description,\n    reference,\n    metadata = {}\n  }) {\n    this.id = id\n    this.source = source\n    this.protocol = protocol\n    this.name = name\n    this.description = description\n    this.reference = reference\n    this.metadata = {\n      createdAt: new Date().toISOString(),\n      updatedAt: new Date().toISOString(),\n      ...metadata\n    }\n  }\n\n  /**\n   * 从原始数据创建ResourceData实例\n   * @param {Object} rawData - 原始数据\n   * @returns {ResourceData} ResourceData实例\n   */\n  static fromRawData(rawData) {\n    return new ResourceData(rawData)\n  }\n\n  /**\n   * 从文件路径和协议推断创建ResourceData\n   * @param {string} filePath - 文件路径（仅用于提取ID，不保存）\n   * @param {string} source - 资源来源\n   * @param {string} protocol - 资源协议\n   * @param {string} reference - 资源引用\n   * @returns {ResourceData} ResourceData实例\n   */\n  static fromFilePath(filePath, source, protocol, reference) {\n    const path = require('path')\n    const fileName = path.basename(filePath, `.${protocol}.md`)\n    \n    return new ResourceData({\n      id: fileName,\n      source,\n      protocol,\n      name: ResourceData._generateDefaultName(fileName, protocol),\n      description: ResourceData._generateDefaultDescription(fileName, protocol),\n      reference,\n      metadata: {\n        inferredFromFile: true\n      }\n    })\n  }\n\n  /**\n   * 生成默认名称\n   * @param {string} id - 资源ID\n   * @param {string} protocol - 资源协议\n   * @returns {string} 默认名称\n   * @private\n   */\n  static _generateDefaultName(id, protocol) {\n    const nameMap = {\n      'role': '角色',\n      'thought': '思维模式',\n      'execution': '执行模式',\n      'knowledge': '知识库'\n    }\n    \n    // 将kebab-case转换为可读名称\n    const readableName = id\n      .split('-')\n      .map(word => word.charAt(0).toUpperCase() + word.slice(1))\n      .join(' ')\n    \n    return `${readableName} ${nameMap[protocol] || protocol}`\n  }\n\n  /**\n   * 生成默认描述\n   * @param {string} id - 资源ID\n   * @param {string} protocol - 资源协议\n   * @returns {string} 默认描述\n   * @private\n   */\n  static _generateDefaultDescription(id, protocol) {\n    const descMap = {\n      'role': '专业角色，提供特定领域的专业能力',\n      'thought': '思维模式，指导AI的思考方式',\n      'execution': '执行模式，定义具体的行为模式',\n      'knowledge': '知识库，提供专业知识和信息'\n    }\n    \n    return descMap[protocol] || `${protocol}类型的资源`\n  }\n\n  /**\n   * 获取完整的资源ID（包含来源前缀）\n   * @returns {string} 完整资源ID\n   */\n  getFullId() {\n    // role类型不需要协议前缀，其他类型需要\n    const baseId = this.protocol === 'role' ? this.id : `${this.protocol}:${this.id}`\n    return `${this.source}:${baseId}`\n  }\n\n  /**\n   * 获取基础资源ID（不包含来源前缀）\n   * @returns {string} 基础资源ID\n   */\n  getBaseId() {\n    return this.protocol === 'role' ? this.id : `${this.protocol}:${this.id}`\n  }\n\n  /**\n   * 检查是否匹配指定的过滤条件\n   * @param {Object} filters - 过滤条件\n   * @returns {boolean} 是否匹配\n   */\n  matches(filters = {}) {\n    for (const [key, value] of Object.entries(filters)) {\n      if (value !== undefined && value !== null) {\n        if (Array.isArray(value)) {\n          if (!value.includes(this[key])) return false\n        } else {\n          if (this[key] !== value) return false\n        }\n      }\n    }\n    return true\n  }\n\n  /**\n   * 更新资源元数据\n   * @param {Object} updates - 更新数据\n   */\n  update(updates) {\n    Object.assign(this, updates)\n    this.metadata.updatedAt = new Date().toISOString()\n  }\n\n  /**\n   * 转换为JSON对象\n   * @returns {Object} JSON对象\n   */\n  toJSON() {\n    return {\n      id: this.id,\n      source: this.source,\n      protocol: this.protocol,\n      name: this.name,\n      description: this.description,\n      reference: this.reference,\n      metadata: this.metadata\n    }\n  }\n\n  /**\n   * 转换为简化的显示格式\n   * @returns {Object} 简化格式\n   */\n  toDisplayFormat() {\n    return {\n      id: this.id,\n      fullId: this.getFullId(),\n      baseId: this.getBaseId(),\n      name: this.name,\n      description: this.description,\n      source: this.source,\n      protocol: this.protocol\n    }\n  }\n\n  /**\n   * 动态获取文件路径\n   * 通过解析 reference 动态计算实际的文件路径\n   * @returns {Promise<string>} 文件路径\n   */\n  async getFilePath() {\n    const ProtocolResolver = require('./ProtocolResolver')\n    const resolver = new ProtocolResolver()\n    \n    try {\n      const resolvedPath = await resolver.resolve(this.reference)\n      return resolvedPath\n    } catch (error) {\n      throw new Error(`无法解析资源路径 ${this.reference}: ${error.message}`)\n    }\n  }\n\n  /**\n   * 克隆资源数据\n   * @returns {ResourceData} 克隆的实例\n   */\n  clone() {\n    return new ResourceData(this.toJSON())\n  }\n}\n\nmodule.exports = ResourceData ","const fs = require('fs-extra')\nconst path = require('path')\nconst ResourceData = require('./ResourceData')\n\n/**\n * 注册表数据管理器 v2.0\n * 基于ResourceData数组的全新架构，严格区分资源来源(source)和资源种类(protocol)\n */\nclass RegistryData {\n  /**\n   * @param {string} source - 注册表来源 ('package' | 'project' | 'user')\n   * @param {string} filePath - 注册表文件路径\n   * @param {Array<ResourceData>} resources - 资源数据数组\n   * @param {Object} metadata - 注册表元数据\n   */\n  constructor(source, filePath, resources = [], metadata = {}) {\n    this.source = source\n    this.filePath = filePath\n    this.resources = resources.map(r => r instanceof ResourceData ? r : ResourceData.fromRawData(r))\n    this.metadata = {\n      version: \"2.0.0\",\n      description: `${source} 级资源注册表`,\n      createdAt: new Date().toISOString(),\n      updatedAt: new Date().toISOString(),\n      ...metadata\n    }\n    this.cache = new Map()\n  }\n\n  /**\n   * 从文件加载注册表数据\n   * @param {string} source - 注册表来源\n   * @param {string} filePath - 文件路径\n   * @returns {Promise<RegistryData>} 注册表数据实例\n   */\n  static async fromFile(source, filePath) {\n    try {\n      const data = await fs.readJSON(filePath)\n      \n      // 处理新格式（v2.0）\n      if (data.version === \"2.0.0\" && Array.isArray(data.resources)) {\n        return new RegistryData(source, filePath, data.resources, data.metadata)\n      }\n      \n      // 处理旧格式（v1.0）- 自动转换\n      if (data.resources && typeof data.resources === 'object') {\n        const resources = []\n        for (const [protocol, resourcesOfType] of Object.entries(data.resources)) {\n          if (resourcesOfType && typeof resourcesOfType === 'object') {\n            for (const [id, reference] of Object.entries(resourcesOfType)) {\n              resources.push(ResourceData.fromFilePath(\n                reference.replace(/^@\\w+:\\/\\//, ''), \n                source, \n                protocol, \n                reference\n              ))\n            }\n          }\n        }\n        return new RegistryData(source, filePath, resources, { \n          migratedFrom: \"v1.0.0\",\n          originalTimestamp: data.timestamp \n        })\n      }\n      \n      throw new Error(`Unsupported registry format in ${filePath}`)\n    } catch (error) {\n      throw new Error(`Failed to load ${source} registry from ${filePath}: ${error.message}`)\n    }\n  }\n\n  /**\n   * 创建空的注册表数据\n   * @param {string} source - 注册表来源\n   * @param {string} filePath - 注册表文件路径\n   * @returns {RegistryData} 空注册表数据实例\n   */\n  static createEmpty(source, filePath) {\n    return new RegistryData(source, filePath, [], {\n      description: `${source} 级资源注册表`,\n      createdAt: new Date().toISOString()\n    })\n  }\n\n  /**\n   * 添加资源\n   * @param {ResourceData|Object} resource - 资源数据\n   */\n  addResource(resource) {\n    const resourceData = resource instanceof ResourceData ? resource : ResourceData.fromRawData(resource)\n    \n    // 对于merged类型的注册表，保持原始来源信息\n    // 只有在非merged注册表中才强制统一来源\n    if (this.source !== 'merged' && resourceData.source !== this.source) {\n      resourceData.source = this.source\n    }\n    \n    // 检查是否已存在相同ID的资源\n    const existingIndex = this.resources.findIndex(r => r.id === resourceData.id && r.protocol === resourceData.protocol)\n    \n    if (existingIndex >= 0) {\n      // 更新现有资源\n      this.resources[existingIndex] = resourceData\n    } else {\n      // 添加新资源\n      this.resources.push(resourceData)\n    }\n    \n    this._updateMetadata()\n    this.cache.clear()\n  }\n\n  /**\n   * 移除资源\n   * @param {string} id - 资源ID\n   * @param {string} protocol - 资源协议\n   * @returns {boolean} 是否成功移除\n   */\n  removeResource(id, protocol) {\n    const initialLength = this.resources.length\n    this.resources = this.resources.filter(r => !(r.id === id && r.protocol === protocol))\n    \n    const removed = this.resources.length < initialLength\n    if (removed) {\n      this._updateMetadata()\n      this.cache.clear()\n    }\n    \n    return removed\n  }\n\n  /**\n   * 查找资源\n   * @param {Object} filters - 过滤条件\n   * @returns {Array<ResourceData>} 匹配的资源数组\n   */\n  findResources(filters = {}) {\n    return this.resources.filter(resource => resource.matches(filters))\n  }\n\n  /**\n   * 根据ID查找资源\n   * @param {string} id - 资源ID\n   * @param {string} protocol - 资源协议（可选）\n   * @returns {ResourceData|null} 找到的资源\n   */\n  findResourceById(id, protocol = null) {\n    return this.resources.find(r => {\n      if (protocol) {\n        return r.id === id && r.protocol === protocol\n      }\n      return r.id === id\n    }) || null\n  }\n\n  /**\n   * 获取指定协议类型的所有资源\n   * @param {string} protocol - 资源协议\n   * @returns {Array<ResourceData>} 资源数组\n   */\n  getResourcesByProtocol(protocol) {\n    return this.resources.filter(r => r.protocol === protocol)\n  }\n\n  /**\n   * 获取资源Map（兼容旧接口）\n   * @param {boolean} includeSourcePrefix - 是否包含源前缀\n   * @returns {Map<string, string>} 资源ID到引用的映射\n   */\n  getResourceMap(includeSourcePrefix = true) {\n    const cacheKey = `resourceMap_${includeSourcePrefix}`\n    if (this.cache.has(cacheKey)) {\n      return this.cache.get(cacheKey)\n    }\n\n    const registry = new Map()\n    \n    for (const resource of this.resources) {\n      if (includeSourcePrefix) {\n        // 包含源前缀的完整ID\n        registry.set(resource.getFullId(), resource.reference)\n        // 同时也注册基础ID（用于向后兼容）\n        registry.set(resource.getBaseId(), resource.reference)\n      } else {\n        // 仅使用基础ID\n        registry.set(resource.getBaseId(), resource.reference)\n      }\n    }\n\n    this.cache.set(cacheKey, registry)\n    return registry\n  }\n\n  /**\n   * 获取所有资源数据\n   * @returns {Array<ResourceData>} 所有资源数组\n   */\n  getAllResources() {\n    return [...this.resources]\n  }\n\n  /**\n   * 获取统计信息\n   * @returns {Object} 统计信息\n   */\n  getStats() {\n    const stats = {\n      totalResources: this.resources.length,\n      byProtocol: {},\n      bySource: {}\n    }\n\n    for (const resource of this.resources) {\n      // 按协议统计\n      stats.byProtocol[resource.protocol] = (stats.byProtocol[resource.protocol] || 0) + 1\n      \n      // 按来源统计\n      stats.bySource[resource.source] = (stats.bySource[resource.source] || 0) + 1\n    }\n\n    return stats\n  }\n\n  /**\n   * 合并其他注册表数据\n   * @param {RegistryData} otherRegistry - 其他注册表数据\n   * @param {boolean} overwrite - 是否覆盖现有资源\n   */\n  merge(otherRegistry, overwrite = false) {\n    for (const resource of otherRegistry.resources) {\n      const existing = this.findResourceById(resource.id, resource.protocol)\n      \n      if (!existing || overwrite) {\n        this.addResource(resource.clone())\n      }\n    }\n  }\n\n  /**\n   * 保存注册表到文件\n   * @returns {Promise<void>}\n   */\n  async save() {\n    try {\n      // 确保目录存在\n      await fs.ensureDir(path.dirname(this.filePath))\n      \n      // 更新元数据\n      this._updateMetadata()\n      \n      // 构建保存数据\n      const saveData = {\n        version: this.metadata.version,\n        source: this.source,\n        metadata: this.metadata,\n        resources: this.resources.map(r => r.toJSON()),\n        stats: this.getStats()\n      }\n      \n      // 保存文件\n      await fs.writeJSON(this.filePath, saveData, { spaces: 2 })\n    } catch (error) {\n      throw new Error(`Failed to save ${this.source} registry to ${this.filePath}: ${error.message}`)\n    }\n  }\n\n  /**\n   * 更新元数据\n   * @private\n   */\n  _updateMetadata() {\n    this.metadata.updatedAt = new Date().toISOString()\n    this.metadata.resourceCount = this.resources.length\n  }\n\n  /**\n   * 获取注册表大小\n   * @returns {number} 资源数量\n   */\n  get size() {\n    return this.resources.length\n  }\n\n  /**\n   * 检查注册表是否为空\n   * @returns {boolean} 是否为空\n   */\n  isEmpty() {\n    return this.resources.length === 0\n  }\n\n  /**\n   * 清空所有资源\n   */\n  clear() {\n    this.resources = []\n    this._updateMetadata()\n    this.cache.clear()\n  }\n\n  /**\n   * 克隆注册表数据\n   * @returns {RegistryData} 克隆的注册表数据\n   */\n  clone() {\n    const clonedResources = this.resources.map(r => r.clone())\n    return new RegistryData(this.source, this.filePath, clonedResources, { ...this.metadata })\n  }\n\n  /**\n   * 转换为JSON对象\n   * @returns {Object} JSON对象\n   */\n  toJSON() {\n    return {\n      version: this.metadata.version,\n      source: this.source,\n      metadata: this.metadata,\n      resources: this.resources.map(r => r.toJSON()),\n      stats: this.getStats()\n    }\n  }\n}\n\nmodule.exports = RegistryData ","/**\n * 资源模块基础数据类型定义\n * 基于DPML资源协议标准\n */\n\n/**\n * 加载语义枚举\n */\nconst LoadingSemantics = {\n  DEFAULT: 'default', // @ - AI自行决定加载时机\n  HOT_LOAD: 'hot_load', // @! - 立即加载\n  LAZY_LOAD: 'lazy_load' // @? - 懒加载\n}\n\n/**\n * 解析后的资源引用\n */\nclass ParsedReference {\n  constructor () {\n    this.loadingSemantics = LoadingSemantics.DEFAULT\n    this.protocol = ''\n    this.path = ''\n    this.queryParams = new QueryParams()\n    this.isNested = false\n    this.nestedRef = null\n    this.originalRef = ''\n  }\n}\n\n/**\n * 查询参数\n */\nclass QueryParams {\n  constructor () {\n    this.line = null // 行范围 \"5-10\"\n    this.format = null // 输出格式 \"json\"\n    this.cache = null // 是否缓存，默认为null表示未设置\n    this.params = new Map() // 其他参数\n  }\n\n  /**\n   * 设置参数\n   */\n  set (key, value) {\n    if (['line', 'format', 'cache'].includes(key)) {\n      this[key] = value\n    } else {\n      this.params.set(key, value)\n    }\n  }\n\n  /**\n   * 获取参数\n   */\n  get (key) {\n    if (['line', 'format', 'cache'].includes(key)) {\n      return this[key]\n    }\n    return this.params.get(key)\n  }\n\n  /**\n   * 获取所有参数\n   */\n  getAll () {\n    const result = {}\n\n    // 只添加非null的内置参数\n    if (this.line !== null) {\n      result.line = this.line\n    }\n    if (this.format !== null) {\n      result.format = this.format\n    }\n    if (this.cache !== null) {\n      result.cache = this.cache\n    }\n\n    // 添加其他参数\n    for (const [key, value] of this.params) {\n      result[key] = value\n    }\n\n    return result\n  }\n\n  /**\n   * 转换为字符串用于缓存键\n   */\n  toString () {\n    const params = []\n\n    // 添加内置参数\n    if (this.line !== null) {\n      params.push(`line=${this.line}`)\n    }\n    if (this.format !== null) {\n      params.push(`format=${this.format}`)\n    }\n    if (this.cache !== null) {\n      params.push(`cache=${this.cache}`)\n    }\n\n    // 添加其他参数（按键排序以确保一致性）\n    const sortedParams = Array.from(this.params.entries()).sort()\n    for (const [key, value] of sortedParams) {\n      params.push(`${key}=${value}`)\n    }\n\n    return params.join('&')\n  }\n}\n\n/**\n * 嵌套引用\n */\nclass NestedReference {\n  constructor () {\n    this.outer = null // 外层引用\n    this.inner = null // 内层引用\n    this.depth = 0 // 嵌套深度\n  }\n}\n\n/**\n * 资源内容\n */\nclass ResourceContent {\n  constructor (path, content, metadata = {}) {\n    this.path = path\n    this.content = content\n    this.metadata = metadata\n    this.relativePath = ''\n    this.lastModified = null\n    this.size = content ? content.length : 0\n  }\n}\n\n/**\n * 懒加载资源\n */\nclass LazyResource {\n  constructor (path, loader) {\n    this.path = path\n    this.loader = loader\n    this.loaded = false\n    this._content = null\n  }\n\n  /**\n   * 加载资源\n   */\n  async load () {\n    if (!this.loaded) {\n      this._content = await this.loader(this.path)\n      this.loaded = true\n    }\n    return this._content\n  }\n}\n\n/**\n * 处理后的结果\n */\nclass ProcessedResult {\n  constructor () {\n    this.content = ''\n    this.metadata = {}\n    this.format = 'text'\n    this.sources = []\n    this.cached = false\n  }\n}\n\n/**\n * 最终资源结果\n */\nclass ResourceResult {\n  constructor () {\n    this.content = ''\n    this.metadata = {}\n    this.sources = []\n    this.format = 'text'\n    this.cached = false\n    this.loadTime = Date.now()\n    this.success = true\n    this.error = null\n  }\n\n  /**\n   * 创建成功结果\n   */\n  static success (content, metadata = {}) {\n    const result = new ResourceResult()\n    result.content = content\n    result.metadata = metadata\n    result.success = true\n    return result\n  }\n\n  /**\n   * 创建错误结果\n   */\n  static error (error, metadata = {}) {\n    const result = new ResourceResult()\n    result.success = false\n    result.error = error\n    result.metadata = metadata\n    return result\n  }\n}\n\n/**\n * 资源协议信息\n */\nclass ProtocolInfo {\n  constructor () {\n    this.name = ''\n    this.description = ''\n    this.location = '' // EBNF路径定义\n    this.params = {} // 支持的参数\n    this.registry = new Map() // ID到路径的映射\n  }\n}\n\nmodule.exports = {\n  LoadingSemantics,\n  ParsedReference,\n  QueryParams,\n  NestedReference,\n  ResourceContent,\n  LazyResource,\n  ProcessedResult,\n  ResourceResult,\n  ProtocolInfo\n}\n","const {\n  LoadingSemantics,\n  ParsedReference,\n  QueryParams,\n  NestedReference\n} = require('./types')\n\n/**\n * 资源协议解析器\n * 解析DPML资源引用语法：@protocol://path?params\n */\nclass ResourceProtocolParser {\n  constructor () {\n    // 资源引用正则表达式\n    this.resourceRefRegex = /^(@[!?]?|@)([a-zA-Z][a-zA-Z0-9_-]*):(.+)$/\n    this.nestedRefRegex = /^(@[!?]?|@)([a-zA-Z][a-zA-Z0-9_-]*):(@[!?]?|@)?(.+)$/\n    this.queryParamsRegex = /^([^?]+)(?:\\?(.+))?$/\n  }\n\n  /**\n   * 解析资源引用\n   * @param {string} resourceRef - 资源引用字符串\n   * @returns {ParsedReference} 解析后的引用对象\n   */\n  parse (resourceRef) {\n    if (!resourceRef || typeof resourceRef !== 'string') {\n      throw new Error('Invalid resource reference: must be a non-empty string')\n    }\n\n    const trimmedRef = resourceRef.trim()\n    if (!this.validateSyntax(trimmedRef)) {\n      throw new Error(`Invalid resource reference syntax: ${trimmedRef}`)\n    }\n\n    const parsed = new ParsedReference()\n    parsed.originalRef = trimmedRef\n\n    // 检查是否为嵌套引用\n    if (this.isNestedReference(trimmedRef)) {\n      return this.parseNestedReference(trimmedRef)\n    }\n\n    // 解析基础引用\n    return this.parseBasicReference(trimmedRef)\n  }\n\n  /**\n   * 解析基础资源引用\n   * @param {string} ref - 基础引用\n   * @returns {ParsedReference}\n   */\n  parseBasicReference (ref) {\n    const parsed = new ParsedReference()\n    parsed.originalRef = ref\n\n    // 解析加载语义\n    parsed.loadingSemantics = this.parseLoadingSemantics(ref)\n\n    // 移除加载语义前缀\n    const withoutSemantics = this.removeLoadingSemantics(ref)\n\n    // 匹配协议和路径\n    const match = withoutSemantics.match(/^([a-zA-Z][a-zA-Z0-9_-]*):(.+)$/)\n    if (!match) {\n      throw new Error(`Invalid protocol format: ${ref}`)\n    }\n\n    parsed.protocol = match[1]\n    let pathAndParams = match[2]\n\n    // 移除 :// 前缀（如果存在）\n    if (pathAndParams.startsWith('//')) {\n      pathAndParams = pathAndParams.substring(2)\n    }\n\n    // 解析路径和查询参数\n    const pathMatch = pathAndParams.match(this.queryParamsRegex)\n    if (pathMatch) {\n      parsed.path = pathMatch[1]\n      if (pathMatch[2]) {\n        parsed.queryParams = this.parseQueryParams(pathMatch[2])\n      }\n    } else {\n      parsed.path = pathAndParams\n    }\n\n    return parsed\n  }\n\n  /**\n   * 解析嵌套引用\n   * @param {string} ref - 嵌套引用\n   * @returns {ParsedReference}\n   */\n  parseNestedReference (ref) {\n    const parsed = new ParsedReference()\n    parsed.originalRef = ref\n    parsed.isNested = true\n\n    // 解析外层加载语义\n    parsed.loadingSemantics = this.parseLoadingSemantics(ref)\n    const withoutOuterSemantics = this.removeLoadingSemantics(ref)\n\n    // 匹配嵌套结构: protocol:@inner_protocol://path 或 protocol:inner_protocol://path\n    const match = withoutOuterSemantics.match(/^([a-zA-Z][a-zA-Z0-9_-]*):(.+)$/)\n    if (!match) {\n      throw new Error(`Invalid nested reference format: ${ref}`)\n    }\n\n    parsed.protocol = match[1]\n    let innerRef = match[2]\n\n    // 处理内层引用：移除可能的 :// 前缀，但保留 @ 前缀\n    if (innerRef.startsWith('//')) {\n      innerRef = innerRef.substring(2)\n    }\n\n    // 确保内层引用有正确的格式\n    if (!innerRef.startsWith('@')) {\n      innerRef = '@' + innerRef\n    }\n\n    // 递归解析内层引用\n    try {\n      const innerParsed = this.parse(innerRef)\n\n      // 创建嵌套引用结构\n      const nested = new NestedReference()\n      nested.outer = parsed\n      nested.inner = innerParsed\n      nested.depth = this.calculateNestingDepth(innerParsed)\n\n      parsed.nestedRef = nested\n    } catch (error) {\n      throw new Error(`Invalid nested inner reference: ${error.message}`)\n    }\n\n    return parsed\n  }\n\n  /**\n   * 解析加载语义\n   * @param {string} ref - 资源引用\n   * @returns {string} 加载语义\n   */\n  parseLoadingSemantics (ref) {\n    if (ref.startsWith('@!')) {\n      return LoadingSemantics.HOT_LOAD\n    } else if (ref.startsWith('@?')) {\n      return LoadingSemantics.LAZY_LOAD\n    } else if (ref.startsWith('@')) {\n      return LoadingSemantics.DEFAULT\n    }\n\n    throw new Error(`Invalid loading semantics: ${ref}`)\n  }\n\n  /**\n   * 移除加载语义前缀\n   * @param {string} ref - 资源引用\n   * @returns {string} 移除前缀后的引用\n   */\n  removeLoadingSemantics (ref) {\n    if (ref.startsWith('@!') || ref.startsWith('@?')) {\n      return ref.substring(2)\n    } else if (ref.startsWith('@')) {\n      return ref.substring(1)\n    }\n    return ref\n  }\n\n  /**\n   * 解析查询参数\n   * @param {string} queryString - 查询字符串\n   * @returns {QueryParams} 查询参数对象\n   */\n  parseQueryParams (queryString) {\n    const params = new QueryParams()\n\n    if (!queryString) {\n      return params\n    }\n\n    const pairs = queryString.split('&')\n    for (const pair of pairs) {\n      const [key, value] = pair.split('=').map(decodeURIComponent)\n\n      if (key) {\n        // 处理特殊参数\n        if (key === 'cache') {\n          params.set(key, value === 'true' || value === '1')\n        } else {\n          params.set(key, value || '')\n        }\n      }\n    }\n\n    return params\n  }\n\n  /**\n   * 验证语法\n   * @param {string} ref - 资源引用\n   * @returns {boolean} 是否有效\n   */\n  validateSyntax (ref) {\n    if (!ref) return false\n\n    // 必须以@开头\n    if (!ref.startsWith('@')) return false\n\n    // 基本格式检查\n    const withoutSemantics = this.removeLoadingSemantics(ref)\n    return /^[a-zA-Z][a-zA-Z0-9_-]*:.+$/.test(withoutSemantics)\n  }\n\n  /**\n   * 检查是否为嵌套引用\n   * @param {string} ref - 资源引用\n   * @returns {boolean} 是否为嵌套引用\n   */\n  isNestedReference (ref) {\n    const withoutSemantics = this.removeLoadingSemantics(ref)\n    const colonIndex = withoutSemantics.indexOf(':')\n\n    if (colonIndex === -1) return false\n\n    const afterColon = withoutSemantics.substring(colonIndex + 1)\n\n    // 检查是否包含内层引用 (@protocol: 或 protocol:)\n    return afterColon.includes('@') || afterColon.includes('://')\n  }\n\n  /**\n   * 计算嵌套深度\n   * @param {ParsedReference} ref - 解析后的引用\n   * @returns {number} 嵌套深度\n   */\n  calculateNestingDepth (ref) {\n    if (!ref.isNested) return 1\n    return 1 + this.calculateNestingDepth(ref.nestedRef.inner)\n  }\n\n  /**\n   * 提取协议名\n   * @param {string} ref - 资源引用\n   * @returns {string} 协议名\n   */\n  extractProtocol (ref) {\n    const withoutSemantics = this.removeLoadingSemantics(ref)\n    const colonIndex = withoutSemantics.indexOf(':')\n    return colonIndex > 0 ? withoutSemantics.substring(0, colonIndex) : ''\n  }\n\n  /**\n   * 提取路径\n   * @param {string} ref - 资源引用\n   * @returns {string} 路径\n   */\n  extractPath (ref) {\n    const withoutSemantics = this.removeLoadingSemantics(ref)\n    const colonIndex = withoutSemantics.indexOf(':')\n    if (colonIndex === -1) return ''\n\n    let pathAndParams = withoutSemantics.substring(colonIndex + 1)\n\n    // 移除 :// 前缀（如果存在）\n    if (pathAndParams.startsWith('//')) {\n      pathAndParams = pathAndParams.substring(2)\n    }\n\n    const queryIndex = pathAndParams.indexOf('?')\n    return queryIndex > 0 ? pathAndParams.substring(0, queryIndex) : pathAndParams\n  }\n\n  /**\n   * 提取查询参数字符串\n   * @param {string} ref - 资源引用\n   * @returns {string} 查询参数字符串\n   */\n  extractParams (ref) {\n    const queryIndex = ref.indexOf('?')\n    return queryIndex > 0 ? ref.substring(queryIndex + 1) : ''\n  }\n}\n\nmodule.exports = ResourceProtocolParser\n","/**\n * BaseDiscovery - 资源发现基础抽象类\n * \n * 按照DPML协议架构文档设计，提供统一的资源发现接口\n * 所有具体的Discovery实现都应该继承这个基类\n */\nclass BaseDiscovery {\n  /**\n   * 构造函数\n   * @param {string} source - 发现源类型 (PACKAGE, PROJECT, USER, INTERNET)\n   * @param {number} priority - 优先级，数字越小优先级越高\n   */\n  constructor(source, priority = 0) {\n    if (!source) {\n      throw new Error('Discovery source is required')\n    }\n    \n    this.source = source\n    this.priority = priority\n    this.cache = new Map()\n  }\n\n  /**\n   * 抽象方法：发现资源\n   * 子类必须实现此方法\n   * @returns {Promise<Array>} 发现的资源列表\n   */\n  async discover() {\n    throw new Error('discover method must be implemented by subclass')\n  }\n\n  /**\n   * 获取发现器信息\n   * @returns {Object} 发现器元数据\n   */\n  getDiscoveryInfo() {\n    return {\n      source: this.source,\n      priority: this.priority,\n      description: `${this.source} resource discovery`\n    }\n  }\n\n  /**\n   * 验证资源结构\n   * @param {Object} resource - 待验证的资源对象\n   * @throws {Error} 如果资源结构无效\n   */\n  validateResource(resource) {\n    if (!resource || typeof resource !== 'object') {\n      throw new Error('Resource must be an object')\n    }\n\n    if (!resource.id || !resource.reference) {\n      throw new Error('Resource must have id and reference')\n    }\n\n    // 验证ID格式 (protocol:resourcePath)\n    if (typeof resource.id !== 'string' || !resource.id.includes(':')) {\n      throw new Error('Resource id must be in format \"protocol:resourcePath\"')\n    }\n\n    // 验证引用格式 (@protocol://path)\n    if (typeof resource.reference !== 'string' || !resource.reference.startsWith('@')) {\n      throw new Error('Resource reference must be in DPML format \"@protocol://path\"')\n    }\n  }\n\n  /**\n   * 规范化资源对象，添加元数据\n   * @param {Object} resource - 原始资源对象\n   * @returns {Object} 规范化后的资源对象\n   */\n  normalizeResource(resource) {\n    // 验证资源结构\n    this.validateResource(resource)\n\n    // 创建规范化的资源对象\n    const normalizedResource = {\n      id: resource.id,\n      reference: resource.reference,\n      metadata: {\n        source: this.source,\n        priority: this.priority,\n        timestamp: new Date(),\n        ...resource.metadata // 保留现有元数据\n      }\n    }\n\n    return normalizedResource\n  }\n\n  /**\n   * 清理缓存\n   */\n  clearCache() {\n    this.cache.clear()\n  }\n\n  /**\n   * 获取缓存大小\n   * @returns {number} 缓存条目数量\n   */\n  getCacheSize() {\n    return this.cache.size\n  }\n\n  /**\n   * 从缓存获取资源\n   * @param {string} key - 缓存键\n   * @returns {*} 缓存的值或undefined\n   */\n  getFromCache(key) {\n    return this.cache.get(key)\n  }\n\n  /**\n   * 设置缓存\n   * @param {string} key - 缓存键\n   * @param {*} value - 缓存值\n   */\n  setCache(key, value) {\n    this.cache.set(key, value)\n  }\n}\n\nmodule.exports = BaseDiscovery","/**\n * 包级资源发现器 - 从 @promptx/resource 包加载系统内置资源\n * 新版本：直接从 npm 包加载，不再依赖文件系统扫描\n */\n\nconst BaseDiscovery = require('./BaseDiscovery')\nconst logger = require('@promptx/logger')\n\n/**\n * 包级资源发现器\n * 负责从 @promptx/resource 包加载系统内置的角色、工具等资源\n */\nclass PackageDiscovery extends BaseDiscovery {\n  constructor(resourceManager) {\n    super('PACKAGE')\n    this.resourceManager = resourceManager\n  }\n\n  /**\n   * 发现包级资源 - 从 @promptx/resource 包加载\n   * @returns {Promise<Array>} 发现的资源列表\n   */\n  async discover() {\n    try {\n      // 使用新的 @promptx/resource API\n      const { registry } = require('@promptx/resource')\n      \n      if (!registry) {\n        logger.warn('[PackageDiscovery] @promptx/resource 注册表未正确加载')\n        return []\n      }\n      const resources = []\n      \n      // v2.0.0 格式：resources 是数组\n      if (Array.isArray(registry.resources)) {\n        for (const resource of registry.resources) {\n          resources.push({\n            id: resource.id,\n            type: resource.protocol,  // 使用 protocol 字段\n            path: resource.metadata?.path || resource.reference,\n            name: resource.name || resource.id,\n            metadata: {\n              description: resource.description,\n              modified: resource.metadata?.modified,\n              size: resource.metadata?.size,\n              source: 'package',  // 小写以保持一致\n              packageName: '@promptx/resource'\n            }\n          })\n        }\n      }\n      \n      logger.info(`[PackageDiscovery] ✅ 从 @promptx/resource 加载了 ${resources.length} 个系统资源`)\n      return resources\n\n    } catch (error) {\n      // 如果包不存在或加载失败，返回空数组（不阻塞其他发现器）\n      logger.warn(`[PackageDiscovery] ⚠️ 加载 @promptx/resource 失败: ${error.message}`)\n      return []\n    }\n  }\n\n  /**\n   * 发现包级资源注册表\n   * @returns {Promise<Map>} 资源注册表 Map<resourceId, reference>\n   */\n  async discoverRegistry() {\n    try {\n      // 使用新的 @promptx/resource API\n      const { registry } = require('@promptx/resource')\n      \n      if (!registry) {\n        logger.warn('[PackageDiscovery] @promptx/resource 注册表未正确加载')\n        return new Map()\n      }\n\n      const registryMap = new Map()\n      \n      // v2.0.0 格式：resources 是数组\n      if (Array.isArray(registry.resources)) {\n        for (const resource of registry.resources) {\n          // 添加多种引用格式\n          const reference = resource.reference || `@package://resources/${resource.metadata?.path}`\n          registryMap.set(resource.id, reference)\n          registryMap.set(`package:${resource.id}`, reference)\n        }\n      }\n      \n      if (registryMap.size > 0) {\n        logger.info(`[PackageDiscovery] ✅ 从 @promptx/resource 加载了 ${registryMap.size / 2} 个系统资源到注册表`)\n      }\n      \n      return registryMap\n\n    } catch (error) {\n      logger.warn(`[PackageDiscovery] ⚠️ 系统资源注册表加载失败: ${error.message}`)\n      return new Map()\n    }\n  }\n\n  /**\n   * 获取包资源的基础目录（用于文件访问）\n   * @returns {Promise<string>} 包资源目录路径\n   */\n  async getPackageRoot() {\n    try {\n      // 获取 @promptx/resource 包的实际路径\n      const resourcePackagePath = require.resolve('@promptx/resource')\n      const path = require('path')\n      \n      // 找到包的根目录（包含 package.json 的目录）\n      let currentDir = path.dirname(resourcePackagePath)\n      while (currentDir !== path.dirname(currentDir)) {\n        const packageJsonPath = path.join(currentDir, 'package.json')\n        try {\n          const packageJson = require(packageJsonPath)\n          if (packageJson.name === '@promptx/resource') {\n            return currentDir\n          }\n        } catch {\n          // 继续向上查找\n        }\n        currentDir = path.dirname(currentDir)\n      }\n      \n      throw new Error('无法找到 @promptx/resource 包的根目录')\n    } catch (error) {\n      logger.error(`[PackageDiscovery] ❌ 获取包根目录失败: ${error.message}`)\n      throw error\n    }\n  }\n\n  /**\n   * 获取注册表数据（ResourceManager 需要的方法）\n   * @returns {Promise<RegistryData>} 注册表数据实例\n   */\n  async getRegistryData() {\n    try {\n      logger.info('[PackageDiscovery] Starting getRegistryData...')\n      const { registry } = require('@promptx/resource')\n      logger.info('[PackageDiscovery] @promptx/resource loaded successfully')\n      const RegistryData = require('../RegistryData')\n      const ResourceData = require('../ResourceData')\n      \n      if (!registry) {\n        logger.warn('[PackageDiscovery] Registry is empty')\n        return new RegistryData('package', '', [])\n      }\n      \n      logger.info(`[PackageDiscovery] Registry loaded with ${registry.resources?.length || 0} resources`)\n      const resources = []\n      \n      // v2.0.0 格式：resources 是数组，直接处理\n      if (Array.isArray(registry.resources)) {\n        for (const resource of registry.resources) {\n          resources.push(new ResourceData({\n            id: resource.id,\n            source: 'package',  // 使用小写保持一致\n            protocol: resource.protocol,  // 直接使用资源的 protocol 字段\n            name: resource.name || resource.id,\n            description: resource.description || '',\n            reference: resource.reference,\n            metadata: resource.metadata || {}\n          }))\n        }\n      }\n      \n      logger.info(`[PackageDiscovery] Successfully created ${resources.length} ResourceData objects`)\n      return new RegistryData('package', '@promptx/resource', resources)\n    } catch (error) {\n      logger.error(`[PackageDiscovery] Error in getRegistryData: ${error.message}`)\n      logger.error(`[PackageDiscovery] Stack trace: ${error.stack}`)\n      logger.warn(`[PackageDiscovery] 获取注册表数据失败: ${error.message}`)\n      const RegistryData = require('../RegistryData')\n      return new RegistryData('package', '', [])\n    }\n  }\n\n  /**\n   * 获取环境信息（用于调试）\n   */\n  getEnvironmentInfo() {\n    return {\n      type: 'PackageDiscovery',\n      source: '@promptx/resource',\n      loaded: this._tryRequirePackage() !== null\n    }\n  }\n\n  /**\n   * 尝试加载包（内部辅助方法）\n   */\n  _tryRequirePackage() {\n    try {\n      const { registry } = require('@promptx/resource')\n      return registry ? { registry } : null\n    } catch {\n      return null\n    }\n  }\n}\n\nmodule.exports = PackageDiscovery","const logger = require('@promptx/logger')\nconst RegistryData = require('../RegistryData')\nconst ResourceData = require('../ResourceData')\nconst fs = require('fs-extra')\nconst path = require('path')\n\n/**\n * ProjectDiscovery - 项目级资源发现器（恢复重构前完整逻辑）\n * \n * 核心设计原则：\n * 1. 完全基于@project协议，支持HTTP/本地模式\n * 2. 优先使用注册表，fallback到动态扫描  \n * 3. 恢复重构前的专业目录结构处理能力\n * 4. 恢复完整的ResourceData构建和文件验证逻辑\n */\nclass ProjectDiscovery {\n  constructor() {\n    this.source = 'PROJECT'\n    this.priority = 2\n    this.projectProtocol = null\n  }\n\n  /**\n   * 获取ProjectProtocol实例\n   */\n  getProjectProtocol() {\n    if (!this.projectProtocol) {\n      const { getGlobalResourceManager } = require('../../resource')\n      const resourceManager = getGlobalResourceManager()\n      this.projectProtocol = resourceManager.protocols.get('project')\n    }\n    return this.projectProtocol\n  }\n\n  /**\n   * 发现项目级资源注册表\n   * @returns {Promise<Map>} 资源注册表 Map<resourceId, reference>\n   */\n  async discoverRegistry() {\n    try {\n      // 1. 优先尝试从注册表加载\n      const registryMap = await this.loadFromRegistry()\n      if (registryMap.size > 0) {\n        logger.debug(`ProjectDiscovery 从注册表加载 ${registryMap.size} 个资源`)\n        return registryMap\n      }\n\n      // 2. Fallback: 动态扫描生成注册表\n      logger.debug('ProjectDiscovery 注册表不存在，使用动态扫描')\n      const resources = await this.scanProjectResources()\n      return this.buildRegistryFromResources(resources)\n\n    } catch (error) {\n      logger.warn(`[ProjectDiscovery] Registry discovery failed: ${error.message}`)\n      return new Map()\n    }\n  }\n\n  /**\n   * 从注册表文件加载资源\n   * @returns {Promise<Map>} 资源注册表\n   */\n  async loadFromRegistry() {\n    try {\n      const protocol = this.getProjectProtocol()\n      \n      // 使用@project协议检查注册表文件\n      const registryPath = await protocol.resolvePath('.promptx/resource/project.registry.json')\n      \n      if (!await fs.pathExists(registryPath)) {\n        return new Map()\n      }\n\n      // 加载并解析注册表\n      const registryData = await RegistryData.fromFile('project', registryPath)\n      return registryData.getResourceMap(true) // 带前缀\n      \n    } catch (error) {\n      logger.warn(`[ProjectDiscovery] Failed to load registry: ${error.message}`)\n      return new Map()\n    }\n  }\n\n  /**\n   * 动态扫描项目资源 - 恢复重构前的专业扫描逻辑\n   * @returns {Promise<Array>} 资源列表\n   */\n  async scanProjectResources() {\n    try {\n      const protocol = this.getProjectProtocol()\n      \n      // 使用@project协议获取资源目录\n      const resourceDir = await protocol.resolvePath('.promptx/resource')\n      \n      if (!await fs.pathExists(resourceDir)) {\n        logger.debug('ProjectDiscovery 项目资源目录不存在')\n        return []\n      }\n\n      // 创建临时注册表来收集资源\n      const tempRegistry = RegistryData.createEmpty('project', null)\n      \n      // 扫描专业目录结构\n      await this._scanDirectory(resourceDir, tempRegistry)\n      \n      // 转换为资源列表\n      const resources = []\n      for (const resource of tempRegistry.resources) {\n        resources.push({\n          id: resource.id,\n          protocol: resource.protocol,\n          reference: resource.reference,\n          source: resource.source\n        })\n      }\n\n      logger.info(`[ProjectDiscovery] ✅ 项目扫描完成，发现 ${resources.length} 个资源`)\n      return resources\n      \n    } catch (error) {\n      logger.warn(`[ProjectDiscovery] 扫描项目资源失败: ${error.message}`)\n      return []\n    }\n  }\n\n  /**\n   * 扫描目录并添加资源到注册表（通用递归扫描）\n   * @param {string} resourcesDir - 资源目录\n   * @param {RegistryData} registryData - 注册表数据\n   * @private\n   */\n  async _scanDirectory(resourcesDir, registryData) {\n    try {\n      // 递归扫描整个resource目录\n      await this._recursiveScan(resourcesDir, '', registryData)\n    } catch (error) {\n      logger.warn(`[ProjectDiscovery] 扫描资源目录失败: ${error.message}`)\n    }\n  }\n\n  /**\n   * 递归扫描目录\n   * @param {string} currentPath - 当前扫描路径\n   * @param {string} relativePath - 相对于resource目录的路径\n   * @param {RegistryData} registryData - 注册表数据\n   * @private\n   */\n  async _recursiveScan(currentPath, relativePath, registryData) {\n    try {\n      const items = await fs.readdir(currentPath)\n      \n      for (const item of items) {\n        const itemPath = path.join(currentPath, item)\n        const stat = await fs.stat(itemPath)\n        const newRelativePath = relativePath ? `${relativePath}/${item}` : item\n        \n        if (stat.isDirectory()) {\n          // 递归扫描子目录\n          await this._recursiveScan(itemPath, newRelativePath, registryData)\n        } else {\n          // 处理文件\n          await this._processFile(itemPath, newRelativePath, registryData)\n        }\n      }\n    } catch (error) {\n      logger.warn(`[ProjectDiscovery] 扫描${currentPath}失败: ${error.message}`)\n    }\n  }\n\n  /**\n   * 处理单个文件\n   * @param {string} filePath - 文件完整路径\n   * @param {string} relativePath - 相对路径\n   * @param {RegistryData} registryData - 注册表数据\n   * @private\n   */\n  async _processFile(filePath, relativePath, registryData) {\n    const fileName = path.basename(filePath)\n    let protocol = null\n    let resourceId = null\n    \n    // 根据文件名后缀识别资源类型\n    if (fileName.endsWith('.role.md')) {\n      protocol = 'role'\n      resourceId = path.basename(fileName, '.role.md')\n    } else if (fileName.endsWith('.thought.md')) {\n      protocol = 'thought'\n      resourceId = path.basename(fileName, '.thought.md')\n    } else if (fileName.endsWith('.execution.md')) {\n      protocol = 'execution'\n      resourceId = path.basename(fileName, '.execution.md')\n    } else if (fileName.endsWith('.knowledge.md')) {\n      protocol = 'knowledge'\n      resourceId = path.basename(fileName, '.knowledge.md')\n    } else if (fileName.endsWith('.tool.js')) {\n      protocol = 'tool'\n      resourceId = path.basename(fileName, '.tool.js')\n    } else if (fileName.endsWith('.manual.md')) {\n      protocol = 'manual'\n      resourceId = path.basename(fileName, '.manual.md')\n    }\n    \n    if (protocol && resourceId) {\n      // 验证文件内容\n      if (await this._validateResourceFile(filePath, protocol)) {\n        const reference = `@project://.promptx/resource/${relativePath}`\n        \n        const resourceData = new ResourceData({\n          id: resourceId,\n          source: 'project',\n          protocol: protocol,\n          name: ResourceData._generateDefaultName(resourceId, protocol),\n          description: ResourceData._generateDefaultDescription(resourceId, protocol),\n          reference: reference,\n          metadata: {\n            scannedAt: new Date().toISOString(),\n            path: relativePath\n          }\n        })\n        \n        registryData.addResource(resourceData)\n        logger.debug(`[ProjectDiscovery] 发现${protocol}资源: ${resourceId} at ${relativePath}`)\n      }\n    }\n  }\n\n\n  /**\n   * 验证资源文件格式（恢复重构前逻辑）\n   * @param {string} filePath - 文件路径\n   * @param {string} protocol - 协议类型\n   * @returns {Promise<boolean>} 是否是有效的资源文件\n   */\n  async _validateResourceFile(filePath, protocol) {\n    try {\n      const content = await fs.readFile(filePath, 'utf8')\n\n      if (!content || typeof content !== 'string') {\n        return false\n      }\n\n      const trimmedContent = content.trim()\n      if (trimmedContent.length === 0) {\n        return false\n      }\n\n      // 根据协议类型验证DPML标签\n      switch (protocol) {\n        case 'role':\n          return trimmedContent.includes('<role>') && trimmedContent.includes('</role>')\n        case 'execution':\n          return trimmedContent.includes('<execution>') && trimmedContent.includes('</execution>')\n        case 'thought':\n          return trimmedContent.includes('<thought>') && trimmedContent.includes('</thought>')\n        case 'knowledge':\n          // knowledge类型比较灵活，只要文件有内容就认为是有效的\n          return true\n        case 'manual':\n          return trimmedContent.includes('<manual>') && trimmedContent.includes('</manual>')\n        case 'tool':\n          // tool文件是JavaScript，进行基本的语法验证\n          try {\n            new Function(trimmedContent)\n            return true\n          } catch (e) {\n            logger.warn(`[ProjectDiscovery] Invalid JavaScript in tool file ${filePath}: ${e.message}`)\n            return false\n          }\n        default:\n          return false\n      }\n    } catch (error) {\n      logger.warn(`[ProjectDiscovery] Failed to validate ${filePath}: ${error.message}`)\n      return false\n    }\n  }\n\n  /**\n   * 从资源列表构建注册表Map\n   * @param {Array} resources - 资源列表\n   * @returns {Map} 资源注册表\n   */\n  buildRegistryFromResources(resources) {\n    const registryMap = new Map()\n    \n    resources.forEach(resource => {\n      const key = `project:${resource.id}`\n      registryMap.set(key, resource.reference)\n    })\n    \n    return registryMap\n  }\n\n  /**\n   * 生成并保存项目注册表文件\n   * @returns {Promise<RegistryData>} 生成的注册表数据\n   */\n  async generateRegistry() {\n    try {\n      const protocol = this.getProjectProtocol()\n      \n      // 获取注册表文件路径\n      const registryPath = await protocol.resolvePath('.promptx/resource/project.registry.json')\n      \n      // 创建注册表数据\n      const registryData = RegistryData.createEmpty('project', registryPath)\n      \n      // 扫描资源目录\n      const resourceDir = await protocol.resolvePath('.promptx/resource')\n      \n      if (await fs.pathExists(resourceDir)) {\n        await this._scanDirectory(resourceDir, registryData)\n      }\n      \n      // 确保目录存在\n      await fs.ensureDir(path.dirname(registryPath))\n      \n      // 保存注册表\n      await registryData.save()\n      \n      logger.info(`[ProjectDiscovery] ✅ 项目注册表生成完成，发现 ${registryData.size} 个资源`)\n      return registryData\n      \n    } catch (error) {\n      logger.error(`[ProjectDiscovery] 生成注册表失败: ${error.message}`)\n      return RegistryData.createEmpty('project')\n    }\n  }\n\n  /**\n   * 获取注册表数据（兼容旧接口）\n   * @returns {Promise<RegistryData>} 注册表数据\n   */\n  async getRegistryData() {\n    try {\n      const protocol = this.getProjectProtocol()\n      const registryPath = await protocol.resolvePath('.promptx/resource/project.registry.json')\n      \n      if (await fs.pathExists(registryPath)) {\n        const registryData = await RegistryData.fromFile('project', registryPath)\n        \n        if (registryData.size > 0) {\n          logger.info(`[ProjectDiscovery] 📋 从注册表加载 ${registryData.size} 个资源`)\n          return registryData\n        }\n      }\n      \n      // 动态生成注册表\n      logger.info(`[ProjectDiscovery] 📋 项目注册表无效，重新生成`)\n      return await this.generateRegistry()\n      \n    } catch (error) {\n      logger.error(`[ProjectDiscovery] 获取注册表数据失败: ${error.message}`)\n      return RegistryData.createEmpty('project')\n    }\n  }\n}\n\nmodule.exports = ProjectDiscovery","const BaseDiscovery = require('./BaseDiscovery')\nconst logger = require('@promptx/logger')\nconst RegistryData = require('../RegistryData')\nconst ResourceData = require('../ResourceData')\nconst fs = require('fs-extra')\nconst path = require('path')\n\n/**\n * UserDiscovery - User 级资源发现器\n * \n * 核心设计原则：\n * 1. 基于 @user 协议，扫描 ~/.promptx/resource 目录\n * 2. 优先使用注册表，fallback 到动态扫描\n * 3. 与 ProjectDiscovery 保持相同的目录结构和扫描逻辑\n * 4. User 级资源具有最高优先级（priority = 3）\n */\nclass UserDiscovery extends BaseDiscovery {\n  constructor() {\n    super('USER', 3)  // source = 'USER', priority = 3 (最高优先级)\n    this.userProtocol = null\n  }\n\n  /**\n   * 获取 UserProtocol 实例\n   */\n  getUserProtocol() {\n    if (!this.userProtocol) {\n      const { getGlobalResourceManager } = require('../../resource')\n      const resourceManager = getGlobalResourceManager()\n      this.userProtocol = resourceManager.protocols.get('user')\n    }\n    return this.userProtocol\n  }\n\n  /**\n   * 发现 User 级资源注册表\n   * @returns {Promise<Map>} 资源注册表 Map<resourceId, reference>\n   */\n  async discoverRegistry() {\n    try {\n      // 1. 优先尝试从注册表加载\n      const registryMap = await this.loadFromRegistry()\n      if (registryMap.size > 0) {\n        logger.debug(`UserDiscovery 从注册表加载 ${registryMap.size} 个资源`)\n        return registryMap\n      }\n\n      // 2. Fallback: 动态扫描生成注册表\n      logger.debug('UserDiscovery 注册表不存在，使用动态扫描')\n      const resources = await this.scanUserResources()\n      return this.buildRegistryFromResources(resources)\n\n    } catch (error) {\n      logger.warn(`[UserDiscovery] Registry discovery failed: ${error.message}`)\n      return new Map()\n    }\n  }\n\n  /**\n   * 从注册表文件加载资源\n   * @returns {Promise<Map>} 资源注册表\n   */\n  async loadFromRegistry() {\n    try {\n      const protocol = this.getUserProtocol()\n      \n      // 使用 @user 协议检查注册表文件\n      const registryPath = await protocol.resolvePath('.promptx/resource/user.registry.json')\n      \n      if (!await fs.pathExists(registryPath)) {\n        return new Map()\n      }\n\n      // 加载并解析注册表\n      const registryData = await RegistryData.fromFile('user', registryPath)\n      return registryData.getResourceMap(true) // 带前缀\n      \n    } catch (error) {\n      logger.warn(`[UserDiscovery] Failed to load registry: ${error.message}`)\n      return new Map()\n    }\n  }\n\n  /**\n   * 动态扫描 User 资源\n   * @returns {Promise<Array>} 资源列表\n   */\n  async scanUserResources() {\n    try {\n      const protocol = this.getUserProtocol()\n      \n      // 使用 @user 协议获取资源目录\n      const resourceDir = await protocol.resolvePath('.promptx/resource')\n      \n      if (!await fs.pathExists(resourceDir)) {\n        logger.debug('UserDiscovery User 资源目录不存在')\n        return []\n      }\n\n      // 创建临时注册表来收集资源\n      const tempRegistry = RegistryData.createEmpty('user', null)\n      \n      // 扫描目录结构（复用 ProjectDiscovery 的扫描逻辑）\n      await this._scanDirectory(resourceDir, tempRegistry)\n      \n      // 转换为资源列表\n      const resources = []\n      for (const resource of tempRegistry.resources) {\n        resources.push({\n          id: resource.id,\n          protocol: resource.protocol,\n          reference: resource.reference,\n          source: resource.source\n        })\n      }\n\n      logger.info(`[UserDiscovery] ✅ User 扫描完成，发现 ${resources.length} 个资源`)\n      return resources\n      \n    } catch (error) {\n      logger.warn(`[UserDiscovery] 扫描 User 资源失败: ${error.message}`)\n      return []\n    }\n  }\n\n  /**\n   * 扫描目录并添加资源到注册表\n   * @param {string} resourcesDir - 资源目录\n   * @param {RegistryData} registryData - 注册表数据\n   * @private\n   */\n  async _scanDirectory(resourcesDir, registryData) {\n    try {\n      // 递归扫描整个 resource 目录\n      await this._recursiveScan(resourcesDir, '', registryData)\n    } catch (error) {\n      logger.warn(`[UserDiscovery] 扫描资源目录失败: ${error.message}`)\n    }\n  }\n\n  /**\n   * 递归扫描目录\n   * @param {string} currentPath - 当前扫描路径\n   * @param {string} relativePath - 相对于 resource 目录的路径\n   * @param {RegistryData} registryData - 注册表数据\n   * @private\n   */\n  async _recursiveScan(currentPath, relativePath, registryData) {\n    try {\n      const items = await fs.readdir(currentPath)\n      \n      for (const item of items) {\n        const itemPath = path.join(currentPath, item)\n        const stat = await fs.stat(itemPath)\n        const newRelativePath = relativePath ? `${relativePath}/${item}` : item\n        \n        if (stat.isDirectory()) {\n          // 递归扫描子目录\n          await this._recursiveScan(itemPath, newRelativePath, registryData)\n        } else {\n          // 处理文件\n          await this._processFile(itemPath, newRelativePath, registryData)\n        }\n      }\n    } catch (error) {\n      logger.warn(`[UserDiscovery] 扫描${currentPath}失败: ${error.message}`)\n    }\n  }\n\n  /**\n   * 处理单个文件\n   * @param {string} filePath - 文件完整路径\n   * @param {string} relativePath - 相对路径\n   * @param {RegistryData} registryData - 注册表数据\n   * @private\n   */\n  async _processFile(filePath, relativePath, registryData) {\n    const fileName = path.basename(filePath)\n    let protocol = null\n    let resourceId = null\n    \n    // 🔍 Knuth调试日志：追踪文件处理\n    logger.debug(`[UserDiscovery._processFile] Processing: ${relativePath} (file: ${fileName})`)\n    \n    // 根据文件名后缀识别资源类型\n    if (fileName.endsWith('.role.md')) {\n      protocol = 'role'\n      resourceId = path.basename(fileName, '.role.md')\n    } else if (fileName.endsWith('.thought.md')) {\n      protocol = 'thought'\n      resourceId = path.basename(fileName, '.thought.md')\n    } else if (fileName.endsWith('.execution.md')) {\n      protocol = 'execution'\n      resourceId = path.basename(fileName, '.execution.md')\n    } else if (fileName.endsWith('.knowledge.md')) {\n      protocol = 'knowledge'\n      resourceId = path.basename(fileName, '.knowledge.md')\n    } else if (fileName.endsWith('.tool.js')) {\n      protocol = 'tool'\n      resourceId = path.basename(fileName, '.tool.js')\n    } else if (fileName.endsWith('.manual.md')) {\n      protocol = 'manual'\n      resourceId = path.basename(fileName, '.manual.md')\n    }\n    \n    if (protocol && resourceId) {\n      // 🔍 Knuth调试：发现资源类型\n      logger.info(`[UserDiscovery._processFile] Found ${protocol} resource: ${resourceId}`)\n      \n      // 验证文件内容\n      if (await this._validateResourceFile(filePath, protocol)) {\n        const reference = `@user://.promptx/resource/${relativePath}`\n        \n        const resourceData = new ResourceData({\n          id: resourceId,\n          source: 'user',\n          protocol: protocol,\n          name: ResourceData._generateDefaultName(resourceId, protocol),\n          description: ResourceData._generateDefaultDescription(resourceId, protocol),\n          reference: reference,\n          metadata: {\n            scannedAt: new Date().toISOString(),\n            path: relativePath\n          }\n        })\n        \n        registryData.addResource(resourceData)\n        logger.info(`[UserDiscovery] ✅ 成功添加${protocol}资源: ${resourceId} at ${relativePath}`)\n      }\n    }\n  }\n\n  /**\n   * 验证资源文件格式\n   * @param {string} filePath - 文件路径\n   * @param {string} protocol - 协议类型\n   * @returns {Promise<boolean>} 是否是有效的资源文件\n   */\n  async _validateResourceFile(filePath, protocol) {\n    try {\n      const content = await fs.readFile(filePath, 'utf8')\n\n      if (!content || typeof content !== 'string') {\n        return false\n      }\n\n      const trimmedContent = content.trim()\n      if (trimmedContent.length === 0) {\n        return false\n      }\n\n      // 根据协议类型验证 DPML 标签\n      switch (protocol) {\n        case 'role':\n          return trimmedContent.includes('<role>') && trimmedContent.includes('</role>')\n        case 'execution':\n          return trimmedContent.includes('<execution>') && trimmedContent.includes('</execution>')\n        case 'thought':\n          return trimmedContent.includes('<thought>') && trimmedContent.includes('</thought>')\n        case 'knowledge':\n          // knowledge 类型比较灵活，只要文件有内容就认为是有效的\n          return true\n        case 'manual':\n          return trimmedContent.includes('<manual>') && trimmedContent.includes('</manual>')\n        case 'tool':\n          // tool 文件是 JavaScript，进行基本的语法验证\n          try {\n            new Function(trimmedContent)\n            return true\n          } catch (e) {\n            logger.warn(`[UserDiscovery] Invalid JavaScript in tool file ${filePath}: ${e.message}`)\n            return false\n          }\n        default:\n          return false\n      }\n    } catch (error) {\n      logger.warn(`[UserDiscovery] Failed to validate ${filePath}: ${error.message}`)\n      return false\n    }\n  }\n\n  /**\n   * 从资源列表构建注册表 Map\n   * @param {Array} resources - 资源列表\n   * @returns {Map} 资源注册表\n   */\n  buildRegistryFromResources(resources) {\n    const registryMap = new Map()\n    \n    resources.forEach(resource => {\n      const key = `user:${resource.id}`\n      registryMap.set(key, resource.reference)\n    })\n    \n    return registryMap\n  }\n\n  /**\n   * 生成并保存 User 注册表文件\n   * @returns {Promise<RegistryData>} 生成的注册表数据\n   */\n  async generateRegistry() {\n    try {\n      const protocol = this.getUserProtocol()\n      \n      // 获取注册表文件路径\n      const registryPath = await protocol.resolvePath('.promptx/resource/user.registry.json')\n      \n      // 创建注册表数据\n      const registryData = RegistryData.createEmpty('user', registryPath)\n      \n      // 扫描资源目录\n      const resourceDir = await protocol.resolvePath('.promptx/resource')\n      \n      if (await fs.pathExists(resourceDir)) {\n        await this._scanDirectory(resourceDir, registryData)\n      }\n      \n      // 确保目录存在\n      await fs.ensureDir(path.dirname(registryPath))\n      \n      // 保存注册表\n      await registryData.save()\n      \n      logger.info(`[UserDiscovery] ✅ User 注册表生成完成，发现 ${registryData.size} 个资源`)\n      return registryData\n      \n    } catch (error) {\n      logger.error(`[UserDiscovery] 生成注册表失败: ${error.message}`)\n      return RegistryData.createEmpty('user')\n    }\n  }\n\n  /**\n   * 获取注册表数据（兼容接口）\n   * @returns {Promise<RegistryData>} 注册表数据\n   */\n  async getRegistryData() {\n    try {\n      const protocol = this.getUserProtocol()\n      const registryPath = await protocol.resolvePath('.promptx/resource/user.registry.json')\n      \n      if (await fs.pathExists(registryPath)) {\n        const registryData = await RegistryData.fromFile('user', registryPath)\n        \n        if (registryData.size > 0) {\n          logger.info(`[UserDiscovery] 📋 从注册表加载 ${registryData.size} 个资源`)\n          return registryData\n        }\n      }\n      \n      // 动态生成注册表\n      logger.info(`[UserDiscovery] 📋 User 注册表无效，重新生成`)\n      return await this.generateRegistry()\n      \n    } catch (error) {\n      logger.error(`[UserDiscovery] 获取注册表数据失败: ${error.message}`)\n      return RegistryData.createEmpty('user')\n    }\n  }\n\n  /**\n   * 发现资源（BaseDiscovery 要求的抽象方法）\n   * @returns {Promise<Array>} 发现的资源列表\n   */\n  async discover() {\n    const registryMap = await this.discoverRegistry()\n    const resources = []\n    \n    for (const [key, reference] of registryMap) {\n      // 解析 key 格式：user:resourceId\n      const [source, id] = key.split(':')\n      if (source === 'user' && id) {\n        resources.push({\n          id,\n          reference,\n          source: 'user'\n        })\n      }\n    }\n    \n    return resources\n  }\n}\n\nmodule.exports = UserDiscovery","const PackageDiscovery = require('./PackageDiscovery')\nconst ProjectDiscovery = require('./ProjectDiscovery')\nconst UserDiscovery = require('./UserDiscovery')\nconst logger = require('@promptx/logger')\n\n/**\n * DiscoveryManager - 资源发现管理器\n * \n * 统一管理多个资源发现器，按照文档架构设计：\n * 1. 按优先级排序发现器 (数字越小优先级越高)\n * 2. 并行执行资源发现\n * 3. 收集并合并所有发现的资源\n * 4. 提供容错机制，单个发现器失败不影响整体\n */\nclass DiscoveryManager {\n  /**\n   * 构造函数\n   * @param {Array} discoveries - 自定义发现器列表，如果不提供则使用默认配置\n   */\n  constructor(discoveries = null) {\n    if (discoveries) {\n      this.discoveries = [...discoveries]\n    } else {\n      // 默认发现器配置：包含包级、项目级和用户级发现\n      this.discoveries = [\n        new PackageDiscovery(),  // 优先级: 1\n        new ProjectDiscovery(),  // 优先级: 2\n        new UserDiscovery()      // 优先级: 3 (最高)\n      ]\n    }\n\n    // 按优先级排序\n    this._sortDiscoveriesByPriority()\n  }\n\n  /**\n   * 添加发现器\n   * @param {Object} discovery - 实现了发现器接口的对象\n   */\n  addDiscovery(discovery) {\n    if (!discovery || typeof discovery.discover !== 'function') {\n      throw new Error('Discovery must implement discover method')\n    }\n\n    this.discoveries.push(discovery)\n    this._sortDiscoveriesByPriority()\n  }\n\n  /**\n   * 移除发现器\n   * @param {string} source - 发现器源类型\n   */\n  removeDiscovery(source) {\n    this.discoveries = this.discoveries.filter(discovery => discovery.source !== source)\n  }\n\n  /**\n   * 发现所有资源（并行模式）\n   * @returns {Promise<Array>} 所有发现的资源列表\n   */\n  async discoverAll() {\n    const discoveryPromises = this.discoveries.map(async (discovery) => {\n      try {\n        const resources = await discovery.discover()\n        return Array.isArray(resources) ? resources : []\n      } catch (error) {\n        logger.warn(`[DiscoveryManager] ${discovery.source} discovery failed: ${error.message}`)\n        return []\n      }\n    })\n\n    // 并行执行所有发现器\n    const discoveryResults = await Promise.allSettled(discoveryPromises)\n\n    // 收集所有成功的结果\n    const allResources = []\n    discoveryResults.forEach((result, index) => {\n      if (result.status === 'fulfilled') {\n        allResources.push(...result.value)\n      } else {\n        logger.warn(`[DiscoveryManager] ${this.discoveries[index].source} discovery rejected: ${result.reason}`)\n      }\n    })\n\n    return allResources\n  }\n\n  /**\n   * 发现并合并所有注册表（RegistryData架构）\n   * @returns {Promise<Map>} 合并后的资源注册表 Map<resourceId, reference>\n   */\n  async discoverRegistries() {\n    const registryPromises = this.discoveries.map(async (discovery) => {\n      try {\n        // 优先使用新的discoverRegistry方法\n        if (typeof discovery.discoverRegistry === 'function') {\n          const registry = await discovery.discoverRegistry()\n          return registry instanceof Map ? registry : new Map()\n        } else {\n          // 向后兼容：将discover()结果转换为注册表格式\n          const resources = await discovery.discover()\n          const registry = new Map()\n          if (Array.isArray(resources)) {\n            resources.forEach(resource => {\n              if (resource.id && resource.reference) {\n                registry.set(resource.id, resource.reference)\n              }\n            })\n          }\n          return registry\n        }\n      } catch (error) {\n        logger.warn(`[DiscoveryManager] ${discovery.source} registry discovery failed: ${error.message}`)\n        return new Map()\n      }\n    })\n\n    // 并行执行所有发现器\n    const registryResults = await Promise.allSettled(registryPromises)\n\n    // 收集所有成功的注册表\n    const registries = []\n    registryResults.forEach((result, index) => {\n      if (result.status === 'fulfilled') {\n        registries.push(result.value)\n      } else {\n        logger.warn(`[DiscoveryManager] ${this.discoveries[index].source} registry discovery rejected: ${result.reason}`)\n        registries.push(new Map())\n      }\n    })\n\n    // 按发现器优先级合并注册表\n    return this._mergeRegistries(registries)\n  }\n\n  /**\n   * 按源类型发现注册表\n   * @param {string} source - 发现器源类型\n   * @returns {Promise<Map>} 指定源的资源注册表\n   */\n  async discoverRegistryBySource(source) {\n    const discovery = this._findDiscoveryBySource(source)\n    if (!discovery) {\n      throw new Error(`Discovery source ${source} not found`)\n    }\n\n    if (typeof discovery.discoverRegistry === 'function') {\n      return await discovery.discoverRegistry()\n    } else {\n      // 向后兼容：将discover()结果转换为注册表格式\n      const resources = await discovery.discover()\n      const registry = new Map()\n      if (Array.isArray(resources)) {\n        resources.forEach(resource => {\n          if (resource.id && resource.reference) {\n            registry.set(resource.id, resource.reference)\n          }\n        })\n      }\n      return registry\n    }\n  }\n\n  /**\n   * 按源类型发现资源\n   * @param {string} source - 发现器源类型\n   * @returns {Promise<Array>} 指定源的资源列表\n   */\n  async discoverBySource(source) {\n    const discovery = this._findDiscoveryBySource(source)\n    if (!discovery) {\n      throw new Error(`Discovery source ${source} not found`)\n    }\n\n    return await discovery.discover()\n  }\n\n  /**\n   * 获取所有发现器信息\n   * @returns {Array} 发现器信息列表\n   */\n  getDiscoveryInfo() {\n    return this.discoveries.map(discovery => {\n      if (typeof discovery.getDiscoveryInfo === 'function') {\n        return discovery.getDiscoveryInfo()\n      } else {\n        return {\n          source: discovery.source || 'UNKNOWN',\n          priority: discovery.priority || 0,\n          description: 'No description available'\n        }\n      }\n    })\n  }\n\n  /**\n   * 清理所有发现器缓存\n   */\n  clearCache() {\n    this.discoveries.forEach(discovery => {\n      if (typeof discovery.clearCache === 'function') {\n        discovery.clearCache()\n      }\n    })\n  }\n\n  /**\n   * 获取发现器数量\n   * @returns {number} 注册的发现器数量\n   */\n  getDiscoveryCount() {\n    return this.discoveries.length\n  }\n\n  /**\n   * 合并多个注册表（支持分层级资源管理）\n   * @param {Array<Map>} registries - 注册表数组，按优先级排序（数字越小优先级越高）\n   * @returns {Map} 合并后的注册表\n   * @private\n   */\n  _mergeRegistries(registries) {\n    const mergedRegistry = new Map()\n\n    // 第一阶段：收集所有资源（包括带前缀的）\n    for (let i = registries.length - 1; i >= 0; i--) {\n      const registry = registries[i]\n      if (registry instanceof Map) {\n        for (const [key, value] of registry) {\n          mergedRegistry.set(key, value)\n        }\n      }\n    }\n\n    // 第二阶段：处理优先级覆盖 - 高优先级的无前缀版本覆盖低优先级的\n    const priorityLevels = ['package', 'project', 'user'] // 优先级：package < project < user\n    \n    // 为每个基础资源ID找到最高优先级的版本\n    const baseResourceMap = new Map() // baseId -> {source, reference, priority}\n    \n    for (const [fullId, reference] of mergedRegistry) {\n      // 解析资源ID：可能是 \"source:resourceId\" 或 \"resourceId\"\n      const colonIndex = fullId.indexOf(':')\n      let source = 'unknown'\n      let baseId = fullId\n      \n      if (colonIndex !== -1) {\n        const possibleSource = fullId.substring(0, colonIndex)\n        if (priorityLevels.includes(possibleSource)) {\n          source = possibleSource\n          baseId = fullId.substring(colonIndex + 1)\n        }\n      }\n      \n      const currentPriority = priorityLevels.indexOf(source)\n      const existing = baseResourceMap.get(baseId)\n      \n      if (!existing || currentPriority > existing.priority) {\n        baseResourceMap.set(baseId, {\n          source,\n          reference,\n          priority: currentPriority,\n          fullId\n        })\n      }\n    }\n    \n    // 第三阶段：构建最终注册表\n    const finalRegistry = new Map()\n    \n    // 1. 添加所有带前缀的资源（用于明确指定级别）\n    for (const [key, value] of mergedRegistry) {\n      if (key.includes(':') && priorityLevels.includes(key.split(':')[0])) {\n        finalRegistry.set(key, value)\n      }\n    }\n    \n    // 2. 添加最高优先级的无前缀版本（用于默认解析）\n    for (const [baseId, info] of baseResourceMap) {\n      finalRegistry.set(baseId, info.reference)\n    }\n\n    return finalRegistry\n  }\n\n  /**\n   * 按优先级排序发现器\n   * @private\n   */\n  _sortDiscoveriesByPriority() {\n    this.discoveries.sort((a, b) => {\n      const priorityA = a.priority || 0\n      const priorityB = b.priority || 0\n      return priorityA - priorityB // 升序排序，数字越小优先级越高\n    })\n  }\n\n  /**\n   * 根据源类型查找发现器\n   * @param {string} source - 发现器源类型\n   * @returns {Object|undefined} 找到的发现器或undefined\n   * @private\n   */\n  _findDiscoveryBySource(source) {\n    return this.discoveries.find(discovery => discovery.source === source)\n  }\n}\n\nmodule.exports = DiscoveryManager","/**\n * 资源协议接口基类\n * 定义所有DPML资源协议的统一规范\n */\nclass ResourceProtocol {\n  /**\n   * 构造函数\n   * @param {string} name - 协议名称\n   * @param {object} options - 配置选项\n   */\n  constructor (name, options = {}) {\n    if (new.target === ResourceProtocol) {\n      throw new Error('ResourceProtocol是抽象类，不能直接实例化')\n    }\n\n    this.name = name\n    this.options = options\n    this.cache = new Map()\n    // 默认禁用缓存，避免开发时的问题，需要时显式启用\n    this.enableCache = options.enableCache === true\n  }\n\n  /**\n   * 协议信息 - 需要子类实现\n   * @returns {object} 协议信息\n   */\n  getProtocolInfo () {\n    throw new Error('子类必须实现 getProtocolInfo() 方法')\n  }\n\n  /**\n   * 解析资源路径 - 需要子类实现\n   * @param {string} resourcePath - 原始资源路径\n   * @param {QueryParams} queryParams - 查询参数\n   * @returns {Promise<string>} 解析后的路径\n   */\n  async resolvePath (resourcePath, queryParams) {\n    throw new Error('子类必须实现 resolvePath() 方法')\n  }\n\n  /**\n   * 加载资源内容 - 需要子类实现\n   * @param {string} resolvedPath - 解析后的路径\n   * @param {QueryParams} queryParams - 查询参数\n   * @returns {Promise<string>} 资源内容\n   */\n  async loadContent (resolvedPath, queryParams) {\n    throw new Error('子类必须实现 loadContent() 方法')\n  }\n\n  /**\n   * 验证资源路径格式 - 可选实现\n   * @param {string} resourcePath - 资源路径\n   * @returns {boolean} 是否有效\n   */\n  validatePath (resourcePath) {\n    return typeof resourcePath === 'string' && resourcePath.length > 0\n  }\n\n  /**\n   * 支持的查询参数列表 - 可选实现\n   * @returns {object} 参数说明\n   */\n  getSupportedParams () {\n    return {\n      line: 'string - 行范围，如 \"1-10\"',\n      format: 'string - 输出格式',\n      cache: 'boolean - 是否缓存'\n    }\n  }\n\n  /**\n   * 统一的资源解析入口点\n   * @param {string} resourcePath - 资源路径\n   * @param {QueryParams} queryParams - 查询参数\n   * @returns {Promise<string>} 资源内容\n   */\n  async resolve (resourcePath, queryParams) {\n    // 1. 验证路径格式\n    if (!this.validatePath(resourcePath)) {\n      const error = new Error(`无效的资源路径: ${resourcePath}`)\n      const logger = require('@promptx/logger')\n      logger.error(`[ResourceProtocol] 路径验证失败: ${resourcePath}`)\n      logger.error(`[ResourceProtocol] 调用堆栈:`, error.stack)\n      throw error\n    }\n\n    // 2. 生成缓存键\n    const cacheKey = this.generateCacheKey(resourcePath, queryParams)\n\n    // 3. 检查缓存\n    if (this.enableCache && this.cache.has(cacheKey)) {\n      return this.cache.get(cacheKey)\n    }\n\n    // 4. 解析路径\n    const resolvedPath = await this.resolvePath(resourcePath, queryParams)\n\n    // 5. 加载内容\n    const content = await this.loadContent(resolvedPath, queryParams)\n\n    // 6. 应用通用查询参数过滤\n    const filteredContent = this.applyCommonParams(content, queryParams)\n\n    // 7. 缓存结果\n    if (this.enableCache) {\n      this.cache.set(cacheKey, filteredContent)\n    }\n\n    return filteredContent\n  }\n\n  /**\n   * 生成缓存键\n   * @param {string} resourcePath - 资源路径\n   * @param {QueryParams} queryParams - 查询参数\n   * @returns {string} 缓存键\n   */\n  generateCacheKey (resourcePath, queryParams) {\n    const params = queryParams ? queryParams.getAll() : {}\n    return `${this.name}:${resourcePath}:${JSON.stringify(params)}`\n  }\n\n  /**\n   * 应用通用查询参数\n   * @param {string} content - 原始内容\n   * @param {QueryParams} queryParams - 查询参数\n   * @returns {string} 过滤后的内容\n   */\n  applyCommonParams (content, queryParams) {\n    if (!queryParams) {\n      return content\n    }\n\n    let result = content\n\n    // 应用行过滤\n    if (queryParams.line) {\n      result = this.applyLineFilter(result, queryParams.line)\n    }\n\n    // 应用格式化（基础实现，子类可以重写）\n    if (queryParams.format && queryParams.format !== 'text') {\n      result = this.applyFormat(result, queryParams.format)\n    }\n\n    return result\n  }\n\n  /**\n   * 应用行过滤\n   * @param {string} content - 内容\n   * @param {string} lineRange - 行范围，如 \"5-10\" 或 \"5\"\n   * @returns {string} 过滤后的内容\n   */\n  applyLineFilter (content, lineRange) {\n    const lines = content.split('\\n')\n\n    if (lineRange.includes('-')) {\n      const [start, end] = lineRange.split('-').map(n => parseInt(n.trim(), 10))\n      const startIndex = Math.max(0, start - 1)\n      const endIndex = Math.min(lines.length, end)\n      return lines.slice(startIndex, endIndex).join('\\n')\n    } else {\n      const lineNum = parseInt(lineRange, 10)\n      const lineIndex = lineNum - 1\n      return lines[lineIndex] || ''\n    }\n  }\n\n  /**\n   * 应用格式化\n   * @param {string} content - 内容\n   * @param {string} format - 格式\n   * @returns {string} 格式化后的内容\n   */\n  applyFormat (content, format) {\n    // 基础实现，子类可以重写\n    switch (format) {\n      case 'json':\n        try {\n          return JSON.stringify(JSON.parse(content), null, 2)\n        } catch {\n          return content\n        }\n      case 'trim':\n        return content.trim()\n      default:\n        return content\n    }\n  }\n\n  /**\n   * 清除缓存\n   */\n  clearCache () {\n    this.cache.clear()\n  }\n\n  /**\n   * 获取缓存统计\n   * @returns {object} 缓存统计信息\n   */\n  getCacheStats () {\n    return {\n      protocol: this.name,\n      size: this.cache.size,\n      enabled: this.enableCache\n    }\n  }\n}\n\nmodule.exports = ResourceProtocol\n","const path = require('path')\nconst fs = require('fs')\nconst fsPromises = require('fs').promises\nconst ResourceProtocol = require('./ResourceProtocol')\nconst { QueryParams } = require('../types')\nconst logger = require('@promptx/logger')\nconst { getDirectoryService } = require('~/utils/DirectoryService')\n\n/**\n * 包协议实现\n * 实现@package://协议，智能检测并访问NPM包资源\n * 支持：本地开发、npm install、npm -g、npx、monorepo等场景\n */\nclass PackageProtocol extends ResourceProtocol {\n  constructor (options = {}) {\n    super('package', options)\n    this.directoryService = getDirectoryService()\n  }\n\n  /**\n   * 设置注册表（保持与其他协议的一致性）\n   */\n  setRegistry (registry) {\n    // Package协议不使用注册表，但为了一致性提供此方法\n    this.registry = registry || {}\n  }\n\n  /**\n   * 获取协议信息\n   */\n  getProtocolInfo () {\n    return {\n      name: this.name,\n      description: '包协议 - 智能访问NPM包资源，支持多种安装模式',\n      examples: [\n        '@package://package.json',\n        '@package://src/index.js',\n        '@package://docs/README.md',\n        '@package://resource/core/thought.md',\n        '@package://templates/basic/template.md'\n      ],\n      installModes: [\n        'development', // 开发模式\n        'local', // 本地npm install\n        'global', // 全局npm install -g\n        'npx', // npx执行\n        'monorepo', // monorepo workspace\n        'link' // npm link\n      ]\n    }\n  }\n\n\n\n  /**\n   * 获取包根目录 - 始终使用 dist 目录\n   */\n  async getPackageRoot () {\n    try {\n      // 直接使用 @promptx/resource 包的 dist 目录\n      const resourcePath = require.resolve('@promptx/resource')\n      logger.info(`[PackageProtocol] require.resolve('@promptx/resource') returned: ${resourcePath}`)\n      \n      // require.resolve 返回的是 dist/index.js，所以 dirname 就是 dist 目录\n      const distDir = path.dirname(resourcePath)\n      logger.info(`[PackageProtocol] Using dist directory as package root: ${distDir}`)\n      \n      const resourcesDir = path.join(distDir, 'resources')\n      logger.info(`[PackageProtocol] Resources directory path: ${resourcesDir}`)\n      logger.info(`[PackageProtocol] Resources directory exists: ${fs.existsSync(resourcesDir)}`)\n      \n      return distDir\n      \n    } catch (error) {\n      logger.error(`[PackageProtocol] Cannot locate @promptx/resource package: ${error.message}`)\n      logger.error(`[PackageProtocol] Error stack:`, error.stack)\n      logger.error(`[PackageProtocol] This is a critical system error, @promptx/resource must exist and be accessible via require`)\n      throw error\n    }\n  }\n\n\n  /**\n   * 解析路径到具体的文件系统路径 - 使用 PackageResource\n   * @param {string} relativePath - 相对于包根目录的路径\n   * @param {QueryParams} params - 查询参数\n   * @returns {Promise<string>} 解析后的绝对路径\n   */\n  async resolvePath (relativePath, params = null) {\n    logger.info(`[PackageProtocol] Resolving path: ${relativePath}`)\n    \n    try {\n      // 使用新的 PackageResource API\n      const resourceModule = require('@promptx/resource')\n      logger.info(`[PackageProtocol] Resource module loaded:`, Object.keys(resourceModule))\n      const { packageResource } = resourceModule\n      logger.info(`[PackageProtocol] PackageResource type:`, typeof packageResource)\n      logger.debug(`[PackageProtocol] Successfully loaded PackageResource`)\n      \n      // 清理路径\n      const cleanPath = relativePath.replace(/^\\/+/, '')\n      logger.debug(`[PackageProtocol] Cleaned path: ${cleanPath}`)\n      \n      // 使用 PackageResource 解析路径（自动处理ASAR）\n      const fullPath = packageResource.resolvePath(cleanPath)\n      logger.info(`[PackageProtocol] PackageResource resolved path: ${fullPath}`)\n      \n      // 检查文件是否存在\n      const exists = packageResource.exists(cleanPath)\n      logger.info(`[PackageProtocol] File exists: ${exists} (path: ${fullPath})`)\n      \n      if (!exists) {\n        logger.error(`[PackageProtocol] Resource file not found: ${fullPath}`)\n        return null\n      }\n      \n      return fullPath\n    } catch (error) {\n      logger.error(`[PackageProtocol] Failed to resolve resource path: ${error.message}`)\n      logger.error(`[PackageProtocol] Error stack:`, error.stack)\n      throw error\n    }\n  }\n\n  /**\n   * 验证文件访问权限（基于package.json的files字段）\n   * @param {string} packageRoot - 包根目录\n   * @param {string} relativePath - 相对路径\n   */\n  validateFileAccess (packageRoot, relativePath) {\n    // 简化版本：既然使用 require.resolve，就信任包的正确性\n    // 不再进行复杂的 files 字段检查\n    logger.debug(`[PackageProtocol] Validating file access for: ${relativePath}`)\n  }\n\n\n  /**\n   * 检查资源是否存在\n   */\n  async exists (resourcePath, queryParams) {\n    try {\n      const resolvedPath = await this.resolvePath(resourcePath, queryParams)\n      await fsPromises.access(resolvedPath)\n      return true\n    } catch (error) {\n      return false\n    }\n  }\n\n  /**\n   * 加载资源内容\n   * @param {string} resolvedPath - 已解析的路径\n   * @param {QueryParams} [queryParams] - 查询参数\n   * @returns {Object} 包含内容和元数据的对象\n   */\n  async loadContent (resolvedPath, queryParams) {\n    try {\n      // 可以直接使用PackageResource的loadContent方法\n      // 但为了保持协议层的一致性，这里继续使用传统方法\n      await fsPromises.access(resolvedPath)\n      const content = await fsPromises.readFile(resolvedPath, 'utf8')\n      const stats = await fsPromises.stat(resolvedPath)\n      const packageRoot = await this.getPackageRoot()\n      \n      return {\n        content,\n        path: resolvedPath,\n        protocol: 'package',\n        metadata: {\n          size: content.length,\n          lastModified: stats.mtime,\n          absolutePath: resolvedPath,\n          relativePath: path.relative(packageRoot, resolvedPath)\n        }\n      }\n    } catch (error) {\n      if (error.code === 'ENOENT') {\n        throw new Error(`Package resource not found: ${resolvedPath}`)\n      }\n      throw new Error(`Failed to load package resource: ${error.message}`)\n    }\n  }\n\n  /**\n   * 获取调试信息\n   */\n  getDebugInfo () {\n    return {\n      protocol: this.name,\n      packageRoot: this.getPackageRoot(),\n      currentWorkingDirectory: process.cwd(),\n      moduleDirectory: __dirname,\n      cacheSize: this.cache.size\n    }\n  }\n\n  /**\n   * 清理缓存\n   */\n  clearCache () {\n    super.clearCache()\n  }\n}\n\nmodule.exports = PackageProtocol\n","const path = require('path')\nconst ProjectManager = require('./ProjectManager')\n\n/**\n * 项目路径解析器 - 新架构\n * 轻量级的@project协议路径解析，基于当前项目状态\n * 替代复杂的.promptx目录查找逻辑\n */\nclass ProjectPathResolver {\n  constructor() {\n    // 支持的项目结构目录映射\n    this.projectDirs = {\n      root: '', // 项目根目录\n      src: 'src', // 源代码目录\n      lib: 'lib', // 库目录\n      build: 'build', // 构建输出目录\n      dist: 'dist', // 分发目录\n      docs: 'docs', // 文档目录\n      test: 'test', // 测试目录\n      tests: 'tests', // 测试目录（复数）\n      spec: 'spec', // 规范测试目录\n      config: 'config', // 配置目录\n      scripts: 'scripts', // 脚本目录\n      assets: 'assets', // 资源目录\n      public: 'public', // 公共资源目录\n      static: 'static', // 静态资源目录\n      templates: 'templates', // 模板目录\n      examples: 'examples', // 示例目录\n      tools: 'tools', // 工具目录\n      '.promptx': '.promptx' // PromptX配置目录\n    }\n  }\n\n  /**\n   * 解析@project://协议路径\n   * @param {string} resourcePath - 资源路径，如 \"src/index.js\" 或 \".promptx/resource/...\"\n   * @returns {string} 解析后的绝对路径\n   */\n  resolvePath(resourcePath) {\n    // 🎯 新架构：直接获取当前项目路径，无需查找\n    const projectRoot = ProjectManager.getCurrentProjectPath()\n    \n    // 特殊处理：.promptx开头的路径直接相对于项目根目录\n    if (resourcePath.startsWith('.promptx/')) {\n      const fullPath = path.join(projectRoot, resourcePath)\n      return this._validatePath(fullPath, projectRoot)\n    }\n\n    // 标准路径处理逻辑\n    const parts = resourcePath.split('/')\n    const dirType = parts[0]\n    const relativePath = parts.slice(1).join('/')\n\n    // 验证目录类型\n    if (!this.projectDirs.hasOwnProperty(dirType)) {\n      throw new Error(`不支持的项目目录类型: ${dirType}。支持的类型: ${Object.keys(this.projectDirs).join(', ')}`)\n    }\n\n    // 构建目标目录路径\n    const projectDirPath = this.projectDirs[dirType]\n    const targetDir = projectDirPath ? path.join(projectRoot, projectDirPath) : projectRoot\n\n    // 如果没有相对路径，返回目录本身\n    if (!relativePath) {\n      return targetDir\n    }\n\n    // 拼接完整路径\n    const fullPath = path.join(targetDir, relativePath)\n    return this._validatePath(fullPath, projectRoot)\n  }\n\n  /**\n   * 获取项目根目录\n   * @returns {string} 当前项目根目录\n   */\n  getProjectRoot() {\n    return ProjectManager.getCurrentProjectPath()\n  }\n\n  /**\n   * 获取PromptX配置目录路径\n   * @returns {string} .promptx目录路径\n   */\n  getPromptXDirectory() {\n    const projectRoot = ProjectManager.getCurrentProjectPath()\n    return path.join(projectRoot, '.promptx')\n  }\n\n  /**\n   * 获取项目资源目录路径\n   * @returns {string} 项目资源目录路径\n   */\n  getResourceDirectory() {\n    const promptxDir = this.getPromptXDirectory()\n    return path.join(promptxDir, 'resource')\n  }\n\n  /**\n   * 获取项目注册表文件路径\n   * @returns {string} 注册表文件路径\n   */\n  getRegistryPath() {\n    const resourceDir = this.getResourceDirectory()\n    return path.join(resourceDir, 'project.registry.json')\n  }\n\n  /**\n   * 获取记忆目录路径\n   * @returns {string} 记忆目录路径\n   */\n  getMemoryDirectory() {\n    const promptxDir = this.getPromptXDirectory()\n    return path.join(promptxDir, 'memory')\n  }\n\n  /**\n   * 验证路径安全性\n   * @param {string} fullPath - 完整路径\n   * @param {string} projectRoot - 项目根目录\n   * @returns {string} 验证后的路径\n   * @private\n   */\n  _validatePath(fullPath, projectRoot) {\n    // 安全检查：确保路径在项目目录内\n    const resolvedPath = path.resolve(fullPath)\n    const resolvedProjectRoot = path.resolve(projectRoot)\n\n    if (!resolvedPath.startsWith(resolvedProjectRoot)) {\n      throw new Error(`安全错误：路径超出项目目录范围: ${resolvedPath}`)\n    }\n\n    return resolvedPath\n  }\n\n  /**\n   * 获取支持的目录类型\n   * @returns {Array<string>} 支持的目录类型列表\n   */\n  getSupportedDirectories() {\n    return Object.keys(this.projectDirs)\n  }\n\n  /**\n   * 检查目录类型是否支持\n   * @param {string} dirType - 目录类型\n   * @returns {boolean} 是否支持\n   */\n  isSupportedDirectory(dirType) {\n    return this.projectDirs.hasOwnProperty(dirType)\n  }\n}\n\n// 创建全局单例实例\nlet globalProjectPathResolver = null\n\n/**\n * 获取全局ProjectPathResolver单例\n * @returns {ProjectPathResolver} 全局ProjectPathResolver实例\n */\nfunction getGlobalProjectPathResolver() {\n  if (!globalProjectPathResolver) {\n    globalProjectPathResolver = new ProjectPathResolver()\n  }\n  return globalProjectPathResolver\n}\n\nmodule.exports = ProjectPathResolver\nmodule.exports.getGlobalProjectPathResolver = getGlobalProjectPathResolver","const ResourceProtocol = require('./ResourceProtocol')\nconst path = require('path')\nconst fs = require('fs').promises\n\n// 使用env-paths提供跨平台用户目录支持\nconst envPaths = require('env-paths')\nconst os = require('os')\n\n/**\n * 获取跨平台用户目录路径\n * 使用env-paths替代platform-folders，提供更好的跨平台兼容性\n */\nconst getUserDirectories = () => {\n  const promptxPaths = envPaths('promptx')\n  \n  return {\n    getHomeFolder: () => os.homedir(),\n    getDesktopFolder: () => path.join(os.homedir(), 'Desktop'),\n    getDocumentsFolder: () => path.join(os.homedir(), 'Documents'),\n    getDownloadsFolder: () => path.join(os.homedir(), 'Downloads'),\n    getMusicFolder: () => path.join(os.homedir(), 'Music'),\n    getPicturesFolder: () => path.join(os.homedir(), 'Pictures'),\n    getVideosFolder: () => path.join(os.homedir(), 'Videos'),\n    // 新增：env-paths标准目录\n    getDataFolder: () => promptxPaths.data,\n    getConfigFolder: () => promptxPaths.config,\n    getCacheFolder: () => promptxPaths.cache,\n    getLogFolder: () => promptxPaths.log,\n    getTempFolder: () => promptxPaths.temp\n  }\n}\n\n/**\n * 用户目录协议实现\n * 实现@user://协议，直接映射到用户主目录，提供简洁的用户文件访问\n */\nclass UserProtocol extends ResourceProtocol {\n  constructor (options = {}) {\n    super('user', options)\n\n    // 支持的用户目录映射\n    this.userDirs = {\n      home: 'getHomeFolder',\n      desktop: 'getDesktopFolder',\n      documents: 'getDocumentsFolder',\n      downloads: 'getDownloadsFolder',\n      music: 'getMusicFolder',\n      pictures: 'getPicturesFolder',\n      videos: 'getVideosFolder',\n      // 新增：env-paths标准目录\n      data: 'getDataFolder',\n      config: 'getConfigFolder',\n      cache: 'getCacheFolder',\n      log: 'getLogFolder',\n      temp: 'getTempFolder'\n    }\n\n    // 目录路径缓存\n    this.dirCache = new Map()\n  }\n\n  /**\n   * 设置注册表（保持与其他协议的一致性）\n   */\n  setRegistry (registry) {\n    // User协议不使用注册表，但为了一致性提供此方法\n    this.registry = registry || {}\n  }\n\n  /**\n   * 获取协议信息\n   * @returns {object} 协议信息\n   */\n  getProtocolInfo () {\n    return {\n      name: 'user',\n      description: '用户目录协议，直接映射到用户主目录',\n      location: 'user://{path}',\n      examples: [\n        'user://.promptx/toolbox/text-analyzer',\n        'user://.bashrc',\n        'user://Documents/notes.txt',\n        'user://Desktop/readme.md',\n        'user://Downloads/file.zip',\n        'user://.promptx/config.json'\n      ],\n      basePath: '用户主目录 (~)',\n      params: this.getSupportedParams()\n    }\n  }\n\n  /**\n   * 支持的查询参数\n   * @returns {object} 参数说明\n   */\n  getSupportedParams () {\n    return {\n      ...super.getSupportedParams(),\n      exists: 'boolean - 仅返回存在的文件/目录',\n      type: 'string - 过滤类型 (file|dir|both)'\n    }\n  }\n\n  /**\n   * 验证用户协议路径\n   * @param {string} resourcePath - 资源路径\n   * @returns {boolean} 是否有效\n   */\n  validatePath (resourcePath) {\n    // UserProtocol需要处理完整的文件路径，包括.promptx开头的路径\n    // 不调用父类的validatePath，因为父类只接受简单的资源ID格式\n    if (!resourcePath || typeof resourcePath !== 'string') {\n      return false\n    }\n    \n    // 接受.promptx开头的路径（这是User级资源的标准路径）\n    if (resourcePath.startsWith('.promptx/')) {\n      return true\n    }\n    \n    // 也接受用户目录类型的路径\n    const parts = resourcePath.split('/')\n    const dirType = parts[0]\n    \n    return this.userDirs.hasOwnProperty(dirType)\n  }\n\n  /**\n   * 解析用户目录路径\n   * @param {string} resourcePath - 原始资源路径，如 \".promptx/toolbox/test-tool\"\n   * @param {QueryParams} queryParams - 查询参数\n   * @returns {Promise<string>} 解析后的绝对路径\n   */\n  async resolvePath (resourcePath, queryParams) {\n    // 直接使用用户主目录作为基础路径\n    const userHomeDir = getUserDirectories().getHomeFolder()\n    \n    // 如果没有相对路径，返回用户主目录本身\n    if (!resourcePath) {\n      return userHomeDir\n    }\n\n    // 拼接完整路径\n    const fullPath = path.join(userHomeDir, resourcePath)\n\n    // 安全检查：确保路径在用户主目录内\n    const resolvedPath = path.resolve(fullPath)\n    const resolvedUserDir = path.resolve(userHomeDir)\n\n    if (!resolvedPath.startsWith(resolvedUserDir)) {\n      throw new Error(`安全错误：路径超出用户目录范围: ${resolvedPath}`)\n    }\n\n    return resolvedPath\n  }\n\n  /**\n   * 获取用户目录路径\n   * @param {string} dirType - 目录类型\n   * @returns {Promise<string>} 目录路径\n   */\n  async getUserDirectory (dirType) {\n    // 检查缓存\n    if (this.dirCache.has(dirType)) {\n      return this.dirCache.get(dirType)\n    }\n\n    const userDirectories = getUserDirectories()\n    const methodName = this.userDirs[dirType]\n\n    if (!userDirectories[methodName]) {\n      throw new Error(`未找到用户目录获取方法: ${methodName}`)\n    }\n\n    try {\n      let dirPath\n\n      // 调用用户目录获取方法\n      if (typeof userDirectories[methodName] === 'function') {\n        dirPath = userDirectories[methodName]()\n      } else {\n        dirPath = userDirectories[methodName]\n      }\n\n      // 缓存结果\n      this.dirCache.set(dirType, dirPath)\n\n      return dirPath\n    } catch (error) {\n      throw new Error(`获取用户目录失败 (${dirType}): ${error.message}`)\n    }\n  }\n\n  /**\n   * 加载资源内容\n   * @param {string} resolvedPath - 解析后的路径\n   * @param {QueryParams} queryParams - 查询参数\n   * @returns {Promise<string>} 资源内容\n   */\n  async loadContent (resolvedPath, queryParams) {\n    try {\n      // 检查路径是否存在\n      const stats = await fs.stat(resolvedPath)\n\n      if (stats.isDirectory()) {\n        return await this.loadDirectoryContent(resolvedPath, queryParams)\n      } else if (stats.isFile()) {\n        return await this.loadFileContent(resolvedPath, queryParams)\n      } else {\n        throw new Error(`不支持的文件类型: ${resolvedPath}`)\n      }\n    } catch (error) {\n      if (error.code === 'ENOENT') {\n        // 如果设置了exists参数为false，返回空内容而不是错误\n        if (queryParams && queryParams.get('exists') === 'false') {\n          return ''\n        }\n        throw new Error(`文件或目录不存在: ${resolvedPath}`)\n      }\n      throw error\n    }\n  }\n\n  /**\n   * 加载文件内容\n   * @param {string} filePath - 文件路径\n   * @param {QueryParams} queryParams - 查询参数\n   * @returns {Promise<string>} 文件内容\n   */\n  async loadFileContent (filePath, queryParams) {\n    const encoding = queryParams?.get('encoding') || 'utf8'\n    return await fs.readFile(filePath, encoding)\n  }\n\n  /**\n   * 加载目录内容\n   * @param {string} dirPath - 目录路径\n   * @param {QueryParams} queryParams - 查询参数\n   * @returns {Promise<string>} 目录内容列表\n   */\n  async loadDirectoryContent (dirPath, queryParams) {\n    const entries = await fs.readdir(dirPath, { withFileTypes: true })\n\n    // 应用类型过滤\n    const typeFilter = queryParams?.get('type')\n    let filteredEntries = entries\n\n    if (typeFilter) {\n      filteredEntries = entries.filter(entry => {\n        switch (typeFilter) {\n          case 'file': return entry.isFile()\n          case 'dir': return entry.isDirectory()\n          case 'both': return true\n          default: return true\n        }\n      })\n    }\n\n    // 格式化输出\n    const format = queryParams?.get('format') || 'list'\n\n    switch (format) {\n      case 'json':\n        return JSON.stringify(\n          filteredEntries.map(entry => ({\n            name: entry.name,\n            type: entry.isDirectory() ? 'directory' : 'file',\n            path: path.join(dirPath, entry.name)\n          })),\n          null,\n          2\n        )\n\n      case 'paths':\n        return filteredEntries\n          .map(entry => path.join(dirPath, entry.name))\n          .join('\\n')\n\n      case 'list':\n      default:\n        return filteredEntries\n          .map(entry => {\n            const type = entry.isDirectory() ? '[DIR]' : '[FILE]'\n            return `${type} ${entry.name}`\n          })\n          .join('\\n')\n    }\n  }\n\n  /**\n   * 列出所有支持的用户目录\n   * @returns {Promise<object>} 目录信息\n   */\n  async listUserDirectories () {\n    const result = {}\n\n    for (const dirType of Object.keys(this.userDirs)) {\n      try {\n        result[dirType] = await this.getUserDirectory(dirType)\n      } catch (error) {\n        result[dirType] = { error: error.message }\n      }\n    }\n\n    return result\n  }\n\n  /**\n   * 清除目录缓存\n   */\n  clearCache () {\n    super.clearCache()\n    this.dirCache.clear()\n  }\n}\n\nmodule.exports = UserProtocol\n","const ResourceProtocol = require('./ResourceProtocol')\nconst path = require('path')\nconst fs = require('fs').promises\nconst { getGlobalProjectPathResolver } = require('~/utils/ProjectPathResolver')\nconst ProjectManager = require('~/utils/ProjectManager')\nconst UserProtocol = require('./UserProtocol')\n\n/**\n * 项目协议实现 - 新架构\n * 实现@project://协议，基于当前项目状态的高性能路径解析\n * 移除.promptx目录查找，直接使用ProjectManager的当前项目信息\n */\nclass ProjectProtocol extends ResourceProtocol {\n  constructor (options = {}) {\n    super('project', options)\n    \n    // 🎯 新架构：延迟初始化路径解析器，避免在项目未初始化时创建\n    this.pathResolver = null\n    \n    // HTTP模式支持：UserProtocol实例用于路径映射\n    this.userProtocol = new UserProtocol(options)\n  }\n\n  /**\n   * 获取路径解析器（延迟初始化）\n   * @returns {ProjectPathResolver} 路径解析器实例\n   */\n  getPathResolver() {\n    if (!this.pathResolver) {\n      this.pathResolver = getGlobalProjectPathResolver()\n    }\n    return this.pathResolver\n  }\n\n  /**\n   * 设置注册表（保持与其他协议的一致性）\n   */\n  setRegistry (registry) {\n    // Project协议不使用注册表，但为了一致性提供此方法\n    this.registry = registry || {}\n  }\n\n  /**\n   * 获取协议信息\n   * @returns {object} 协议信息\n   */\n  getProtocolInfo () {\n    return {\n      name: 'project',\n      description: '项目协议，基于当前项目状态的高性能路径解析',\n      location: 'project://{directory}/{path}',\n      examples: [\n        'project://src/index.js',\n        'project://lib/utils.js',\n        'project://docs/README.md',\n        'project://root/package.json',\n        'project://test/unit/'\n      ],\n      supportedDirectories: this.getPathResolver().getSupportedDirectories(),\n      architecture: 'state-based',\n      params: this.getSupportedParams()\n    }\n  }\n\n  /**\n   * 支持的查询参数\n   * @returns {object} 参数说明\n   */\n  getSupportedParams () {\n    return {\n      ...super.getSupportedParams(),\n      from: 'string - 指定搜索起始目录',\n      create: 'boolean - 如果目录不存在是否创建',\n      exists: 'boolean - 仅返回存在的文件/目录',\n      type: 'string - 过滤类型 (file|dir|both)'\n    }\n  }\n\n  /**\n   * 验证项目协议路径\n   * @param {string} resourcePath - 资源路径\n   * @returns {boolean} 是否有效\n   */\n  validatePath (resourcePath) {\n    if (!super.validatePath(resourcePath)) {\n      return false\n    }\n\n    // 特殊处理：允许.promptx开头的路径（项目配置目录）\n    if (resourcePath.startsWith('.promptx/')) {\n      return true\n    }\n\n    // 解析路径的第一部分（目录类型）\n    const parts = resourcePath.split('/')\n    const dirType = parts[0]\n\n    return this.getPathResolver().isSupportedDirectory(dirType)\n  }\n\n\n  /**\n   * 解析项目路径 - 新架构：高性能零查找 + HTTP模式支持\n   * @param {string} resourcePath - 原始资源路径，如 \"src/index.js\" 或 \".promptx/resource/...\"\n   * @param {QueryParams} queryParams - 查询参数\n   * @returns {Promise<string>} 解析后的绝对路径\n   */\n  async resolvePath (resourcePath, queryParams) {\n    try {\n      // 🎯 检测当前项目的transport模式\n      const currentProject = ProjectManager.getCurrentProject()\n      const { transport } = currentProject\n      \n      if (transport === 'http') {\n        return await this.resolveHttpPath(resourcePath, queryParams, currentProject)\n      } else {\n        return this.resolveLocalPath(resourcePath, queryParams, currentProject)\n      }\n    } catch (error) {\n      throw new Error(`解析@project://路径失败: ${error.message}`)\n    }\n  }\n\n  /**\n   * 本地模式路径解析（原有逻辑）\n   * @param {string} resourcePath - 资源路径\n   * @param {QueryParams} queryParams - 查询参数\n   * @param {Object} currentProject - 当前项目信息\n   * @returns {string} 解析后的绝对路径\n   */\n  resolveLocalPath(resourcePath, queryParams, currentProject) {\n    // 🚀 新架构：直接使用路径解析器，无需查找.promptx\n    return this.getPathResolver().resolvePath(resourcePath)\n  }\n\n  /**\n   * HTTP模式路径解析（映射到用户目录的项目空间）\n   * @param {string} resourcePath - 资源路径，如\".promptx/resource/xxx\"\n   * @param {QueryParams} queryParams - 查询参数\n   * @param {Object} currentProject - 当前项目信息\n   * @returns {Promise<string>} 解析后的绝对路径\n   */\n  async resolveHttpPath(resourcePath, queryParams, currentProject) {\n    // 🎯 使用projectHash作为目录名\n    const projectHash = this.generateProjectHash(currentProject.workingDirectory)\n    \n    // 🔧 HTTP模式专用路径转换：将.promptx替换为data（仅HTTP模式）\n    // @project://.promptx → @user://.promptx/project/{projectHash}/data/\n    // @project://.promptx/resource/xxx → @user://.promptx/project/{projectHash}/data/resource/xxx\n    // @project://src/index.js → @user://.promptx/project/{projectHash}/data/src/index.js\n    let mappedResourcePath = resourcePath\n    if (resourcePath === '.promptx') {\n      // 特殊处理：.promptx根目录映射到data目录\n      mappedResourcePath = 'data'\n    } else if (resourcePath.startsWith('.promptx/')) {\n      // HTTP模式：将.promptx/替换为data/，提升用户体验\n      mappedResourcePath = resourcePath.replace(/^\\.promptx\\//, 'data/')\n    } else {\n      // 非.promptx路径直接映射到data目录下\n      mappedResourcePath = `data/${resourcePath}`\n    }\n    \n    const mappedPath = `.promptx/project/${projectHash}/${mappedResourcePath}`\n    \n    // 委托给UserProtocol处理\n    return await this.userProtocol.resolvePath(mappedPath, queryParams)\n  }\n\n  /**\n   * 生成项目路径的Hash值（与ProjectManager保持一致）\n   * @param {string} projectPath - 项目路径\n   * @returns {string} 8位Hash值\n   */\n  generateProjectHash(projectPath) {\n    const crypto = require('crypto')\n    return crypto.createHash('md5').update(path.resolve(projectPath)).digest('hex').substr(0, 8)\n  }\n\n  /**\n   * 加载资源内容\n   * @param {string} resolvedPath - 解析后的路径\n   * @param {QueryParams} queryParams - 查询参数\n   * @returns {Promise<string>} 资源内容\n   */\n  async loadContent (resolvedPath, queryParams) {\n    try {\n      // 🎯 检测transport模式\n      const currentProject = ProjectManager.getCurrentProject()\n      const { transport } = currentProject\n      \n      if (transport === 'http') {\n        // HTTP模式下，使用UserProtocol的loadContent方法\n        return await this.userProtocol.loadContent(resolvedPath, queryParams)\n      } else {\n        // 本地模式，使用原有逻辑\n        return await this.loadLocalContent(resolvedPath, queryParams)\n      }\n    } catch (error) {\n      throw error\n    }\n  }\n\n  /**\n   * 本地模式加载资源内容（原有逻辑）\n   * @param {string} resolvedPath - 解析后的路径\n   * @param {QueryParams} queryParams - 查询参数\n   * @returns {Promise<string>} 资源内容\n   */\n  async loadLocalContent (resolvedPath, queryParams) {\n    try {\n      // 检查路径是否存在\n      const stats = await fs.stat(resolvedPath)\n\n      if (stats.isDirectory()) {\n        return await this.loadDirectoryContent(resolvedPath, queryParams)\n      } else if (stats.isFile()) {\n        return await this.loadFileContent(resolvedPath, queryParams)\n      } else {\n        throw new Error(`不支持的文件类型: ${resolvedPath}`)\n      }\n    } catch (error) {\n      if (error.code === 'ENOENT') {\n        // 检查是否需要创建目录\n        if (queryParams?.get('create') === 'true') {\n          await fs.mkdir(path.dirname(resolvedPath), { recursive: true })\n          return '' // 返回空内容\n        }\n\n        // 如果设置了exists参数为false，返回空内容而不是错误\n        if (queryParams?.get('exists') === 'false') {\n          return ''\n        }\n        throw new Error(`文件或目录不存在: ${resolvedPath}`)\n      }\n      throw error\n    }\n  }\n\n  /**\n   * 加载文件内容\n   * @param {string} filePath - 文件路径\n   * @param {QueryParams} queryParams - 查询参数\n   * @returns {Promise<string>} 文件内容\n   */\n  async loadFileContent (filePath, queryParams) {\n    const encoding = queryParams?.get('encoding') || 'utf8'\n    return await fs.readFile(filePath, encoding)\n  }\n\n  /**\n   * 加载目录内容\n   * @param {string} dirPath - 目录路径\n   * @param {QueryParams} queryParams - 查询参数\n   * @returns {Promise<string>} 目录内容列表\n   */\n  async loadDirectoryContent (dirPath, queryParams) {\n    const entries = await fs.readdir(dirPath, { withFileTypes: true })\n\n    // 应用类型过滤\n    const typeFilter = queryParams?.get('type')\n    let filteredEntries = entries\n\n    if (typeFilter) {\n      filteredEntries = entries.filter(entry => {\n        switch (typeFilter) {\n          case 'file': return entry.isFile()\n          case 'dir': return entry.isDirectory()\n          case 'both': return true\n          default: return true\n        }\n      })\n    }\n\n    // 格式化输出\n    const format = queryParams?.get('format') || 'list'\n\n    switch (format) {\n      case 'json':\n        return JSON.stringify(\n          filteredEntries.map(entry => ({\n            name: entry.name,\n            type: entry.isDirectory() ? 'directory' : 'file',\n            path: path.join(dirPath, entry.name)\n          })),\n          null,\n          2\n        )\n\n      case 'paths':\n        return filteredEntries\n          .map(entry => path.join(dirPath, entry.name))\n          .join('\\n')\n\n      case 'list':\n      default:\n        return filteredEntries\n          .map(entry => {\n            const type = entry.isDirectory() ? '[DIR]' : '[FILE]'\n            return `${type} ${entry.name}`\n          })\n          .join('\\n')\n    }\n  }\n\n  /**\n   * 列出项目结构信息 - 新架构\n   * @returns {Promise<object>} 项目信息\n   */\n  async getProjectInfo () {\n    try {\n      const projectRoot = this.getPathResolver().getProjectRoot()\n      const promptxPath = this.getPathResolver().getPromptXDirectory()\n      \n      const result = {\n        projectRoot,\n        promptxPath,\n        architecture: 'state-based',\n        supportedDirectories: this.getPathResolver().getSupportedDirectories(),\n        directories: {}\n      }\n\n      // 检查支持的目录是否存在\n      for (const dirType of this.getPathResolver().getSupportedDirectories()) {\n        try {\n          const fullPath = this.getPathResolver().resolvePath(dirType)\n          const stats = await fs.stat(fullPath)\n          result.directories[dirType] = {\n            path: fullPath,\n            exists: true,\n            type: stats.isDirectory() ? 'directory' : 'file'\n          }\n        } catch (error) {\n          result.directories[dirType] = {\n            path: 'N/A',\n            exists: false\n          }\n        }\n      }\n\n      return result\n    } catch (error) {\n      return { \n        error: `获取项目信息失败: ${error.message}`,\n        architecture: 'state-based'\n      }\n    }\n  }\n\n  /**\n   * 清除缓存 - 新架构：无需清除路径缓存\n   */\n  clearCache () {\n    super.clearCache()\n    // 🎯 新架构：基于状态管理，无需路径缓存\n  }\n}\n\nmodule.exports = ProjectProtocol\n","const ResourceProtocol = require('./ResourceProtocol')\nconst fs = require('fs-extra')\nconst path = require('path')\n\n/**\n * AI角色协议处理器\n * 处理 role:// 协议的资源解析，直接加载完整role文件\n */\nclass RoleProtocol extends ResourceProtocol {\n  constructor () {\n    super('role')\n    this.registry = {}\n    this.registryManager = null // 统一注册表管理器\n  }\n\n  /**\n   * 设置注册表管理器\n   */\n  setRegistryManager(manager) {\n    this.registryManager = manager\n  }\n\n  /**\n   * 设置注册表\n   */\n  setRegistry (registry) {\n    this.registry = registry || {}\n  }\n\n  /**\n   * 获取协议信息\n   */\n  getProtocolInfo () {\n    return {\n      name: 'role',\n      description: 'AI角色资源协议',\n      location: 'role://{role_id}',\n      examples: [\n        'role://video-copywriter',\n        'role://product-owner',\n        'role://assistant',\n        'role://prompt-developer'\n      ]\n    }\n  }\n\n  /**\n   * 解析角色协议\n   * @param {string} rolePath - 角色路径，如 'java-developer'\n   * @param {Object} queryParams - 查询参数（暂未使用）\n   * @returns {Promise<string>} 角色文件内容\n   */\n  async resolve(rolePath, queryParams = {}) {\n    try {\n      // 构建可能的资源ID格式\n      const fullResourceId = `role:${rolePath}`\n      const shortResourceId = rolePath\n      \n      // 从RegistryData查找资源\n      let resourceData = this.registryManager.registryData.findResourceById(rolePath, 'role')\n      \n      if (!resourceData) {\n        // 如果没找到，尝试其他格式\n        resourceData = this.registryManager.registryData.findResourceById(fullResourceId)\n      }\n      \n      if (!resourceData) {\n        const availableRoles = this.registryManager.registryData.getResourcesByProtocol('role')\n          .map(r => r.id).join(', ')\n        throw new Error(`角色 '${rolePath}' 未找到。可用角色: ${availableRoles}`)\n      }\n\n      // 通过ResourceManager加载实际内容\n      const result = await this.registryManager.loadResourceByProtocol(resourceData.reference)\n      \n      return result\n    } catch (error) {\n      throw new Error(`RoleProtocol.resolve failed: ${error.message}`)\n    }\n  }\n\n  /**\n   * 加载资源内容\n   */\n  async loadContent (resolvedPath, queryParams) {\n    try {\n      const content = await fs.readFile(resolvedPath, 'utf-8')\n      return content\n    } catch (error) {\n      throw new Error(`无法加载角色文件 ${resolvedPath}: ${error.message}`)\n    }\n  }\n\n  /**\n   * 验证资源路径\n   */\n  validatePath (resourcePath) {\n    return /^[a-zA-Z0-9_-]+$/.test(resourcePath)\n  }\n}\n\nmodule.exports = RoleProtocol\n","const ResourceProtocol = require('./ResourceProtocol')\nconst fs = require('fs-extra')\nconst path = require('path')\n\n/**\n * 思维模式协议处理器\n * 处理 thought:// 协议的资源解析\n */\nclass ThoughtProtocol extends ResourceProtocol {\n  constructor () {\n    super('thought')\n    this.registry = {}\n    this.registryManager = null // 统一注册表管理器\n  }\n\n  /**\n   * 设置注册表管理器\n   */\n  setRegistryManager(manager) {\n    this.registryManager = manager\n  }\n\n  /**\n   * 设置注册表\n   */\n  setRegistry (registry) {\n    this.registry = registry || {}\n  }\n\n  /**\n   * 获取协议信息\n   */\n  getProtocolInfo () {\n    return {\n      name: 'thought',\n      description: '思维模式资源协议',\n      location: 'thought://{thought_id}',\n      examples: [\n        'thought://prompt-developer',\n        'thought://product-owner'\n      ]\n    }\n  }\n\n  /**\n   * 解析思维协议\n   * @param {string} thoughtPath - 思维路径，如 'remember'\n   * @param {Object} queryParams - 查询参数（暂未使用）\n   * @returns {Promise<string>} 思维文件内容\n   */\n  async resolve(thoughtPath, queryParams = {}) {\n    try {\n      // 构建可能的资源ID格式\n      const fullResourceId = `thought:${thoughtPath}`\n      \n      // 从RegistryData查找资源\n      let resourceData = this.registryManager.registryData.findResourceById(thoughtPath, 'thought')\n      \n      if (!resourceData) {\n        // 如果没找到，尝试其他格式\n        resourceData = this.registryManager.registryData.findResourceById(fullResourceId)\n      }\n      \n      if (!resourceData) {\n        const availableThoughts = this.registryManager.registryData.getResourcesByProtocol('thought')\n          .map(r => r.id).join(', ')\n        throw new Error(`思维模式 '${thoughtPath}' 未找到。可用思维模式: ${availableThoughts}`)\n      }\n\n      // 通过ResourceManager加载实际内容\n      const result = await this.registryManager.loadResourceByProtocol(resourceData.reference)\n      \n      return result\n    } catch (error) {\n      throw new Error(`ThoughtProtocol.resolve failed: ${error.message}`)\n    }\n  }\n\n  /**\n   * 加载资源内容\n   */\n  async loadContent (resolvedPath, queryParams) {\n    try {\n      const content = await fs.readFile(resolvedPath, 'utf-8')\n      return content\n    } catch (error) {\n      throw new Error(`无法加载思维模式文件 ${resolvedPath}: ${error.message}`)\n    }\n  }\n\n  /**\n   * 验证资源路径\n   */\n  validatePath (resourcePath) {\n    return /^[a-zA-Z0-9_-]+$/.test(resourcePath)\n  }\n}\n\nmodule.exports = ThoughtProtocol\n","const ResourceProtocol = require('./ResourceProtocol')\nconst fs = require('fs-extra')\nconst path = require('path')\n\n/**\n * 执行模式协议处理器\n * 处理 execution:// 协议的资源解析\n */\nclass ExecutionProtocol extends ResourceProtocol {\n  constructor () {\n    super('execution')\n    this.registry = {}\n    this.registryManager = null // 统一注册表管理器\n  }\n\n  /**\n   * 设置注册表管理器\n   */\n  setRegistryManager(manager) {\n    this.registryManager = manager\n  }\n\n  /**\n   * 设置注册表\n   */\n  setRegistry (registry) {\n    this.registry = registry || {}\n  }\n\n  /**\n   * 获取协议信息\n   */\n  getProtocolInfo () {\n    return {\n      name: 'execution',\n      description: '执行模式资源协议',\n      location: 'execution://{execution_id}',\n      examples: [\n        'execution://deal-at-reference',\n        'execution://prompt-developer',\n        'execution://memory-trigger'\n      ]\n    }\n  }\n\n  /**\n   * 解析执行协议\n   * @param {string} executionPath - 执行路径，如 'best-practice'\n   * @param {Object} queryParams - 查询参数（暂未使用）\n   * @returns {Promise<string>} 执行文件内容\n   */\n  async resolve(executionPath, queryParams = {}) {\n    try {\n      // 构建可能的资源ID格式\n      const fullResourceId = `execution:${executionPath}`\n      \n      // 从RegistryData查找资源\n      let resourceData = this.registryManager.registryData.findResourceById(executionPath, 'execution')\n      \n      if (!resourceData) {\n        // 如果没找到，尝试其他格式\n        resourceData = this.registryManager.registryData.findResourceById(fullResourceId)\n      }\n      \n      if (!resourceData) {\n        const availableExecutions = this.registryManager.registryData.getResourcesByProtocol('execution')\n          .map(r => r.id).join(', ')\n        throw new Error(`执行模式 '${executionPath}' 未找到。可用执行模式: ${availableExecutions}`)\n      }\n\n      // 通过ResourceManager加载实际内容\n      const result = await this.registryManager.loadResourceByProtocol(resourceData.reference)\n      \n      return result\n    } catch (error) {\n      throw new Error(`ExecutionProtocol.resolve failed: ${error.message}`)\n    }\n  }\n\n  /**\n   * 加载资源内容\n   */\n  async loadContent (resolvedPath, queryParams) {\n    try {\n      const content = await fs.readFile(resolvedPath, 'utf-8')\n      return content\n    } catch (error) {\n      throw new Error(`无法加载执行模式文件 ${resolvedPath}: ${error.message}`)\n    }\n  }\n\n  /**\n   * 验证资源路径\n   */\n  validatePath (resourcePath) {\n    return /^[a-zA-Z0-9_-]+$/.test(resourcePath)\n  }\n}\n\nmodule.exports = ExecutionProtocol\n","const ResourceProtocol = require('./ResourceProtocol')\nconst fs = require('fs-extra')\nconst path = require('path')\n\n/**\n * 知识资源协议处理器\n * 处理 knowledge:// 协议的资源解析\n */\nclass KnowledgeProtocol extends ResourceProtocol {\n  constructor () {\n    super('knowledge')\n    this.registry = {}\n    this.registryManager = null // 统一注册表管理器\n  }\n\n  /**\n   * 设置注册表管理器\n   */\n  setRegistryManager(manager) {\n    this.registryManager = manager\n  }\n\n  /**\n   * 设置注册表\n   */\n  setRegistry (registry) {\n    this.registry = registry || {}\n  }\n\n  /**\n   * 获取协议信息\n   */\n  getProtocolInfo () {\n    return {\n      name: 'knowledge',\n      description: '知识资源协议',\n      location: 'knowledge://{knowledge_id}',\n      examples: [\n        'knowledge://xiaohongshu-marketing',\n        'knowledge://ai-tools-guide'\n      ]\n    }\n  }\n\n  /**\n   * 解析知识协议\n   * @param {string} knowledgePath - 知识路径，如 'scrum'\n   * @param {Object} queryParams - 查询参数（暂未使用）\n   * @returns {Promise<string>} 知识文件内容\n   */\n  async resolve(knowledgePath, queryParams = {}) {\n    try {\n      // 构建可能的资源ID格式\n      const fullResourceId = `knowledge:${knowledgePath}`\n      \n      // 从RegistryData查找资源\n      let resourceData = this.registryManager.registryData.findResourceById(knowledgePath, 'knowledge')\n      \n      if (!resourceData) {\n        // 如果没找到，尝试其他格式\n        resourceData = this.registryManager.registryData.findResourceById(fullResourceId)\n      }\n      \n      if (!resourceData) {\n        const availableKnowledge = this.registryManager.registryData.getResourcesByProtocol('knowledge')\n          .map(r => r.id).join(', ')\n        throw new Error(`知识模块 '${knowledgePath}' 未找到。可用知识模块: ${availableKnowledge}`)\n      }\n\n      // 通过ResourceManager加载实际内容\n      const result = await this.registryManager.loadResourceByProtocol(resourceData.reference)\n      \n      return result\n    } catch (error) {\n      throw new Error(`KnowledgeProtocol.resolve failed: ${error.message}`)\n    }\n  }\n\n  /**\n   * 加载资源内容\n   */\n  async loadContent (resolvedPath, queryParams) {\n    try {\n      const content = await fs.readFile(resolvedPath, 'utf-8')\n      return content\n    } catch (error) {\n      throw new Error(`无法加载知识资源文件 ${resolvedPath}: ${error.message}`)\n    }\n  }\n\n  /**\n   * 验证资源路径\n   */\n  validatePath (resourcePath) {\n    return /^[a-zA-Z0-9_-]+$/.test(resourcePath)\n  }\n}\n\nmodule.exports = KnowledgeProtocol ","const ResourceProtocol = require('./ResourceProtocol');\n\n/**\n * Tool协议处理器\n * 处理 @tool://tool-name 格式的资源引用\n * 从注册表中查找并加载工具JavaScript代码\n */\nclass ToolProtocol extends ResourceProtocol {\n  constructor() {\n    super('tool');\n    this.registryManager = null;\n  }\n\n  /**\n   * 设置注册表管理器引用\n   * @param {Object} manager - ResourceManager实例\n   */\n  setRegistryManager(manager) {\n    this.registryManager = manager;\n  }\n\n  /**\n   * 解析工具资源路径\n   * @param {string} toolPath - 工具名称，如 \"calculator\"\n   * @param {Object} queryParams - 查询参数（可选）\n   * @returns {Promise<Object>} 工具代码和元数据\n   */\n  async resolve(toolPath, queryParams = {}) {\n    if (!this.registryManager) {\n      throw new Error('ToolProtocol: Registry manager not set');\n    }\n\n    // 1. 从注册表查找tool资源\n    const toolResource = this.registryManager.registryData\n      .findResourceById(toolPath, 'tool');\n    \n    if (!toolResource) {\n      throw new Error(`Tool '${toolPath}' not found in registry`);\n    }\n\n    // 2. 加载tool文件内容\n    const toolContent = await this.registryManager\n      .loadResourceByProtocol(toolResource.reference);\n    \n    // 3. 验证工具代码格式\n    this.validateToolContent(toolContent, toolPath);\n\n    // 4. 返回工具信息\n    return {\n      id: toolPath,\n      content: toolContent,\n      metadata: toolResource,\n      source: toolResource.source || 'unknown'\n    };\n  }\n\n  /**\n   * 验证工具内容格式\n   * @param {string} content - 工具文件内容\n   * @param {string} toolPath - 工具路径\n   */\n  validateToolContent(content, toolPath) {\n    if (!content || typeof content !== 'string') {\n      throw new Error(`Tool '${toolPath}': Invalid or empty content`);\n    }\n\n    // 基本的JavaScript语法检查\n    try {\n      // 尝试创建一个函数来验证语法\n      new Function(content);\n    } catch (syntaxError) {\n      throw new Error(`Tool '${toolPath}': JavaScript syntax error - ${syntaxError.message}`);\n    }\n  }\n\n  /**\n   * 获取协议信息\n   * @returns {Object} 协议描述信息\n   */\n  getProtocolInfo() {\n    return {\n      name: 'tool',\n      description: 'Tool资源协议 - 加载可执行的JavaScript工具',\n      syntax: 'tool://{tool_id}',\n      examples: [\n        'tool://calculator',\n        'tool://send-email', \n        'tool://data-processor',\n        'tool://api-client'\n      ],\n      supportedFileTypes: ['.tool.js'],\n      usageNote: '工具文件必须导出符合PromptX Tool Interface的对象'\n    };\n  }\n\n  /**\n   * 检查缓存策略\n   * @param {string} toolPath - 工具路径\n   * @returns {boolean} 是否应该缓存\n   */\n  shouldCache(toolPath) {\n    // 工具代码通常比较稳定，启用缓存以提高性能\n    return true;\n  }\n\n  /**\n   * 获取缓存键\n   * @param {string} toolPath - 工具路径\n   * @returns {string} 缓存键\n   */\n  getCacheKey(toolPath) {\n    return `tool://${toolPath}`;\n  }\n}\n\nmodule.exports = ToolProtocol;","const ResourceProtocol = require('./ResourceProtocol')\n\n/**\n * Manual协议处理器\n * 处理 @manual://tool-name 格式的资源引用\n * 从注册表中查找并加载工具使用手册\n */\nclass ManualProtocol extends ResourceProtocol {\n  constructor() {\n    super('manual')\n    this.registryManager = null\n  }\n\n  /**\n   * 设置注册表管理器引用\n   * @param {Object} manager - ResourceManager实例\n   */\n  setRegistryManager(manager) {\n    this.registryManager = manager\n  }\n\n  /**\n   * 解析工具手册资源路径\n   * @param {string} manualPath - 手册名称，如 \"calculator\"\n   * @param {Object} queryParams - 查询参数（可选）\n   * @returns {Promise<Object>} 手册内容和元数据\n   */\n  async resolve(manualPath, queryParams = {}) {\n    if (!this.registryManager) {\n      throw new Error('ManualProtocol: Registry manager not set')\n    }\n\n    // 1. 从注册表查找manual资源\n    const manualResource = this.registryManager.registryData\n      .findResourceById(manualPath, 'manual')\n    \n    if (!manualResource) {\n      // 尝试查找对应的tool资源，给出更友好的提示\n      const toolResource = this.registryManager.registryData\n        .findResourceById(manualPath, 'tool')\n      \n      if (toolResource) {\n        throw new Error(`Manual '${manualPath}' not found. Found corresponding tool but no manual. Consider creating ${manualPath}.manual.md`)\n      }\n      \n      throw new Error(`Manual '${manualPath}' not found in registry`)\n    }\n\n    // 2. 加载manual文件内容\n    const manualContent = await this.registryManager\n      .loadResourceByProtocol(manualResource.reference)\n    \n    // 3. 验证手册内容格式\n    this.validateManualContent(manualContent, manualPath)\n\n    // 4. 返回手册信息\n    return {\n      id: manualPath,\n      content: manualContent,\n      metadata: manualResource,\n      source: manualResource.source || 'unknown'\n    }\n  }\n\n  /**\n   * 验证手册内容格式\n   * @param {string} content - 手册文件内容\n   * @param {string} manualPath - 手册路径\n   */\n  validateManualContent(content, manualPath) {\n    if (!content || typeof content !== 'string') {\n      throw new Error(`Manual '${manualPath}': Invalid or empty content`)\n    }\n\n    const trimmedContent = content.trim()\n    if (trimmedContent.length === 0) {\n      throw new Error(`Manual '${manualPath}': Empty manual content`)\n    }\n\n    // 验证是否包含<manual>标签\n    if (!trimmedContent.includes('<manual>') || !trimmedContent.includes('</manual>')) {\n      throw new Error(`Manual '${manualPath}': Missing required <manual> tags`)\n    }\n  }\n\n  /**\n   * 获取协议信息\n   * @returns {Object} 协议描述信息\n   */\n  getProtocolInfo() {\n    return {\n      name: 'manual',\n      description: 'Manual资源协议 - 加载工具使用手册和说明文档',\n      syntax: 'manual://{manual_id}',\n      examples: [\n        'manual://calculator',\n        'manual://send-email',\n        'manual://data-processor',\n        'manual://api-client'\n      ],\n      supportedFileTypes: ['.manual.md'],\n      usageNote: '手册文件必须使用<manual>标签包裹内容，提供工具的详细使用说明'\n    }\n  }\n\n  /**\n   * 检查缓存策略\n   * @param {string} manualPath - 手册路径\n   * @returns {boolean} 是否应该缓存\n   */\n  shouldCache(manualPath) {\n    // 手册内容通常比较稳定，启用缓存\n    return true\n  }\n\n  /**\n   * 获取缓存键\n   * @param {string} manualPath - 手册路径\n   * @returns {string} 缓存键\n   */\n  getCacheKey(manualPath) {\n    return `manual://${manualPath}`\n  }\n}\n\nmodule.exports = ManualProtocol","const ResourceProtocol = require('./ResourceProtocol')\nconst path = require('path')\nconst fs = require('fs').promises\n\n/**\n * 文件协议实现\n * 实现@file://协议，用于访问本地文件系统中的文件\n */\nclass FileProtocol extends ResourceProtocol {\n  constructor (options = {}) {\n    super('file', options)\n  }\n\n  /**\n   * 设置注册表（保持与其他协议的一致性）\n   */\n  setRegistry (registry) {\n    // File协议不使用注册表，但为了一致性提供此方法\n    this.registry = registry || {}\n  }\n\n  /**\n   * 获取协议信息\n   * @returns {object} 协议信息\n   */\n  getProtocolInfo () {\n    return {\n      name: 'file',\n      description: '文件系统协议，提供本地文件访问',\n      location: 'file://{path}',\n      examples: [\n        'file://package.json',\n        'file:///absolute/path/to/file.txt',\n        'file://./relative/path/file.md',\n        'file://../parent/file.json'\n      ],\n      params: this.getSupportedParams()\n    }\n  }\n\n  /**\n   * 支持的查询参数\n   * @returns {object} 参数说明\n   */\n  getSupportedParams () {\n    return {\n      ...super.getSupportedParams(),\n      encoding: 'string - 文件编码 (utf8, ascii, binary等)',\n      exists: 'boolean - 仅返回存在的文件'\n    }\n  }\n\n  /**\n   * 验证文件协议路径\n   * @param {string} resourcePath - 资源路径\n   * @returns {boolean} 是否有效\n   */\n  validatePath (resourcePath) {\n    if (!super.validatePath(resourcePath)) {\n      return false\n    }\n\n    // 基本路径验证 - 允许相对路径和绝对路径\n    return typeof resourcePath === 'string' && resourcePath.length > 0\n  }\n\n  /**\n   * 解析文件路径\n   * @param {string} resourcePath - 原始资源路径\n   * @param {QueryParams} queryParams - 查询参数\n   * @returns {Promise<string>} 解析后的绝对路径\n   */\n  async resolvePath (resourcePath, queryParams) {\n    let resolvedPath\n\n    if (path.isAbsolute(resourcePath)) {\n      // 绝对路径直接使用\n      resolvedPath = resourcePath\n    } else {\n      // 相对路径相对于当前工作目录解析\n      resolvedPath = path.resolve(process.cwd(), resourcePath)\n    }\n\n    // 规范化路径\n    resolvedPath = path.normalize(resolvedPath)\n\n    return resolvedPath\n  }\n\n  /**\n   * 加载资源内容\n   * @param {string} resolvedPath - 解析后的路径\n   * @param {QueryParams} queryParams - 查询参数\n   * @returns {Promise<string>} 资源内容\n   */\n  async loadContent (resolvedPath, queryParams) {\n    try {\n      // 检查路径是否存在\n      const stats = await fs.stat(resolvedPath)\n\n      if (stats.isDirectory()) {\n        return await this.loadDirectoryContent(resolvedPath, queryParams)\n      } else if (stats.isFile()) {\n        return await this.loadFileContent(resolvedPath, queryParams)\n      } else {\n        throw new Error(`不支持的文件类型: ${resolvedPath}`)\n      }\n    } catch (error) {\n      if (error.code === 'ENOENT') {\n        // 如果设置了exists参数为false，返回空内容而不是错误\n        if (queryParams && queryParams.get('exists') === 'false') {\n          return ''\n        }\n        throw new Error(`文件或目录不存在: ${resolvedPath}`)\n      }\n      throw error\n    }\n  }\n\n  /**\n   * 加载文件内容\n   * @param {string} filePath - 文件路径\n   * @param {QueryParams} queryParams - 查询参数\n   * @returns {Promise<string>} 文件内容\n   */\n  async loadFileContent (filePath, queryParams) {\n    const encoding = queryParams?.get('encoding') || 'utf8'\n    return await fs.readFile(filePath, encoding)\n  }\n\n  /**\n   * 加载目录内容\n   * @param {string} dirPath - 目录路径\n   * @param {QueryParams} queryParams - 查询参数\n   * @returns {Promise<string>} 目录内容列表\n   */\n  async loadDirectoryContent (dirPath, queryParams) {\n    const entries = await fs.readdir(dirPath, { withFileTypes: true })\n\n    // 应用类型过滤\n    const typeFilter = queryParams?.get('type')\n    let filteredEntries = entries\n\n    if (typeFilter) {\n      filteredEntries = entries.filter(entry => {\n        switch (typeFilter) {\n          case 'file': return entry.isFile()\n          case 'dir': return entry.isDirectory()\n          case 'both': return true\n          default: return true\n        }\n      })\n    }\n\n    // 格式化输出\n    const format = queryParams?.get('format') || 'list'\n\n    switch (format) {\n      case 'json':\n        return JSON.stringify(\n          filteredEntries.map(entry => ({\n            name: entry.name,\n            type: entry.isDirectory() ? 'directory' : 'file',\n            path: path.join(dirPath, entry.name)\n          })),\n          null,\n          2\n        )\n\n      case 'paths':\n        return filteredEntries\n          .map(entry => path.join(dirPath, entry.name))\n          .join('\\n')\n\n      case 'list':\n      default:\n        return filteredEntries\n          .map(entry => {\n            const type = entry.isDirectory() ? '[DIR]' : '[FILE]'\n            return `${type} ${entry.name}`\n          })\n          .join('\\n')\n    }\n  }\n}\n\nmodule.exports = FileProtocol","const fs = require('fs')\nconst RegistryData = require('./RegistryData')\nconst ResourceProtocolParser = require('./resourceProtocolParser') \nconst DiscoveryManager = require('./discovery/DiscoveryManager')\nconst logger = require('@promptx/logger')\n\n// 导入协议处理器\nconst PackageProtocol = require('./protocols/PackageProtocol')\nconst ProjectProtocol = require('./protocols/ProjectProtocol')\nconst RoleProtocol = require('./protocols/RoleProtocol')\nconst ThoughtProtocol = require('./protocols/ThoughtProtocol')\nconst ExecutionProtocol = require('./protocols/ExecutionProtocol')\nconst KnowledgeProtocol = require('./protocols/KnowledgeProtocol')\nconst ToolProtocol = require('./protocols/ToolProtocol')\nconst ManualProtocol = require('./protocols/ManualProtocol')\nconst UserProtocol = require('./protocols/UserProtocol')\nconst FileProtocol = require('./protocols/FileProtocol')\n\nclass ResourceManager {\n  constructor() {\n    // 新架构：统一的资源注册表\n    this.registryData = RegistryData.createEmpty('merged', null)\n    \n    // 协议解析器\n    this.protocolParser = new ResourceProtocolParser()\n    this.parser = new ResourceProtocolParser() // 向后兼容别名\n    \n    // 资源发现管理器\n    this.discoveryManager = new DiscoveryManager()\n    \n    // 初始化协议处理器\n    this.protocols = new Map()\n    this.initializeProtocols()\n  }\n\n  /**\n   * 初始化所有协议处理器\n   */\n  initializeProtocols() {\n    // 基础协议 - 直接文件系统映射\n    this.protocols.set('package', new PackageProtocol())\n    this.protocols.set('project', new ProjectProtocol()) \n    this.protocols.set('file', new FileProtocol())\n    this.protocols.set('user', new UserProtocol())\n\n    // 逻辑协议 - 需要注册表查询\n    this.protocols.set('role', new RoleProtocol())\n    this.protocols.set('thought', new ThoughtProtocol())\n    this.protocols.set('execution', new ExecutionProtocol())\n    this.protocols.set('knowledge', new KnowledgeProtocol())\n    this.protocols.set('tool', new ToolProtocol())\n    this.protocols.set('manual', new ManualProtocol())\n  }\n\n  /**\n   * 新架构初始化方法\n   */\n  async initializeWithNewArchitecture() {\n    try {\n      logger.info('[ResourceManager] Starting initialization...')\n      \n      // 1. 清空现有注册表\n      this.registryData.clear()\n      logger.info('[ResourceManager] Cleared existing registry')\n\n      // 2. 清除发现器缓存\n      if (this.discoveryManager && typeof this.discoveryManager.clearCache === 'function') {\n        this.discoveryManager.clearCache()\n        logger.info('[ResourceManager] Cleared discovery cache')\n      }\n\n      // 3. 填充新的RegistryData\n      logger.info('[ResourceManager] Populating registry data...')\n      await this.populateRegistryData()\n\n      // 4. 为逻辑协议设置注册表引用\n      this.setupLogicalProtocols()\n\n      // 5. 设置初始化状态\n      this.initialized = true\n\n      // 记录初始化完成的统计信息\n      const stats = this.registryData.getStats()\n      logger.info('[ResourceManager] Initialization complete:', {\n        totalResources: this.registryData.size,\n        bySource: stats.bySource,\n        byProtocol: stats.byProtocol\n      })\n    } catch (error) {\n      logger.warn(`ResourceManager new architecture initialization failed: ${error.message}`)\n      logger.warn('ResourceManager continuing with empty registry')\n      this.initialized = true // 即使失败也标记为已初始化，避免重复尝试\n    }\n  }\n\n  /**\n   * 填充新的RegistryData\n   */\n  async populateRegistryData() {\n    // 清空现有数据\n    this.registryData.clear()\n    \n    logger.info('[ResourceManager] Discovery managers:', {\n      count: this.discoveryManager.discoveries.length,\n      sources: this.discoveryManager.discoveries.map(d => d.source)\n    })\n    \n    // 从各个发现器获取RegistryData并合并\n    for (const discovery of this.discoveryManager.discoveries) {\n      try {\n        logger.info(`[ResourceManager] Loading from ${discovery.source} discovery...`)\n        \n        if (typeof discovery.getRegistryData === 'function') {\n          const registryData = await discovery.getRegistryData()\n          if (registryData && registryData.resources) {\n            const resourceCount = registryData.size || 0\n            logger.info(`[ResourceManager] Found ${resourceCount} resources from ${discovery.source}`)\n            \n            // 合并资源到主注册表\n            this.registryData.merge(registryData, true) // 允许覆盖\n            \n            // 调试：打印合并的资源\n            if (discovery.source === 'USER' && registryData.resources) {\n              logger.debug(`[ResourceManager] USER resources to merge:`, registryData.resources.map(r => `${r.protocol}://${r.id}`))\n            }\n            \n            // 记录合并后的状态\n            logger.info(`[ResourceManager] After merging ${discovery.source}, total: ${this.registryData.size}`)\n          } else {\n            logger.info(`[ResourceManager] No resources found from ${discovery.source}`)\n          }\n        } else {\n          logger.info(`[ResourceManager] ${discovery.source} does not support getRegistryData`)\n        }\n      } catch (error) {\n        logger.warn(`Failed to get RegistryData from ${discovery.source}: ${error.message}`)\n      }\n    }\n    \n    logger.info('[ResourceManager] Registry population complete, total resources:', this.registryData.size)\n  }\n\n  /**\n   * 为逻辑协议设置注册表引用\n   */\n  setupLogicalProtocols() {\n    // 将统一注册表传递给逻辑协议处理器\n    const roleProtocol = this.protocols.get('role')\n    const executionProtocol = this.protocols.get('execution')\n    const thoughtProtocol = this.protocols.get('thought')\n    const knowledgeProtocol = this.protocols.get('knowledge')\n    const toolProtocol = this.protocols.get('tool')\n    const manualProtocol = this.protocols.get('manual')\n    \n    if (roleProtocol) {\n      roleProtocol.setRegistryManager(this)\n    }\n    if (executionProtocol) {\n      executionProtocol.setRegistryManager(this)\n    }\n    if (thoughtProtocol) {\n      thoughtProtocol.setRegistryManager(this)\n    }\n    if (knowledgeProtocol) {\n      knowledgeProtocol.setRegistryManager(this)\n    }\n    if (toolProtocol) {\n      toolProtocol.setRegistryManager(this)\n    }\n    if (manualProtocol) {\n      manualProtocol.setRegistryManager(this)\n    }\n    \n    // 逻辑协议设置完成，不输出日志避免干扰用户界面\n  }\n\n  /**\n   * 通过协议解析加载资源内容\n   * @param {string} reference - 资源引用\n   * @returns {Promise<string>} 资源内容\n   */\n  async loadResourceByProtocol(reference) {\n    // 1. 使用ResourceProtocolParser解析DPML语法\n    const parsed = this.protocolParser.parse(reference)\n    \n    // 2. 获取对应的协议处理器\n    const protocol = this.protocols.get(parsed.protocol)\n    if (!protocol) {\n      throw new Error(`不支持的协议: ${parsed.protocol}`)\n    }\n\n    // 3. 委托给协议处理器解析并加载内容\n    const result = await protocol.resolve(parsed.path, parsed.queryParams)\n    \n    // 4. 确保返回字符串内容，解包可能的对象格式\n    if (typeof result === 'string') {\n      return result\n    } else if (result && typeof result === 'object' && result.content) {\n      return result.content\n    } else {\n      throw new Error(`协议${parsed.protocol}返回了无效的内容格式`)\n    }\n  }\n\n  async loadResource(resourceId) {\n    try {\n      // 确保ResourceManager已初始化\n      if (!this.initialized) {\n        logger.info('[ResourceManager] Initializing resource manager...')\n        await this.initializeWithNewArchitecture()\n      }\n      \n      // 处理@开头的DPML格式（如 @file://path, @!role://java-developer）\n      if (resourceId.startsWith('@')) {\n        const parsed = this.protocolParser.parse(resourceId)\n        \n        // 对于基础协议（file, user, package, project），直接通过协议处理器加载\n        const basicProtocols = ['file', 'user', 'package', 'project']\n        if (basicProtocols.includes(parsed.protocol)) {\n          const content = await this.loadResourceByProtocol(resourceId)\n          return {\n            success: true,\n            content,\n            resourceId,\n            reference: resourceId\n          }\n        }\n        \n        // 对于逻辑协议，从RegistryData查找资源\n        logger.debug(`[ResourceManager] Finding resource: protocol=${parsed.protocol}, id=${parsed.path}`)\n        const resourceData = this.registryData.findResourceById(parsed.path, parsed.protocol)\n        if (!resourceData) {\n          // 打印所有可用的资源以便调试\n          const availableResources = this.registryData.getResourcesByProtocol(parsed.protocol)\n          logger.error(`[ResourceManager] Resource not found: ${parsed.protocol}:${parsed.path}`)\n          logger.error(`[ResourceManager] Available ${parsed.protocol} resources:`, availableResources.map(r => `${r.id} (${r.source})`))\n          throw new Error(`Resource not found: ${parsed.protocol}:${parsed.path}`)\n        }\n        logger.debug(`[ResourceManager] Found resource: ${resourceData.id} from ${resourceData.source}`)\n        \n        // 通过协议解析加载内容\n        const content = await this.loadResourceByProtocol(resourceData.reference)\n        \n        return {\n          success: true,\n          content,\n          resourceId,\n          reference: resourceData.reference\n        }\n      }\n      \n      // 处理URL格式（如 thought://systematic-testing）\n      const urlMatch = resourceId.match(/^([a-zA-Z][a-zA-Z0-9_-]*):\\/\\/(.+)$/)\n      if (urlMatch) {\n        const [, protocol, id] = urlMatch\n        const resourceData = this.registryData.findResourceById(id, protocol)\n        if (!resourceData) {\n          throw new Error(`Resource not found: ${resourceId}`)\n        }\n        \n        // 通过协议解析加载内容\n        const content = await this.loadResourceByProtocol(resourceData.reference)\n        \n        return {\n          success: true,\n          content,\n          resourceId,\n          reference: resourceData.reference\n        }\n      }\n      \n      // 处理传统格式（如 role:java-developer）\n      let reference = null\n      \n      // 如果包含协议前缀（如 thought:remember）\n      if (resourceId.includes(':')) {\n        const [protocol, id] = resourceId.split(':', 2)\n        const resourceData = this.registryData.findResourceById(id, protocol)\n        if (resourceData) {\n          reference = resourceData.reference\n        }\n      } else {\n        // 如果没有协议前缀，尝试查找任意协议的资源\n        const resourceData = this.registryData.findResourceById(resourceId)\n        if (resourceData) {\n          reference = resourceData.reference\n        }\n      }\n      \n      if (!reference) {\n        throw new Error(`Resource not found: ${resourceId}`)\n      }\n      \n      // 通过协议解析加载内容\n      const content = await this.loadResourceByProtocol(reference)\n\n      return {\n        success: true,\n        content,\n        resourceId,\n        reference\n      }\n    } catch (error) {\n      logger.debug(`ResourceManager.loadResource failed for ${resourceId}: ${error.message}`)\n      return {\n        success: false,\n        error: error,  // 返回完整的Error对象，而不是message字符串\n        resourceId\n      }\n    }\n  }\n\n  /**\n   * 解析协议引用并返回相关信息\n   */\n  async resolveProtocolReference(reference) {\n    try {\n      const parsed = this.protocolParser.parse(reference)\n      \n      return {\n        success: true,\n        protocol: parsed.protocol,\n        path: parsed.path,\n        queryParams: parsed.queryParams,\n        reference\n      }\n    } catch (error) {\n      return {\n        success: false,\n        error: error.message,\n        reference\n      }\n    }\n  }\n\n  /**\n   * 获取所有可用的协议列表\n   */\n  getAvailableProtocols() {\n    return Array.from(this.protocols.keys())\n  }\n\n  /**\n   * 检查是否支持指定协议\n   */\n  supportsProtocol(protocol) {\n    return this.protocols.has(protocol)\n  }\n\n  /**\n   * 设置初始化状态\n   */\n  set initialized(value) {\n    this._initialized = value\n  }\n\n  /**\n   * 获取初始化状态\n   */\n  get initialized() {\n    return this._initialized || false\n  }\n\n  /**\n   * 解析资源URL（向后兼容接口）\n   * 返回格式：{success: boolean, content?: string, error?: Error}\n   */\n  async resolve(resourceUrl) {\n    return await this.loadResource(resourceUrl)\n  }\n\n  /**\n   * 获取注册表统计信息\n   */\n  getStats() {\n    return {\n      totalResources: this.registryData.size,\n      protocols: this.getAvailableProtocols(),\n      initialized: this.initialized\n    }\n  }\n\n  /**\n   * 刷新资源（重新发现并注册）\n   */\n  async refreshResources() {\n    try {\n      // 1. 标记为未初始化\n      this.initialized = false\n      \n      // 2. 清空注册表\n      this.registryData.clear()\n      \n      // 3. 清除发现器缓存\n      if (this.discoveryManager && typeof this.discoveryManager.clearCache === 'function') {\n        this.discoveryManager.clearCache()\n      }\n      \n      // 4. 重新初始化\n      await this.initializeWithNewArchitecture()\n      \n    } catch (error) {\n      logger.warn(`ResourceManager resource refresh failed: ${error.message}`)\n      // 失败时保持注册表为空状态，下次调用时重试\n    }\n  }\n}\n\nmodule.exports = ResourceManager","/**\n * PromptX Resource Module\n * 基于DPML资源协议的统一资源管理模块\n *\n * 提供完整的资源协议解析、注册表管理、资源加载功能\n */\n\n// 核心管理器\nconst ResourceManager = require('./resourceManager')\n\n// 核心组件\nconst ResourceProtocolParser = require('./resourceProtocolParser')\n\n// 数据类型\nconst {\n  LoadingSemantics,\n  ParsedReference,\n  QueryParams,\n  NestedReference,\n  ResourceContent,\n  LazyResource,\n  ProcessedResult,\n  ResourceResult,\n  ProtocolInfo\n} = require('./types')\n\n// 全局单例 ResourceManager 实例\nlet globalResourceManager = null\n\n/**\n * 获取全局单例 ResourceManager 实例\n * 确保整个应用程序使用同一个 ResourceManager 实例\n */\nfunction getGlobalResourceManager() {\n  if (!globalResourceManager) {\n    globalResourceManager = new ResourceManager()\n  }\n  return globalResourceManager\n}\n\n/**\n * 重置全局 ResourceManager 实例\n * 主要用于测试或需要完全重新初始化的场景\n */\nfunction resetGlobalResourceManager() {\n  globalResourceManager = null\n}\n\n// 导出主接口\nmodule.exports = {\n  // 主管理器类\n  ResourceManager,\n\n  // 全局单例实例\n  getGlobalResourceManager,\n  resetGlobalResourceManager,\n\n  // 核心组件\n  ResourceProtocolParser,\n\n  // 数据类型\n  LoadingSemantics,\n  ParsedReference,\n  QueryParams,\n  NestedReference,\n  ResourceContent,\n  LazyResource,\n  ProcessedResult,\n  ResourceResult,\n  ProtocolInfo,\n\n  // 便捷方法 - 创建默认实例（保持向后兼容）\n  createManager: (options) => new ResourceManager(options),\n\n  // 便捷方法 - 快速解析\n  parse: (resourceRef) => {\n    const parser = new ResourceProtocolParser()\n    return parser.parse(resourceRef)\n  },\n\n  // 便捷方法 - 快速验证\n  validate: (resourceRef) => {\n    try {\n      const parser = new ResourceProtocolParser()\n      parser.parse(resourceRef)\n      return true\n    } catch (error) {\n      return false\n    }\n  }\n}\n"],"mappings":"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","names":["exports","module","exports","module","exports","module","workspaceFromProject","exports","module","exports","module","exports","module","exports","module","exports","module","exports","module","exports","module","exports","module","exports","module","exports","module","exports","module","exports","module","exports","module","exports","module","exports","module","fullPath","exports","module","exports","module","exports","module","exports","module","exports","module","exports","module","exports","module","exports","module","exports","module","exports","module","content","exports","module"]}