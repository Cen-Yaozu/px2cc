"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));

// ../../node_modules/.pnpm/tsup@8.5.0_jiti@2.5.1_postcss@8.5.6_tsx@4.20.5_typescript@5.9.2_yaml@2.8.1/node_modules/tsup/assets/cjs_shims.js
var init_cjs_shims = __esm({
  "../../node_modules/.pnpm/tsup@8.5.0_jiti@2.5.1_postcss@8.5.6_tsx@4.20.5_typescript@5.9.2_yaml@2.8.1/node_modules/tsup/assets/cjs_shims.js"() {
    "use strict";
  }
});

// src/toolx/SandboxIsolationManager.js
var require_SandboxIsolationManager = __commonJS({
  "src/toolx/SandboxIsolationManager.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var path = require("path");
    var Module = require("module");
    var logger = require("@promptx/logger");
    var SandboxIsolationManager = class {
      constructor(workingPath, options = {}) {
        this.workingPath = workingPath;
        this.toolboxPath = options.toolboxPath || workingPath;
        this.sandboxPath = workingPath;
        this.options = {
          enableDependencyLoading: true,
          enableBuiltinModules: true,
          enableFileSystemAccess: false,
          ...options
        };
        this.isolatedContext = null;
      }
      /**
       * åˆ›å»ºå®Œå…¨éš”ç¦»çš„æ²™ç®±ç¯å¢ƒ
       * @returns {Object} éš”ç¦»çš„æ²™ç®±ä¸Šä¸‹æ–‡
       */
      createIsolatedContext() {
        if (this.isolatedContext) {
          return this.isolatedContext;
        }
        this.isolatedContext = {
          // 1. æ¨¡å—ç³»ç»Ÿéš”ç¦» - æ ¸å¿ƒåŠŸèƒ½
          require: this.createIsolatedRequire(),
          module: { exports: {} },
          exports: {},
          // 2. è¿›ç¨‹ç¯å¢ƒéš”ç¦»
          process: this.createIsolatedProcess(),
          // 3. å…¨å±€å¯¹è±¡éš”ç¦»
          ...this.createIsolatedGlobals(),
          // 4. è·¯å¾„ç›¸å…³éš”ç¦»
          __dirname: this.workingPath,
          __filename: path.join(this.workingPath, "sandbox.js"),
          // 5. æ³¨å…¥å—é™çš„ fsï¼ˆç›´æ¥å¯ç”¨ï¼‰
          fs: this.createRestrictedFS(),
          // 6. é˜»æ­¢åŠ¨æ€ä»£ç æ‰§è¡Œ
          eval: () => {
            throw new Error("[SandboxIsolation] eval is not allowed in sandbox");
          },
          Function: void 0
        };
        return this.isolatedContext;
      }
      /**
       * åˆ›å»ºéš”ç¦»çš„requireå‡½æ•° - è§£å†³æ ¸å¿ƒä¾èµ–åŠ è½½é—®é¢˜
       * @returns {Function} éš”ç¦»çš„requireå‡½æ•°
       */
      createIsolatedRequire() {
        const contextFile = path.join(this.toolboxPath, "package.json");
        let sandboxRequire;
        try {
          sandboxRequire = Module.createRequire(contextFile);
        } catch (error) {
          const virtualContextFile = path.join(this.toolboxPath, "virtual-context.js");
          sandboxRequire = Module.createRequire(virtualContextFile);
        }
        return (moduleName) => {
          if (moduleName === "fs" || moduleName === "fs/promises") {
            return this.createRestrictedFS();
          }
          if (moduleName === "child_process") {
            throw new Error("[SandboxIsolation] child_process is not allowed in sandbox");
          }
          if (moduleName === "path") {
            return this.createRestrictedPath();
          }
          try {
            return sandboxRequire(moduleName);
          } catch (error) {
            return this.handleRequireFallback(moduleName, error);
          }
        };
      }
      /**
       * å¤„ç†requireå¤±è´¥çš„æ™ºèƒ½fallback
       * @param {string} moduleName - æ¨¡å—å
       * @param {Error} error - åŸå§‹é”™è¯¯
       * @returns {*} æ¨¡å—å¯¹è±¡æˆ–æŠ›å‡ºé”™è¯¯
       */
      handleRequireFallback(moduleName, error) {
        if (this.options.enableBuiltinModules && this.isBuiltinModule(moduleName)) {
          try {
            return require(moduleName);
          } catch (builtinError) {
          }
        }
        if (this.options.analysisMode && error.code === "MODULE_NOT_FOUND") {
          logger.debug(`[SandboxIsolation] Analysis mode: mocking module ${moduleName}`);
          return this.createMockModule();
        }
        throw error;
      }
      /**
       * æ£€æŸ¥æ˜¯å¦ä¸ºNode.jså†…ç½®æ¨¡å—
       * @param {string} moduleName - æ¨¡å—å
       * @returns {boolean} æ˜¯å¦ä¸ºå†…ç½®æ¨¡å—
       */
      isBuiltinModule(moduleName) {
        const builtinModules = [
          "path",
          "fs",
          "url",
          "crypto",
          "util",
          "os",
          "events",
          "stream",
          "http",
          "https",
          "querystring",
          "zlib",
          "buffer",
          "child_process"
        ];
        return builtinModules.includes(moduleName) || moduleName.startsWith("node:");
      }
      /**
       * åˆ›å»ºmockæ¨¡å—å¯¹è±¡
       * @returns {Object} mockå¯¹è±¡
       */
      createMockModule() {
        return new Proxy({}, {
          get: () => () => ({}),
          // æ‰€æœ‰å±æ€§å’Œæ–¹æ³•éƒ½è¿”å›ç©ºå‡½æ•°/å¯¹è±¡
          apply: () => ({}),
          // å¦‚æœè¢«å½“ä½œå‡½æ•°è°ƒç”¨
          construct: () => ({})
          // å¦‚æœè¢«å½“ä½œæ„é€ å‡½æ•°
        });
      }
      /**
       * åˆ›å»ºå—é™çš„æ–‡ä»¶ç³»ç»Ÿ
       * å®ç°å®Œå…¨é€æ˜çš„æ‹¦æˆªï¼Œåœ¨VMå±‚é¢æ§åˆ¶æ–‡ä»¶è®¿é—®è¾¹ç•Œ
       * @returns {Object} å—é™çš„fså¯¹è±¡
       */
      createRestrictedFS() {
        const realFs = require("fs");
        const boundary = path.resolve(this.workingPath);
        logger.info(`[SandboxFS] Creating restricted FS with boundary: ${boundary}`);
        const resolveSafePath = (inputPath) => {
          if (!inputPath) {
            throw new Error("[SandboxFS] Path is required");
          }
          let resolved;
          if (path.isAbsolute(inputPath)) {
            resolved = path.resolve(inputPath);
          } else {
            resolved = path.resolve(boundary, inputPath);
          }
          resolved = path.normalize(resolved);
          if (!resolved.startsWith(boundary)) {
            logger.error(`[SandboxFS] \u6587\u4EF6\u8BBF\u95EE\u8D8A\u6743\u5C1D\u8BD5\uFF1A
          \u8F93\u5165\u8DEF\u5F84: ${inputPath}
          \u89E3\u6790\u7ED3\u679C: ${resolved}
          \u5141\u8BB8\u8FB9\u754C: ${boundary}
          \u8C03\u7528\u6808: ${new Error().stack}
        `);
            throw new Error(
              `[SandboxFS] \u6587\u4EF6\u8BBF\u95EE\u88AB\u62D2\u7EDD\uFF1A\u8DEF\u5F84 "${inputPath}" \u8D85\u51FA\u5DE5\u4F5C\u76EE\u5F55\u8FB9\u754C ${boundary}`
            );
          }
          return resolved;
        };
        const handler = {
          get(target, prop) {
            const original = target[prop];
            if (typeof original !== "function") {
              if (prop === "promises") {
                return new Proxy(realFs.promises, {
                  get(promiseTarget, promiseProp) {
                    const promiseOriginal = promiseTarget[promiseProp];
                    if (typeof promiseOriginal !== "function") {
                      return promiseOriginal;
                    }
                    return async function(...args) {
                      if (args.length > 0 && typeof args[0] === "string") {
                        args[0] = resolveSafePath(args[0]);
                      }
                      if ((promiseProp === "rename" || promiseProp === "copyFile") && args.length > 1) {
                        args[1] = resolveSafePath(args[1]);
                      }
                      return await promiseOriginal.apply(promiseTarget, args);
                    };
                  }
                });
              }
              return original;
            }
            return function(...args) {
              if (args.length > 0 && typeof args[0] === "string") {
                args[0] = resolveSafePath(args[0]);
              }
              if ((prop === "renameSync" || prop === "copyFileSync") && args.length > 1) {
                args[1] = resolveSafePath(args[1]);
              }
              return original.apply(target, args);
            };
          }
        };
        return new Proxy(realFs, handler);
      }
      /**
       * åˆ›å»ºå—é™çš„ path æ¨¡å—
       * é˜²æ­¢ä½¿ç”¨ path.resolve ç»•è¿‡é™åˆ¶
       * @returns {Object} å—é™çš„pathå¯¹è±¡
       */
      createRestrictedPath() {
        const realPath = require("path");
        const boundary = path.resolve(this.workingPath);
        return new Proxy(realPath, {
          get(target, prop) {
            if (prop === "resolve") {
              return (...args) => {
                const resolved = target.resolve(...args);
                if (!resolved.startsWith(boundary)) {
                  logger.warn(`[SandboxPath] path.resolve \u5C1D\u8BD5\u8D8A\u6743: ${resolved}`);
                }
                return resolved;
              };
            }
            return target[prop];
          }
        });
      }
      /**
       * åˆ›å»ºéš”ç¦»çš„processå¯¹è±¡
       * @returns {Object} éš”ç¦»çš„processå¯¹è±¡
       */
      createIsolatedProcess() {
        return {
          // ç¯å¢ƒå˜é‡ï¼ˆæµ…æ‹·è´ï¼Œé¿å…æ±¡æŸ“ï¼‰
          env: { ...process.env },
          // å·¥ä½œç›®å½•è¿”å› workingPathï¼ˆ~/.promptxï¼‰
          cwd: () => this.workingPath,
          // å®‰å…¨çš„åªè¯»å±æ€§
          version: process.version,
          platform: process.platform,
          arch: process.arch,
          pid: process.pid,
          // æ—¶é—´ç›¸å…³
          hrtime: process.hrtime,
          uptime: process.uptime,
          // ç¦ç”¨å±é™©æ–¹æ³•
          exit: () => {
            throw new Error("[SandboxIsolation] process.exit() is not allowed in sandbox");
          },
          abort: () => {
            throw new Error("[SandboxIsolation] process.abort() is not allowed in sandbox");
          },
          // é˜»æ­¢åº•å±‚è®¿é—®
          binding: () => {
            throw new Error("[SandboxIsolation] process.binding() is not allowed in sandbox");
          },
          dlopen: () => {
            throw new Error("[SandboxIsolation] Native modules are not allowed in sandbox");
          }
        };
      }
      /**
       * åˆ›å»ºéš”ç¦»çš„å…¨å±€å¯¹è±¡
       * @returns {Object} å®‰å…¨çš„å…¨å±€å¯¹è±¡é›†åˆ
       */
      createIsolatedGlobals() {
        return {
          // åŸºç¡€ç±»å‹
          Object,
          Array,
          String,
          Number,
          Boolean,
          Date,
          RegExp,
          Error,
          // JSONå¤„ç†
          JSON,
          // æ•°å­¦å¯¹è±¡
          Math,
          // URLå¤„ç†
          URL,
          URLSearchParams,
          // ç¼“å†²åŒº
          Buffer,
          // å®šæ—¶å™¨
          setTimeout,
          clearTimeout,
          setInterval,
          clearInterval,
          setImmediate,
          clearImmediate,
          // è¾“å‡º
          console,
          // Keep console for sandboxed code
          // Promiseç›¸å…³
          Promise
        };
      }
      /**
       * å¯ç”¨åˆ†ææ¨¡å¼ - ç”¨äºå·¥å…·åˆ†æé˜¶æ®µ
       */
      enableAnalysisMode() {
        this.options.analysisMode = true;
        this.isolatedContext = null;
      }
      /**
       * å¯ç”¨æ‰§è¡Œæ¨¡å¼ - ç”¨äºå·¥å…·æ‰§è¡Œé˜¶æ®µ
       */
      enableExecutionMode() {
        this.options.analysisMode = false;
        this.isolatedContext = null;
      }
      /**
       * æ¸…ç†éš”ç¦»ç®¡ç†å™¨
       */
      cleanup() {
        this.isolatedContext = null;
      }
      /**
       * è·å–éš”ç¦»çŠ¶æ€ä¿¡æ¯
       * @returns {Object} çŠ¶æ€ä¿¡æ¯
       */
      getIsolationStatus() {
        return {
          sandboxPath: this.sandboxPath,
          options: this.options,
          contextCreated: !!this.isolatedContext,
          timestamp: (/* @__PURE__ */ new Date()).toISOString()
        };
      }
    };
    module2.exports = SandboxIsolationManager;
  }
});

// src/toolx/SandboxErrorManager.js
var require_SandboxErrorManager = __commonJS({
  "src/toolx/SandboxErrorManager.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var SandboxErrorManager = class {
      constructor() {
        this.version = "1.0.0";
      }
      /**
       * åˆ†æåŸå§‹é”™è¯¯å¹¶ç”Ÿæˆæ™ºèƒ½é”™è¯¯ä¿¡æ¯
       * @param {Error} originalError - åŸå§‹é”™è¯¯å¯¹è±¡
       * @param {Object} context - é”™è¯¯ä¸Šä¸‹æ–‡ä¿¡æ¯
       * @param {string} context.toolId - å·¥å…·ID
       * @param {Array} context.dependencies - å£°æ˜çš„ä¾èµ–åˆ—è¡¨
       * @param {string} context.sandboxPath - æ²™ç®±è·¯å¾„
       * @param {string} context.phase - æ‰§è¡Œé˜¶æ®µ (analyze|prepare|execute)
       * @returns {Object} å¢å¼ºçš„é”™è¯¯ä¿¡æ¯
       */
      analyzeError(originalError, context = {}) {
        const errorType = this.classifyError(originalError, context);
        const agentInstructions = this.generateAgentInstructions(errorType, originalError, context);
        return {
          // ä¿æŒä¸ToolCommandå…¼å®¹çš„åŸå§‹ä¿¡æ¯
          originalError,
          message: originalError.message,
          // å¢å¼ºçš„æ™ºèƒ½ä¿¡æ¯
          type: errorType,
          agentInstructions,
          context,
          // MCPå‹å¥½çš„æ ¼å¼åŒ–æ¶ˆæ¯
          formattedMessage: this.formatForMCP(errorType, originalError, agentInstructions, context)
        };
      }
      /**
       * é”™è¯¯åˆ†ç±»é€»è¾‘
       * @param {Error} error - é”™è¯¯å¯¹è±¡
       * @param {Object} context - ä¸Šä¸‹æ–‡ä¿¡æ¯
       * @returns {string} é”™è¯¯ç±»å‹
       */
      classifyError(error, context) {
        const message = error.message.toLowerCase();
        if (message.includes("cannot find module")) {
          const missingModule = this.extractModuleName(error.message);
          let isDeclaredDependency = false;
          if (Array.isArray(context.dependencies)) {
            isDeclaredDependency = context.dependencies.some(
              (dep) => dep.split("@")[0] === missingModule
            );
          } else if (typeof context.dependencies === "object" && context.dependencies) {
            isDeclaredDependency = Object.keys(context.dependencies).includes(missingModule);
          }
          if (isDeclaredDependency) {
            return "DEPENDENCY_MISSING";
          } else {
            return "UNDECLARED_DEPENDENCY";
          }
        }
        if (message.includes("pnpm install failed") || message.includes("dependency installation") || message.includes("npm err")) {
          return "DEPENDENCY_INSTALL_FAILED";
        }
        if (message.includes("failed to load tool") || message.includes("tool does not export") || message.includes("invalid tool export format")) {
          return "TOOL_LOADING_ERROR";
        }
        if (message.includes("parameter validation failed") || message.includes("missing required parameter")) {
          return "PARAMETER_VALIDATION_ERROR";
        }
        if (message.includes("sandbox") || message.includes("vm")) {
          return "SANDBOX_ENVIRONMENT_ERROR";
        }
        if (message.includes("timeout") || message.includes("etimedout")) {
          return "NETWORK_TIMEOUT";
        }
        return "UNKNOWN_ERROR";
      }
      /**
       * ä¸ºAgentç”Ÿæˆæ™ºèƒ½æŒ‡ä»¤
       * @param {string} errorType - é”™è¯¯ç±»å‹
       * @param {Error} originalError - åŸå§‹é”™è¯¯
       * @param {Object} context - ä¸Šä¸‹æ–‡
       * @returns {Object} AgentæŒ‡ä»¤å¯¹è±¡
       */
      generateAgentInstructions(errorType, originalError, context) {
        switch (errorType) {
          case "DEPENDENCY_MISSING":
            return {
              action: "AUTO_RETRY_WITH_FORCE_REINSTALL",
              autoRetryable: true,
              command: "\u81EA\u52A8\u91CD\u8BD5\uFF0C\u6DFB\u52A0 forceReinstall: true \u53C2\u6570",
              explanation: "\u4F9D\u8D56\u5DF2\u58F0\u660E\u4F46\u672A\u6B63\u786E\u5B89\u88C5\uFF0C\u901A\u8FC7\u5F3A\u5236\u91CD\u88C5\u53EF\u89E3\u51B3",
              userMessage: `\u68C0\u6D4B\u5230\u4F9D\u8D56 ${this.extractModuleName(originalError.message)} \u5B89\u88C5\u4E0D\u5B8C\u6574\uFF0C\u6B63\u5728\u81EA\u52A8\u91CD\u65B0\u5B89\u88C5...`,
              retryParameters: { forceReinstall: true }
            };
          case "UNDECLARED_DEPENDENCY": {
            const missingModule = this.extractModuleName(originalError.message);
            return {
              action: "REPORT_MISSING_DEPENDENCY",
              autoRetryable: false,
              command: "\u63D0\u793A\u5DE5\u5177\u5F00\u53D1\u8005\u6DFB\u52A0\u4F9D\u8D56\u58F0\u660E",
              explanation: `\u5DE5\u5177\u4EE3\u7801\u4F7F\u7528\u4E86\u672A\u58F0\u660E\u7684\u4F9D\u8D56: ${missingModule}`,
              userMessage: `\u274C \u5DE5\u5177\u7F3A\u5C11\u4F9D\u8D56\u58F0\u660E

\u{1F527} \u9700\u8981\u5728\u5DE5\u5177\u7684 getDependencies() \u65B9\u6CD5\u4E2D\u6DFB\u52A0\uFF1A
   '${missingModule}': 'latest'

\u{1F4DD} \u5B8C\u6574\u793A\u4F8B\uFF08\u65B0\u683C\u5F0F\uFF09\uFF1A
   getDependencies() {
     return {
       ${context.dependencies && typeof context.dependencies === "object" && !Array.isArray(context.dependencies) ? Object.entries(context.dependencies).map(([k, v]) => `'${k}': '${v}'`).join(",\n       ") + "," : "// \u5176\u4ED6\u4F9D\u8D56..."}
       '${missingModule}': 'latest'
     };
   }`,
              developerAction: `\u5728 ${context.toolId}.tool.js \u7684 getDependencies() \u4E2D\u6DFB\u52A0 '${missingModule}': 'latest'`
            };
          }
          case "DEPENDENCY_INSTALL_FAILED":
            return {
              action: "CHECK_NETWORK_AND_RETRY",
              autoRetryable: false,
              command: "\u68C0\u67E5\u7F51\u7EDC\u8FDE\u63A5\uFF0C\u5EFA\u8BAE\u7528\u6237\u7A0D\u540E\u91CD\u8BD5",
              explanation: "\u4F9D\u8D56\u5B89\u88C5\u8FC7\u7A0B\u5931\u8D25\uFF0C\u53EF\u80FD\u662F\u7F51\u7EDC\u95EE\u9898\u6216\u5305\u6E90\u95EE\u9898",
              userMessage: `\u274C \u4F9D\u8D56\u5B89\u88C5\u5931\u8D25

\u{1F310} \u53EF\u80FD\u539F\u56E0\uFF1A
   \u2022 \u7F51\u7EDC\u8FDE\u63A5\u4E0D\u7A33\u5B9A
   \u2022 npm/pnpm \u955C\u50CF\u6E90\u95EE\u9898
   \u2022 \u4F9D\u8D56\u5305\u7248\u672C\u4E0D\u5B58\u5728

\u{1F4A1} \u5EFA\u8BAE\u89E3\u51B3\u65B9\u6848\uFF1A
   1. \u68C0\u67E5\u7F51\u7EDC\u8FDE\u63A5
   2. \u7A0D\u540E\u91CD\u8BD5\uFF08\u4F7F\u7528 forceReinstall: true\uFF09
   3. \u5982\u679C\u6301\u7EED\u5931\u8D25\uFF0C\u8BF7\u8054\u7CFB\u5F00\u53D1\u8005`,
              retryDelay: 5e3
            };
          case "TOOL_LOADING_ERROR":
            return {
              action: "REPORT_TOOL_ERROR",
              autoRetryable: false,
              command: "\u62A5\u544A\u5DE5\u5177\u6587\u4EF6\u95EE\u9898",
              explanation: "\u5DE5\u5177\u4EE3\u7801\u672C\u8EAB\u5B58\u5728\u95EE\u9898\uFF0C\u9700\u8981\u5F00\u53D1\u8005\u4FEE\u590D",
              userMessage: `\u274C \u5DE5\u5177\u52A0\u8F7D\u5931\u8D25

\u{1F527} \u5DE5\u5177\u4EE3\u7801\u95EE\u9898\uFF1A${originalError.message}

\u{1F4A1} \u8FD9\u662F\u5DE5\u5177\u5F00\u53D1\u95EE\u9898\uFF0C\u8BF7\u8054\u7CFB\u5DE5\u5177\u4F5C\u8005\u4FEE\u590D`,
              developerAction: "\u68C0\u67E5\u5DE5\u5177\u7684 module.exports \u548C\u57FA\u672C\u8BED\u6CD5"
            };
          case "NETWORK_TIMEOUT":
            return {
              action: "RETRY_WITH_EXTENDED_TIMEOUT",
              autoRetryable: true,
              command: "\u81EA\u52A8\u91CD\u8BD5\uFF0C\u4F7F\u7528\u66F4\u957F\u7684\u8D85\u65F6\u65F6\u95F4",
              explanation: "\u7F51\u7EDC\u8D85\u65F6\uFF0C\u4F7F\u7528\u66F4\u957F\u8D85\u65F6\u65F6\u95F4\u91CD\u8BD5",
              userMessage: "\u23F0 \u7F51\u7EDC\u8D85\u65F6\uFF0C\u6B63\u5728\u4F7F\u7528\u66F4\u957F\u8D85\u65F6\u65F6\u95F4\u91CD\u8BD5...",
              retryParameters: { timeout: 6e4 }
              // 60ç§’
            };
          default:
            return {
              action: "REPORT_UNKNOWN_ERROR",
              autoRetryable: false,
              command: "\u62A5\u544A\u672A\u77E5\u9519\u8BEF\u7ED9\u7528\u6237",
              explanation: "\u672A\u77E5\u9519\u8BEF\u7C7B\u578B\uFF0C\u9700\u8981\u4EBA\u5DE5\u5206\u6790",
              userMessage: `\u274C \u6267\u884C\u5931\u8D25\uFF1A${originalError.message}

\u{1F916} \u8FD9\u662F\u4E00\u4E2A\u672A\u5206\u7C7B\u7684\u9519\u8BEF\uFF0C\u8BF7\u5C06\u6B64\u4FE1\u606F\u53CD\u9988\u7ED9\u5F00\u53D1\u8005\u4EE5\u6539\u8FDB\u9519\u8BEF\u5904\u7406`,
              debugInfo: {
                stack: originalError.stack,
                context
              }
            };
        }
      }
      /**
       * ä¸ºMCPåè®®æ ¼å¼åŒ–é”™è¯¯æ¶ˆæ¯
       * @param {string} errorType - é”™è¯¯ç±»å‹
       * @param {Error} originalError - åŸå§‹é”™è¯¯
       * @param {Object} agentInstructions - AgentæŒ‡ä»¤
       * @param {Object} context - ä¸Šä¸‹æ–‡
       * @returns {string} MCPå‹å¥½çš„é”™è¯¯æ¶ˆæ¯
       */
      formatForMCP(errorType, originalError, agentInstructions, context) {
        const emoji = this.getErrorEmoji(errorType);
        const timestamp = (/* @__PURE__ */ new Date()).toISOString();
        let message = `${emoji} ToolSandbox\u6267\u884C\u5931\u8D25

\u{1F3F7}\uFE0F \u9519\u8BEF\u7C7B\u578B: ${errorType}
\u23F0 \u65F6\u95F4: ${timestamp}
\u{1F527} \u5DE5\u5177: ${context.toolId || "unknown"}
\u{1F4C1} \u9636\u6BB5: ${context.phase || "unknown"}

\u{1F4CB} \u8BE6\u7EC6\u4FE1\u606F:
${originalError.message}

\u{1F916} AI\u5904\u7406\u5EFA\u8BAE:
${agentInstructions.userMessage || agentInstructions.explanation}`;
        if (agentInstructions.autoRetryable) {
          message += `

\u{1F504} \u81EA\u52A8\u6062\u590D: ${agentInstructions.action}
\u26A1 \u64CD\u4F5C: ${agentInstructions.command}`;
        }
        return message;
      }
      /**
       * ä»é”™è¯¯æ¶ˆæ¯ä¸­æå–æ¨¡å—å
       * @param {string} errorMessage - é”™è¯¯æ¶ˆæ¯
       * @returns {string} æ¨¡å—å
       */
      extractModuleName(errorMessage) {
        const match = errorMessage.match(/Cannot (?:find|resolve) module ['\"]([^'\"]+)['\"]/);
        return match ? match[1] : "unknown";
      }
      /**
       * æ ¹æ®é”™è¯¯ç±»å‹è·å–å¯¹åº”emoji
       * @param {string} errorType - é”™è¯¯ç±»å‹
       * @returns {string} emoji
       */
      getErrorEmoji(errorType) {
        const emojiMap = {
          "DEPENDENCY_MISSING": "\u{1F4E6}",
          "UNDECLARED_DEPENDENCY": "\u{1F50D}",
          "DEPENDENCY_INSTALL_FAILED": "\u{1F310}",
          "TOOL_LOADING_ERROR": "\u{1F527}",
          "PARAMETER_VALIDATION_ERROR": "\u{1F4DD}",
          "SANDBOX_ENVIRONMENT_ERROR": "\u{1F3D7}\uFE0F",
          "NETWORK_TIMEOUT": "\u23F0",
          "UNKNOWN_ERROR": "\u2753"
        };
        return emojiMap[errorType] || "\u274C";
      }
      /**
       * æ£€æŸ¥é”™è¯¯æ˜¯å¦å¯ä»¥è‡ªåŠ¨æ¢å¤
       * @param {Object} intelligentError - æ™ºèƒ½é”™è¯¯å¯¹è±¡
       * @returns {boolean} æ˜¯å¦å¯è‡ªåŠ¨æ¢å¤
       */
      isAutoRecoverable(intelligentError) {
        return intelligentError.agentInstructions.autoRetryable === true;
      }
      /**
       * è·å–è‡ªåŠ¨æ¢å¤çš„é‡è¯•å‚æ•°
       * @param {Object} intelligentError - æ™ºèƒ½é”™è¯¯å¯¹è±¡
       * @returns {Object|null} é‡è¯•å‚æ•°
       */
      getRetryParameters(intelligentError) {
        return intelligentError.agentInstructions.retryParameters || null;
      }
    };
    module2.exports = SandboxErrorManager;
  }
});

// src/toolx/ToolDirectoryManager.js
var require_ToolDirectoryManager = __commonJS({
  "src/toolx/ToolDirectoryManager.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var path = require("path");
    var fs = require("fs").promises;
    var logger = require("@promptx/logger");
    var ToolDirectoryManager = class {
      constructor(toolId, resourceManager) {
        this.toolId = toolId;
        this.resourceManager = resourceManager;
        this.directories = {
          working: "@user://.promptx",
          // å·¥ä½œç›®å½•
          toolbox: `@user://.promptx/toolbox/${toolId}`,
          // å·¥å…·éš”ç¦»ç›®å½•
          dependencies: `@user://.promptx/toolbox/${toolId}/node_modules`,
          // ä¾èµ–ç›®å½•
          cache: `@user://.promptx/cache/${toolId}`,
          // ç¼“å­˜ç›®å½•
          temp: `@user://.promptx/temp/${toolId}`
          // ä¸´æ—¶æ–‡ä»¶ç›®å½•
        };
        this.resolvedPaths = {};
      }
      /**
       * åˆå§‹åŒ–æ‰€æœ‰è·¯å¾„ï¼ˆé€šè¿‡åè®®è§£æï¼‰
       */
      async initialize() {
        for (const [key, protocolPath] of Object.entries(this.directories)) {
          this.resolvedPaths[key] = await this.resolveProtocolPath(protocolPath);
        }
        logger.debug("[ToolDirectoryManager] Initialized paths:", this.resolvedPaths);
      }
      /**
       * é€šè¿‡åè®®è§£æè·¯å¾„
       * @param {string} protocolPath - åè®®è·¯å¾„ï¼Œå¦‚ @user://.promptx
       * @returns {Promise<string>} è§£æåçš„ç»å¯¹è·¯å¾„
       */
      async resolveProtocolPath(protocolPath) {
        const result = await this.resourceManager.resolveProtocolReference(protocolPath);
        if (!result.success) {
          throw new Error(`Failed to resolve protocol path ${protocolPath}: ${result.error}`);
        }
        const protocol = this.resourceManager.protocols.get(result.protocol);
        if (!protocol) {
          throw new Error(`Protocol ${result.protocol} not supported`);
        }
        if (typeof protocol.resolvePath === "function") {
          return await protocol.resolvePath(result.path, result.queryParams || /* @__PURE__ */ new Map());
        } else {
          throw new Error(`Protocol ${result.protocol} does not support path resolution`);
        }
      }
      /**
       * è·å–å·¥ä½œç›®å½•è·¯å¾„
       * @returns {string} å·¥ä½œç›®å½•è·¯å¾„
       */
      getWorkingPath() {
        return this.resolvedPaths.working;
      }
      /**
       * è·å–å·¥å…·ç®±ç›®å½•è·¯å¾„
       * @returns {string} å·¥å…·ç®±ç›®å½•è·¯å¾„
       */
      getToolboxPath() {
        return this.resolvedPaths.toolbox;
      }
      /**
       * è·å–ä¾èµ–ç›®å½•è·¯å¾„
       * @returns {string} node_modules è·¯å¾„
       */
      getDependenciesPath() {
        return this.resolvedPaths.dependencies;
      }
      /**
       * è·å–ç¼“å­˜ç›®å½•è·¯å¾„
       * @returns {string} ç¼“å­˜ç›®å½•è·¯å¾„
       */
      getCachePath() {
        return this.resolvedPaths.cache;
      }
      /**
       * è·å–ä¸´æ—¶ç›®å½•è·¯å¾„
       * @returns {string} ä¸´æ—¶ç›®å½•è·¯å¾„
       */
      getTempPath() {
        return this.resolvedPaths.temp;
      }
      /**
       * è·å– package.json è·¯å¾„
       * @returns {string} package.json è·¯å¾„
       */
      getPackageJsonPath() {
        return path.join(this.resolvedPaths.toolbox, "package.json");
      }
      /**
       * ç¡®ä¿å¿…è¦çš„ç›®å½•å­˜åœ¨
       */
      async ensureDirectories() {
        await this.ensureDirectory(this.resolvedPaths.working);
        await this.ensureDirectory(this.resolvedPaths.toolbox);
      }
      /**
       * ç¡®ä¿å•ä¸ªç›®å½•å­˜åœ¨
       * @param {string} dirPath - ç›®å½•è·¯å¾„
       */
      async ensureDirectory(dirPath) {
        try {
          await fs.access(dirPath);
        } catch (error) {
          if (error.code === "ENOENT") {
            await fs.mkdir(dirPath, { recursive: true });
            logger.debug(`[ToolDirectoryManager] Created directory: ${dirPath}`);
          } else {
            throw error;
          }
        }
      }
      /**
       * æ£€æŸ¥ç›®å½•æ˜¯å¦å­˜åœ¨
       * @param {string} dirPath - ç›®å½•è·¯å¾„
       * @returns {Promise<boolean>} æ˜¯å¦å­˜åœ¨
       */
      async directoryExists(dirPath) {
        try {
          await fs.access(dirPath);
          return true;
        } catch {
          return false;
        }
      }
      /**
       * æ£€æŸ¥å·¥å…·ç®±ç›®å½•æ˜¯å¦å­˜åœ¨
       * @returns {Promise<boolean>}
       */
      async toolboxExists() {
        return await this.directoryExists(this.resolvedPaths.toolbox);
      }
      /**
       * æ¸…ç†ä¸´æ—¶æ–‡ä»¶
       */
      async cleanupTemp() {
        if (this.resolvedPaths.temp && await this.directoryExists(this.resolvedPaths.temp)) {
          const { rmdir } = require("fs").promises;
          await rmdir(this.resolvedPaths.temp, { recursive: true });
          logger.debug(`[ToolDirectoryManager] Cleaned up temp directory: ${this.resolvedPaths.temp}`);
        }
      }
      /**
       * åˆ é™¤å·¥å…·ç®±ç›®å½•ï¼ˆç”¨äºå¼ºåˆ¶é‡å»ºï¼‰
       */
      async deleteToolbox() {
        if (this.resolvedPaths.toolbox && await this.toolboxExists()) {
          const { rmdir } = require("fs").promises;
          await rmdir(this.resolvedPaths.toolbox, { recursive: true });
          logger.debug(`[ToolDirectoryManager] Deleted toolbox directory: ${this.resolvedPaths.toolbox}`);
        }
      }
      /**
       * è·å–åè®®è·¯å¾„ï¼ˆç”¨äºæ—¥å¿—æˆ–è°ƒè¯•ï¼‰
       * @param {string} key - ç›®å½•é”®å
       * @returns {string} åè®®è·¯å¾„
       */
      getProtocolPath(key) {
        return this.directories[key];
      }
      /**
       * æ”¯æŒè‡ªå®šä¹‰åè®®è·¯å¾„ï¼ˆæœªæ¥æ‰©å±•ï¼‰
       * æ¯”å¦‚æ”¯æŒ @project:// æˆ– @s3:// ç­‰
       */
      async setCustomDirectory(key, protocolPath) {
        this.directories[key] = protocolPath;
        this.resolvedPaths[key] = await this.resolveProtocolPath(protocolPath);
      }
    };
    module2.exports = ToolDirectoryManager;
  }
});

// src/toolx/ESModuleRequireSupport.js
var require_ESModuleRequireSupport = __commonJS({
  "src/toolx/ESModuleRequireSupport.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var path = require("path");
    var fs = require("fs").promises;
    var logger = require("@promptx/logger");
    var ESModuleRequireSupport = class {
      constructor(toolboxPath) {
        this.toolboxPath = toolboxPath;
        this.moduleTypeCache = /* @__PURE__ */ new Map();
      }
      /**
       * åˆ›å»ºç»Ÿä¸€çš„ require å‡½æ•°
       * æ‰€æœ‰æ¨¡å—éƒ½è¿”å› Promiseï¼Œå®ç°ç»Ÿä¸€çš„ä½¿ç”¨ä½“éªŒ
       * 
       * @param {Function} sandboxRequire - æ²™ç®±ç¯å¢ƒçš„ require å‡½æ•°
       * @returns {Function} å¢å¼ºçš„ require å‡½æ•°
       */
      createUnifiedRequire(sandboxRequire) {
        return async (moduleName) => {
          try {
            const moduleType = await this.detectModuleType(moduleName);
            logger.debug(`[ESModuleSupport] Loading ${moduleName} as ${moduleType}`);
            if (moduleType === "esm") {
              return await this.loadESModule(moduleName);
            } else {
              try {
                const module3 = sandboxRequire(moduleName);
                return Promise.resolve(module3);
              } catch (error) {
                if (error.code === "ERR_REQUIRE_ESM") {
                  logger.debug(`[ESModuleSupport] Fallback to ES Module for ${moduleName}`);
                  return await this.loadESModule(moduleName);
                }
                throw error;
              }
            }
          } catch (error) {
            logger.error(`[ESModuleSupport] Failed to load module ${moduleName}: ${error.message}`);
            throw new Error(`Cannot load module '${moduleName}': ${error.message}`);
          }
        };
      }
      /**
       * æ£€æµ‹æ¨¡å—ç±»å‹
       * @param {string} moduleName - æ¨¡å—å
       * @returns {Promise<string>} 'esm' | 'commonjs' | 'unknown'
       */
      async detectModuleType(moduleName) {
        if (this.moduleTypeCache.has(moduleName)) {
          return this.moduleTypeCache.get(moduleName);
        }
        try {
          const packagePath = this.resolvePackagePath(moduleName);
          const packageJsonPath = path.join(packagePath, "package.json");
          const packageJsonContent = await fs.readFile(packageJsonPath, "utf8");
          const packageJson = JSON.parse(packageJsonContent);
          let moduleType = "commonjs";
          if (packageJson.type === "module") {
            moduleType = "esm";
          } else if (packageJson.exports && typeof packageJson.exports === "object") {
            if (packageJson.exports.import || packageJson.exports["."] && packageJson.exports["."].import) {
              moduleType = "esm";
            }
          } else if (packageJson.module) {
            if (!packageJson.main) {
              moduleType = "esm";
            }
          }
          this.moduleTypeCache.set(moduleName, moduleType);
          logger.debug(`[ESModuleSupport] Module ${moduleName} detected as ${moduleType}`);
          return moduleType;
        } catch (error) {
          logger.debug(`[ESModuleSupport] Cannot detect module type for ${moduleName}: ${error.message}`);
          this.moduleTypeCache.set(moduleName, "unknown");
          return "unknown";
        }
      }
      /**
       * è§£æåŒ…è·¯å¾„ï¼ˆæ”¯æŒ scoped åŒ…ï¼‰
       * @param {string} moduleName - æ¨¡å—å
       * @returns {string} åŒ…çš„å®é™…è·¯å¾„
       */
      resolvePackagePath(moduleName) {
        const parts = moduleName.split("/");
        if (moduleName.startsWith("@") && parts.length >= 2) {
          const scopedPackageName = parts.slice(0, 2).join("/");
          return path.join(this.toolboxPath, "node_modules", scopedPackageName);
        } else {
          return path.join(this.toolboxPath, "node_modules", parts[0]);
        }
      }
      /**
       * åŠ è½½ ES Module
       * @param {string} moduleName - æ¨¡å—å
       * @returns {Promise<Object>} æ¨¡å—å¯¹è±¡
       */
      async loadESModule(moduleName) {
        try {
          const modulePath = this.resolveModuleEntryPoint(moduleName);
          logger.debug(`[ESModuleSupport] Importing ES Module from ${modulePath}`);
          const module3 = await import(modulePath);
          return module3.default || module3;
        } catch (error) {
          logger.error(`[ESModuleSupport] Failed to load ES Module ${moduleName}: ${error.message}`);
          throw new Error(`Failed to import ES Module '${moduleName}': ${error.message}`);
        }
      }
      /**
       * è§£ææ¨¡å—å…¥å£ç‚¹
       * @param {string} moduleName - æ¨¡å—å
       * @returns {string} æ¨¡å—å…¥å£æ–‡ä»¶çš„å®Œæ•´è·¯å¾„
       */
      resolveModuleEntryPoint(moduleName) {
        try {
          const packagePath = this.resolvePackagePath(moduleName);
          const packageJsonPath = path.join(packagePath, "package.json");
          const packageJson = require(packageJsonPath);
          let entryPoint = "index.js";
          if (packageJson.exports) {
            if (typeof packageJson.exports === "string") {
              entryPoint = packageJson.exports;
            } else if (packageJson.exports["."]) {
              if (typeof packageJson.exports["."] === "string") {
                entryPoint = packageJson.exports["."];
              } else if (packageJson.exports["."].import) {
                entryPoint = packageJson.exports["."].import;
              } else if (packageJson.exports["."].default) {
                entryPoint = packageJson.exports["."].default;
              }
            }
          } else if (packageJson.module) {
            entryPoint = packageJson.module;
          } else if (packageJson.main) {
            entryPoint = packageJson.main;
          }
          const fullPath = path.join(packagePath, entryPoint);
          const parts = moduleName.split("/");
          if (moduleName.startsWith("@") && parts.length > 2) {
            const subpath = parts.slice(2).join("/");
            return path.join(packagePath, subpath);
          } else if (!moduleName.startsWith("@") && parts.length > 1) {
            const subpath = parts.slice(1).join("/");
            return path.join(packagePath, subpath);
          }
          return fullPath;
        } catch (error) {
          return this.resolvePackagePath(moduleName);
        }
      }
      /**
       * æ‰¹é‡æ£€æµ‹ä¾èµ–çš„æ¨¡å—ç±»å‹
       * @param {Object} dependencies - ä¾èµ–å¯¹è±¡ { packageName: version }
       * @returns {Promise<Object>} { commonjs: [], esmodule: [], unknown: [] }
       */
      async detectDependenciesTypes(dependencies) {
        const result = {
          commonjs: [],
          esmodule: [],
          unknown: []
        };
        for (const [packageName, version] of Object.entries(dependencies)) {
          const moduleType = await this.detectModuleType(packageName);
          if (moduleType === "esm") {
            result.esmodule.push({ name: packageName, version });
          } else if (moduleType === "commonjs") {
            result.commonjs.push({ name: packageName, version });
          } else {
            result.unknown.push({ name: packageName, version });
          }
        }
        logger.debug(`[ESModuleSupport] Dependencies analysis:`, {
          commonjs: result.commonjs.length,
          esmodule: result.esmodule.length,
          unknown: result.unknown.length
        });
        return result;
      }
      /**
       * æ£€æŸ¥æ˜¯å¦æœ‰ ES Module ä¾èµ–
       * @param {Object} dependencies - ä¾èµ–å¯¹è±¡
       * @returns {Promise<boolean>}
       */
      async hasESModuleDependencies(dependencies) {
        const types = await this.detectDependenciesTypes(dependencies);
        return types.esmodule.length > 0;
      }
      /**
       * æ¸…ç†ç¼“å­˜
       */
      clearCache() {
        this.moduleTypeCache.clear();
      }
      /**
       * è·å–ç¼“å­˜ç»Ÿè®¡
       */
      getCacheStats() {
        return {
          size: this.moduleTypeCache.size,
          modules: Array.from(this.moduleTypeCache.entries())
        };
      }
    };
    module2.exports = ESModuleRequireSupport;
  }
});

// src/utils/ServerEnvironment.js
var require_ServerEnvironment = __commonJS({
  "src/utils/ServerEnvironment.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var ServerEnvironment = class {
      constructor() {
        this.transport = null;
        this.host = null;
        this.port = null;
        this.processId = null;
        this.initialized = false;
      }
      /**
       * åˆå§‹åŒ–æœåŠ¡ç¯å¢ƒï¼ˆå„å¯åŠ¨æ¸ é“è°ƒç”¨ä¸€æ¬¡ï¼‰
       * @param {Object} config - é…ç½®å¯¹è±¡
       * @param {string} config.transport - ä¼ è¾“åè®®
       * @param {string} config.host - ä¸»æœºåœ°å€ï¼ˆå¯é€‰ï¼‰
       * @param {number} config.port - ç«¯å£å·ï¼ˆå¯é€‰ï¼‰
       */
      initialize(config) {
        this.transport = config.transport;
        this.host = config.host || null;
        this.port = config.port || null;
        this.processId = process.pid;
        this.initialized = true;
      }
      /**
       * è·å–MCP IDï¼ˆåŸºäºprocessIdç”Ÿæˆï¼‰
       * @returns {string} MCPè¿›ç¨‹ID
       */
      getMcpId() {
        if (!this.initialized) {
          throw new Error("ServerEnvironment not initialized");
        }
        return `mcp-${this.processId}`;
      }
      /**
       * è·å–ä¼ è¾“åè®®
       * @returns {string} transportç±»å‹
       */
      getTransport() {
        if (!this.initialized) {
          throw new Error("ServerEnvironment not initialized");
        }
        return this.transport;
      }
      /**
       * è·å–æœåŠ¡å™¨åœ°å€ä¿¡æ¯ï¼ˆä»…HTTP/SSEæ¨¡å¼ï¼‰
       * @returns {Object|null} {host, port} æˆ– null
       */
      getServerAddress() {
        if (!this.initialized) {
          throw new Error("ServerEnvironment not initialized");
        }
        if (this.transport === "stdio") {
          return null;
        }
        return {
          host: this.host,
          port: this.port
        };
      }
      /**
       * æ£€æŸ¥æ˜¯å¦å·²åˆå§‹åŒ–
       * @returns {boolean}
       */
      isInitialized() {
        return this.initialized;
      }
    };
    var globalServerEnvironment = null;
    function getGlobalServerEnvironment() {
      if (!globalServerEnvironment) {
        globalServerEnvironment = new ServerEnvironment();
      }
      return globalServerEnvironment;
    }
    module2.exports = ServerEnvironment;
    module2.exports.getGlobalServerEnvironment = getGlobalServerEnvironment;
  }
});

// src/utils/ProjectManager.js
var require_ProjectManager = __commonJS({
  "src/utils/ProjectManager.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var fs = require("fs-extra");
    var path = require("path");
    var os = require("os");
    var crypto = require("crypto");
    var { getGlobalServerEnvironment } = require_ServerEnvironment();
    var logger = require("@promptx/logger");
    var ProjectManager = class {
      constructor() {
        this.promptxHomeDir = path.join(os.homedir(), ".promptx");
        this.projectsDir = path.join(this.promptxHomeDir, "project");
      }
      // ğŸ¯ æ–°æ¶æ„ï¼šå½“å‰é¡¹ç›®çŠ¶æ€ç®¡ç†
      static currentProject = {
        workingDirectory: null,
        mcpId: null,
        ideType: null,
        transport: null,
        initialized: false
      };
      /**
       * è®¾ç½®å½“å‰é¡¹ç›®ï¼ˆinitæ—¶è°ƒç”¨ï¼‰
       * @param {string} workingDirectory - é¡¹ç›®å·¥ä½œç›®å½•ç»å¯¹è·¯å¾„
       * @param {string} mcpId - MCPè¿›ç¨‹ID
       * @param {string} ideType - IDEç±»å‹
       * @param {string} transport - ä¼ è¾“åè®®ç±»å‹
       */
      static setCurrentProject(workingDirectory, mcpId, ideType, transport) {
        this.currentProject = {
          workingDirectory: path.resolve(workingDirectory),
          mcpId,
          ideType,
          transport,
          initialized: true
        };
      }
      /**
       * è·å–å½“å‰é¡¹ç›®è·¯å¾„ï¼ˆ@projectåè®®ä½¿ç”¨ï¼‰
       * @returns {string} å½“å‰é¡¹ç›®å·¥ä½œç›®å½•
       */
      static getCurrentProjectPath() {
        logger.debug(`[ProjectManager DEBUG] getCurrentProjectPath\u88AB\u8C03\u7528`);
        logger.debug(`[ProjectManager DEBUG] currentProject.initialized: ${this.currentProject.initialized}`);
        logger.debug(`[ProjectManager DEBUG] currentProject\u72B6\u6001:`, JSON.stringify(this.currentProject, null, 2));
        const stack = new Error().stack;
        const stackLines = stack.split("\n").slice(1, 8);
        logger.error(`[ProjectManager DEBUG] \u5B8C\u6574\u8C03\u7528\u6808:`);
        stackLines.forEach((line, index) => {
          logger.error(`[ProjectManager DEBUG]   ${index + 1}. ${line.trim()}`);
        });
        if (!this.currentProject.initialized) {
          logger.error(`[ProjectManager DEBUG] \u274C \u9879\u76EE\u672A\u521D\u59CB\u5316\uFF0C\u5C06\u629B\u51FA\u9519\u8BEF`);
          throw new Error("\u9879\u76EE\u672A\u521D\u59CB\u5316\uFF0C\u8BF7\u5148\u8C03\u7528 init \u547D\u4EE4");
        }
        logger.debug(`[ProjectManager DEBUG] \u2705 \u8FD4\u56DE\u9879\u76EE\u8DEF\u5F84: ${this.currentProject.workingDirectory}`);
        return this.currentProject.workingDirectory;
      }
      /**
       * è·å–å½“å‰é¡¹ç›®ä¿¡æ¯
       * @returns {Object} å½“å‰é¡¹ç›®å®Œæ•´ä¿¡æ¯
       */
      static getCurrentProject() {
        logger.debug(`[ProjectManager DEBUG] getCurrentProject\u88AB\u8C03\u7528`);
        logger.debug(`[ProjectManager DEBUG] currentProject.initialized: ${this.currentProject.initialized}`);
        logger.debug(`[ProjectManager DEBUG] currentProject\u72B6\u6001:`, JSON.stringify(this.currentProject, null, 2));
        if (!this.currentProject.initialized) {
          logger.error(`[ProjectManager DEBUG] \u274C \u9879\u76EE\u672A\u521D\u59CB\u5316\uFF0C\u5C06\u629B\u51FA\u9519\u8BEF`);
          throw new Error("\u9879\u76EE\u672A\u521D\u59CB\u5316\uFF0C\u8BF7\u5148\u8C03\u7528 init \u547D\u4EE4");
        }
        logger.debug(`[ProjectManager DEBUG] \u2705 \u8FD4\u56DE\u9879\u76EE\u4FE1\u606F`);
        return { ...this.currentProject };
      }
      /**
       * æ£€æŸ¥é¡¹ç›®æ˜¯å¦å·²åˆå§‹åŒ–
       * @returns {boolean} æ˜¯å¦å·²åˆå§‹åŒ–
       */
      static isInitialized() {
        return this.currentProject.initialized;
      }
      /**
       * æ³¨å†Œé¡¹ç›®åˆ°MCPå®ä¾‹ - ä½¿ç”¨Hashç›®å½•ç»“æ„
       * @param {string} projectPath - é¡¹ç›®ç»å¯¹è·¯å¾„
       * @param {string} mcpId - MCPè¿›ç¨‹ID
       * @param {string} ideType - IDEç±»å‹ï¼ˆcursor/vscodeç­‰ï¼‰
       * @param {string} transport - ä¼ è¾“åè®®ç±»å‹ï¼ˆstdio/http/sseï¼‰
       * @returns {Promise<Object>} é¡¹ç›®é…ç½®å¯¹è±¡
       */
      async registerProject(projectPath, mcpId, ideType, transport = "stdio") {
        if (!await this.validateProjectPath(projectPath)) {
          throw new Error(`\u65E0\u6548\u7684\u9879\u76EE\u8DEF\u5F84: ${projectPath}`);
        }
        const projectConfig = {
          mcpId,
          ideType: ideType.toLowerCase(),
          transport: transport.toLowerCase(),
          projectPath: path.resolve(projectPath),
          projectHash: this.generateProjectHash(projectPath)
        };
        const projectHash = this.generateProjectHash(projectPath);
        const projectConfigDir = path.join(this.projectsDir, projectHash);
        await fs.ensureDir(projectConfigDir);
        await fs.ensureDir(path.join(projectConfigDir, ".promptx"));
        await fs.ensureDir(path.join(projectConfigDir, ".promptx", "memory"));
        await fs.ensureDir(path.join(projectConfigDir, ".promptx", "resource"));
        const fileName = this.generateConfigFileName(mcpId, ideType, transport, projectPath);
        const configPath = path.join(projectConfigDir, fileName);
        await fs.writeJson(configPath, projectConfig, { spaces: 2 });
        return projectConfig;
      }
      /**
       * æ ¹æ®MCP IDè·å–å•ä¸ªé¡¹ç›®é…ç½®ï¼ˆå‡è®¾åªæœ‰ä¸€ä¸ªé¡¹ç›®ï¼‰
       * @param {string} mcpId - MCPè¿›ç¨‹ID
       * @returns {Promise<Object|null>} é¡¹ç›®é…ç½®å¯¹è±¡
       */
      async getProjectByMcpId(mcpId) {
        const projects = await this.getProjectsByMcpId(mcpId);
        return projects.length > 0 ? projects[0] : null;
      }
      /**
       * æ ¹æ®MCP IDè·å–æ‰€æœ‰ç»‘å®šçš„é¡¹ç›®é…ç½® - æ”¯æŒHashç›®å½•ç»“æ„
       * @param {string} mcpId - MCPè¿›ç¨‹ID
       * @returns {Promise<Array>} é¡¹ç›®é…ç½®æ•°ç»„
       */
      async getProjectsByMcpId(mcpId) {
        if (!await fs.pathExists(this.projectsDir)) {
          return [];
        }
        const hashDirs = await fs.readdir(this.projectsDir);
        const projects = [];
        for (const hashDir of hashDirs) {
          const hashDirPath = path.join(this.projectsDir, hashDir);
          if (!(await fs.stat(hashDirPath)).isDirectory()) {
            continue;
          }
          try {
            const configFiles = await fs.readdir(hashDirPath);
            for (const file of configFiles) {
              if (file.startsWith("mcp-") && file.endsWith(".json")) {
                try {
                  const configPath = path.join(hashDirPath, file);
                  const config = await fs.readJson(configPath);
                  if (config.mcpId === mcpId) {
                    projects.push(config);
                  }
                } catch (error) {
                  logger.warn(`\u8DF3\u8FC7\u635F\u574F\u7684\u914D\u7F6E\u6587\u4EF6: ${file}`);
                }
              }
            }
          } catch (error) {
            logger.warn(`\u8DF3\u8FC7\u65E0\u6CD5\u8BFB\u53D6\u7684\u76EE\u5F55: ${hashDir}`);
          }
        }
        return projects;
      }
      /**
       * è·å–ç‰¹å®šé¡¹ç›®çš„æ‰€æœ‰å®ä¾‹ï¼ˆä¸åŒIDE/MCPçš„ç»‘å®šï¼‰ - æ”¯æŒHashç›®å½•ç»“æ„
       * @param {string} projectPath - é¡¹ç›®è·¯å¾„
       * @returns {Promise<Array>} é¡¹ç›®å®ä¾‹æ•°ç»„
       */
      async getProjectInstances(projectPath) {
        if (!await fs.pathExists(this.projectsDir)) {
          return [];
        }
        const projectHash = this.generateProjectHash(projectPath);
        const projectConfigDir = path.join(this.projectsDir, projectHash);
        if (!await fs.pathExists(projectConfigDir)) {
          return [];
        }
        const instances = [];
        try {
          const configFiles = await fs.readdir(projectConfigDir);
          for (const file of configFiles) {
            if (file.startsWith("mcp-") && file.endsWith(".json")) {
              try {
                const configPath = path.join(projectConfigDir, file);
                const config = await fs.readJson(configPath);
                if (config.projectHash === projectHash) {
                  instances.push(config);
                }
              } catch (error) {
                logger.warn(`\u8DF3\u8FC7\u635F\u574F\u7684\u914D\u7F6E\u6587\u4EF6: ${file}`);
              }
            }
          }
        } catch (error) {
          logger.warn(`\u65E0\u6CD5\u8BFB\u53D6\u9879\u76EE\u914D\u7F6E\u76EE\u5F55: ${projectConfigDir}`);
        }
        return instances;
      }
      /**
       * åˆ é™¤é¡¹ç›®ç»‘å®š - æ”¯æŒHashç›®å½•ç»“æ„
       * @param {string} mcpId - MCPè¿›ç¨‹ID
       * @param {string} ideType - IDEç±»å‹
       * @param {string} transport - ä¼ è¾“åè®®ç±»å‹
       * @param {string} projectPath - é¡¹ç›®è·¯å¾„
       * @returns {Promise<boolean>} æ˜¯å¦åˆ é™¤æˆåŠŸ
       */
      async removeProject(mcpId, ideType, transport, projectPath) {
        const projectHash = this.generateProjectHash(projectPath);
        const projectConfigDir = path.join(this.projectsDir, projectHash);
        const fileName = this.generateConfigFileName(mcpId, ideType, transport, projectPath);
        const configPath = path.join(projectConfigDir, fileName);
        if (await fs.pathExists(configPath)) {
          await fs.remove(configPath);
          try {
            const remainingFiles = await fs.readdir(projectConfigDir);
            const mcpConfigFiles = remainingFiles.filter((file) => file.startsWith("mcp-") && file.endsWith(".json"));
            if (mcpConfigFiles.length === 0) {
              await fs.remove(projectConfigDir);
            }
          } catch (error) {
          }
          return true;
        }
        return false;
      }
      /**
       * æ¸…ç†è¿‡æœŸçš„é¡¹ç›®é…ç½® - æ”¯æŒHashç›®å½•ç»“æ„
       * @returns {Promise<number>} æ¸…ç†çš„é…ç½®æ–‡ä»¶æ•°é‡
       */
      async cleanupExpiredProjects() {
        if (!await fs.pathExists(this.projectsDir)) {
          return 0;
        }
        const hashDirs = await fs.readdir(this.projectsDir);
        let cleanedCount = 0;
        for (const hashDir of hashDirs) {
          const hashDirPath = path.join(this.projectsDir, hashDir);
          if (!(await fs.stat(hashDirPath)).isDirectory()) {
            continue;
          }
          try {
            const configFiles = await fs.readdir(hashDirPath);
            let hasValidConfig = false;
            for (const file of configFiles) {
              if (file.startsWith("mcp-") && file.endsWith(".json")) {
                try {
                  const configPath = path.join(hashDirPath, file);
                  const config = await fs.readJson(configPath);
                  if (!await fs.pathExists(config.projectPath)) {
                    await fs.remove(configPath);
                    cleanedCount++;
                    logger.info(`\u6E05\u7406\u8FC7\u671F\u9879\u76EE\u914D\u7F6E: ${file}`);
                  } else {
                    hasValidConfig = true;
                  }
                } catch (error) {
                  await fs.remove(path.join(hashDirPath, file));
                  cleanedCount++;
                  logger.info(`\u6E05\u7406\u635F\u574F\u914D\u7F6E\u6587\u4EF6: ${file}`);
                }
              }
            }
            if (!hasValidConfig) {
              await fs.remove(hashDirPath);
              logger.info(`\u6E05\u7406\u7A7A\u7684\u9879\u76EEHash\u76EE\u5F55: ${hashDir}`);
            }
          } catch (error) {
            await fs.remove(hashDirPath);
            cleanedCount++;
            logger.info(`\u6E05\u7406\u65E0\u6CD5\u8BBF\u95EE\u7684\u76EE\u5F55: ${hashDir}`);
          }
        }
        return cleanedCount;
      }
      /**
       * ç”Ÿæˆå¤šé¡¹ç›®ç¯å¢ƒä¸‹çš„AIæç¤ºè¯
       * @param {string} contextType - ä¸Šä¸‹æ–‡ç±»å‹ï¼š'list'/'action'/'learn'
       * @param {string} mcpId - MCPè¿›ç¨‹ID
       * @param {string} ideType - IDEç±»å‹
       * @returns {Promise<string>} æ ¼å¼åŒ–çš„AIæç¤ºè¯
       */
      async generateTopLevelProjectPrompt(contextType = "list", mcpId, ideType) {
        const projects = await this.getProjectsByMcpId(mcpId);
        if (projects.length === 0) {
          return "";
        }
        if (projects.length === 1) {
          const project = projects[0];
          const basePrompt = `\u{1F6D1} **\u9879\u76EE\u73AF\u5883\u9A8C\u8BC1** \u{1F6D1}
\u{1F4CD} \u5F53\u524D\u7ED1\u5B9A\u9879\u76EE: ${project.projectPath}
\u{1F517} MCP\u5B9E\u4F8B: ${mcpId} (${ideType})

\u26A0\uFE0F **\u6267\u884C\u524D\u786E\u8BA4**\uFF1A\u4E0A\u8FF0\u8DEF\u5F84\u662F\u5426\u4E3A\u4F60\u5F53\u524D\u5DE5\u4F5C\u7684\u9879\u76EE\uFF1F`;
          switch (contextType) {
            case "action":
              return `${basePrompt}
\u5982\u4E0D\u4E00\u81F4\uFF0C\u7ACB\u5373\u505C\u6B62\u6240\u6709\u64CD\u4F5C\u5E76\u4F7F\u7528 \`promptx_init\` \u66F4\u65B0\uFF01

\u{1F4A5} **\u4E25\u91CD\u8B66\u544A**\uFF1A\u5728\u9519\u8BEF\u9879\u76EE\u8DEF\u5F84\u4E0B\u64CD\u4F5C\u5C06\u5BFC\u81F4\u4E0D\u53EF\u9884\u77E5\u7684\u9519\u8BEF\uFF01`;
            case "learn":
              return `${basePrompt}
\u9519\u8BEF\u73AF\u5883\u5C06\u5BFC\u81F4\u77E5\u8BC6\u5173\u8054\u5931\u6548\uFF01

\u{1F4A5} **\u4E25\u91CD\u8B66\u544A**\uFF1A\u9879\u76EE\u73AF\u5883\u4E0D\u5339\u914D\u5C06\u5F71\u54CD\u5B66\u4E60\u6548\u679C\uFF01`;
            default:
              return `${basePrompt}
\u5982\u4E0D\u4E00\u81F4\uFF0C\u5FC5\u987B\u4F7F\u7528 \`promptx_init\` \u66F4\u65B0\u6B63\u786E\u8DEF\u5F84\uFF01

\u{1F4A5} **\u4E25\u91CD\u8B66\u544A**\uFF1A\u9519\u8BEF\u7684\u9879\u76EE\u73AF\u5883\u5C06\u5BFC\u81F4\u670D\u52A1\u5F02\u5E38\uFF01`;
          }
        }
        const projectList = projects.map(
          (proj, index) => `${index + 1}. ${path.basename(proj.projectPath)} (${proj.projectPath})`
        ).join("\n");
        return `\u{1F3AF} **\u591A\u9879\u76EE\u73AF\u5883\u68C0\u6D4B** \u{1F3AF}
\u{1F4CD} \u5F53\u524DMCP\u5B9E\u4F8B(${mcpId})\u5DF2\u7ED1\u5B9A ${projects.length} \u4E2A\u9879\u76EE\uFF1A

${projectList}

\u26A0\uFE0F **\u8BF7\u660E\u786E\u6307\u5B9A**\uFF1A\u4F60\u8981\u5728\u54EA\u4E2A\u9879\u76EE\u4E2D\u6267\u884C\u64CD\u4F5C\uFF1F
\u{1F4A1} **\u5EFA\u8BAE**\uFF1A\u5728\u5BF9\u8BDD\u4E2D\u660E\u786E\u8BF4\u660E\u9879\u76EE\u540D\u79F0\u6216\u8DEF\u5F84`;
      }
      /**
       * éªŒè¯è·¯å¾„æ˜¯å¦ä¸ºæœ‰æ•ˆçš„é¡¹ç›®ç›®å½•
       * @param {string} projectPath - è¦éªŒè¯çš„è·¯å¾„
       * @returns {Promise<boolean>} æ˜¯å¦ä¸ºæœ‰æ•ˆé¡¹ç›®ç›®å½•
       */
      async validateProjectPath(projectPath) {
        try {
          const stat = await fs.stat(projectPath);
          if (!stat.isDirectory()) {
            return false;
          }
          const resolved = path.resolve(projectPath);
          const homeDir = os.homedir();
          if (resolved === homeDir) {
            return false;
          }
          return true;
        } catch (error) {
          return false;
        }
      }
      /**
       * ç”Ÿæˆé…ç½®æ–‡ä»¶å
       * @param {string} mcpId - MCPè¿›ç¨‹ID
       * @param {string} ideType - IDEç±»å‹
       * @param {string} transport - ä¼ è¾“åè®®ç±»å‹
       * @param {string} projectPath - é¡¹ç›®è·¯å¾„
       * @returns {string} é…ç½®æ–‡ä»¶å
       */
      generateConfigFileName(mcpId, ideType, transport, projectPath) {
        const projectHash = this.generateProjectHash(projectPath);
        const projectName = path.basename(projectPath).toLowerCase().replace(/[^a-z0-9-]/g, "-");
        const ideTypeSafe = ideType.replace(/[^a-z0-9-]/g, "").toLowerCase() || "unknown";
        const transportSafe = transport.replace(/[^a-z0-9-]/g, "").toLowerCase() || "unknown";
        return `mcp-${transportSafe}-${mcpId.replace("mcp-", "")}-${ideTypeSafe}-${projectName}-${projectHash}.json`;
      }
      /**
       * ç”Ÿæˆé¡¹ç›®è·¯å¾„çš„Hashå€¼
       * @param {string} projectPath - é¡¹ç›®è·¯å¾„
       * @returns {string} 8ä½Hashå€¼
       */
      generateProjectHash(projectPath) {
        return crypto.createHash("md5").update(path.resolve(projectPath)).digest("hex").substr(0, 8);
      }
      /**
       * ä»é…ç½®æ–‡ä»¶ä¸­è·å–IDEç±»å‹
       * @param {string} mcpId - MCPè¿›ç¨‹ID
       * @returns {Promise<string>} IDEç±»å‹
       */
      async getIdeType(mcpId) {
        const project = await this.getProjectByMcpId(mcpId);
        return project ? project.ideType : "unknown";
      }
      /**
       * ç”ŸæˆMCPè¿›ç¨‹ID - åŸºäºè¿›ç¨‹IDç¡®ä¿å®ä¾‹å”¯ä¸€
       * @param {string} ideType - IDEç±»å‹ï¼ˆä¿ç•™å‚æ•°å…¼å®¹æ€§ï¼Œå®é™…ä¸ä½¿ç”¨ï¼‰
       * @returns {string} MCPè¿›ç¨‹ID
       */
      static generateMcpId(ideType = "unknown") {
        const serverEnv = getGlobalServerEnvironment();
        if (serverEnv.isInitialized()) {
          return serverEnv.getMcpId();
        }
        return `mcp-${process.pid}`;
      }
      /**
       * ç»Ÿä¸€é¡¹ç›®æ³¨å†Œæ–¹æ³• - æ–°æ¶æ„ï¼šè®¾ç½®å½“å‰é¡¹ç›®å¹¶æŒä¹…åŒ–é…ç½®
       * @param {string} workingDirectory - é¡¹ç›®å·¥ä½œç›®å½•
       * @param {string} ideType - IDEç±»å‹ï¼ˆå¯é€‰ï¼Œé»˜è®¤'unknown'ï¼‰
       * @returns {Promise<Object>} é¡¹ç›®é…ç½®å¯¹è±¡
       */
      static async registerCurrentProject(workingDirectory, ideType = "unknown") {
        logger.debug(`[ProjectManager DEBUG] ======= registerCurrentProject\u5F00\u59CB =======`);
        logger.debug(`[ProjectManager DEBUG] \u53C2\u6570 - workingDirectory: ${workingDirectory}`);
        logger.debug(`[ProjectManager DEBUG] \u53C2\u6570 - ideType: ${ideType}`);
        logger.debug(`[ProjectManager DEBUG] \u6CE8\u518C\u524D currentProject\u72B6\u6001:`, JSON.stringify(this.currentProject, null, 2));
        const serverEnv = getGlobalServerEnvironment();
        if (!serverEnv.isInitialized()) {
          logger.error(`[ProjectManager DEBUG] \u274C ServerEnvironment\u672A\u521D\u59CB\u5316`);
          throw new Error("ServerEnvironment not initialized");
        }
        const mcpId = serverEnv.getMcpId();
        const transport = serverEnv.getTransport();
        logger.debug(`[ProjectManager DEBUG] ServerEnvironment\u4FE1\u606F - mcpId: ${mcpId}, transport: ${transport}`);
        logger.debug(`[ProjectManager DEBUG] \u8C03\u7528 setCurrentProject...`);
        this.setCurrentProject(workingDirectory, mcpId, ideType, transport);
        logger.debug(`[ProjectManager DEBUG] setCurrentProject\u5B8C\u6210\u540E currentProject\u72B6\u6001:`, JSON.stringify(this.currentProject, null, 2));
        logger.debug(`[ProjectManager DEBUG] \u5F00\u59CB\u6301\u4E45\u5316\u9879\u76EE\u914D\u7F6E...`);
        const projectManager = getGlobalProjectManager();
        const result = await projectManager.registerProject(workingDirectory, mcpId, ideType, transport);
        logger.debug(`[ProjectManager DEBUG] \u9879\u76EE\u914D\u7F6E\u6301\u4E45\u5316\u5B8C\u6210:`, JSON.stringify(result, null, 2));
        logger.debug(`[ProjectManager DEBUG] ======= registerCurrentProject\u7ED3\u675F =======`);
        return result;
      }
    };
    var globalProjectManager = null;
    function getGlobalProjectManager() {
      if (!globalProjectManager) {
        globalProjectManager = new ProjectManager();
      }
      return globalProjectManager;
    }
    module2.exports = ProjectManager;
    module2.exports.ProjectManager = ProjectManager;
    module2.exports.getGlobalProjectManager = getGlobalProjectManager;
  }
});

// src/utils/ProjectPathResolver.js
var require_ProjectPathResolver = __commonJS({
  "src/utils/ProjectPathResolver.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var path = require("path");
    var ProjectManager = require_ProjectManager();
    var ProjectPathResolver = class {
      constructor() {
        this.projectDirs = {
          root: "",
          // é¡¹ç›®æ ¹ç›®å½•
          src: "src",
          // æºä»£ç ç›®å½•
          lib: "lib",
          // åº“ç›®å½•
          build: "build",
          // æ„å»ºè¾“å‡ºç›®å½•
          dist: "dist",
          // åˆ†å‘ç›®å½•
          docs: "docs",
          // æ–‡æ¡£ç›®å½•
          test: "test",
          // æµ‹è¯•ç›®å½•
          tests: "tests",
          // æµ‹è¯•ç›®å½•ï¼ˆå¤æ•°ï¼‰
          spec: "spec",
          // è§„èŒƒæµ‹è¯•ç›®å½•
          config: "config",
          // é…ç½®ç›®å½•
          scripts: "scripts",
          // è„šæœ¬ç›®å½•
          assets: "assets",
          // èµ„æºç›®å½•
          public: "public",
          // å…¬å…±èµ„æºç›®å½•
          static: "static",
          // é™æ€èµ„æºç›®å½•
          templates: "templates",
          // æ¨¡æ¿ç›®å½•
          examples: "examples",
          // ç¤ºä¾‹ç›®å½•
          tools: "tools",
          // å·¥å…·ç›®å½•
          ".promptx": ".promptx"
          // PromptXé…ç½®ç›®å½•
        };
      }
      /**
       * è§£æ@project://åè®®è·¯å¾„
       * @param {string} resourcePath - èµ„æºè·¯å¾„ï¼Œå¦‚ "src/index.js" æˆ– ".promptx/resource/..."
       * @returns {string} è§£æåçš„ç»å¯¹è·¯å¾„
       */
      resolvePath(resourcePath) {
        const projectRoot = ProjectManager.getCurrentProjectPath();
        if (resourcePath.startsWith(".promptx/")) {
          const fullPath2 = path.join(projectRoot, resourcePath);
          return this._validatePath(fullPath2, projectRoot);
        }
        const parts = resourcePath.split("/");
        const dirType = parts[0];
        const relativePath = parts.slice(1).join("/");
        if (!this.projectDirs.hasOwnProperty(dirType)) {
          throw new Error(`\u4E0D\u652F\u6301\u7684\u9879\u76EE\u76EE\u5F55\u7C7B\u578B: ${dirType}\u3002\u652F\u6301\u7684\u7C7B\u578B: ${Object.keys(this.projectDirs).join(", ")}`);
        }
        const projectDirPath = this.projectDirs[dirType];
        const targetDir = projectDirPath ? path.join(projectRoot, projectDirPath) : projectRoot;
        if (!relativePath) {
          return targetDir;
        }
        const fullPath = path.join(targetDir, relativePath);
        return this._validatePath(fullPath, projectRoot);
      }
      /**
       * è·å–é¡¹ç›®æ ¹ç›®å½•
       * @returns {string} å½“å‰é¡¹ç›®æ ¹ç›®å½•
       */
      getProjectRoot() {
        return ProjectManager.getCurrentProjectPath();
      }
      /**
       * è·å–PromptXé…ç½®ç›®å½•è·¯å¾„
       * @returns {string} .promptxç›®å½•è·¯å¾„
       */
      getPromptXDirectory() {
        const projectRoot = ProjectManager.getCurrentProjectPath();
        return path.join(projectRoot, ".promptx");
      }
      /**
       * è·å–é¡¹ç›®èµ„æºç›®å½•è·¯å¾„
       * @returns {string} é¡¹ç›®èµ„æºç›®å½•è·¯å¾„
       */
      getResourceDirectory() {
        const promptxDir = this.getPromptXDirectory();
        return path.join(promptxDir, "resource");
      }
      /**
       * è·å–é¡¹ç›®æ³¨å†Œè¡¨æ–‡ä»¶è·¯å¾„
       * @returns {string} æ³¨å†Œè¡¨æ–‡ä»¶è·¯å¾„
       */
      getRegistryPath() {
        const resourceDir = this.getResourceDirectory();
        return path.join(resourceDir, "project.registry.json");
      }
      /**
       * è·å–è®°å¿†ç›®å½•è·¯å¾„
       * @returns {string} è®°å¿†ç›®å½•è·¯å¾„
       */
      getMemoryDirectory() {
        const promptxDir = this.getPromptXDirectory();
        return path.join(promptxDir, "memory");
      }
      /**
       * éªŒè¯è·¯å¾„å®‰å…¨æ€§
       * @param {string} fullPath - å®Œæ•´è·¯å¾„
       * @param {string} projectRoot - é¡¹ç›®æ ¹ç›®å½•
       * @returns {string} éªŒè¯åçš„è·¯å¾„
       * @private
       */
      _validatePath(fullPath, projectRoot) {
        const resolvedPath = path.resolve(fullPath);
        const resolvedProjectRoot = path.resolve(projectRoot);
        if (!resolvedPath.startsWith(resolvedProjectRoot)) {
          throw new Error(`\u5B89\u5168\u9519\u8BEF\uFF1A\u8DEF\u5F84\u8D85\u51FA\u9879\u76EE\u76EE\u5F55\u8303\u56F4: ${resolvedPath}`);
        }
        return resolvedPath;
      }
      /**
       * è·å–æ”¯æŒçš„ç›®å½•ç±»å‹
       * @returns {Array<string>} æ”¯æŒçš„ç›®å½•ç±»å‹åˆ—è¡¨
       */
      getSupportedDirectories() {
        return Object.keys(this.projectDirs);
      }
      /**
       * æ£€æŸ¥ç›®å½•ç±»å‹æ˜¯å¦æ”¯æŒ
       * @param {string} dirType - ç›®å½•ç±»å‹
       * @returns {boolean} æ˜¯å¦æ”¯æŒ
       */
      isSupportedDirectory(dirType) {
        return this.projectDirs.hasOwnProperty(dirType);
      }
    };
    var globalProjectPathResolver = null;
    function getGlobalProjectPathResolver() {
      if (!globalProjectPathResolver) {
        globalProjectPathResolver = new ProjectPathResolver();
      }
      return globalProjectPathResolver;
    }
    module2.exports = ProjectPathResolver;
    module2.exports.getGlobalProjectPathResolver = getGlobalProjectPathResolver;
  }
});

// src/toolx/ToolSandbox.js
var require_ToolSandbox = __commonJS({
  "src/toolx/ToolSandbox.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var path = require("path");
    var fs = require("fs").promises;
    var { spawn } = require("child_process");
    var vm = require("vm");
    var SandboxIsolationManager = require_SandboxIsolationManager();
    var SandboxErrorManager = require_SandboxErrorManager();
    var ToolDirectoryManager = require_ToolDirectoryManager();
    var ESModuleRequireSupport = require_ESModuleRequireSupport();
    var logger = require("@promptx/logger");
    var ToolSandbox2 = class {
      constructor(toolReference, options = {}) {
        this.toolReference = toolReference;
        this.resourceManager = null;
        this.toolId = null;
        this.toolContent = null;
        this.toolInstance = null;
        this.dependencies = [];
        this.directoryManager = null;
        this.sandboxPath = null;
        this.sandboxContext = null;
        this.isolationManager = null;
        this.errorManager = new SandboxErrorManager();
        this.esModuleSupport = null;
        this.isAnalyzed = false;
        this.isPrepared = false;
        this.options = {
          timeout: 3e4,
          enableDependencyInstall: true,
          rebuild: false,
          // å¼ºåˆ¶é‡å»ºæ²™ç®±ï¼ˆç”¨äºå¤„ç†å¼‚å¸¸æƒ…å†µï¼‰
          ...options
        };
      }
      /**
       * è®¾ç½®ResourceManagerå®ä¾‹
       * @param {ResourceManager} resourceManager 
       */
      setResourceManager(resourceManager) {
        this.resourceManager = resourceManager;
      }
      /**
       * æ¸…ç†æ²™ç®±çŠ¶æ€å’Œç¼“å­˜
       * @param {boolean} deleteDirectory - æ˜¯å¦åˆ é™¤æ²™ç®±ç›®å½•
       */
      async clearSandbox(deleteDirectory = false) {
        logger.debug(`[ToolSandbox] Clearing sandbox state${deleteDirectory ? " and deleting directory" : ""}`);
        this.isAnalyzed = false;
        this.isPrepared = false;
        this.toolContent = null;
        this.toolInstance = null;
        this.dependencies = [];
        this.sandboxContext = null;
        if (deleteDirectory && this.directoryManager) {
          try {
            await this.directoryManager.deleteToolbox();
          } catch (error) {
            logger.debug(`[ToolSandbox] Error deleting toolbox directory (can be ignored): ${error.message}`);
          }
        }
      }
      /**
       * åˆ†æå·¥å…·ï¼šåŠ è½½å·¥å…·å†…å®¹ï¼Œæå–å…ƒä¿¡æ¯å’Œä¾èµ–
       * @returns {Promise<Object>} åˆ†æç»“æœ
       */
      async analyze() {
        if (this.isAnalyzed && !this.options.rebuild) {
          logger.debug(`[ToolSandbox] Using cached analysis result, dependencies: ${JSON.stringify(this.dependencies)}`);
          return this.getAnalysisResult();
        }
        if (!this.resourceManager) {
          throw new Error("ResourceManager not set. Call setResourceManager() first.");
        }
        try {
          this.toolId = this.extractToolId(this.toolReference);
          const loadOptions = this.options.forceReinstall ? { noCache: true } : {};
          logger.debug(`[ToolSandbox] Loading tool ${this.toolReference}, options:`, loadOptions);
          const toolResult = await this.resourceManager.loadResource(this.toolReference, loadOptions);
          if (!toolResult.success) {
            logger.debug(`[ToolSandbox] Debug: Trying to find tool ${this.toolReference}`);
            const directLookup = this.resourceManager.registryData.findResourceById(`tool:${this.toolId}`, "tool");
            logger.debug(`[ToolSandbox]    - Direct lookup tool:${this.toolId}: ${directLookup ? "found" : "not found"}`);
            throw new Error(`Failed to load tool: ${toolResult.error.message}`);
          }
          this.toolContent = toolResult.content;
          logger.debug(`[ToolSandbox] Loaded tool content first 200 chars:`, this.toolContent.substring(0, 200));
          this.directoryManager = new ToolDirectoryManager(this.toolId, this.resourceManager);
          await this.directoryManager.initialize();
          await this.directoryManager.ensureDirectories();
          this.sandboxPath = this.directoryManager.getWorkingPath();
          await this.analyzeToolInSandbox();
          this.isAnalyzed = true;
          return this.getAnalysisResult();
        } catch (error) {
          throw new Error(`Tool analysis failed: ${error.message}`);
        }
      }
      /**
       * å‡†å¤‡ä¾èµ–ï¼šå®‰è£…ä¾èµ–ï¼Œå‡†å¤‡æ‰§è¡Œç¯å¢ƒ
       * @returns {Promise<Object>} å‡†å¤‡ç»“æœ
       */
      async prepareDependencies() {
        logger.info(`[ToolSandbox] Starting prepareDependencies for tool ${this.toolId}`);
        if (this.options.rebuild) {
          logger.info(`[ToolSandbox] Manually triggering sandbox rebuild`);
          await this.clearSandbox(true);
          if (this.directoryManager) {
            await this.directoryManager.initialize();
          }
        }
        if (!this.isAnalyzed) {
          logger.info(`[ToolSandbox] Starting tool analysis`);
          await this.analyze();
          logger.info(`[ToolSandbox] Tool analysis completed`);
        }
        if (!this.options.rebuild && await this.checkDependenciesNeedUpdate()) {
          logger.debug(`[ToolSandbox] Dependency changes detected, auto-rebuilding sandbox`);
          await this.clearSandbox(true);
          await this.analyze();
        }
        if (this.isPrepared) {
          return { success: true, message: "Dependencies already prepared" };
        }
        try {
          await this.ensureSandboxDirectory();
          const hasDependencies = typeof this.dependencies === "object" && !Array.isArray(this.dependencies) ? Object.keys(this.dependencies).length > 0 : this.dependencies.length > 0;
          if (hasDependencies) {
            logger.info(`[ToolSandbox] Installing dependencies`);
            await this.installDependencies();
            logger.info(`[ToolSandbox] Dependencies installation completed`);
            await this.detectAndHandleESModules();
          }
          logger.info(`[ToolSandbox] Creating execution sandbox`);
          await this.createExecutionSandbox();
          logger.info(`[ToolSandbox] Execution sandbox created`);
          this.isPrepared = true;
          return {
            success: true,
            sandboxPath: this.directoryManager.getWorkingPath(),
            toolboxPath: this.directoryManager.getToolboxPath(),
            dependencies: this.dependencies
          };
        } catch (error) {
          throw new Error(`Dependency preparation failed: ${error.message}`);
        }
      }
      /**
       * æ‰§è¡Œå·¥å…·
       * @param {Object} parameters - å·¥å…·å‚æ•°
       * @returns {Promise<Object>} æ‰§è¡Œç»“æœ
       */
      async execute(parameters = {}) {
        var _a, _b;
        const startTime = Date.now();
        logger.info(`[ToolSandbox] Executing tool "${this.toolId}" with params: ${JSON.stringify(parameters)}`);
        if (!this.isPrepared) {
          logger.debug(`[ToolSandbox] Preparing dependencies for tool ${this.toolId}`);
          await this.prepareDependencies();
        }
        try {
          await this.validateParameters(parameters);
          const result = await this.executeInSandbox(parameters);
          const elapsed = ((Date.now() - startTime) / 1e3).toFixed(1);
          logger.info(`[ToolSandbox] Tool "${this.toolId}" executed successfully in ${elapsed}s, result type: ${typeof result}`);
          return {
            success: true,
            data: result,
            metadata: {
              toolId: this.toolId,
              sandboxPath: this.directoryManager.getWorkingPath(),
              toolboxPath: this.directoryManager.getToolboxPath(),
              executionTime: Date.now()
            }
          };
        } catch (error) {
          const intelligentError = this.errorManager.analyzeError(error, {
            toolId: this.toolId,
            dependencies: this.dependencies,
            sandboxPath: (_a = this.directoryManager) == null ? void 0 : _a.getWorkingPath(),
            toolboxPath: (_b = this.directoryManager) == null ? void 0 : _b.getToolboxPath(),
            phase: "execute"
          });
          const enhancedError = new Error(intelligentError.formattedMessage);
          enhancedError.intelligentError = intelligentError;
          enhancedError.originalError = error;
          throw enhancedError;
        }
      }
      /**
       * æå–å·¥å…·ID
       * @param {string} toolReference - @tool://url-validator
       * @returns {string} å·¥å…·ID
       */
      extractToolId(toolReference) {
        const match = toolReference.match(/^@tool:\/\/(.+)$/);
        if (!match) {
          throw new Error(`Invalid tool reference format: ${toolReference}`);
        }
        return match[1];
      }
      /**
       * åœ¨åŸºç¡€æ²™ç®±ä¸­åˆ†æå·¥å…·
       */
      async analyzeToolInSandbox() {
        var _a;
        this.isolationManager = new SandboxIsolationManager(this.directoryManager.getWorkingPath(), {
          enableDependencyLoading: false,
          analysisMode: true
        });
        const sandbox = this.isolationManager.createIsolatedContext();
        logger.debug(
          `[ToolSandbox] Tool code getDependencies section:`,
          ((_a = this.toolContent.match(/getDependencies[\s\S]*?return[\s\S]*?\]/)) == null ? void 0 : _a[0]) || "getDependencies not found"
        );
        const script = new vm.Script(this.toolContent, { filename: `${this.toolId}.js` });
        const context = vm.createContext(sandbox);
        try {
          script.runInContext(context);
        } catch (error) {
          const filteredError = this._filterRequireError(error);
          if (filteredError) {
            throw filteredError;
          }
        }
        const exported = context.module.exports;
        if (!exported) {
          throw new Error(`Tool does not export anything: ${this.toolId}`);
        }
        let toolInstance;
        if (typeof exported === "function") {
          toolInstance = new exported();
        } else if (typeof exported === "object") {
          toolInstance = exported;
        } else {
          throw new Error(`Invalid tool export format: ${this.toolId}`);
        }
        if (typeof toolInstance.getDependencies === "function") {
          try {
            this.dependencies = toolInstance.getDependencies() || {};
            logger.debug(`[ToolSandbox] Extracted dependencies: ${JSON.stringify(this.dependencies)}`);
          } catch (error) {
            logger.warn(`[ToolSandbox] Failed to get dependencies for ${this.toolId}: ${error.message}`);
            this.dependencies = {};
          }
        } else {
          logger.debug(`[ToolSandbox] Tool does not have getDependencies method`);
          this.dependencies = {};
        }
        this.toolInstance = toolInstance;
      }
      /**
       * æ™ºèƒ½è¿‡æ»¤requireé”™è¯¯
       * @param {Error} error - æ•è·çš„é”™è¯¯
       * @returns {Error|null} - å¦‚æœæ˜¯çœŸæ­£çš„é”™è¯¯åˆ™è¿”å›Errorå¯¹è±¡ï¼Œå¦‚æœæ˜¯é¢„æœŸçš„requireé”™è¯¯åˆ™è¿”å›null
       * @private
       */
      _filterRequireError(error) {
        if (error.code === "MODULE_NOT_FOUND") {
          const missingModule = this._extractMissingModuleName(error.message);
          if (missingModule) {
            const declaredDependencies = this._extractDeclaredDependencies();
            if (this._isDeclaredInDependencies(missingModule, declaredDependencies)) {
              logger.debug(`[ToolSandbox] Dependency ${missingModule} not installed, will install in prepareDependencies phase`);
              return null;
            } else {
              return new Error(`\u672A\u58F0\u660E\u7684\u4F9D\u8D56: ${missingModule}\uFF0C\u8BF7\u5728getDependencies()\u4E2D\u6DFB\u52A0\u6B64\u4F9D\u8D56`);
            }
          }
        }
        return error;
      }
      /**
       * ä»é”™è¯¯ä¿¡æ¯ä¸­æå–ç¼ºå¤±çš„æ¨¡å—å
       * @param {string} errorMessage - é”™è¯¯ä¿¡æ¯
       * @returns {string|null} - æ¨¡å—åæˆ–null
       * @private
       */
      _extractMissingModuleName(errorMessage) {
        const match = errorMessage.match(/Cannot (?:find|resolve) module ['"]([^'"]+)['"]/);
        return match ? match[1] : null;
      }
      /**
       * å°è¯•ä»å·¥å…·ä»£ç ä¸­æå–å·²å£°æ˜çš„ä¾èµ–
       * @returns {string[]} - ä¾èµ–åˆ—è¡¨
       * @private
       */
      _extractDeclaredDependencies() {
        try {
          const dependencyMatch = this.toolContent.match(/getDependencies\s*\(\s*\)\s*\{[\s\S]*?return\s*\[([\s\S]*?)\]/);
          if (dependencyMatch) {
            const dependencyString = dependencyMatch[1];
            const stringMatches = dependencyString.match(/['"]([^'"]+)['"]/g);
            if (stringMatches) {
              return stringMatches.map((str) => str.slice(1, -1));
            }
          }
        } catch (error) {
          logger.warn(`[ToolSandbox] Unable to parse dependency declaration: ${error.message}`);
        }
        return [];
      }
      /**
       * æ£€æŸ¥æ¨¡å—æ˜¯å¦åœ¨ä¾èµ–å£°æ˜ä¸­
       * @param {string} moduleName - æ¨¡å—å
       * @param {string[]} declaredDependencies - å·²å£°æ˜çš„ä¾èµ–åˆ—è¡¨
       * @returns {boolean} - æ˜¯å¦å·²å£°æ˜
       * @private
       */
      _isDeclaredInDependencies(moduleName, declaredDependencies) {
        return declaredDependencies.some((dep) => {
          const depName = dep.split("@")[0];
          return depName === moduleName;
        });
      }
      /**
       * æ£€æŸ¥æ²™ç®±ç›®å½•æ˜¯å¦å­˜åœ¨
       * @returns {Promise<boolean>}
       */
      async sandboxExists() {
        if (!this.directoryManager) {
          return false;
        }
        return await this.directoryManager.toolboxExists();
      }
      /**
       * ç¡®ä¿æ²™ç®±ç›®å½•å­˜åœ¨
       */
      async ensureSandboxDirectory() {
        if (this.directoryManager) {
          await this.directoryManager.ensureDirectories();
        }
      }
      /**
       * å®‰è£…ä¾èµ–
       */
      async installDependencies() {
        const hasDependencies = typeof this.dependencies === "object" && !Array.isArray(this.dependencies) ? Object.keys(this.dependencies).length > 0 : this.dependencies.length > 0;
        if (!hasDependencies) {
          return;
        }
        await this.createPackageJson();
        await this.runPnpmInstall();
      }
      /**
       * æ£€æŸ¥ä¾èµ–æ˜¯å¦éœ€è¦æ›´æ–°
       * @returns {Promise<boolean>} trueè¡¨ç¤ºéœ€è¦æ›´æ–°
       */
      async checkDependenciesNeedUpdate() {
        const packageJsonPath = this.directoryManager.getPackageJsonPath();
        try {
          const existingContent = await fs.readFile(packageJsonPath, "utf-8");
          const existingPackageJson = JSON.parse(existingContent);
          const existingDeps = existingPackageJson.dependencies || {};
          let newDeps = {};
          if (typeof this.dependencies === "object" && !Array.isArray(this.dependencies)) {
            newDeps = this.dependencies;
          } else if (Array.isArray(this.dependencies)) {
            for (const dep of this.dependencies) {
              if (dep.includes("@")) {
                const lastAtIndex = dep.lastIndexOf("@");
                if (lastAtIndex > 0) {
                  const name = dep.substring(0, lastAtIndex);
                  const version = dep.substring(lastAtIndex + 1);
                  newDeps[name] = version;
                } else {
                  newDeps[dep] = "latest";
                }
              } else {
                newDeps[dep] = "latest";
              }
            }
          }
          const existingKeys = Object.keys(existingDeps).sort();
          const newKeys = Object.keys(newDeps).sort();
          if (existingKeys.length !== newKeys.length || !existingKeys.every((key, index) => key === newKeys[index])) {
            logger.debug(`[ToolSandbox] Dependency list changed - old: ${existingKeys.join(", ")} | new: ${newKeys.join(", ")}`);
            return true;
          }
          for (const key of existingKeys) {
            if (existingDeps[key] !== newDeps[key]) {
              logger.debug(`[ToolSandbox] Dependency version changed - ${key}: ${existingDeps[key]} -> ${newDeps[key]}`);
              return true;
            }
          }
          return false;
        } catch (error) {
          logger.debug(`[ToolSandbox] package.json does not exist or is invalid, needs to be created`);
          return true;
        }
      }
      /**
       * åˆ›å»ºpackage.json
       */
      async createPackageJson() {
        const packageJsonPath = this.directoryManager.getPackageJsonPath();
        const packageJson = {
          name: `toolbox-${this.toolId}`,
          version: "1.0.0",
          description: `Sandbox for tool: ${this.toolId}`,
          private: true,
          dependencies: {}
        };
        logger.debug(`[ToolSandbox] Processing dependencies: ${JSON.stringify(this.dependencies)}`);
        if (typeof this.dependencies === "object" && !Array.isArray(this.dependencies)) {
          packageJson.dependencies = this.dependencies;
        } else if (Array.isArray(this.dependencies)) {
          logger.warn(`[ToolSandbox] Tool ${this.toolId} is using deprecated array format for dependencies. Please update to object format.`);
          for (const dep of this.dependencies) {
            if (dep.includes("@")) {
              const lastAtIndex = dep.lastIndexOf("@");
              if (lastAtIndex > 0) {
                const name = dep.substring(0, lastAtIndex);
                const version = dep.substring(lastAtIndex + 1);
                logger.debug(`[ToolSandbox] Parsing dependency "${dep}" => name="${name}", version="${version}"`);
                packageJson.dependencies[name] = version;
              } else {
                packageJson.dependencies[dep] = "latest";
              }
            } else {
              packageJson.dependencies[dep] = "latest";
            }
          }
        }
        await fs.writeFile(packageJsonPath, JSON.stringify(packageJson, null, 2));
      }
      /**
       * è¿è¡Œpnpmå®‰è£…
       */
      async runPnpmInstall() {
        const startTime = Date.now();
        let depsList = "";
        if (typeof this.dependencies === "object" && !Array.isArray(this.dependencies)) {
          depsList = Object.keys(this.dependencies).map((name) => `${name}@${this.dependencies[name]}`).join(", ");
        } else if (Array.isArray(this.dependencies)) {
          depsList = this.dependencies.join(", ");
        }
        logger.info(`[ToolSandbox] Installing dependencies: [${depsList}]`);
        return new Promise((resolve, reject) => {
          const pnpmModulePath = require.resolve("pnpm");
          const pnpmBinPath = path.join(path.dirname(pnpmModulePath), "bin", "pnpm.cjs");
          const nodeExecutable = process.env.PROMPTX_NODE_EXECUTABLE || "node";
          const spawnEnv = { ...process.env };
          if (nodeExecutable === process.env.PROMPTX_NODE_EXECUTABLE && nodeExecutable.includes("electron")) {
            spawnEnv.ELECTRON_RUN_AS_NODE = "1";
            logger.info(`[ToolSandbox] Setting ELECTRON_RUN_AS_NODE=1 for this subprocess only`);
          }
          spawnEnv.CI = "1";
          const pnpmArgs = [
            pnpmBinPath,
            "install",
            "--config.confirmModulesPurge=false",
            "--prefer-offline",
            "--ignore-scripts",
            "--reporter=append-only"
          ];
          const fullCommand = `${nodeExecutable} ${pnpmArgs.join(" ")}`;
          logger.info(`[ToolSandbox] Executing command: ${fullCommand}`);
          logger.info(`[ToolSandbox] Working directory: ${this.directoryManager.getToolboxPath()}`);
          logger.info(`[ToolSandbox] Using Node.js executable: ${nodeExecutable}`);
          const timeout = setTimeout(() => {
            const elapsed = ((Date.now() - startTime) / 1e3).toFixed(1);
            logger.error(`[ToolSandbox] pnpm install timeout (${elapsed}s > 30s)`);
            logger.error(`[ToolSandbox] Command: ${fullCommand}`);
            logger.error(`[ToolSandbox] Working directory: ${this.directoryManager.getToolboxPath()}`);
            logger.error(`[ToolSandbox] Installing packages: [${depsList}]`);
            logger.error(`[ToolSandbox] Stdout output: ${stdout}`);
            logger.error(`[ToolSandbox] Stderr output: ${stderr}`);
            pnpm.kill("SIGTERM");
            reject(new Error(`pnpm install timeout after 30s. Command: ${fullCommand}`));
          }, 3e4);
          const pnpm = spawn(nodeExecutable, pnpmArgs, {
            cwd: this.directoryManager.getToolboxPath(),
            // ä½¿ç”¨ toolbox è·¯å¾„å®‰è£…ä¾èµ–
            env: spawnEnv,
            // ä½¿ç”¨å®šåˆ¶çš„ç¯å¢ƒå˜é‡
            stdio: "pipe"
          });
          let stdout = "";
          let stderr = "";
          pnpm.stdout.on("data", (data) => {
            const output = data.toString();
            stdout += output;
            logger.debug(`[ToolSandbox] pnpm stdout: ${output}`);
          });
          pnpm.stderr.on("data", (data) => {
            const error = data.toString();
            stderr += error;
            logger.warn(`[ToolSandbox] pnpm stderr: ${error}`);
          });
          pnpm.on("close", (code) => {
            clearTimeout(timeout);
            const elapsed = ((Date.now() - startTime) / 1e3).toFixed(1);
            if (code === 0) {
              logger.info(`[ToolSandbox] Dependencies installed successfully in ${elapsed}s`);
              logger.debug(`[ToolSandbox] Installed packages: [${depsList}]`);
              resolve({ stdout, stderr });
            } else {
              logger.error(`[ToolSandbox] pnpm install failed with exit code ${code} after ${elapsed}s`);
              logger.error(`[ToolSandbox] Command: ${fullCommand}`);
              logger.error(`[ToolSandbox] Working directory: ${this.directoryManager.getToolboxPath()}`);
              logger.error(`[ToolSandbox] Installing packages: [${depsList}]`);
              logger.error(`[ToolSandbox] Stdout: ${stdout}`);
              logger.error(`[ToolSandbox] Stderr: ${stderr}`);
              reject(new Error(`pnpm install failed with code ${code}: ${stderr}`));
            }
          });
          pnpm.on("error", (error) => {
            logger.error(`[ToolSandbox] Failed to spawn pnpm: ${error.message}`);
            reject(new Error(`Failed to spawn pnpm: ${error.message}`));
          });
        });
      }
      /**
       * æ£€æµ‹å’Œå¤„ç† ES Module ä¾èµ–
       */
      async detectAndHandleESModules() {
        if (!this.esModuleSupport) {
          this.esModuleSupport = new ESModuleRequireSupport(this.directoryManager.getToolboxPath());
        }
        const dependencyTypes = await this.esModuleSupport.detectDependenciesTypes(this.dependencies);
        if (dependencyTypes.esmodule.length > 0) {
          logger.warn(`[ToolSandbox] \u68C0\u6D4B\u5230 ES Module \u4F9D\u8D56\uFF1A`, dependencyTypes.esmodule.map((d) => d.name).join(", "));
          logger.info(`[ToolSandbox] ES Module \u5305\u9700\u8981\u4F7F\u7528\u52A8\u6001 import() \u52A0\u8F7D\uFF0C\u5DE5\u5177\u53EF\u80FD\u9700\u8981\u76F8\u5E94\u8C03\u6574`);
          this.esModuleDependencies = dependencyTypes.esmodule;
        }
        if (dependencyTypes.unknown.length > 0) {
          logger.debug(`[ToolSandbox] \u65E0\u6CD5\u68C0\u6D4B\u7684\u4F9D\u8D56\u7C7B\u578B\uFF1A`, dependencyTypes.unknown.map((d) => d.name).join(", "));
        }
        return dependencyTypes;
      }
      /**
       * åˆ›å»ºæ‰§è¡Œæ²™ç®±ç¯å¢ƒ
       */
      async createExecutionSandbox() {
        this.isolationManager = new SandboxIsolationManager(this.directoryManager.getWorkingPath(), {
          enableDependencyLoading: true,
          analysisMode: false,
          toolboxPath: this.directoryManager.getToolboxPath()
          // ä¼ é€’ toolbox è·¯å¾„ç”¨äºä¾èµ–åŠ è½½
        });
        this.sandboxContext = this.isolationManager.createIsolatedContext();
        if (!this.esModuleSupport) {
          this.esModuleSupport = new ESModuleRequireSupport(this.directoryManager.getToolboxPath());
        }
        this.sandboxContext.loadModule = async (moduleName) => {
          const moduleType = await this.esModuleSupport.detectModuleType(moduleName);
          if (moduleType === "esm") {
            try {
              return await this.esModuleSupport.loadESModule(moduleName);
            } catch (error) {
              const module3 = this.sandboxContext.require(moduleName);
              return module3.default || module3;
            }
          } else {
            return this.sandboxContext.require(moduleName);
          }
        };
        this.sandboxContext.importModule = this.sandboxContext.loadModule;
        const originalRequire = this.sandboxContext.require;
        const esModuleSupport = this.esModuleSupport;
        this.sandboxContext.require = function(moduleName) {
          try {
            const packageJsonPath = require.resolve(`${moduleName}/package.json`, {
              paths: [esModuleSupport.toolboxPath]
            });
            const packageJson = require(packageJsonPath);
            if (packageJson.type === "module") {
              const error = new Error(
                `\u274C "${moduleName}" \u662F ES Module \u5305\uFF0C\u8BF7\u4F7F\u7528 await loadModule('${moduleName}') \u4EE3\u66FF require('${moduleName}')
\u{1F4A1} \u63D0\u793A\uFF1AloadModule \u4F1A\u81EA\u52A8\u68C0\u6D4B\u5305\u7C7B\u578B\u5E76\u6B63\u786E\u52A0\u8F7D`
              );
              error.code = "ERR_REQUIRE_ESM";
              throw error;
            }
          } catch (checkError) {
            if (checkError.code === "ERR_REQUIRE_ESM") {
              throw checkError;
            }
          }
          const result = originalRequire(moduleName);
          if (result && result.__esModule && result.default && !result.default.__esModule) {
            const error = new Error(
              `\u274C "${moduleName}" \u662F ES Module \u5305\uFF0C\u8BF7\u4F7F\u7528 await loadModule('${moduleName}') \u4EE3\u66FF require('${moduleName}')
\u{1F4A1} \u63D0\u793A\uFF1AloadModule \u4F1A\u81EA\u52A8\u68C0\u6D4B\u5305\u7C7B\u578B\u5E76\u6B63\u786E\u52A0\u8F7D`
            );
            error.code = "ERR_REQUIRE_ESM";
            throw error;
          }
          return result;
        };
        if (this.esModuleDependencies && this.esModuleDependencies.length > 0) {
          logger.debug(`[ToolSandbox] \u5DF2\u4E3A\u5DE5\u5177 ${this.toolId} \u542F\u7528 ES Module \u652F\u6301\uFF0C\u68C0\u6D4B\u5230 ${this.esModuleDependencies.length} \u4E2A ES Module \u4F9D\u8D56`);
        } else {
          logger.debug(`[ToolSandbox] \u5DF2\u4E3A\u5DE5\u5177 ${this.toolId} \u542F\u7528 importModule \u51FD\u6570`);
        }
        const script = new vm.Script(this.toolContent, { filename: `${this.toolId}.js` });
        const context = vm.createContext(this.sandboxContext);
        script.runInContext(context);
        const exported = context.module.exports;
        if (typeof exported === "function") {
          this.toolInstance = new exported();
        } else if (typeof exported === "object") {
          this.toolInstance = exported;
        }
      }
      /**
       * è§£æåè®®è·¯å¾„ï¼ˆæ”¯æŒ@project://ç­‰åè®®ï¼‰
       * @param {string} protocolPath - åè®®è·¯å¾„ï¼Œå¦‚@project://.promptx/cwd
       * @returns {Promise<string>} è§£æåçš„ç»å¯¹è·¯å¾„
       */
      async resolveProtocolPath(protocolPath) {
        if (!protocolPath) {
          throw new Error("protocolPath is required but was undefined");
        }
        if (protocolPath.startsWith("@project://")) {
          const { getGlobalProjectPathResolver } = require_ProjectPathResolver();
          const pathResolver = getGlobalProjectPathResolver();
          try {
            const relativePath = protocolPath.replace(/^@project:\/\//, "");
            const resolvedPath = pathResolver.resolvePath(relativePath);
            const fs2 = require("fs").promises;
            try {
              await fs2.access(resolvedPath);
            } catch (error) {
              if (error.code === "ENOENT") {
                await fs2.mkdir(resolvedPath, { recursive: true });
                logger.debug(`[ToolSandbox] Created unified working directory: ${resolvedPath}`);
              }
            }
            return resolvedPath;
          } catch (error) {
            throw new Error(`\u89E3\u6790@project://\u8DEF\u5F84\u5931\u8D25: ${error.message}`);
          }
        }
        if (protocolPath.startsWith("@")) {
          if (!this.resourceManager) {
            throw new Error("ResourceManager not set. Cannot resolve protocol path.");
          }
          throw new Error(`\u6682\u4E0D\u652F\u6301\u7684\u534F\u8BAE\u8DEF\u5F84: ${protocolPath}`);
        }
        return protocolPath;
      }
      /**
       * å‚æ•°éªŒè¯
       */
      async validateParameters(parameters) {
        var _a;
        if (typeof this.toolInstance.validate === "function") {
          const result = this.toolInstance.validate(parameters);
          if (typeof result === "boolean" && !result) {
            throw new Error("Parameter validation failed");
          } else if (result && typeof result === "object" && !result.valid) {
            throw new Error(`Parameter validation failed: ${(_a = result.errors) == null ? void 0 : _a.join(", ")}`);
          }
        }
      }
      /**
       * åœ¨æ²™ç®±ä¸­æ‰§è¡Œå·¥å…·
       */
      async executeInSandbox(parameters) {
        if (!this.toolInstance || typeof this.toolInstance.execute !== "function") {
          throw new Error(`Tool ${this.toolId} does not have execute method`);
        }
        return await this.toolInstance.execute(parameters);
      }
      /**
       * è·å–åˆ†æç»“æœ
       */
      getAnalysisResult() {
        var _a, _b, _c, _d;
        return {
          toolId: this.toolId,
          dependencies: this.dependencies,
          sandboxPath: (_a = this.directoryManager) == null ? void 0 : _a.getWorkingPath(),
          toolboxPath: (_b = this.directoryManager) == null ? void 0 : _b.getToolboxPath(),
          hasMetadata: typeof ((_c = this.toolInstance) == null ? void 0 : _c.getMetadata) === "function",
          hasSchema: typeof ((_d = this.toolInstance) == null ? void 0 : _d.getSchema) === "function"
        };
      }
      /**
       * æ¸…ç†æ²™ç®±èµ„æº
       */
      async cleanup() {
        if (this.isolationManager) {
          this.isolationManager.cleanup();
          this.isolationManager = null;
        }
        if (this.esModuleSupport) {
          this.esModuleSupport.clearCache();
          this.esModuleSupport = null;
        }
        this.sandboxContext = null;
        this.toolInstance = null;
        this.esModuleDependencies = null;
      }
      /**
       * è·å–å·¥å…·å…ƒä¿¡æ¯
       */
      getToolMetadata() {
        if (this.toolInstance && typeof this.toolInstance.getMetadata === "function") {
          return this.toolInstance.getMetadata();
        }
        return null;
      }
      /**
       * è·å–å·¥å…·Schema
       */
      getToolSchema() {
        if (this.toolInstance && typeof this.toolInstance.getSchema === "function") {
          return this.toolInstance.getSchema();
        }
        return null;
      }
    };
    module2.exports = ToolSandbox2;
  }
});

// src/toolx/ToolInterface.js
var require_ToolInterface = __commonJS({
  "src/toolx/ToolInterface.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var TOOL_INTERFACE2 = {
      // å¿…é¡»å®ç°çš„æ–¹æ³•
      required: [
        {
          name: "getMetadata",
          signature: "() => Object",
          description: "\u83B7\u53D6\u5DE5\u5177\u5143\u4FE1\u606F",
          returns: {
            name: "string - \u5DE5\u5177\u540D\u79F0",
            description: "string - \u5DE5\u5177\u63CF\u8FF0",
            version: "string - \u7248\u672C\u53F7",
            category: "string - \u5206\u7C7B\uFF08\u53EF\u9009\uFF09",
            author: "string - \u4F5C\u8005\uFF08\u53EF\u9009\uFF09"
          }
        },
        {
          name: "getSchema",
          signature: "() => Object",
          description: "\u83B7\u53D6\u53C2\u6570JSON Schema",
          returns: {
            type: "string - \u53C2\u6570\u7C7B\u578B\uFF0C\u901A\u5E38\u4E3Aobject",
            properties: "Object - \u53C2\u6570\u5C5E\u6027\u5B9A\u4E49",
            required: "Array - \u5FC5\u9700\u53C2\u6570\u5217\u8868\uFF08\u53EF\u9009\uFF09",
            additionalProperties: "boolean - \u662F\u5426\u5141\u8BB8\u989D\u5916\u53C2\u6570\uFF08\u53EF\u9009\uFF09"
          }
        },
        {
          name: "execute",
          signature: "(parameters: Object) => Promise<any>",
          description: "\u6267\u884C\u5DE5\u5177\u4E3B\u903B\u8F91",
          parameters: {
            parameters: "Object - \u5DE5\u5177\u53C2\u6570\uFF0C\u7B26\u5408getSchema\u5B9A\u4E49"
          },
          returns: "Promise<any> - \u5DE5\u5177\u6267\u884C\u7ED3\u679C"
        }
      ],
      // å¯é€‰å®ç°çš„æ–¹æ³•
      optional: [
        {
          name: "getPackage",
          signature: "() => Object",
          description: "\u83B7\u53D6\u5DE5\u5177\u5305\u4FE1\u606F\uFF08\u53EF\u9009\uFF0C\u7528\u4E8E\u4F9D\u8D56\u7BA1\u7406\uFF09",
          returns: {
            directory: "string - \u5DE5\u5177\u76EE\u5F55\u8DEF\u5F84",
            dependencies: "Object - \u4F9D\u8D56\u5BF9\u8C61\uFF0C\u683C\u5F0F\uFF1A{\u5305\u540D: \u7248\u672C}",
            packageJson: "Object - package.json\u5185\u5BB9\uFF08\u53EF\u9009\uFF09"
          }
        },
        {
          name: "validate",
          signature: "(parameters: Object) => Object",
          description: "\u9A8C\u8BC1\u53C2\u6570\uFF08\u53EF\u9009\uFF0C\u6709\u9ED8\u8BA4\u5B9E\u73B0\uFF09",
          parameters: {
            parameters: "Object - \u5F85\u9A8C\u8BC1\u53C2\u6570"
          },
          returns: {
            valid: "boolean - \u9A8C\u8BC1\u662F\u5426\u901A\u8FC7",
            errors: "Array<string> - \u9519\u8BEF\u4FE1\u606F\u5217\u8868"
          }
        },
        {
          name: "cleanup",
          signature: "() => void | Promise<void>",
          description: "\u6E05\u7406\u8D44\u6E90\uFF08\u53EF\u9009\uFF09",
          returns: "void | Promise<void>"
        },
        {
          name: "init",
          signature: "(config?: Object) => void | Promise<void>",
          description: "\u521D\u59CB\u5316\u5DE5\u5177\uFF08\u53EF\u9009\uFF09",
          parameters: {
            config: "Object - \u521D\u59CB\u5316\u914D\u7F6E\uFF08\u53EF\u9009\uFF09"
          },
          returns: "void | Promise<void>"
        }
      ]
    };
    var TOOL_ERROR_CODES2 = {
      VALIDATION_ERROR: "VALIDATION_ERROR",
      // å‚æ•°éªŒè¯å¤±è´¥
      EXECUTION_ERROR: "EXECUTION_ERROR",
      // æ‰§è¡Œé”™è¯¯
      TIMEOUT_ERROR: "TIMEOUT_ERROR",
      // è¶…æ—¶é”™è¯¯
      PERMISSION_ERROR: "PERMISSION_ERROR",
      // æƒé™é”™è¯¯
      RESOURCE_ERROR: "RESOURCE_ERROR",
      // èµ„æºé”™è¯¯
      CONFIGURATION_ERROR: "CONFIGURATION_ERROR"
      // é…ç½®é”™è¯¯
    };
    var TOOL_RESULT_FORMAT2 = {
      success: {
        success: true,
        data: "any - \u5DE5\u5177\u8FD4\u56DE\u7684\u5B9E\u9645\u6570\u636E",
        metadata: {
          tool: "string - \u5DE5\u5177\u540D\u79F0",
          executionTime: "string - \u6267\u884C\u65F6\u95F4",
          timestamp: "string - \u65F6\u95F4\u6233"
          // ...å…¶ä»–å…ƒä¿¡æ¯
        }
      },
      error: {
        success: false,
        error: {
          code: "string - \u9519\u8BEF\u4EE3\u7801\uFF08\u89C1TOOL_ERROR_CODES\uFF09",
          message: "string - \u9519\u8BEF\u6D88\u606F",
          details: "Object - \u9519\u8BEF\u8BE6\u60C5\uFF08\u53EF\u9009\uFF09"
        },
        metadata: {
          tool: "string - \u5DE5\u5177\u540D\u79F0",
          timestamp: "string - \u65F6\u95F4\u6233"
          // ...å…¶ä»–å…ƒä¿¡æ¯
        }
      }
    };
    var EXAMPLE_TOOL2 = `
class ExampleTool {
  getMetadata() {
    return {
      name: 'example-tool',
      description: '\u793A\u4F8B\u5DE5\u5177',
      version: '1.0.0',
      category: 'example',
      author: 'PromptX Team'
    };
  }

  getSchema() {
    return {
      type: 'object',
      properties: {
        input: {
          type: 'string',
          description: '\u8F93\u5165\u53C2\u6570'
        }
      },
      required: ['input'],
      additionalProperties: false
    };
  }

  async execute(parameters) {
    const { input } = parameters;
    
    // \u5DE5\u5177\u903B\u8F91
    const result = \`\u5904\u7406\u7ED3\u679C: \${input}\`;
    
    return result;
  }

  // \u53EF\u9009\uFF1A\u58F0\u660E\u4F9D\u8D56\uFF08\u65B0\u683C\u5F0F\uFF1A\u5BF9\u8C61\uFF09
  getDependencies() {
    return {
      'lodash': '^4.17.21',
      'axios': '^1.6.0'
    };
  }

  // \u53EF\u9009\uFF1A\u81EA\u5B9A\u4E49\u53C2\u6570\u9A8C\u8BC1
  validate(parameters) {
    const errors = [];
    
    if (!parameters.input || parameters.input.trim() === '') {
      errors.push('input\u4E0D\u80FD\u4E3A\u7A7A');
    }
    
    return { valid: errors.length === 0, errors };
  }

  // \u53EF\u9009\uFF1A\u6E05\u7406\u8D44\u6E90
  cleanup() {
    console.log('\u6E05\u7406\u8D44\u6E90');
  }
}

module.exports = ExampleTool;
`;
    module2.exports = {
      TOOL_INTERFACE: TOOL_INTERFACE2,
      TOOL_ERROR_CODES: TOOL_ERROR_CODES2,
      TOOL_RESULT_FORMAT: TOOL_RESULT_FORMAT2,
      EXAMPLE_TOOL: EXAMPLE_TOOL2
    };
  }
});

// src/toolx/ToolValidator.js
var require_ToolValidator = __commonJS({
  "src/toolx/ToolValidator.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var { TOOL_INTERFACE: TOOL_INTERFACE2, TOOL_ERROR_CODES: TOOL_ERROR_CODES2 } = require_ToolInterface();
    var ToolValidator2 = class {
      /**
       * éªŒè¯å·¥å…·æ˜¯å¦ç¬¦åˆæ¥å£è§„èŒƒ
       * @param {any} tool - å¾…éªŒè¯çš„å·¥å…·å¯¹è±¡
       * @returns {Object} éªŒè¯ç»“æœ {valid: boolean, errors: [], warnings: []}
       */
      static validateTool(tool) {
        const errors = [];
        const warnings = [];
        if (!tool || typeof tool !== "object") {
          errors.push("\u5DE5\u5177\u5FC5\u987B\u662F\u5BF9\u8C61\u7C7B\u578B");
          return { valid: false, errors, warnings };
        }
        for (const methodSpec of TOOL_INTERFACE2.required) {
          const methodName = methodSpec.name;
          if (!(methodName in tool)) {
            errors.push(`\u7F3A\u5C11\u5FC5\u9700\u65B9\u6CD5: ${methodName}`);
            continue;
          }
          if (typeof tool[methodName] !== "function") {
            errors.push(`${methodName} \u5FC5\u987B\u662F\u51FD\u6570\u7C7B\u578B`);
            continue;
          }
          try {
            const validationResult = this.validateMethod(tool, methodSpec);
            if (!validationResult.valid) {
              errors.push(...validationResult.errors);
              warnings.push(...validationResult.warnings);
            }
          } catch (error) {
            warnings.push(`${methodName} \u65B9\u6CD5\u9A8C\u8BC1\u65F6\u51FA\u9519: ${error.message}`);
          }
        }
        for (const methodSpec of TOOL_INTERFACE2.optional) {
          const methodName = methodSpec.name;
          if (methodName in tool) {
            if (typeof tool[methodName] !== "function") {
              warnings.push(`${methodName} \u5E94\u8BE5\u662F\u51FD\u6570\u7C7B\u578B`);
            } else {
              try {
                const validationResult = this.validateMethod(tool, methodSpec);
                if (!validationResult.valid) {
                  warnings.push(...validationResult.errors);
                }
              } catch (error) {
                warnings.push(`${methodName} \u65B9\u6CD5\u9A8C\u8BC1\u65F6\u51FA\u9519: ${error.message}`);
              }
            }
          }
        }
        return {
          valid: errors.length === 0,
          errors,
          warnings
        };
      }
      /**
       * éªŒè¯ç‰¹å®šæ–¹æ³•
       * @param {Object} tool - å·¥å…·å¯¹è±¡
       * @param {Object} methodSpec - æ–¹æ³•è§„èŒƒ
       * @returns {Object} éªŒè¯ç»“æœ
       */
      static validateMethod(tool, methodSpec) {
        const errors = [];
        const warnings = [];
        const methodName = methodSpec.name;
        try {
          switch (methodName) {
            case "getMetadata":
              return this.validateGetMetadata(tool);
            case "getSchema":
              return this.validateGetSchema(tool);
            case "execute":
              return this.validateExecute(tool);
            case "validate":
              return this.validateValidateMethod(tool);
            default:
              return { valid: true, errors: [], warnings: [] };
          }
        } catch (error) {
          errors.push(`${methodName} \u65B9\u6CD5\u8C03\u7528\u5931\u8D25: ${error.message}`);
          return { valid: false, errors, warnings };
        }
      }
      /**
       * éªŒè¯getMetadataæ–¹æ³•
       * @param {Object} tool - å·¥å…·å¯¹è±¡
       * @returns {Object} éªŒè¯ç»“æœ
       */
      static validateGetMetadata(tool) {
        const errors = [];
        const warnings = [];
        try {
          const metadata = tool.getMetadata();
          if (!metadata || typeof metadata !== "object") {
            errors.push("getMetadata() \u5FC5\u987B\u8FD4\u56DE\u5BF9\u8C61");
            return { valid: false, errors, warnings };
          }
          if (!metadata.name || typeof metadata.name !== "string") {
            errors.push("metadata.name \u5FC5\u987B\u662F\u975E\u7A7A\u5B57\u7B26\u4E32");
          }
          if (!metadata.description || typeof metadata.description !== "string") {
            errors.push("metadata.description \u5FC5\u987B\u662F\u975E\u7A7A\u5B57\u7B26\u4E32");
          }
          if (!metadata.version || typeof metadata.version !== "string") {
            errors.push("metadata.version \u5FC5\u987B\u662F\u975E\u7A7A\u5B57\u7B26\u4E32");
          }
          if (metadata.category && typeof metadata.category !== "string") {
            warnings.push("metadata.category \u5E94\u8BE5\u662F\u5B57\u7B26\u4E32\u7C7B\u578B");
          }
          if (metadata.author && typeof metadata.author !== "string") {
            warnings.push("metadata.author \u5E94\u8BE5\u662F\u5B57\u7B26\u4E32\u7C7B\u578B");
          }
        } catch (error) {
          errors.push(`getMetadata() \u6267\u884C\u5931\u8D25: ${error.message}`);
        }
        return { valid: errors.length === 0, errors, warnings };
      }
      /**
       * éªŒè¯getSchemaæ–¹æ³•
       * @param {Object} tool - å·¥å…·å¯¹è±¡
       * @returns {Object} éªŒè¯ç»“æœ
       */
      static validateGetSchema(tool) {
        const errors = [];
        const warnings = [];
        try {
          const schema = tool.getSchema();
          if (!schema || typeof schema !== "object") {
            errors.push("getSchema() \u5FC5\u987B\u8FD4\u56DE\u5BF9\u8C61");
            return { valid: false, errors, warnings };
          }
          if (!schema.type) {
            warnings.push("schema.type \u5EFA\u8BAE\u5B9A\u4E49");
          }
          if (schema.type && typeof schema.type !== "string") {
            errors.push("schema.type \u5FC5\u987B\u662F\u5B57\u7B26\u4E32");
          }
          if (schema.properties && typeof schema.properties !== "object") {
            errors.push("schema.properties \u5FC5\u987B\u662F\u5BF9\u8C61");
          }
          if (schema.required && !Array.isArray(schema.required)) {
            errors.push("schema.required \u5FC5\u987B\u662F\u6570\u7EC4");
          }
        } catch (error) {
          errors.push(`getSchema() \u6267\u884C\u5931\u8D25: ${error.message}`);
        }
        return { valid: errors.length === 0, errors, warnings };
      }
      /**
       * éªŒè¯executeæ–¹æ³•
       * @param {Object} tool - å·¥å…·å¯¹è±¡
       * @returns {Object} éªŒè¯ç»“æœ
       */
      static validateExecute(tool) {
        const errors = [];
        const warnings = [];
        const executeMethod = tool.execute;
        if (executeMethod.length === 0) {
          warnings.push("execute() \u65B9\u6CD5\u5EFA\u8BAE\u63A5\u53D7parameters\u53C2\u6570");
        }
        return { valid: errors.length === 0, errors, warnings };
      }
      /**
       * éªŒè¯validateæ–¹æ³•ï¼ˆå¯é€‰ï¼‰
       * @param {Object} tool - å·¥å…·å¯¹è±¡
       * @returns {Object} éªŒè¯ç»“æœ
       */
      static validateValidateMethod(tool) {
        const errors = [];
        const warnings = [];
        try {
          const testParams = {};
          const result = tool.validate(testParams);
          if (!result || typeof result !== "object") {
            errors.push("validate() \u5FC5\u987B\u8FD4\u56DE\u5BF9\u8C61");
            return { valid: false, errors, warnings };
          }
          if (typeof result.valid !== "boolean") {
            errors.push("validate() \u8FD4\u56DE\u503C\u5FC5\u987B\u5305\u542Bvalid(boolean)\u5B57\u6BB5");
          }
          if (result.errors && !Array.isArray(result.errors)) {
            errors.push("validate() \u8FD4\u56DE\u503C\u7684errors\u5B57\u6BB5\u5FC5\u987B\u662F\u6570\u7EC4");
          }
        } catch (error) {
          warnings.push(`validate() \u65B9\u6CD5\u6D4B\u8BD5\u5931\u8D25: ${error.message}`);
        }
        return { valid: errors.length === 0, errors, warnings };
      }
      /**
       * ä¸ºå·¥å…·æä¾›é»˜è®¤çš„validateæ–¹æ³•å®ç°
       * @param {Object} tool - å·¥å…·å¯¹è±¡
       * @param {Object} parameters - å¾…éªŒè¯å‚æ•°
       * @returns {Object} éªŒè¯ç»“æœ
       */
      static defaultValidate(tool, parameters) {
        const errors = [];
        try {
          const schema = tool.getSchema();
          if (!parameters || typeof parameters !== "object") {
            errors.push("\u53C2\u6570\u5FC5\u987B\u662F\u5BF9\u8C61\u7C7B\u578B");
            return { valid: false, errors };
          }
          if (schema.required && Array.isArray(schema.required)) {
            for (const field of schema.required) {
              if (!(field in parameters)) {
                errors.push(`\u7F3A\u5C11\u5FC5\u9700\u53C2\u6570: ${field}`);
              }
            }
          }
          if (schema.properties && typeof schema.properties === "object") {
            for (const [field, fieldSchema] of Object.entries(schema.properties)) {
              if (field in parameters) {
                const value = parameters[field];
                const expectedType = fieldSchema.type;
                if (expectedType && !this.validateType(value, expectedType)) {
                  errors.push(`\u53C2\u6570 ${field} \u7C7B\u578B\u9519\u8BEF\uFF0C\u671F\u671B ${expectedType}\uFF0C\u5B9E\u9645 ${typeof value}`);
                }
              }
            }
          }
        } catch (error) {
          errors.push(`\u53C2\u6570\u9A8C\u8BC1\u5931\u8D25: ${error.message}`);
        }
        return { valid: errors.length === 0, errors };
      }
      /**
       * ç±»å‹éªŒè¯è¾…åŠ©æ–¹æ³•
       * @param {*} value - å¾…éªŒè¯å€¼
       * @param {string} expectedType - æœŸæœ›ç±»å‹
       * @returns {boolean} æ˜¯å¦åŒ¹é…
       */
      static validateType(value, expectedType) {
        switch (expectedType) {
          case "string":
            return typeof value === "string";
          case "number":
            return typeof value === "number";
          case "boolean":
            return typeof value === "boolean";
          case "object":
            return typeof value === "object" && value !== null;
          case "array":
            return Array.isArray(value);
          default:
            return true;
        }
      }
      /**
       * ç”Ÿæˆå·¥å…·æ¥å£æŠ¥å‘Š
       * @param {Object} tool - å·¥å…·å¯¹è±¡
       * @returns {Object} æ¥å£æŠ¥å‘Š
       */
      static generateInterfaceReport(tool) {
        const validation = this.validateTool(tool);
        const report = {
          toolName: "unknown",
          valid: validation.valid,
          errors: validation.errors,
          warnings: validation.warnings,
          implementedMethods: {
            required: [],
            optional: []
          },
          metadata: null,
          schema: null
        };
        try {
          if (tool.getMetadata) {
            const metadata = tool.getMetadata();
            report.toolName = metadata.name || "unknown";
            report.metadata = metadata;
          }
          if (tool.getSchema) {
            report.schema = tool.getSchema();
          }
          for (const methodSpec of TOOL_INTERFACE2.required) {
            if (typeof tool[methodSpec.name] === "function") {
              report.implementedMethods.required.push(methodSpec.name);
            }
          }
          for (const methodSpec of TOOL_INTERFACE2.optional) {
            if (typeof tool[methodSpec.name] === "function") {
              report.implementedMethods.optional.push(methodSpec.name);
            }
          }
        } catch (error) {
          report.warnings.push(`\u751F\u6210\u62A5\u544A\u65F6\u51FA\u9519: ${error.message}`);
        }
        return report;
      }
    };
    module2.exports = ToolValidator2;
  }
});

// src/toolx/ToolUtils.js
var require_ToolUtils = __commonJS({
  "src/toolx/ToolUtils.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var ToolValidator2 = require_ToolValidator();
    var { TOOL_ERROR_CODES: TOOL_ERROR_CODES2, TOOL_RESULT_FORMAT: TOOL_RESULT_FORMAT2 } = require_ToolInterface();
    var ToolUtils2 = class {
      /**
       * åˆ›å»ºæ ‡å‡†åŒ–çš„æˆåŠŸç»“æœ
       * @param {*} data - ç»“æœæ•°æ®
       * @param {Object} options - é€‰é¡¹
       * @returns {Object} æ ‡å‡†åŒ–ç»“æœ
       */
      static createSuccessResult(data, options = {}) {
        const {
          tool = "unknown",
          executionTime = null,
          metadata = {}
        } = options;
        return {
          success: true,
          data,
          metadata: {
            tool,
            executionTime,
            timestamp: (/* @__PURE__ */ new Date()).toISOString(),
            ...metadata
          }
        };
      }
      /**
       * åˆ›å»ºæ ‡å‡†åŒ–çš„é”™è¯¯ç»“æœ
       * @param {string} code - é”™è¯¯ä»£ç 
       * @param {string} message - é”™è¯¯æ¶ˆæ¯
       * @param {Object} options - é€‰é¡¹
       * @returns {Object} æ ‡å‡†åŒ–é”™è¯¯
       */
      static createErrorResult(code, message, options = {}) {
        const {
          tool = "unknown",
          details = {},
          metadata = {}
        } = options;
        return {
          success: false,
          error: {
            code,
            message,
            details
          },
          metadata: {
            tool,
            timestamp: (/* @__PURE__ */ new Date()).toISOString(),
            ...metadata
          }
        };
      }
      /**
       * éªŒè¯å·¥å…·ç»“æœæ ¼å¼
       * @param {Object} result - å·¥å…·ç»“æœ
       * @returns {Object} éªŒè¯ç»“æœ
       */
      static validateResult(result) {
        const errors = [];
        if (!result || typeof result !== "object") {
          errors.push("\u7ED3\u679C\u5FC5\u987B\u662F\u5BF9\u8C61\u7C7B\u578B");
          return { valid: false, errors };
        }
        if (typeof result.success !== "boolean") {
          errors.push("\u7ED3\u679C\u5FC5\u987B\u5305\u542Bsuccess(boolean)\u5B57\u6BB5");
        }
        if (result.success) {
          if (!("data" in result)) {
            errors.push("\u6210\u529F\u7ED3\u679C\u5FC5\u987B\u5305\u542Bdata\u5B57\u6BB5");
          }
        } else {
          if (!result.error || typeof result.error !== "object") {
            errors.push("\u9519\u8BEF\u7ED3\u679C\u5FC5\u987B\u5305\u542Berror(object)\u5B57\u6BB5");
          } else {
            if (!result.error.code || typeof result.error.code !== "string") {
              errors.push("\u9519\u8BEF\u7ED3\u679C\u5FC5\u987B\u5305\u542Berror.code(string)\u5B57\u6BB5");
            }
            if (!result.error.message || typeof result.error.message !== "string") {
              errors.push("\u9519\u8BEF\u7ED3\u679C\u5FC5\u987B\u5305\u542Berror.message(string)\u5B57\u6BB5");
            }
          }
        }
        return { valid: errors.length === 0, errors };
      }
      /**
       * å®‰å…¨åœ°æ‰§è¡Œå·¥å…·æ–¹æ³•
       * @param {Object} tool - å·¥å…·å®ä¾‹
       * @param {string} methodName - æ–¹æ³•å
       * @param {...any} args - æ–¹æ³•å‚æ•°
       * @returns {Promise<*>} æ‰§è¡Œç»“æœ
       */
      static async safeExecute(tool, methodName, ...args) {
        try {
          if (!tool || typeof tool[methodName] !== "function") {
            throw new Error(`\u5DE5\u5177\u4E0D\u5B58\u5728\u65B9\u6CD5: ${methodName}`);
          }
          const result = await tool[methodName](...args);
          return result;
        } catch (error) {
          throw new Error(`\u65B9\u6CD5\u6267\u884C\u5931\u8D25 ${methodName}: ${error.message}`);
        }
      }
      /**
       * å·¥å…·æ€§èƒ½åˆ†æ
       * @param {Object} tool - å·¥å…·å®ä¾‹
       * @param {Object} parameters - æµ‹è¯•å‚æ•°
       * @param {Object} options - é€‰é¡¹
       * @returns {Promise<Object>} æ€§èƒ½åˆ†æç»“æœ
       */
      static async benchmarkTool(tool, parameters = {}, options = {}) {
        const {
          iterations = 10,
          warmup = 3
        } = options;
        const results = {
          toolName: "unknown",
          iterations,
          warmup,
          times: [],
          stats: {}
        };
        try {
          if (tool.getMetadata) {
            const metadata = tool.getMetadata();
            results.toolName = metadata.name || "unknown";
          }
          const validation = ToolValidator2.validateTool(tool);
          if (!validation.valid) {
            throw new Error(`\u5DE5\u5177\u63A5\u53E3\u9A8C\u8BC1\u5931\u8D25: ${validation.errors.join(", ")}`);
          }
          for (let i = 0; i < warmup; i++) {
            await tool.execute(parameters);
          }
          for (let i = 0; i < iterations; i++) {
            const startTime = process.hrtime.bigint();
            await tool.execute(parameters);
            const endTime = process.hrtime.bigint();
            const executionTime = Number(endTime - startTime) / 1e6;
            results.times.push(executionTime);
          }
          results.stats = this.calculateStats(results.times);
        } catch (error) {
          results.error = error.message;
        }
        return results;
      }
      /**
       * è®¡ç®—ç»Ÿè®¡ä¿¡æ¯
       * @param {Array<number>} times - æ—¶é—´æ•°ç»„
       * @returns {Object} ç»Ÿè®¡ä¿¡æ¯
       */
      static calculateStats(times) {
        if (times.length === 0) {
          return {};
        }
        const sorted = [...times].sort((a, b) => a - b);
        const sum = times.reduce((a, b) => a + b, 0);
        return {
          count: times.length,
          min: Math.min(...times),
          max: Math.max(...times),
          mean: sum / times.length,
          median: sorted[Math.floor(sorted.length / 2)],
          p95: sorted[Math.floor(sorted.length * 0.95)],
          p99: sorted[Math.floor(sorted.length * 0.99)]
        };
      }
      /**
       * ç”Ÿæˆå·¥å…·æ¨¡æ¿ä»£ç 
       * @param {Object} options - å·¥å…·é€‰é¡¹
       * @returns {string} å·¥å…·æ¨¡æ¿ä»£ç 
       */
      static generateToolTemplate(options = {}) {
        const {
          toolName = "ExampleTool",
          className = "ExampleTool",
          description = "\u793A\u4F8B\u5DE5\u5177",
          category = "utility",
          author = "PromptX Developer"
        } = options;
        return `/**
 * ${className} - ${description}
 * \u4F7F\u7528PromptX\u9E2D\u5B50\u7C7B\u578B\u63A5\u53E3\uFF0C\u65E0\u9700\u7EE7\u627F\u4EFB\u4F55\u57FA\u7C7B
 */
class ${className} {
  getMetadata() {
    return {
      name: '${toolName}',
      description: '${description}',
      version: '1.0.0',
      category: '${category}',
      author: '${author}'
    };
  }

  getSchema() {
    return {
      type: 'object',
      properties: {
        input: {
          type: 'string',
          description: '\u8F93\u5165\u53C2\u6570'
        }
      },
      required: ['input'],
      additionalProperties: false
    };
  }

  async execute(parameters) {
    const { input } = parameters;
    
    try {
      // TODO: \u5B9E\u73B0\u5DE5\u5177\u903B\u8F91
      const result = \`\u5904\u7406\u7ED3\u679C: \${input}\`;
      
      return result;
    } catch (error) {
      throw new Error(\`\u6267\u884C\u5931\u8D25: \${error.message}\`);
    }
  }

  // \u53EF\u9009\uFF1A\u81EA\u5B9A\u4E49\u53C2\u6570\u9A8C\u8BC1
  validate(parameters) {
    const errors = [];
    
    if (!parameters.input || parameters.input.trim() === '') {
      errors.push('input\u4E0D\u80FD\u4E3A\u7A7A');
    }
    
    return { valid: errors.length === 0, errors };
  }

  // \u53EF\u9009\uFF1A\u6E05\u7406\u8D44\u6E90
  cleanup() {
    // \u6E05\u7406\u903B\u8F91
  }
}

module.exports = ${className};
`;
      }
      /**
       * åˆ›å»ºå·¥å…·å¼€å‘æŒ‡å—
       * @returns {string} å¼€å‘æŒ‡å—
       */
      static getDevGuide() {
        return `
# PromptX Tool \u5F00\u53D1\u6307\u5357

## \u9E2D\u5B50\u7C7B\u578B\u63A5\u53E3
PromptX\u5DE5\u5177\u4F7F\u7528\u9E2D\u5B50\u7C7B\u578B\u8BBE\u8BA1\uFF0C\u65E0\u9700\u7EE7\u627F\u4EFB\u4F55\u57FA\u7C7B\u3002\u53EA\u9700\u5B9E\u73B0\u4EE5\u4E0B\u63A5\u53E3\uFF1A

### \u5FC5\u9700\u65B9\u6CD5
1. \`getMetadata()\` - \u8FD4\u56DE\u5DE5\u5177\u5143\u4FE1\u606F
2. \`getSchema()\` - \u8FD4\u56DE\u53C2\u6570JSON Schema
3. \`execute(parameters)\` - \u6267\u884C\u5DE5\u5177\u903B\u8F91

### \u53EF\u9009\u65B9\u6CD5
1. \`validate(parameters)\` - \u81EA\u5B9A\u4E49\u53C2\u6570\u9A8C\u8BC1
2. \`cleanup()\` - \u6E05\u7406\u8D44\u6E90
3. \`init(config)\` - \u521D\u59CB\u5316\u5DE5\u5177

## \u5F00\u53D1\u6B65\u9AA4
1. \u4F7F\u7528 ToolUtils.generateToolTemplate() \u751F\u6210\u6A21\u677F
2. \u5B9E\u73B0\u5FC5\u9700\u7684\u63A5\u53E3\u65B9\u6CD5
3. \u4F7F\u7528 ToolValidator.validateTool() \u9A8C\u8BC1\u63A5\u53E3
4. \u4F7F\u7528 ToolUtils.benchmarkTool() \u6027\u80FD\u6D4B\u8BD5
5. \u6CE8\u518C\u5230\u5DE5\u5177\u6CE8\u518C\u8868

## \u793A\u4F8B\u4EE3\u7801
\`\`\`javascript
${this.generateToolTemplate()}
\`\`\`

## \u6700\u4F73\u5B9E\u8DF5
- \u4FDD\u6301execute\u65B9\u6CD5\u7684\u5E42\u7B49\u6027
- \u63D0\u4F9B\u6E05\u6670\u7684\u9519\u8BEF\u6D88\u606F
- \u4F7F\u7528\u5408\u9002\u7684JSON Schema\u9A8C\u8BC1
- \u5B9E\u73B0\u9002\u5F53\u7684\u8D44\u6E90\u6E05\u7406
- \u9075\u5FAA\u7EDF\u4E00\u7684\u7ED3\u679C\u683C\u5F0F
`;
      }
    };
    module2.exports = ToolUtils2;
  }
});

// src/toolx/index.js
init_cjs_shims();
var ToolSandbox = require_ToolSandbox();
var ToolValidator = require_ToolValidator();
var ToolUtils = require_ToolUtils();
var { TOOL_INTERFACE, TOOL_ERROR_CODES, TOOL_RESULT_FORMAT, EXAMPLE_TOOL } = require_ToolInterface();
var globalSandbox = null;
function getGlobalToolSandbox(toolResource) {
  return new ToolSandbox(toolResource);
}
function initialize(options = {}) {
  try {
    return {
      success: true,
      message: "ToolSandbox\u5DE5\u5177\u6846\u67B6\u521D\u59CB\u5316\u6210\u529F",
      framework: {
        executor: "ToolSandbox",
        version: "2.0.0",
        features: [
          "\u81EA\u52A8\u4F9D\u8D56\u7BA1\u7406",
          "\u6C99\u7BB1\u9694\u79BB\u6267\u884C",
          "\u4E09\u9636\u6BB5\u6267\u884C\u6D41\u7A0B",
          "pnpm\u96C6\u6210"
        ]
      }
    };
  } catch (error) {
    return {
      success: false,
      message: `\u5DE5\u5177\u6846\u67B6\u521D\u59CB\u5316\u5931\u8D25: ${error.message}`,
      error
    };
  }
}
async function executeTool(toolResource, parameters = {}, resourceManager = null) {
  if (!resourceManager) {
    throw new Error("ResourceManager is required for ToolSandbox execution");
  }
  const sandbox = getGlobalToolSandbox(toolResource);
  sandbox.setResourceManager(resourceManager);
  try {
    await sandbox.analyze();
    await sandbox.prepareDependencies();
    return await sandbox.execute(parameters);
  } finally {
    await sandbox.cleanup();
  }
}
function reset() {
  globalSandbox = null;
}
function getStats() {
  return {
    framework: {
      name: "PromptX ToolSandbox Framework",
      version: "2.0.0",
      executor: "ToolSandbox",
      features: [
        "\u81EA\u52A8\u4F9D\u8D56\u7BA1\u7406",
        "\u6C99\u7BB1\u9694\u79BB\u6267\u884C",
        "\u4E09\u9636\u6BB5\u6267\u884C\u6D41\u7A0B",
        "pnpm\u96C6\u6210",
        "@tool://\u534F\u8BAE\u652F\u6301"
      ]
    }
  };
}
module.exports = {
  // æ ¸å¿ƒç±»
  ToolSandbox,
  ToolValidator,
  ToolUtils,
  // æ¥å£è§„èŒƒ
  TOOL_INTERFACE,
  TOOL_ERROR_CODES,
  TOOL_RESULT_FORMAT,
  EXAMPLE_TOOL,
  // å…¨å±€å®ä¾‹è·å–å™¨
  getGlobalToolSandbox,
  // ä¾¿æ·æ–¹æ³•
  initialize,
  executeTool,
  reset,
  getStats
};
//# sourceMappingURL=toolx.js.map