{"version":3,"sources":["../src/index.ts"],"sourcesContent":["import * as path from 'path'\nimport * as fs from 'fs'\nimport { promises as fsPromises } from 'fs'\nimport type { Resource, ResourceRegistry, ResourcePackage } from './types'\n\nconst logger = require('@promptx/logger')\n\n// electron-util - 解决ASAR打包后的路径问题\nlet fixPathForAsarUnpack: ((path: string) => string) | undefined\ntry {\n  // 只在Electron环境中加载electron-util\n  if (process.versions && process.versions.electron) {\n    const electronUtil = require('electron-util')\n    fixPathForAsarUnpack = electronUtil.fixPathForAsarUnpack\n  }\n} catch (error) {\n  // 如果不在Electron环境中或electron-util未安装，使用空函数\n  fixPathForAsarUnpack = undefined\n}\n\n/**\n * PackageResource - 统一的包资源访问管理器\n * 自动处理所有路径问题（ASAR、跨平台等）\n */\nclass PackageResource {\n  private baseDir: string\n\n  constructor() {\n    this.baseDir = __dirname\n  }\n\n  /**\n   * 解析资源路径 - 自动处理ASAR路径转换\n   * @param {string} resourcePath - 相对于包根目录的资源路径\n   * @returns {string} 解析后的绝对路径\n   */\n  resolvePath(resourcePath: string): string {\n    const basePath = path.join(this.baseDir, resourcePath)\n    \n    // 在Electron环境中，自动处理ASAR路径\n    if (fixPathForAsarUnpack) {\n      return fixPathForAsarUnpack(basePath)\n    }\n    \n    return basePath\n  }\n\n  /**\n   * 检查资源是否存在\n   * @param {string} resourcePath - 资源路径\n   * @returns {boolean} 资源是否存在\n   */\n  exists(resourcePath: string): boolean {\n    try {\n      const resolvedPath = this.resolvePath(resourcePath)\n      return fs.existsSync(resolvedPath)\n    } catch (error) {\n      return false\n    }\n  }\n\n  /**\n   * 异步检查资源是否存在\n   * @param {string} resourcePath - 资源路径\n   * @returns {Promise<boolean>} 资源是否存在\n   */\n  async existsAsync(resourcePath: string): Promise<boolean> {\n    try {\n      const resolvedPath = this.resolvePath(resourcePath)\n      await fsPromises.access(resolvedPath)\n      return true\n    } catch (error) {\n      return false\n    }\n  }\n\n  /**\n   * 加载资源内容\n   * @param {string} resourcePath - 资源路径\n   * @returns {Promise<{content: string, metadata: object}>} 资源内容和元数据\n   */\n  async loadContent(resourcePath: string): Promise<{\n    content: string\n    metadata: {\n      path: string\n      size: number\n      lastModified: Date\n      relativePath: string\n    }\n  }> {\n    const resolvedPath = this.resolvePath(resourcePath)\n    \n    try {\n      const content = await fsPromises.readFile(resolvedPath, 'utf8')\n      const stats = await fsPromises.stat(resolvedPath)\n      \n      return {\n        content,\n        metadata: {\n          path: resolvedPath,\n          size: content.length,\n          lastModified: stats.mtime,\n          relativePath: resourcePath\n        }\n      }\n    } catch (error: any) {\n      if (error.code === 'ENOENT') {\n        throw new Error(`Resource not found: ${resourcePath} (resolved: ${resolvedPath})`)\n      }\n      throw new Error(`Failed to load resource: ${error.message}`)\n    }\n  }\n\n  /**\n   * 同步加载资源内容\n   * @param {string} resourcePath - 资源路径\n   * @returns {string} 资源内容\n   */\n  loadContentSync(resourcePath: string): string {\n    const resolvedPath = this.resolvePath(resourcePath)\n    \n    try {\n      return fs.readFileSync(resolvedPath, 'utf8')\n    } catch (error: any) {\n      if (error.code === 'ENOENT') {\n        throw new Error(`Resource not found: ${resourcePath} (resolved: ${resolvedPath})`)\n      }\n      throw new Error(`Failed to load resource: ${error.message}`)\n    }\n  }\n\n  /**\n   * 便捷方法 - 加载角色资源\n   * @param {string} roleName - 角色名称\n   * @returns {Promise<{content: string, metadata: object}>} 角色资源\n   */\n  async loadRole(roleName: string) {\n    return this.loadContent(`resources/role/${roleName}/${roleName}.role.md`)\n  }\n\n  /**\n   * 便捷方法 - 加载工具资源\n   * @param {string} toolName - 工具名称\n   * @returns {Promise<{content: string, metadata: object}>} 工具资源\n   */\n  async loadTool(toolName: string) {\n    return this.loadContent(`resources/tool/${toolName}/${toolName}.tool.md`)\n  }\n\n  /**\n   * 便捷方法 - 加载手册资源\n   * @param {string} manualName - 手册名称\n   * @returns {Promise<{content: string, metadata: object}>} 手册资源\n   */\n  async loadManual(manualName: string) {\n    return this.loadContent(`resources/manual/${manualName}/${manualName}.manual.md`)\n  }\n}\n\n// 包根目录 - 构建后的 dist 目录就是包根目录\nconst packageRoot = __dirname\n\n// 注册表路径 - 直接从当前目录（dist/）读取，在Electron环境中处理ASAR路径\nlet registryPath = path.join(__dirname, 'registry.json')\nif (fixPathForAsarUnpack) {\n  registryPath = fixPathForAsarUnpack(registryPath)\n}\n\n// 加载注册表\nlet registry: ResourceRegistry\n\ntry {\n  if (fs.existsSync(registryPath)) {\n    const content = fs.readFileSync(registryPath, 'utf-8')\n    registry = JSON.parse(content) as ResourceRegistry\n    \n    // 验证版本\n    if (registry.version !== '2.0.0') {\n      throw new Error(`Unsupported registry version: ${registry.version}`)\n    }\n  } else {\n    throw new Error('Registry file not found')\n  }\n} catch (error: any) {\n  logger.error('[@promptx/resource] Failed to load registry:', error.message)\n  logger.error('[@promptx/resource] Registry path:', registryPath)\n  logger.error('[@promptx/resource] __dirname:', __dirname)\n  throw new Error(`@promptx/resource package is corrupted: ${error.message}`)\n}\n\n/**\n * 获取资源的绝对路径\n */\nexport function getResourcePath(relativePath: string): string {\n  // 处理相对路径\n  if (!relativePath.startsWith('resources/')) {\n    relativePath = `resources/${relativePath}`\n  }\n  return path.join(packageRoot, relativePath)\n}\n\n/**\n * 根据 ID 查找资源\n */\nexport function findResourceById(id: string): Resource | undefined {\n  if (!registry || !Array.isArray(registry.resources)) return undefined\n  return registry.resources.find(r => r.id === id)\n}\n\n/**\n * 根据协议类型获取资源列表\n */\nexport function getResourcesByProtocol(protocol: string): Resource[] {\n  if (!registry || !Array.isArray(registry.resources)) return []\n  return registry.resources.filter(r => r.protocol === protocol)\n}\n\n/**\n * 获取所有资源列表\n */\nexport function getAllResources(): Resource[] {\n  if (!registry || !Array.isArray(registry.resources)) return []\n  return registry.resources\n}\n\n// 导出单例实例\nconst packageResource = new PackageResource()\n\n// 导出包信息\nconst resourcePackage: ResourcePackage = {\n  registry,\n  getResourcePath,\n  findResourceById,\n  getResourcesByProtocol,\n  getAllResources\n}\n\n// CommonJS 导出（兼容性）\nmodule.exports = {\n  ...resourcePackage,\n  packageResource,\n  PackageResource,\n  registry\n}\n\n// ES Module 导出\nexport { registry, packageResource, PackageResource }\nexport default resourcePackage"],"mappings":";;;;;;;;AAAA,YAAY,UAAU;AACtB,YAAY,QAAQ;AACpB,SAAS,YAAY,kBAAkB;AAGvC,IAAM,SAAS,UAAQ,iBAAiB;AAGxC,IAAI;AACJ,IAAI;AAEF,MAAI,QAAQ,YAAY,QAAQ,SAAS,UAAU;AACjD,UAAM,eAAe,UAAQ,eAAe;AAC5C,2BAAuB,aAAa;AAAA,EACtC;AACF,SAAS,OAAO;AAEd,yBAAuB;AACzB;AAMA,IAAM,kBAAN,MAAsB;AAAA,EAGpB,cAAc;AACZ,SAAK,UAAU;AAAA,EACjB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,YAAY,cAA8B;AACxC,UAAM,WAAgB,UAAK,KAAK,SAAS,YAAY;AAGrD,QAAI,sBAAsB;AACxB,aAAO,qBAAqB,QAAQ;AAAA,IACtC;AAEA,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,OAAO,cAA+B;AACpC,QAAI;AACF,YAAM,eAAe,KAAK,YAAY,YAAY;AAClD,aAAU,cAAW,YAAY;AAAA,IACnC,SAAS,OAAO;AACd,aAAO;AAAA,IACT;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,MAAM,YAAY,cAAwC;AACxD,QAAI;AACF,YAAM,eAAe,KAAK,YAAY,YAAY;AAClD,YAAM,WAAW,OAAO,YAAY;AACpC,aAAO;AAAA,IACT,SAAS,OAAO;AACd,aAAO;AAAA,IACT;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,MAAM,YAAY,cAQf;AACD,UAAM,eAAe,KAAK,YAAY,YAAY;AAElD,QAAI;AACF,YAAM,UAAU,MAAM,WAAW,SAAS,cAAc,MAAM;AAC9D,YAAM,QAAQ,MAAM,WAAW,KAAK,YAAY;AAEhD,aAAO;AAAA,QACL;AAAA,QACA,UAAU;AAAA,UACR,MAAM;AAAA,UACN,MAAM,QAAQ;AAAA,UACd,cAAc,MAAM;AAAA,UACpB,cAAc;AAAA,QAChB;AAAA,MACF;AAAA,IACF,SAAS,OAAY;AACnB,UAAI,MAAM,SAAS,UAAU;AAC3B,cAAM,IAAI,MAAM,uBAAuB,YAAY,eAAe,YAAY,GAAG;AAAA,MACnF;AACA,YAAM,IAAI,MAAM,4BAA4B,MAAM,OAAO,EAAE;AAAA,IAC7D;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,gBAAgB,cAA8B;AAC5C,UAAM,eAAe,KAAK,YAAY,YAAY;AAElD,QAAI;AACF,aAAU,gBAAa,cAAc,MAAM;AAAA,IAC7C,SAAS,OAAY;AACnB,UAAI,MAAM,SAAS,UAAU;AAC3B,cAAM,IAAI,MAAM,uBAAuB,YAAY,eAAe,YAAY,GAAG;AAAA,MACnF;AACA,YAAM,IAAI,MAAM,4BAA4B,MAAM,OAAO,EAAE;AAAA,IAC7D;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,MAAM,SAAS,UAAkB;AAC/B,WAAO,KAAK,YAAY,kBAAkB,QAAQ,IAAI,QAAQ,UAAU;AAAA,EAC1E;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,MAAM,SAAS,UAAkB;AAC/B,WAAO,KAAK,YAAY,kBAAkB,QAAQ,IAAI,QAAQ,UAAU;AAAA,EAC1E;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,MAAM,WAAW,YAAoB;AACnC,WAAO,KAAK,YAAY,oBAAoB,UAAU,IAAI,UAAU,YAAY;AAAA,EAClF;AACF;AAGA,IAAM,cAAc;AAGpB,IAAI,eAAoB,UAAK,WAAW,eAAe;AACvD,IAAI,sBAAsB;AACxB,iBAAe,qBAAqB,YAAY;AAClD;AAGA,IAAI;AAEJ,IAAI;AACF,MAAO,cAAW,YAAY,GAAG;AAC/B,UAAM,UAAa,gBAAa,cAAc,OAAO;AACrD,eAAW,KAAK,MAAM,OAAO;AAG7B,QAAI,SAAS,YAAY,SAAS;AAChC,YAAM,IAAI,MAAM,iCAAiC,SAAS,OAAO,EAAE;AAAA,IACrE;AAAA,EACF,OAAO;AACL,UAAM,IAAI,MAAM,yBAAyB;AAAA,EAC3C;AACF,SAAS,OAAY;AACnB,SAAO,MAAM,gDAAgD,MAAM,OAAO;AAC1E,SAAO,MAAM,sCAAsC,YAAY;AAC/D,SAAO,MAAM,kCAAkC,SAAS;AACxD,QAAM,IAAI,MAAM,2CAA2C,MAAM,OAAO,EAAE;AAC5E;AAKO,SAAS,gBAAgB,cAA8B;AAE5D,MAAI,CAAC,aAAa,WAAW,YAAY,GAAG;AAC1C,mBAAe,aAAa,YAAY;AAAA,EAC1C;AACA,SAAY,UAAK,aAAa,YAAY;AAC5C;AAKO,SAAS,iBAAiB,IAAkC;AACjE,MAAI,CAAC,YAAY,CAAC,MAAM,QAAQ,SAAS,SAAS,EAAG,QAAO;AAC5D,SAAO,SAAS,UAAU,KAAK,OAAK,EAAE,OAAO,EAAE;AACjD;AAKO,SAAS,uBAAuB,UAA8B;AACnE,MAAI,CAAC,YAAY,CAAC,MAAM,QAAQ,SAAS,SAAS,EAAG,QAAO,CAAC;AAC7D,SAAO,SAAS,UAAU,OAAO,OAAK,EAAE,aAAa,QAAQ;AAC/D;AAKO,SAAS,kBAA8B;AAC5C,MAAI,CAAC,YAAY,CAAC,MAAM,QAAQ,SAAS,SAAS,EAAG,QAAO,CAAC;AAC7D,SAAO,SAAS;AAClB;AAGA,IAAM,kBAAkB,IAAI,gBAAgB;AAG5C,IAAM,kBAAmC;AAAA,EACvC;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AACF;AAGA,OAAO,UAAU;AAAA,EACf,GAAG;AAAA,EACH;AAAA,EACA;AAAA,EACA;AACF;AAIA,IAAO,gBAAQ;","names":[]}