"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var index_exports = {};
__export(index_exports, {
  PackageResource: () => PackageResource,
  default: () => index_default,
  findResourceById: () => findResourceById,
  getAllResources: () => getAllResources,
  getResourcePath: () => getResourcePath,
  getResourcesByProtocol: () => getResourcesByProtocol,
  packageResource: () => packageResource,
  registry: () => registry
});
module.exports = __toCommonJS(index_exports);
var path = __toESM(require("path"));
var fs = __toESM(require("fs"));
var import_fs = require("fs");
var logger = require("@promptx/logger");
var fixPathForAsarUnpack;
try {
  if (process.versions && process.versions.electron) {
    const electronUtil = require("electron-util");
    fixPathForAsarUnpack = electronUtil.fixPathForAsarUnpack;
  }
} catch (error) {
  fixPathForAsarUnpack = void 0;
}
var PackageResource = class {
  constructor() {
    this.baseDir = __dirname;
  }
  /**
   * 解析资源路径 - 自动处理ASAR路径转换
   * @param {string} resourcePath - 相对于包根目录的资源路径
   * @returns {string} 解析后的绝对路径
   */
  resolvePath(resourcePath) {
    const basePath = path.join(this.baseDir, resourcePath);
    if (fixPathForAsarUnpack) {
      return fixPathForAsarUnpack(basePath);
    }
    return basePath;
  }
  /**
   * 检查资源是否存在
   * @param {string} resourcePath - 资源路径
   * @returns {boolean} 资源是否存在
   */
  exists(resourcePath) {
    try {
      const resolvedPath = this.resolvePath(resourcePath);
      return fs.existsSync(resolvedPath);
    } catch (error) {
      return false;
    }
  }
  /**
   * 异步检查资源是否存在
   * @param {string} resourcePath - 资源路径
   * @returns {Promise<boolean>} 资源是否存在
   */
  async existsAsync(resourcePath) {
    try {
      const resolvedPath = this.resolvePath(resourcePath);
      await import_fs.promises.access(resolvedPath);
      return true;
    } catch (error) {
      return false;
    }
  }
  /**
   * 加载资源内容
   * @param {string} resourcePath - 资源路径
   * @returns {Promise<{content: string, metadata: object}>} 资源内容和元数据
   */
  async loadContent(resourcePath) {
    const resolvedPath = this.resolvePath(resourcePath);
    try {
      const content = await import_fs.promises.readFile(resolvedPath, "utf8");
      const stats = await import_fs.promises.stat(resolvedPath);
      return {
        content,
        metadata: {
          path: resolvedPath,
          size: content.length,
          lastModified: stats.mtime,
          relativePath: resourcePath
        }
      };
    } catch (error) {
      if (error.code === "ENOENT") {
        throw new Error(`Resource not found: ${resourcePath} (resolved: ${resolvedPath})`);
      }
      throw new Error(`Failed to load resource: ${error.message}`);
    }
  }
  /**
   * 同步加载资源内容
   * @param {string} resourcePath - 资源路径
   * @returns {string} 资源内容
   */
  loadContentSync(resourcePath) {
    const resolvedPath = this.resolvePath(resourcePath);
    try {
      return fs.readFileSync(resolvedPath, "utf8");
    } catch (error) {
      if (error.code === "ENOENT") {
        throw new Error(`Resource not found: ${resourcePath} (resolved: ${resolvedPath})`);
      }
      throw new Error(`Failed to load resource: ${error.message}`);
    }
  }
  /**
   * 便捷方法 - 加载角色资源
   * @param {string} roleName - 角色名称
   * @returns {Promise<{content: string, metadata: object}>} 角色资源
   */
  async loadRole(roleName) {
    return this.loadContent(`resources/role/${roleName}/${roleName}.role.md`);
  }
  /**
   * 便捷方法 - 加载工具资源
   * @param {string} toolName - 工具名称
   * @returns {Promise<{content: string, metadata: object}>} 工具资源
   */
  async loadTool(toolName) {
    return this.loadContent(`resources/tool/${toolName}/${toolName}.tool.md`);
  }
  /**
   * 便捷方法 - 加载手册资源
   * @param {string} manualName - 手册名称
   * @returns {Promise<{content: string, metadata: object}>} 手册资源
   */
  async loadManual(manualName) {
    return this.loadContent(`resources/manual/${manualName}/${manualName}.manual.md`);
  }
};
var packageRoot = __dirname;
var registryPath = path.join(__dirname, "registry.json");
if (fixPathForAsarUnpack) {
  registryPath = fixPathForAsarUnpack(registryPath);
}
var registry;
try {
  if (fs.existsSync(registryPath)) {
    const content = fs.readFileSync(registryPath, "utf-8");
    registry = JSON.parse(content);
    if (registry.version !== "2.0.0") {
      throw new Error(`Unsupported registry version: ${registry.version}`);
    }
  } else {
    throw new Error("Registry file not found");
  }
} catch (error) {
  logger.error("[@promptx/resource] Failed to load registry:", error.message);
  logger.error("[@promptx/resource] Registry path:", registryPath);
  logger.error("[@promptx/resource] __dirname:", __dirname);
  throw new Error(`@promptx/resource package is corrupted: ${error.message}`);
}
function getResourcePath(relativePath) {
  if (!relativePath.startsWith("resources/")) {
    relativePath = `resources/${relativePath}`;
  }
  return path.join(packageRoot, relativePath);
}
function findResourceById(id) {
  if (!registry || !Array.isArray(registry.resources)) return void 0;
  return registry.resources.find((r) => r.id === id);
}
function getResourcesByProtocol(protocol) {
  if (!registry || !Array.isArray(registry.resources)) return [];
  return registry.resources.filter((r) => r.protocol === protocol);
}
function getAllResources() {
  if (!registry || !Array.isArray(registry.resources)) return [];
  return registry.resources;
}
var packageResource = new PackageResource();
var resourcePackage = {
  registry,
  getResourcePath,
  findResourceById,
  getResourcesByProtocol,
  getAllResources
};
module.exports = {
  ...resourcePackage,
  packageResource,
  PackageResource,
  registry
};
var index_default = resourcePackage;
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  PackageResource,
  findResourceById,
  getAllResources,
  getResourcePath,
  getResourcesByProtocol,
  packageResource,
  registry
});
//# sourceMappingURL=index.js.map